var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 14:53:29 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Tue, 26 Sep 2017 21:15:47 GMT\x0aETag: \x223e74-55a1e2dc5a6c0-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-5002/5003\x0aContent-Length: 5003\x0aKeep-Alive: timeout=5, max=18\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/**\x0a * tinymce_mce_popup.js\x0a *\x0a * Released under LGPL License.\x0a * Copyright (c) 1999-2017 Ephox Corp. All rights reserved\x0a *\x0a * License: http://www.tinymce.com/license\x0a * Contributing: http://www.tinymce.com/contributing\x0a */\x0a\x0avar tinymce, tinyMCE;\x0a\x0a/**\x0a * TinyMCE popup/dialog helper class. This gives you easy access to the\x0a * parent editor instance and a bunch of other things. It\x27s higly recommended\x0a * that you load this script into your dialogs.\x0a *\x0a * @static\x0a * @class tinyMCEPopup\x0a */\x0avar tinyMCEPopup = {\x0a  /**\x0a   * Initializes the popup this will be called automatically.\x0a   *\x0a   * @method init\x0a   */\x0a  init: function () {\x0a    var self = this, parentWin, settings, uiWindow;\x0a\x0a    // Find window & API\x0a    parentWin = self.getWin();\x0a    tinymce = tinyMCE = parentWin.tinymce;\x0a    self.editor = tinymce.EditorManager.activeEditor;\x0a    self.params = self.editor.windowManager.getParams();\x0a\x0a    uiWindow = self.editor.windowManager.windows[self.editor.windowManager.windows.length - 1];\x0a    self.features = uiWindow.features;\x0a    self.uiWindow = uiWindow;\x0a\x0a    settings = self.editor.settings;\x0a\x0a    // Setup popup CSS path(s)\x0a    if (settings.popup_css !== false) {\x0a      if (settings.popup_css) {\x0a        settings.popup_css = self.editor.documentBaseURI.toAbsolute(settings.popup_css);\x0a      } else {\x0a        settings.popup_css = self.editor.baseURI.toAbsolute(\x22plugins/compat3x/css/dialog.css\x22);\x0a      }\x0a    }\x0a\x0a    if (settings.popup_css_add) {\x0a      settings.popup_css += \x27,\x27 + self.editor.documentBaseURI.toAbsolute(settings.popup_css_add);\x0a    }\x0a\x0a    // Setup local DOM\x0a    self.dom = self.editor.windowManager.createInstance(\x27tinymce.dom.DOMUtils\x27, document, {\x0a      ownEvents: true,\x0a      proxy: tinyMCEPopup._eventProxy\x0a    });\x0a\x0a    self.dom.bind(window, \x27ready\x27, self._onDOMLoaded, self);\x0a\x0a    // Enables you to skip loading the default css\x0a    if (self.features.popup_css !== false) {\x0a      self.dom.loadCSS(self.features.popup_css || self.editor.settings.popup_css);\x0a    }\x0a\x0a    // Setup on init listeners\x0a    self.listeners = [];\x0a\x0a    /**\x0a     * Fires when the popup is initialized.\x0a     *\x0a     * @event onInit\x0a     * @param {tinymce.Editor} editor Editor instance.\x0a     * @example\x0a     * // Alerts the selected contents when the dialog is loaded\x0a     * tinyMCEPopup.onInit.add(function(ed) {\x0a     *     alert(ed.selection.getContent());\x0a     * });\x0a     *\x0a     * // Executes the init method on page load in some object using the SomeObject scope\x0a     * tinyMCEPopup.onInit.add(SomeObject.init, SomeObject);\x0a     */\x0a    self.onInit = {\x0a      add: function (func, scope) {\x0a        self.listeners.push({ func: func, scope: scope });\x0a      }\x0a    };\x0a\x0a    self.isWindow = !self.getWindowArg(\x27mce_inline\x27);\x0a    self.id = self.getWindowArg(\x27mce_window_id\x27);\x0a  },\x0a\x0a  /**\x0a   * Returns the reference to the parent window that opened the dialog.\x0a   *\x0a   * @method getWin\x0a   * @return {Window} Reference to the parent window that opened the dialog.\x0a   */\x0a  getWin: function () {\x0a    // Added frameElement check to fix bug: #2817583\x0a    return (!window.frameElement && window.dialogArguments) || opener || parent || top;\x0a  },\x0a\x0a  /**\x0a   * Returns a window argument/parameter by name.\x0a   *\x0a   * @method getWindowArg\x0a   * @param {String} name Name of the window argument to retrieve.\x0a   * @param {String} defaultValue Optional default value to return.\x0a   * @return {String} Argument value or default value if it wasn\x27t found.\x0a   */\x0a  getWindowArg: function (name, defaultValue) {\x0a    var value = this.params[name];\x0a\x0a    return tinymce.is(value) ? value : defaultValue;\x0a  },\x0a\x0a  /**\x0a   * Returns a editor parameter/config option value.\x0a   *\x0a   * @method getParam\x0a   * @param {String} name Name of the editor config option to retrieve.\x0a   * @param {String} defaultValue Optional default value to return.\x0a   * @return {String} Parameter value or default value if it wasn\x27t found.\x0a   */\x0a  getParam: function (name, defaultValue) {\x0a    return this.editor.getParam(name, defaultValue);\x0a  },\x0a\x0a  /**\x0a   * Returns a language item by key.\x0a   *\x0a   * @method getLang\x0a   * @param {String} name Language item like mydialog.something.\x0a   * @param {String} defaultValue Optional default value to return.\x0a   * @return {String} Language value for the item like \x22my string\x22 or the default value if it wasn\x27t found.\x0a   */\x0a  getLang: function (name, defaultValue) {\x0a    return this.editor.getLang(name, defaultValue);\x0a  },\x0a\x0a  /**\x0a   * Executed a command on editor that opened the dialog/popup.\x0a   *\x0a   * @method execCommand\x0a   * @param {String} cmd Command to execute.\x0a   * @param {Boolean} ui Optional boolean value if the UI for the command should be presented or not.\x0a   * @param {Object} val Optional value to pass with the comman like an URL.\x0a   * @param {Object} a Optional arguments object.\x0a   */\x0a  execCommand: function (cmd, ui, val, args) {\x0a    args = args || {};\x0a    args.skip_focus = 1;\x0a\x0a    this.restoreSelection();\x0a    return this.editor.execCommand(cmd, ui, val, args);\x0a  },\x0a\x0a  /**\x0a   * Resizes the dialog to the inner size of the window. This is needed since various browsers\x0a   * have different border sizes on windows.\x0a   *\x0a   * @method resizeToInnerSize\x0a   */\x0a  resizeToInnerSize: function () {\x0a    /*var self = this;\x0a\x0a    // Detach it to workaround a Chrome specific bug\x0a    // https://sourceforge.net/tracker/?func=detail&atid=635682&aid=2926339&group_id=103281\x0a    setTimeout(function() {\x0a      var vp = self.dom.getViewPort(window);\x0a\x0a      self.editor.windowManager.resizeBy(\x0a        self.getWindowArg(\x27mce_width\x27) - vp.w,\x0a        self.getWindowArg(\x27mce_height\x27) - vp.h,\x0a        self.id || window\x0a      );\x0a    }, 10);*/\x0a  },\x0a\x0a  /**\x0a   * Will executed the specified string when the page has been loaded. This function\x0a   * was added for compatibility with the 2.x branch.\x0a   *\x0a   * @method executeOnLoad\x0a   * @param {String} evil String to evalutate on init.\x0a   */\x0a  executeOnLoad: function (evil) {\x0a    this.onInit.add(function () {\x0a      eval(evil);\x0a    });\x0a  },\x0a\x0a  /**\x0a   * Stores the current editor selection for later restoration. This can be useful since some browsers\x0a   * looses it\x27s selection if a control element is selected/focused inside the dialogs.\x0a   *\x0a   * @method storeSelection\x0a   */\x0a  storeSelection: function () {\x0a    this.editor.windowManager.bookmark = tinyMCEPopup.editor.selection.getBookmark(1);\x0a  },\x0a\x0a  /**\x0a   * Restores any stored selection. This can be useful since some browsers\x0a   * looses it\x27s selection if a control element is selected/focused inside the dialogs.\x0a   *\x0a   * @method restoreSelection\x0a   */\x0a  restoreSelection: function () {\x0a    var self = tinyMCEPopup;\x0a\x0a    if (!self.isWindow && tinymce.isIE) {\x0a      self.editor.selection.moveToBookmark(self.editor.windowManager.bookmark);\x0a    }\x0a  },\x0a\x0a  /**\x0a   * Loads a specific dialog language pack. If you pass in plugin_url as a argument\x0a   * when you open the window it will load the \x3cplugin url\x3e/langs/\x3ccode\x3e_dlg.js lang pack file.\x0a   *\x0a   * @method requireLangPack\x0a   */\x0a  requireLangPack: function () {\x0a    var self = this, url = self.getWindowArg(\x27plugin_url\x27) || self.getWindowArg(\x27theme_url\x27), settings = self.editor.settings, lang;\x0a\x0a    if (settings.language !== false) {\x0a      lang = settings.language || \x22en\x22;\x0a    }\x0a\x0a    if (url && lang && self.features.translate_i18n !== false && settings.language_load !== false) {\x0a      url += \x27/langs/\x27 + lang + \x27_dlg.js\x27;\x0a\x0a      if (!tinymce.ScriptLoader.isDone(url)) {\x0a        document.write(\x27\x3cscript type=\x22text/javascript\x22 src=\x22\x27 + url + \x27\x22\x3e\x3c/script\x3e\x27);\x0a        tinymce.ScriptLoader.markDone(url);\x0a      }\x0a    }\x0a  },\x0a\x0a  /**\x0a   * Executes a color picker on the specified element id. When the user\x0a   * then selects a color it will be set as the value of the specified element.\x0a   *\x0a   * @method pickColor\x0a   * @param {DOMEvent} e DOM event object.\x0a   * @param {string} element_id Element id to be filled with the color value from the picker.\x0a   */\x0a  pickColor: function (e, element_id) {\x0a    var el = document.getElementById(element_id), colorPickerCallback = this.editor.settings.color_picker_callback;\x0a    if (colorPickerCallback) {\x0a      colorPickerCallback.call(\x0a        this.editor,\x0a        function (value) {\x0a          el.value = value;\x0a          try {\x0a            el.onchange();\x0a          } catch (ex) {\x0a            // Try fire event, ignore errors\x0a          }\x0a        },\x0a        el.value\x0a      );\x0a    }\x0a  },\x0a\x0a  /**\x0a   * Opens a filebrowser/imagebrowser this will set the output value from\x0a   * the browser as a value on the specified element.\x0a   *\x0a   * @method openBrowser\x0a   * @param {string} element_id Id of the element to set value in.\x0a   * @param {string} type Type of browser to open image/file/flash.\x0a   * @param {string} option Option name to get the file_broswer_callback function name from.\x0a   */\x0a  openBrowser: function (element_id, type) {\x0a    tinyMCEPopup.restoreSelection();\x0a    this.editor.execCallback(\x27file_browser_callback\x27, element_id, document.getElementById(element_id).value, type, window);\x0a  },\x0a\x0a  /**\x0a   * Creates a confirm dialog. Please don\x27t use the blocking behavior of this\x0a   * native version use the callback method instead then it can be extended.\x0a   *\x0a   * @method confirm\x0a   * @param {String} t Title for the new confirm dialog.\x0a   * @param {function} cb Callback function to be executed after the user has selected ok or cancel.\x0a   * @param {Object} s Optional scope to execute the callback in.\x0a   */\x0a  confirm: function (t, cb, s) {\x0a    this.editor.windowManager.confirm(t, cb, s, window);\x0a  },\x0a\x0a  /**\x0a   * Creates a alert dialog. Please don\x27t use the blocking behavior of this\x0a   * native version use the callback method instead then it can be extended.\x0a   *\x0a   * @method alert\x0a   * @param {String} tx Title for the new alert dialog.\x0a   * @param {function} cb Callback function to be executed after the user has selected ok.\x0a   * @param {Object} s Optional scope to execute the callback in.\x0a   */\x0a  alert: function (tx, cb, s) {\x0a    this.editor.windowManager.alert(tx, cb, s, window);\x0a  },\x0a\x0a  /**\x0a   * Closes the current window.\x0a   *\x0a   * @method close\x0a   */\x0a  close: function () {\x0a    var t = this;\x0a\x0a    // To avoid domain relaxing issue in Opera\x0a    function close() {\x0a      t.editor.windowManager.close(window);\x0a      tinymce = tinyMCE = t.editor = t.params = t.dom = t.dom.doc = null; // Cleanup\x0a    }\x0a\x0a    if (tinymce.isOpera) {\x0a      t.getWin().setTimeout(close, 0);\x0a    } else {\x0a      close();\x0a    }\x0a  },\x0a\x0a  // Internal functions\x0a\x0a  _restoreSelection: function () {\x0a    var e = window.event.srcElement;\x0a\x0a    if (e.nodeName == \x27INPUT\x27 && (e.type == \x27submit\x27 || e.type == \x27button\x27)) {\x0a      tinyMCEPopup.restoreSelection();\x0a    }\x0a  },\x0a\x0a  /* _restoreSelection : function() {\x0a      var e = window.event.srcElement;\x0a\x0a      // If user focus a non text input or textarea\x0a      if ((e.nodeName != \x27INPUT\x27 && e.nodeName != \x27TEXTAREA\x27) || e.type != \x27text\x27)\x0a        tinyMCEPopup.restoreSelection();\x0a    },*/\x0a\x0a  _onDOMLoaded: function () {\x0a    var t = tinyMCEPopup, ti = document.title, h, nv;\x0a\x0a    // Translate page\x0a    if (t.features.translate_i18n !== false) {\x0a      var map = {\x0a        \x22update\x22: \x22Ok\x22,\x0a        \x22insert\x22: \x22Ok\x22,\x0a        \x22cancel\x22: \x22Cancel\x22,\x0a        \x22not_set\x22: \x22--\x22,\x0a        \x22class_name\x22: \x22Class name\x22,\x0a        \x22browse\x22: \x22Browse\x22\x0a      };\x0a\x0a      var langCode = (tinymce.settings ? tinymce.settings : t.editor.settings).language || \x27en\x27;\x0a      for (var key in map) {\x0a        tinymce.i18n.data[langCode + \x22.\x22 + key] = tinymce.i18n.translate(map[key]);\x0a      }\x0a\x0a      h = document.body.innerHTML;\x0a\x0a      // Replace a=x with a=\x22x\x22 in IE\x0a      if (tinymce.isIE) {\x0a        h = h.replace(/ (value|title|alt)=([^\x22][^\x5cs\x3e]+)/gi, \x27 $1=\x22$2\x22\x27);\x0a      }\x0a\x0a      document.dir = t.editor.getParam(\x27directionality\x27, \x27\x27);\x0a\x0a      if ((nv = t.editor.translate(h)) && nv != h) {\x0a        document.body.innerHTML = nv;\x0a      }\x0a\x0a      if ((nv = t.editor.translate(ti)) && nv != ti) {\x0a        document.title = ti = nv;\x0a      }\x0a    }\x0a\x0a    if (!t.editor.getParam(\x27browser_preferred_colors\x27, false) || !t.isWindow) {\x0a      t.dom.addClass(document.body, \x27forceColors\x27);\x0a    }\x0a\x0a    document.body.style.display = \x27\x27;\x0a\x0a    // Restore selection in IE when focus is placed on a non textarea or input element of the type text\x0a    if (tinymce.Env.ie) {\x0a      if (tinymce.Env.ie \x3c 11) {\x0a        document.attachEvent(\x27onmouseup\x27, tinyMCEPopup._restoreSelection);\x0a\x0a        // Add base target element for it since it would fail with modal dialogs\x0a        t.dom.add(t.dom.select(\x27head\x27)[0], \x27base\x27, { target: \x27_self\x27 });\x0a      } else {\x0a        document.addEventListener(\x27mouseup\x27, tinyMCEPopup._restoreSelection, false);\x0a      }\x0a    }\x0a\x0a    t.restoreSelection();\x0a    t.resizeToInnerSize();\x0a\x0a    // Set inline title\x0a    if (!t.isWindow) {\x0a      t.editor.windowManager.setTitle(window, ti);\x0a    } else {\x0a      window.focus();\x0a    }\x0a\x0a    if (!tinymce.isIE && !t.isWindow) {\x0a      t.dom.bind(document, \x27focus\x27, function () {\x0a        t.editor.windowManager.focus(t.id);\x0a      });\x0a    }\x0a\x0a    // Patch for accessibility\x0a    tinymce.each(t.dom.select(\x27select\x27), function (e) {\x0a      e.onkeydown = tinyMCEPopup._accessHandler;\x0a    });\x0a\x0a    // Call onInit\x0a    // Init must be called before focus so the selection won\x27t get lost by the focus call\x0a    tinymce.each(t.listeners, function (o) {\x0a      o.func.call(o.scope, t.editor);\x0a    });\x0a\x0a    // Move focus to window\x0a    if (t.getWindowArg(\x27mce_auto_focus\x27, true)) {\x0a      window.focus();\x0a\x0a      // Focus element with mceFocus class\x0a      tinymce.each(document.forms, function (f) {\x0a        tinymce.each(f.elements, function (e) {\x0a          if (t.dom.hasClass(e, \x27mceFocus\x27) && !e.disabled) {\x0a            e.focus();\x0a            return false; // Break loop\x0a          }\x0a        });\x0a      });\x0a    }\x0a\x0a    document.onkeyup = tinyMCEPopup._closeWinKeyHandler;\x0a\x0a    if (\x27textContent\x27 in document) {\x0a      t.uiWindow.getEl(\x27head\x27).firstChild.textContent = document.title;\x0a    } else {\x0a      t.uiWindow.getEl(\x27head\x27).firstChild.innerText = document.title;\x0a    }\x0a  },\x0a\x0a  _accessHandler: function (e) {\x0a    e = e || window.event;\x0a\x0a    if (e.keyCode == 13 || e.keyCode == 32) {\x0a      var elm = e.target || e.srcElement;\x0a\x0a      if (elm.onchange) {\x0a        elm.onchange();\x0a      }\x0a\x0a      return tinymce.dom.Event.cancel(e);\x0a    }\x0a  },\x0a\x0a  _closeWinKeyHandler: function (e) {\x0a    e = e || window.event;\x0a\x0a    if (e.keyCode == 27) {\x0a      tinyMCEPopup.close();\x0a    }\x0a  },\x0a\x0a  _eventProxy: function (id) {\x0a    return function (evt) {\x0a      tinyMCEPopup.dom.events.callNativeHandler(id, evt);\x0a    };\x0a  }\x0a};\x0a\x0atinyMCEPopup.init();\x0a\x0atinymce.util.Dispatcher = function (scope) {\x0a  this.scope = scope || this;\x0a  this.listeners = [];\x0a\x0a  this.add = function (callback, scope) {\x0a    this.listeners.push({ cb: callback, scope: scope || this.scope });\x0a\x0a    return callback;\x0a  };\x0a\x0a  this.addToTop = function (callback, scope) {\x0a    var self = this, listener = { cb: callback, scope: scope || self.scope };\x0a\x0a    // Create new listeners if addToTop is executed in a dispatch loop\x0a    if (self.inDispatch) {\x0a      self.listeners = [listener].concat(self.listeners);\x0a    } else {\x0a      self.listeners.unshift(listener);\x0a    }\x0a\x0a    return callback;\x0a  };\x0a\x0a  this.remove = function (callback) {\x0a    var listeners = this.listeners, output = null;\x0a\x0a    tinymce.each(listeners, function (listener, i) {\x0a      if (callback == listener.cb) {\x0a        output = listener;\x0a        listeners.splice(i, 1);\x0a        return false;\x0a      }\x0a    });\x0a\x0a    return output;\x0a  };\x0a\x0a  this.dispatch = function () {\x0a    var self = this, returnValue, args = arguments, i, listeners = self.listeners, listener;\x0a\x0a    self.inDispatch = true;\x0a\x0a    // Needs to be a real loop since the listener count might change while looping\x0a    // And this is also more efficient\x0a    for (i = 0; i \x3c listeners.length; i++) {\x0a      listener = listeners[i];\x0a      returnValue = listener.cb.apply(listener.scope, args.length \x3e 0 ? args : [listener.scope]);\x0a\x0a      if (returnValue === false) {\x0a        break;\x0a      }\x0a    }\x0a\x0a    self.inDispatch = false;\x0a\x0a    return returnValue;\x0a  };\x0a};\x0a'}