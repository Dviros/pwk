var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:05:06 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Fri, 14 Dec 2018 04:41:57 GMT\x0aETag: \x2239d5-57cf40d168f40-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-3925/3926\x0aContent-Length: 3926\x0aKeep-Alive: timeout=5, max=45\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a(function (global, factory) {\x0a  typeof exports === \x27object\x27 && typeof module !== \x27undefined\x27 ? factory(exports) :\x0a  typeof define === \x27function\x27 && define.amd ? define([\x27exports\x27], factory) :\x0a  (factory((global.WHATWGFetch = {})));\x0a}(this, (function (exports) { \x27use strict\x27;\x0a\x0a  var support = {\x0a    searchParams: \x27URLSearchParams\x27 in self,\x0a    iterable: \x27Symbol\x27 in self && \x27iterator\x27 in Symbol,\x0a    blob:\x0a      \x27FileReader\x27 in self &&\x0a      \x27Blob\x27 in self &&\x0a      (function() {\x0a        try {\x0a          new Blob();\x0a          return true\x0a        } catch (e) {\x0a          return false\x0a        }\x0a      })(),\x0a    formData: \x27FormData\x27 in self,\x0a    arrayBuffer: \x27ArrayBuffer\x27 in self\x0a  };\x0a\x0a  function isDataView(obj) {\x0a    return obj && DataView.prototype.isPrototypeOf(obj)\x0a  }\x0a\x0a  if (support.arrayBuffer) {\x0a    var viewClasses = [\x0a      \x27[object Int8Array]\x27,\x0a      \x27[object Uint8Array]\x27,\x0a      \x27[object Uint8ClampedArray]\x27,\x0a      \x27[object Int16Array]\x27,\x0a      \x27[object Uint16Array]\x27,\x0a      \x27[object Int32Array]\x27,\x0a      \x27[object Uint32Array]\x27,\x0a      \x27[object Float32Array]\x27,\x0a      \x27[object Float64Array]\x27\x0a    ];\x0a\x0a    var isArrayBufferView =\x0a      ArrayBuffer.isView ||\x0a      function(obj) {\x0a        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) \x3e -1\x0a      };\x0a  }\x0a\x0a  function normalizeName(name) {\x0a    if (typeof name !== \x27string\x27) {\x0a      name = String(name);\x0a    }\x0a    if (/[^a-z0-9\x5c-#$%&\x27*+.^_`|~]/i.test(name)) {\x0a      throw new TypeError(\x27Invalid character in header field name\x27)\x0a    }\x0a    return name.toLowerCase()\x0a  }\x0a\x0a  function normalizeValue(value) {\x0a    if (typeof value !== \x27string\x27) {\x0a      value = String(value);\x0a    }\x0a    return value\x0a  }\x0a\x0a  // Build a destructive iterator for the value list\x0a  function iteratorFor(items) {\x0a    var iterator = {\x0a      next: function() {\x0a        var value = items.shift();\x0a        return {done: value === undefined, value: value}\x0a      }\x0a    };\x0a\x0a    if (support.iterable) {\x0a      iterator[Symbol.iterator] = function() {\x0a        return iterator\x0a      };\x0a    }\x0a\x0a    return iterator\x0a  }\x0a\x0a  function Headers(headers) {\x0a    this.map = {};\x0a\x0a    if (headers instanceof Headers) {\x0a      headers.forEach(function(value, name) {\x0a        this.append(name, value);\x0a      }, this);\x0a    } else if (Array.isArray(headers)) {\x0a      headers.forEach(function(header) {\x0a        this.append(header[0], header[1]);\x0a      }, this);\x0a    } else if (headers) {\x0a      Object.getOwnPropertyNames(headers).forEach(function(name) {\x0a        this.append(name, headers[name]);\x0a      }, this);\x0a    }\x0a  }\x0a\x0a  Headers.prototype.append = function(name, value) {\x0a    name = normalizeName(name);\x0a    value = normalizeValue(value);\x0a    var oldValue = this.map[name];\x0a    this.map[name] = oldValue ? oldValue + \x27, \x27 + value : value;\x0a  };\x0a\x0a  Headers.prototype[\x27delete\x27] = function(name) {\x0a    delete this.map[normalizeName(name)];\x0a  };\x0a\x0a  Headers.prototype.get = function(name) {\x0a    name = normalizeName(name);\x0a    return this.has(name) ? this.map[name] : null\x0a  };\x0a\x0a  Headers.prototype.has = function(name) {\x0a    return this.map.hasOwnProperty(normalizeName(name))\x0a  };\x0a\x0a  Headers.prototype.set = function(name, value) {\x0a    this.map[normalizeName(name)] = normalizeValue(value);\x0a  };\x0a\x0a  Headers.prototype.forEach = function(callback, thisArg) {\x0a    for (var name in this.map) {\x0a      if (this.map.hasOwnProperty(name)) {\x0a        callback.call(thisArg, this.map[name], name, this);\x0a      }\x0a    }\x0a  };\x0a\x0a  Headers.prototype.keys = function() {\x0a    var items = [];\x0a    this.forEach(function(value, name) {\x0a      items.push(name);\x0a    });\x0a    return iteratorFor(items)\x0a  };\x0a\x0a  Headers.prototype.values = function() {\x0a    var items = [];\x0a    this.forEach(function(value) {\x0a      items.push(value);\x0a    });\x0a    return iteratorFor(items)\x0a  };\x0a\x0a  Headers.prototype.entries = function() {\x0a    var items = [];\x0a    this.forEach(function(value, name) {\x0a      items.push([name, value]);\x0a    });\x0a    return iteratorFor(items)\x0a  };\x0a\x0a  if (support.iterable) {\x0a    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\x0a  }\x0a\x0a  function consumed(body) {\x0a    if (body.bodyUsed) {\x0a      return Promise.reject(new TypeError(\x27Already read\x27))\x0a    }\x0a    body.bodyUsed = true;\x0a  }\x0a\x0a  function fileReaderReady(reader) {\x0a    return new Promise(function(resolve, reject) {\x0a      reader.onload = function() {\x0a        resolve(reader.result);\x0a      };\x0a      reader.onerror = function() {\x0a        reject(reader.error);\x0a      };\x0a    })\x0a  }\x0a\x0a  function readBlobAsArrayBuffer(blob) {\x0a    var reader = new FileReader();\x0a    var promise = fileReaderReady(reader);\x0a    reader.readAsArrayBuffer(blob);\x0a    return promise\x0a  }\x0a\x0a  function readBlobAsText(blob) {\x0a    var reader = new FileReader();\x0a    var promise = fileReaderReady(reader);\x0a    reader.readAsText(blob);\x0a    return promise\x0a  }\x0a\x0a  function readArrayBufferAsText(buf) {\x0a    var view = new Uint8Array(buf);\x0a    var chars = new Array(view.length);\x0a\x0a    for (var i = 0; i \x3c view.length; i++) {\x0a      chars[i] = String.fromCharCode(view[i]);\x0a    }\x0a    return chars.join(\x27\x27)\x0a  }\x0a\x0a  function bufferClone(buf) {\x0a    if (buf.slice) {\x0a      return buf.slice(0)\x0a    } else {\x0a      var view = new Uint8Array(buf.byteLength);\x0a      view.set(new Uint8Array(buf));\x0a      return view.buffer\x0a    }\x0a  }\x0a\x0a  function Body() {\x0a    this.bodyUsed = false;\x0a\x0a    this._initBody = function(body) {\x0a      this._bodyInit = body;\x0a      if (!body) {\x0a        this._bodyText = \x27\x27;\x0a      } else if (typeof body === \x27string\x27) {\x0a        this._bodyText = body;\x0a      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\x0a        this._bodyBlob = body;\x0a      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\x0a        this._bodyFormData = body;\x0a      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\x0a        this._bodyText = body.toString();\x0a      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\x0a        this._bodyArrayBuffer = bufferClone(body.buffer);\x0a        // IE 10-11 can\x27t handle a DataView body.\x0a        this._bodyInit = new Blob([this._bodyArrayBuffer]);\x0a      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\x0a        this._bodyArrayBuffer = bufferClone(body);\x0a      } else {\x0a        this._bodyText = body = Object.prototype.toString.call(body);\x0a      }\x0a\x0a      if (!this.headers.get(\x27content-type\x27)) {\x0a        if (typeof body === \x27string\x27) {\x0a          this.headers.set(\x27content-type\x27, \x27text/plain;charset=UTF-8\x27);\x0a        } else if (this._bodyBlob && this._bodyBlob.type) {\x0a          this.headers.set(\x27content-type\x27, this._bodyBlob.type);\x0a        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\x0a          this.headers.set(\x27content-type\x27, \x27application/x-www-form-urlencoded;charset=UTF-8\x27);\x0a        }\x0a      }\x0a    };\x0a\x0a    if (support.blob) {\x0a      this.blob = function() {\x0a        var rejected = consumed(this);\x0a        if (rejected) {\x0a          return rejected\x0a        }\x0a\x0a        if (this._bodyBlob) {\x0a          return Promise.resolve(this._bodyBlob)\x0a        } else if (this._bodyArrayBuffer) {\x0a          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\x0a        } else if (this._bodyFormData) {\x0a          throw new Error(\x27could not read FormData body as blob\x27)\x0a        } else {\x0a          return Promise.resolve(new Blob([this._bodyText]))\x0a        }\x0a      };\x0a\x0a      this.arrayBuffer = function() {\x0a        if (this._bodyArrayBuffer) {\x0a          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\x0a        } else {\x0a          return this.blob().then(readBlobAsArrayBuffer)\x0a        }\x0a      };\x0a    }\x0a\x0a    this.text = function() {\x0a      var rejected = consumed(this);\x0a      if (rejected) {\x0a        return rejected\x0a      }\x0a\x0a      if (this._bodyBlob) {\x0a        return readBlobAsText(this._bodyBlob)\x0a      } else if (this._bodyArrayBuffer) {\x0a        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\x0a      } else if (this._bodyFormData) {\x0a        throw new Error(\x27could not read FormData body as text\x27)\x0a      } else {\x0a        return Promise.resolve(this._bodyText)\x0a      }\x0a    };\x0a\x0a    if (support.formData) {\x0a      this.formData = function() {\x0a        return this.text().then(decode)\x0a      };\x0a    }\x0a\x0a    this.json = function() {\x0a      return this.text().then(JSON.parse)\x0a    };\x0a\x0a    return this\x0a  }\x0a\x0a  // HTTP methods whose capitalization should be normalized\x0a  var methods = [\x27DELETE\x27, \x27GET\x27, \x27HEAD\x27, \x27OPTIONS\x27, \x27POST\x27, \x27PUT\x27];\x0a\x0a  function normalizeMethod(method) {\x0a    var upcased = method.toUpperCase();\x0a    return methods.indexOf(upcased) \x3e -1 ? upcased : method\x0a  }\x0a\x0a  function Request(input, options) {\x0a    options = options || {};\x0a    var body = options.body;\x0a\x0a    if (input instanceof Request) {\x0a      if (input.bodyUsed) {\x0a        throw new TypeError(\x27Already read\x27)\x0a      }\x0a      this.url = input.url;\x0a      this.credentials = input.credentials;\x0a      if (!options.headers) {\x0a        this.headers = new Headers(input.headers);\x0a      }\x0a      this.method = input.method;\x0a      this.mode = input.mode;\x0a      this.signal = input.signal;\x0a      if (!body && input._bodyInit != null) {\x0a        body = input._bodyInit;\x0a        input.bodyUsed = true;\x0a      }\x0a    } else {\x0a      this.url = String(input);\x0a    }\x0a\x0a    this.credentials = options.credentials || this.credentials || \x27same-origin\x27;\x0a    if (options.headers || !this.headers) {\x0a      this.headers = new Headers(options.headers);\x0a    }\x0a    this.method = normalizeMethod(options.method || this.method || \x27GET\x27);\x0a    this.mode = options.mode || this.mode || null;\x0a    this.signal = options.signal || this.signal;\x0a    this.referrer = null;\x0a\x0a    if ((this.method === \x27GET\x27 || this.method === \x27HEAD\x27) && body) {\x0a      throw new TypeError(\x27Body not allowed for GET or HEAD requests\x27)\x0a    }\x0a    this._initBody(body);\x0a  }\x0a\x0a  Request.prototype.clone = function() {\x0a    return new Request(this, {body: this._bodyInit})\x0a  };\x0a\x0a  function decode(body) {\x0a    var form = new FormData();\x0a    body\x0a      .trim()\x0a      .split(\x27&\x27)\x0a      .forEach(function(bytes) {\x0a        if (bytes) {\x0a          var split = bytes.split(\x27=\x27);\x0a          var name = split.shift().replace(/\x5c+/g, \x27 \x27);\x0a          var value = split.join(\x27=\x27).replace(/\x5c+/g, \x27 \x27);\x0a          form.append(decodeURIComponent(name), decodeURIComponent(value));\x0a        }\x0a      });\x0a    return form\x0a  }\x0a\x0a  function parseHeaders(rawHeaders) {\x0a    var headers = new Headers();\x0a    // Replace instances of \x5cr\x5cn and \x5cn followed by at least one space or horizontal tab with a space\x0a    // https://tools.ietf.org/html/rfc7230#section-3.2\x0a    var preProcessedHeaders = rawHeaders.replace(/\x5cr?\x5cn[\x5ct ]+/g, \x27 \x27);\x0a    preProcessedHeaders.split(/\x5cr?\x5cn/).forEach(function(line) {\x0a      var parts = line.split(\x27:\x27);\x0a      var key = parts.shift().trim();\x0a      if (key) {\x0a        var value = parts.join(\x27:\x27).trim();\x0a        headers.append(key, value);\x0a      }\x0a    });\x0a    return headers\x0a  }\x0a\x0a  Body.call(Request.prototype);\x0a\x0a  function Response(bodyInit, options) {\x0a    if (!options) {\x0a      options = {};\x0a    }\x0a\x0a    this.type = \x27default\x27;\x0a    this.status = options.status === undefined ? 200 : options.status;\x0a    this.ok = this.status \x3e= 200 && this.status \x3c 300;\x0a    this.statusText = \x27statusText\x27 in options ? options.statusText : \x27OK\x27;\x0a    this.headers = new Headers(options.headers);\x0a    this.url = options.url || \x27\x27;\x0a    this._initBody(bodyInit);\x0a  }\x0a\x0a  Body.call(Response.prototype);\x0a\x0a  Response.prototype.clone = function() {\x0a    return new Response(this._bodyInit, {\x0a      status: this.status,\x0a      statusText: this.statusText,\x0a      headers: new Headers(this.headers),\x0a      url: this.url\x0a    })\x0a  };\x0a\x0a  Response.error = function() {\x0a    var response = new Response(null, {status: 0, statusText: \x27\x27});\x0a    response.type = \x27error\x27;\x0a    return response\x0a  };\x0a\x0a  var redirectStatuses = [301, 302, 303, 307, 308];\x0a\x0a  Response.redirect = function(url, status) {\x0a    if (redirectStatuses.indexOf(status) === -1) {\x0a      throw new RangeError(\x27Invalid status code\x27)\x0a    }\x0a\x0a    return new Response(null, {status: status, headers: {location: url}})\x0a  };\x0a\x0a  exports.DOMException = self.DOMException;\x0a  try {\x0a    new exports.DOMException();\x0a  } catch (err) {\x0a    exports.DOMException = function(message, name) {\x0a      this.message = message;\x0a      this.name = name;\x0a      var error = Error(message);\x0a      this.stack = error.stack;\x0a    };\x0a    exports.DOMException.prototype = Object.create(Error.prototype);\x0a    exports.DOMException.prototype.constructor = exports.DOMException;\x0a  }\x0a\x0a  function fetch(input, init) {\x0a    return new Promise(function(resolve, reject) {\x0a      var request = new Request(input, init);\x0a\x0a      if (request.signal && request.signal.aborted) {\x0a        return reject(new exports.DOMException(\x27Aborted\x27, \x27AbortError\x27))\x0a      }\x0a\x0a      var xhr = new XMLHttpRequest();\x0a\x0a      function abortXhr() {\x0a        xhr.abort();\x0a      }\x0a\x0a      xhr.onload = function() {\x0a        var options = {\x0a          status: xhr.status,\x0a          statusText: xhr.statusText,\x0a          headers: parseHeaders(xhr.getAllResponseHeaders() || \x27\x27)\x0a        };\x0a        options.url = \x27responseURL\x27 in xhr ? xhr.responseURL : options.headers.get(\x27X-Request-URL\x27);\x0a        var body = \x27response\x27 in xhr ? xhr.response : xhr.responseText;\x0a        resolve(new Response(body, options));\x0a      };\x0a\x0a      xhr.onerror = function() {\x0a        reject(new TypeError(\x27Network request failed\x27));\x0a      };\x0a\x0a      xhr.ontimeout = function() {\x0a        reject(new TypeError(\x27Network request failed\x27));\x0a      };\x0a\x0a      xhr.onabort = function() {\x0a        reject(new exports.DOMException(\x27Aborted\x27, \x27AbortError\x27));\x0a      };\x0a\x0a      xhr.open(request.method, request.url, true);\x0a\x0a      if (request.credentials === \x27include\x27) {\x0a        xhr.withCredentials = true;\x0a      } else if (request.credentials === \x27omit\x27) {\x0a        xhr.withCredentials = false;\x0a      }\x0a\x0a      if (\x27responseType\x27 in xhr && support.blob) {\x0a        xhr.responseType = \x27blob\x27;\x0a      }\x0a\x0a      request.headers.forEach(function(value, name) {\x0a        xhr.setRequestHeader(name, value);\x0a      });\x0a\x0a      if (request.signal) {\x0a        request.signal.addEventListener(\x27abort\x27, abortXhr);\x0a\x0a        xhr.onreadystatechange = function() {\x0a          // DONE (success or failure)\x0a          if (xhr.readyState === 4) {\x0a            request.signal.removeEventListener(\x27abort\x27, abortXhr);\x0a          }\x0a        };\x0a      }\x0a\x0a      xhr.send(typeof request._bodyInit === \x27undefined\x27 ? null : request._bodyInit);\x0a    })\x0a  }\x0a\x0a  fetch.polyfill = true;\x0a\x0a  if (!self.fetch) {\x0a    self.fetch = fetch;\x0a    self.Headers = Headers;\x0a    self.Request = Request;\x0a    self.Response = Response;\x0a  }\x0a\x0a  exports.Headers = Headers;\x0a  exports.Request = Request;\x0a  exports.Response = Response;\x0a  exports.fetch = fetch;\x0a\x0a  Object.defineProperty(exports, \x27__esModule\x27, { value: true });\x0a\x0a})));\x0a'}