var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:04:59 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Wed, 23 May 2018 10:05:31 GMT\x0aETag: \x221356-56cdcacc8d0c0-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-1620/1621\x0aContent-Length: 1621\x0aKeep-Alive: timeout=5, max=45\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/*!\x0a * hoverIntent v1.8.3 // 2014.08.11 // jQuery v1.9.1+\x0a * http://cherne.net/brian/resources/jquery.hoverIntent.html\x0a *\x0a * You may use hoverIntent under the terms of the MIT license. Basically that\x0a * means you are free to use hoverIntent as long as this header is left intact.\x0a * Copyright 2007, 2014 Brian Cherne\x0a */\x0a \x0a/* hoverIntent is similar to jQuery\x27s built-in \x22hover\x22 method except that\x0a * instead of firing the handlerIn function immediately, hoverIntent checks\x0a * to see if the user\x27s mouse has slowed down (beneath the sensitivity\x0a * threshold) before firing the event. The handlerOut function is only\x0a * called after a matching handlerIn.\x0a *\x0a * // basic usage ... just like .hover()\x0a * .hoverIntent( handlerIn, handlerOut )\x0a * .hoverIntent( handlerInOut )\x0a *\x0a * // basic usage ... with event delegation!\x0a * .hoverIntent( handlerIn, handlerOut, selector )\x0a * .hoverIntent( handlerInOut, selector )\x0a *\x0a * // using a basic configuration object\x0a * .hoverIntent( config )\x0a *\x0a * @param  handlerIn   function OR configuration object\x0a * @param  handlerOut  function OR selector for delegation OR undefined\x0a * @param  selector    selector OR undefined\x0a * @author Brian Cherne \x3cbrian(at)cherne(dot)net\x3e\x0a */\x0a(function($) {\x0a    $.fn.hoverIntent = function(handlerIn,handlerOut,selector) {\x0a\x0a        // default configuration values\x0a        var cfg = {\x0a            interval: 100,\x0a            sensitivity: 6,\x0a            timeout: 0\x0a        };\x0a\x0a        if ( typeof handlerIn === \x22object\x22 ) {\x0a            cfg = $.extend(cfg, handlerIn );\x0a        } else if ($.isFunction(handlerOut)) {\x0a            cfg = $.extend(cfg, { over: handlerIn, out: handlerOut, selector: selector } );\x0a        } else {\x0a            cfg = $.extend(cfg, { over: handlerIn, out: handlerIn, selector: handlerOut } );\x0a        }\x0a\x0a        // instantiate variables\x0a        // cX, cY = current X and Y position of mouse, updated by mousemove event\x0a        // pX, pY = previous X and Y position of mouse, set by mouseover and polling interval\x0a        var cX, cY, pX, pY;\x0a\x0a        // A private function for getting mouse position\x0a        var track = function(ev) {\x0a            cX = ev.pageX;\x0a            cY = ev.pageY;\x0a        };\x0a\x0a        // A private function for comparing current and previous mouse position\x0a        var compare = function(ev,ob) {\x0a            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);\x0a            // compare mouse positions to see if they\x27ve crossed the threshold\x0a            if ( Math.sqrt( (pX-cX)*(pX-cX) + (pY-cY)*(pY-cY) ) \x3c cfg.sensitivity ) {\x0a                $(ob).off(\x22mousemove.hoverIntent\x22,track);\x0a                // set hoverIntent state to true (so mouseOut can be called)\x0a                ob.hoverIntent_s = true;\x0a                return cfg.over.apply(ob,[ev]);\x0a            } else {\x0a                // set previous coordinates for next time\x0a                pX = cX; pY = cY;\x0a                // use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)\x0a                ob.hoverIntent_t = setTimeout( function(){compare(ev, ob);} , cfg.interval );\x0a            }\x0a        };\x0a\x0a        // A private function for delaying the mouseOut function\x0a        var delay = function(ev,ob) {\x0a            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);\x0a            ob.hoverIntent_s = false;\x0a            return cfg.out.apply(ob,[ev]);\x0a        };\x0a\x0a        // A private function for handling mouse \x27hovering\x27\x0a        var handleHover = function(e) {\x0a            // copy objects to be passed into t (required for event object to be passed in IE)\x0a            var ev = $.extend({},e);\x0a            var ob = this;\x0a\x0a            // cancel hoverIntent timer if it exists\x0a            if (ob.hoverIntent_t) { ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t); }\x0a\x0a            // if e.type === \x22mouseenter\x22\x0a            if (e.type === \x22mouseenter\x22) {\x0a                // set \x22previous\x22 X and Y position based on initial entry point\x0a                pX = ev.pageX; pY = ev.pageY;\x0a                // update \x22current\x22 X and Y position based on mousemove\x0a                $(ob).on(\x22mousemove.hoverIntent\x22,track);\x0a                // start polling interval (self-calling timeout) to compare mouse coordinates over time\x0a                if (!ob.hoverIntent_s) { ob.hoverIntent_t = setTimeout( function(){compare(ev,ob);} , cfg.interval );}\x0a\x0a                // else e.type == \x22mouseleave\x22\x0a            } else {\x0a                // unbind expensive mousemove event\x0a                $(ob).off(\x22mousemove.hoverIntent\x22,track);\x0a                // if hoverIntent state is true, then call the mouseOut function after the specified delay\x0a                if (ob.hoverIntent_s) { ob.hoverIntent_t = setTimeout( function(){delay(ev,ob);} , cfg.timeout );}\x0a            }\x0a        };\x0a\x0a        // listen for mouseenter and mouseleave\x0a        return this.on({\x27mouseenter.hoverIntent\x27:handleHover,\x27mouseleave.hoverIntent\x27:handleHover}, cfg.selector);\x0a    };\x0a})(jQuery);\x0ar\xb1\x87\xd1\xf3)\xe0:\x83\x8d^\xa2\xd1'}