var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:12:02 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Tue, 05 Mar 2019 01:52:51 GMT\x0aETag: \x22275c-5834f217c42c0-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-3182/3183\x0aContent-Length: 3183\x0aKeep-Alive: timeout=5, max=19\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/**\x0a * Handles the addition of the comment form.\x0a *\x0a * @since 2.7.0\x0a * @output wp-includes/js/comment-reply.js\x0a *\x0a * @namespace addComment\x0a *\x0a * @type {Object}\x0a */\x0awindow.addComment = ( function( window ) {\x0a\x09// Avoid scope lookups on commonly used variables.\x0a\x09var document = window.document;\x0a\x0a\x09// Settings.\x0a\x09var config = {\x0a\x09\x09commentReplyClass : \x27comment-reply-link\x27,\x0a\x09\x09cancelReplyId     : \x27cancel-comment-reply-link\x27,\x0a\x09\x09commentFormId     : \x27commentform\x27,\x0a\x09\x09temporaryFormId   : \x27wp-temp-form-div\x27,\x0a\x09\x09parentIdFieldId   : \x27comment_parent\x27,\x0a\x09\x09postIdFieldId     : \x27comment_post_ID\x27\x0a\x09};\x0a\x0a\x09// Cross browser MutationObserver.\x0a\x09var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;\x0a\x0a\x09// Check browser cuts the mustard.\x0a\x09var cutsTheMustard = \x27querySelector\x27 in document && \x27addEventListener\x27 in window;\x0a\x0a\x09/*\x0a\x09 * Check browser supports dataset.\x0a\x09 * !! sets the variable to true if the property exists.\x0a\x09 */\x0a\x09var supportsDataset = !! document.documentElement.dataset;\x0a\x0a\x09// For holding the cancel element.\x0a\x09var cancelElement;\x0a\x0a\x09// For holding the comment form element.\x0a\x09var commentFormElement;\x0a\x0a\x09// The respond element.\x0a\x09var respondElement;\x0a\x0a\x09// The mutation observer.\x0a\x09var observer;\x0a\x0a\x09if ( cutsTheMustard && document.readyState !== \x27loading\x27 ) {\x0a\x09\x09ready();\x0a\x09} else if ( cutsTheMustard ) {\x0a\x09\x09window.addEventListener( \x27DOMContentLoaded\x27, ready, false );\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Sets up object variables after the DOM is ready.\x0a\x09 *\x0a\x09 * @since 5.1.1\x0a\x09 */\x0a\x09function ready() {\x0a\x09\x09// Initialise the events.\x0a\x09\x09init();\x0a\x0a\x09\x09// Set up a MutationObserver to check for comments loaded late.\x0a\x09\x09observeChanges();\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Add events to links classed .comment-reply-link.\x0a\x09 *\x0a\x09 * Searches the context for reply links and adds the JavaScript events\x0a\x09 * required to move the comment form. To allow for lazy loading of\x0a\x09 * comments this method is exposed as window.commentReply.init().\x0a\x09 *\x0a\x09 * @since 5.1.0\x0a\x09 *\x0a\x09 * @memberOf addComment\x0a\x09 *\x0a\x09 * @param {HTMLElement} context The parent DOM element to search for links.\x0a\x09 */\x0a\x09function init( context ) {\x0a\x09\x09if ( ! cutsTheMustard ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09// Get required elements.\x0a\x09\x09cancelElement = getElementById( config.cancelReplyId );\x0a\x09\x09commentFormElement = getElementById( config.commentFormId );\x0a\x0a\x09\x09// No cancel element, no replies.\x0a\x09\x09if ( ! cancelElement ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09cancelElement.addEventListener( \x27touchstart\x27, cancelEvent );\x0a\x09\x09cancelElement.addEventListener( \x27click\x27,      cancelEvent );\x0a\x0a\x09\x09var links = replyLinks( context );\x0a\x09\x09var element;\x0a\x0a\x09\x09for ( var i = 0, l = links.length; i \x3c l; i++ ) {\x0a\x09\x09\x09element = links[i];\x0a\x0a\x09\x09\x09element.addEventListener( \x27touchstart\x27, clickEvent );\x0a\x09\x09\x09element.addEventListener( \x27click\x27,      clickEvent );\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Return all links classed .comment-reply-link.\x0a\x09 *\x0a\x09 * @since 5.1.0\x0a\x09 *\x0a\x09 * @param {HTMLElement} context The parent DOM element to search for links.\x0a\x09 *\x0a\x09 * @return {HTMLCollection|NodeList|Array}\x0a\x09 */\x0a\x09function replyLinks( context ) {\x0a\x09\x09var selectorClass = config.commentReplyClass;\x0a\x09\x09var allReplyLinks;\x0a\x0a\x09\x09// childNodes is a handy check to ensure the context is a HTMLElement.\x0a\x09\x09if ( ! context || ! context.childNodes ) {\x0a\x09\x09\x09context = document;\x0a\x09\x09}\x0a\x0a\x09\x09if ( document.getElementsByClassName ) {\x0a\x09\x09\x09// Fastest.\x0a\x09\x09\x09allReplyLinks = context.getElementsByClassName( selectorClass );\x0a\x09\x09}\x0a\x09\x09else {\x0a\x09\x09\x09// Fast.\x0a\x09\x09\x09allReplyLinks = context.querySelectorAll( \x27.\x27 + selectorClass );\x0a\x09\x09}\x0a\x0a\x09\x09return allReplyLinks;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Cancel event handler.\x0a\x09 *\x0a\x09 * @since 5.1.0\x0a\x09 *\x0a\x09 * @param {Event} event The calling event.\x0a\x09 */\x0a\x09function cancelEvent( event ) {\x0a\x09\x09var cancelLink = this;\x0a\x09\x09var temporaryFormId  = config.temporaryFormId;\x0a\x09\x09var temporaryElement = getElementById( temporaryFormId );\x0a\x0a\x09\x09if ( ! temporaryElement || ! respondElement ) {\x0a\x09\x09\x09// Conditions for cancel link fail.\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09getElementById( config.parentIdFieldId ).value = \x270\x27;\x0a\x0a\x09\x09// Move the respond form back in place of the temporary element.\x0a\x09\x09temporaryElement.parentNode.replaceChild( respondElement ,temporaryElement );\x0a\x09\x09cancelLink.style.display = \x27none\x27;\x0a\x09\x09event.preventDefault();\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Click event handler.\x0a\x09 *\x0a\x09 * @since 5.1.0\x0a\x09 *\x0a\x09 * @param {Event} event The calling event.\x0a\x09 */\x0a\x09function clickEvent( event ) {\x0a\x09\x09var replyLink = this,\x0a\x09\x09\x09commId    = getDataAttribute( replyLink, \x27belowelement\x27),\x0a\x09\x09\x09parentId  = getDataAttribute( replyLink, \x27commentid\x27 ),\x0a\x09\x09\x09respondId = getDataAttribute( replyLink, \x27respondelement\x27),\x0a\x09\x09\x09postId    = getDataAttribute( replyLink, \x27postid\x27),\x0a\x09\x09\x09follow;\x0a\x0a\x09\x09if ( ! commId || ! parentId || ! respondId || ! postId ) {\x0a\x09\x09\x09/*\x0a\x09\x09\x09 * Theme or plugin defines own link via custom `wp_list_comments()` callback\x0a\x09\x09\x09 * and calls `moveForm()` either directly or via a custom event hook.\x0a\x09\x09\x09 */\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09/*\x0a\x09\x09 * Third party comments systems can hook into this function via the global scope,\x0a\x09\x09 * therefore the click event needs to reference the global scope.\x0a\x09\x09 */\x0a\x09\x09follow = window.addComment.moveForm(commId, parentId, respondId, postId);\x0a\x09\x09if ( false === follow ) {\x0a\x09\x09\x09event.preventDefault();\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Creates a mutation observer to check for newly inserted comments.\x0a\x09 *\x0a\x09 * @since 5.1.0\x0a\x09 */\x0a\x09function observeChanges() {\x0a\x09\x09if ( ! MutationObserver ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09var observerOptions = {\x0a\x09\x09\x09childList: true,\x0a\x09\x09\x09subTree: true\x0a\x09\x09};\x0a\x0a\x09\x09observer = new MutationObserver( handleChanges );\x0a\x09\x09observer.observe( document.body, observerOptions );\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Handles DOM changes, calling init() if any new nodes are added.\x0a\x09 *\x0a\x09 * @since 5.1.0\x0a\x09 *\x0a\x09 * @param {Array} mutationRecords Array of MutationRecord objects.\x0a\x09 */\x0a\x09function handleChanges( mutationRecords ) {\x0a\x09\x09var i = mutationRecords.length;\x0a\x0a\x09\x09while ( i-- ) {\x0a\x09\x09\x09// Call init() once if any record in this set adds nodes.\x0a\x09\x09\x09if ( mutationRecords[ i ].addedNodes.length ) {\x0a\x09\x09\x09\x09init();\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Backward compatible getter of data-* attribute.\x0a\x09 *\x0a\x09 * Uses element.dataset if it exists, otherwise uses getAttribute.\x0a\x09 *\x0a\x09 * @since 5.1.0\x0a\x09 *\x0a\x09 * @param {HTMLElement} Element DOM element with the attribute.\x0a\x09 * @param {String}      Attribute the attribute to get.\x0a\x09 *\x0a\x09 * @return {String}\x0a\x09 */\x0a\x09function getDataAttribute( element, attribute ) {\x0a\x09\x09if ( supportsDataset ) {\x0a\x09\x09\x09return element.dataset[attribute];\x0a\x09\x09}\x0a\x09\x09else {\x0a\x09\x09\x09return element.getAttribute( \x27data-\x27 + attribute );\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Get element by ID.\x0a\x09 *\x0a\x09 * Local alias for document.getElementById.\x0a\x09 *\x0a\x09 * @since 5.1.0\x0a\x09 *\x0a\x09 * @param {HTMLElement} The requested element.\x0a\x09 */\x0a\x09function getElementById( elementId ) {\x0a\x09\x09return document.getElementById( elementId );\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Moves the reply form from its current position to the reply location.\x0a\x09 *\x0a\x09 * @since 2.7.0\x0a\x09 *\x0a\x09 * @memberOf addComment\x0a\x09 *\x0a\x09 * @param {String} addBelowId HTML ID of element the form follows.\x0a\x09 * @param {String} commentId  Database ID of comment being replied to.\x0a\x09 * @param {String} respondId  HTML ID of \x27respond\x27 element.\x0a\x09 * @param {String} postId     Database ID of the post.\x0a\x09 */\x0a\x09function moveForm( addBelowId, commentId, respondId, postId ) {\x0a\x09\x09// Get elements based on their IDs.\x0a\x09\x09var addBelowElement = getElementById( addBelowId );\x0a\x09\x09respondElement  = getElementById( respondId );\x0a\x0a\x09\x09// Get the hidden fields.\x0a\x09\x09var parentIdField   = getElementById( config.parentIdFieldId );\x0a\x09\x09var postIdField     = getElementById( config.postIdFieldId );\x0a\x09\x09var element, cssHidden, style;\x0a\x0a\x09\x09if ( ! addBelowElement || ! respondElement || ! parentIdField ) {\x0a\x09\x09\x09// Missing key elements, fail.\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09addPlaceHolder( respondElement );\x0a\x0a\x09\x09// Set the value of the post.\x0a\x09\x09if ( postId && postIdField ) {\x0a\x09\x09\x09postIdField.value = postId;\x0a\x09\x09}\x0a\x0a\x09\x09parentIdField.value = commentId;\x0a\x0a\x09\x09cancelElement.style.display = \x27\x27;\x0a\x09\x09addBelowElement.parentNode.insertBefore( respondElement, addBelowElement.nextSibling );\x0a\x0a\x09\x09/*\x0a\x09\x09 * This is for backward compatibility with third party commenting systems\x0a\x09\x09 * hooking into the event using older techniques.\x0a\x09\x09 */\x0a\x09\x09cancelElement.onclick = function(){\x0a\x09\x09\x09return false;\x0a\x09\x09};\x0a\x0a\x09\x09// Focus on the first field in the comment form.\x0a\x09\x09try {\x0a\x09\x09\x09for ( var i = 0; i \x3c commentFormElement.elements.length; i++ ) {\x0a\x09\x09\x09\x09element = commentFormElement.elements[i];\x0a\x09\x09\x09\x09cssHidden = false;\x0a\x0a\x09\x09\x09\x09// Get elements computed style.\x0a\x09\x09\x09\x09if ( \x27getComputedStyle\x27 in window ) {\x0a\x09\x09\x09\x09\x09// Modern browsers.\x0a\x09\x09\x09\x09\x09style = window.getComputedStyle( element );\x0a\x09\x09\x09\x09} else if ( document.documentElement.currentStyle ) {\x0a\x09\x09\x09\x09\x09// IE 8.\x0a\x09\x09\x09\x09\x09style = element.currentStyle;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09/*\x0a\x09\x09\x09\x09 * For display none, do the same thing jQuery does. For visibility,\x0a\x09\x09\x09\x09 * check the element computed style since browsers are already doing\x0a\x09\x09\x09\x09 * the job for us. In fact, the visibility computed style is the actual\x0a\x09\x09\x09\x09 * computed value and already takes into account the element ancestors.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09if ( ( element.offsetWidth \x3c= 0 && element.offsetHeight \x3c= 0 ) || style.visibility === \x27hidden\x27 ) {\x0a\x09\x09\x09\x09\x09cssHidden = true;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Skip form elements that are hidden or disabled.\x0a\x09\x09\x09\x09if ( \x27hidden\x27 === element.type || element.disabled || cssHidden ) {\x0a\x09\x09\x09\x09\x09continue;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09element.focus();\x0a\x09\x09\x09\x09// Stop after the first focusable element.\x0a\x09\x09\x09\x09break;\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09\x09catch(e) {\x0a\x0a\x09\x09}\x0a\x0a\x09\x09/*\x0a\x09\x09 * false is returned for backward compatibility with third party commenting systems\x0a\x09\x09 * hooking into this function.\x0a\x09\x09 */\x0a\x09\x09return false;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Add placeholder element.\x0a\x09 *\x0a\x09 * Places a place holder element above the #respond element for\x0a\x09 * the form to be returned to if needs be.\x0a\x09 *\x0a\x09 * @since 2.7.0\x0a\x09 *\x0a\x09 * @param {HTMLelement} respondElement the #respond element holding comment form.\x0a\x09 */\x0a\x09function addPlaceHolder( respondElement ) {\x0a\x09\x09var temporaryFormId  = config.temporaryFormId;\x0a\x09\x09var temporaryElement = getElementById( temporaryFormId );\x0a\x0a\x09\x09if ( temporaryElement ) {\x0a\x09\x09\x09// The element already exists, no need to recreate.\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09temporaryElement = document.createElement( \x27div\x27 );\x0a\x09\x09temporaryElement.id = temporaryFormId;\x0a\x09\x09temporaryElement.style.display = \x27none\x27;\x0a\x09\x09respondElement.parentNode.insertBefore( temporaryElement, respondElement );\x0a\x09}\x0a\x0a\x09return {\x0a\x09\x09init: init,\x0a\x09\x09moveForm: moveForm\x0a\x09};\x0a})( window );\x0a'}