var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:05:36 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 16 May 2019 18:12:57 GMT\x0aETag: \x221bb98-58905372b9c40-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-24928/24929\x0aContent-Length: 24929\x0aKeep-Alive: timeout=5, max=29\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0athis[\x22wp\x22] = this[\x22wp\x22] || {}; this[\x22wp\x22][\x22richText\x22] =\x0a/******/ (function(modules) { // webpackBootstrap\x0a/******/ \x09// The module cache\x0a/******/ \x09var installedModules = {};\x0a/******/\x0a/******/ \x09// The require function\x0a/******/ \x09function __webpack_require__(moduleId) {\x0a/******/\x0a/******/ \x09\x09// Check if module is in cache\x0a/******/ \x09\x09if(installedModules[moduleId]) {\x0a/******/ \x09\x09\x09return installedModules[moduleId].exports;\x0a/******/ \x09\x09}\x0a/******/ \x09\x09// Create a new module (and put it into the cache)\x0a/******/ \x09\x09var module = installedModules[moduleId] = {\x0a/******/ \x09\x09\x09i: moduleId,\x0a/******/ \x09\x09\x09l: false,\x0a/******/ \x09\x09\x09exports: {}\x0a/******/ \x09\x09};\x0a/******/\x0a/******/ \x09\x09// Execute the module function\x0a/******/ \x09\x09modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\x0a/******/\x0a/******/ \x09\x09// Flag the module as loaded\x0a/******/ \x09\x09module.l = true;\x0a/******/\x0a/******/ \x09\x09// Return the exports of the module\x0a/******/ \x09\x09return module.exports;\x0a/******/ \x09}\x0a/******/\x0a/******/\x0a/******/ \x09// expose the modules object (__webpack_modules__)\x0a/******/ \x09__webpack_require__.m = modules;\x0a/******/\x0a/******/ \x09// expose the module cache\x0a/******/ \x09__webpack_require__.c = installedModules;\x0a/******/\x0a/******/ \x09// define getter function for harmony exports\x0a/******/ \x09__webpack_require__.d = function(exports, name, getter) {\x0a/******/ \x09\x09if(!__webpack_require__.o(exports, name)) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, name, { enumerable: true, get: getter });\x0a/******/ \x09\x09}\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// define __esModule on exports\x0a/******/ \x09__webpack_require__.r = function(exports) {\x0a/******/ \x09\x09if(typeof Symbol !== \x27undefined\x27 && Symbol.toStringTag) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, Symbol.toStringTag, { value: \x27Module\x27 });\x0a/******/ \x09\x09}\x0a/******/ \x09\x09Object.defineProperty(exports, \x27__esModule\x27, { value: true });\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// create a fake namespace object\x0a/******/ \x09// mode & 1: value is a module id, require it\x0a/******/ \x09// mode & 2: merge all properties of value into the ns\x0a/******/ \x09// mode & 4: return value when already ns object\x0a/******/ \x09// mode & 8|1: behave like require\x0a/******/ \x09__webpack_require__.t = function(value, mode) {\x0a/******/ \x09\x09if(mode & 1) value = __webpack_require__(value);\x0a/******/ \x09\x09if(mode & 8) return value;\x0a/******/ \x09\x09if((mode & 4) && typeof value === \x27object\x27 && value && value.__esModule) return value;\x0a/******/ \x09\x09var ns = Object.create(null);\x0a/******/ \x09\x09__webpack_require__.r(ns);\x0a/******/ \x09\x09Object.defineProperty(ns, \x27default\x27, { enumerable: true, value: value });\x0a/******/ \x09\x09if(mode & 2 && typeof value != \x27string\x27) for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\x0a/******/ \x09\x09return ns;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// getDefaultExport function for compatibility with non-harmony modules\x0a/******/ \x09__webpack_require__.n = function(module) {\x0a/******/ \x09\x09var getter = module && module.__esModule ?\x0a/******/ \x09\x09\x09function getDefault() { return module[\x27default\x27]; } :\x0a/******/ \x09\x09\x09function getModuleExports() { return module; };\x0a/******/ \x09\x09__webpack_require__.d(getter, \x27a\x27, getter);\x0a/******/ \x09\x09return getter;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// Object.prototype.hasOwnProperty.call\x0a/******/ \x09__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\x0a/******/\x0a/******/ \x09// __webpack_public_path__\x0a/******/ \x09__webpack_require__.p = \x22\x22;\x0a/******/\x0a/******/\x0a/******/ \x09// Load entry module and return exports\x0a/******/ \x09return __webpack_require__(__webpack_require__.s = 361);\x0a/******/ })\x0a/************************************************************************/\x0a/******/ ({\x0a\x0a/***/ 0:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22element\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 15:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _defineProperty; });\x0afunction _defineProperty(obj, key, value) {\x0a  if (key in obj) {\x0a    Object.defineProperty(obj, key, {\x0a      value: value,\x0a      enumerable: true,\x0a      configurable: true,\x0a      writable: true\x0a    });\x0a  } else {\x0a    obj[key] = value;\x0a  }\x0a\x0a  return obj;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 17:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\x0afunction _arrayWithoutHoles(arr) {\x0a  if (Array.isArray(arr)) {\x0a    for (var i = 0, arr2 = new Array(arr.length); i \x3c arr.length; i++) {\x0a      arr2[i] = arr[i];\x0a    }\x0a\x0a    return arr2;\x0a  }\x0a}\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js\x0avar iterableToArray = __webpack_require__(34);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\x0afunction _nonIterableSpread() {\x0a  throw new TypeError(\x22Invalid attempt to spread non-iterable instance\x22);\x0a}\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _toConsumableArray; });\x0a\x0a\x0a\x0afunction _toConsumableArray(arr) {\x0a  return _arrayWithoutHoles(arr) || Object(iterableToArray[\x22a\x22 /* default */])(arr) || _nonIterableSpread();\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 19:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _extends; });\x0afunction _extends() {\x0a  _extends = Object.assign || function (target) {\x0a    for (var i = 1; i \x3c arguments.length; i++) {\x0a      var source = arguments[i];\x0a\x0a      for (var key in source) {\x0a        if (Object.prototype.hasOwnProperty.call(source, key)) {\x0a          target[key] = source[key];\x0a        }\x0a      }\x0a    }\x0a\x0a    return target;\x0a  };\x0a\x0a  return _extends.apply(this, arguments);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 2:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22lodash\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 26:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22hooks\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 30:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0avar LEAF_KEY, hasWeakMap;\x0a\x0a/**\x0a * Arbitrary value used as key for referencing cache object in WeakMap tree.\x0a *\x0a * @type {Object}\x0a */\x0aLEAF_KEY = {};\x0a\x0a/**\x0a * Whether environment supports WeakMap.\x0a *\x0a * @type {boolean}\x0a */\x0ahasWeakMap = typeof WeakMap !== \x27undefined\x27;\x0a\x0a/**\x0a * Returns the first argument as the sole entry in an array.\x0a *\x0a * @param {*} value Value to return.\x0a *\x0a * @return {Array} Value returned as entry in array.\x0a */\x0afunction arrayOf( value ) {\x0a\x09return [ value ];\x0a}\x0a\x0a/**\x0a * Returns true if the value passed is object-like, or false otherwise. A value\x0a * is object-like if it can support property assignment, e.g. object or array.\x0a *\x0a * @param {*} value Value to test.\x0a *\x0a * @return {boolean} Whether value is object-like.\x0a */\x0afunction isObjectLike( value ) {\x0a\x09return !! value && \x27object\x27 === typeof value;\x0a}\x0a\x0a/**\x0a * Creates and returns a new cache object.\x0a *\x0a * @return {Object} Cache object.\x0a */\x0afunction createCache() {\x0a\x09var cache = {\x0a\x09\x09clear: function() {\x0a\x09\x09\x09cache.head = null;\x0a\x09\x09},\x0a\x09};\x0a\x0a\x09return cache;\x0a}\x0a\x0a/**\x0a * Returns true if entries within the two arrays are strictly equal by\x0a * reference from a starting index.\x0a *\x0a * @param {Array}  a         First array.\x0a * @param {Array}  b         Second array.\x0a * @param {number} fromIndex Index from which to start comparison.\x0a *\x0a * @return {boolean} Whether arrays are shallowly equal.\x0a */\x0afunction isShallowEqual( a, b, fromIndex ) {\x0a\x09var i;\x0a\x0a\x09if ( a.length !== b.length ) {\x0a\x09\x09return false;\x0a\x09}\x0a\x0a\x09for ( i = fromIndex; i \x3c a.length; i++ ) {\x0a\x09\x09if ( a[ i ] !== b[ i ] ) {\x0a\x09\x09\x09return false;\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09return true;\x0a}\x0a\x0a/**\x0a * Returns a memoized selector function. The getDependants function argument is\x0a * called before the memoized selector and is expected to return an immutable\x0a * reference or array of references on which the selector depends for computing\x0a * its own return value. The memoize cache is preserved only as long as those\x0a * dependant references remain the same. If getDependants returns a different\x0a * reference(s), the cache is cleared and the selector value regenerated.\x0a *\x0a * @param {Function} selector      Selector function.\x0a * @param {Function} getDependants Dependant getter returning an immutable\x0a *                                 reference or array of reference used in\x0a *                                 cache bust consideration.\x0a *\x0a * @return {Function} Memoized selector.\x0a */\x0a/* harmony default export */ __webpack_exports__[\x22a\x22] = (function( selector, getDependants ) {\x0a\x09var rootCache, getCache;\x0a\x0a\x09// Use object source as dependant if getter not provided\x0a\x09if ( ! getDependants ) {\x0a\x09\x09getDependants = arrayOf;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Returns the root cache. If WeakMap is supported, this is assigned to the\x0a\x09 * root WeakMap cache set, otherwise it is a shared instance of the default\x0a\x09 * cache object.\x0a\x09 *\x0a\x09 * @return {(WeakMap|Object)} Root cache object.\x0a\x09 */\x0a\x09function getRootCache() {\x0a\x09\x09return rootCache;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Returns the cache for a given dependants array. When possible, a WeakMap\x0a\x09 * will be used to create a unique cache for each set of dependants. This\x0a\x09 * is feasible due to the nature of WeakMap in allowing garbage collection\x0a\x09 * to occur on entries where the key object is no longer referenced. Since\x0a\x09 * WeakMap requires the key to be an object, this is only possible when the\x0a\x09 * dependant is object-like. The root cache is created as a hierarchy where\x0a\x09 * each top-level key is the first entry in a dependants set, the value a\x0a\x09 * WeakMap where each key is the next dependant, and so on. This continues\x0a\x09 * so long as the dependants are object-like. If no dependants are object-\x0a\x09 * like, then the cache is shared across all invocations.\x0a\x09 *\x0a\x09 * @see isObjectLike\x0a\x09 *\x0a\x09 * @param {Array} dependants Selector dependants.\x0a\x09 *\x0a\x09 * @return {Object} Cache object.\x0a\x09 */\x0a\x09function getWeakMapCache( dependants ) {\x0a\x09\x09var caches = rootCache,\x0a\x09\x09\x09isUniqueByDependants = true,\x0a\x09\x09\x09i, dependant, map, cache;\x0a\x0a\x09\x09for ( i = 0; i \x3c dependants.length; i++ ) {\x0a\x09\x09\x09dependant = dependants[ i ];\x0a\x0a\x09\x09\x09// Can only compose WeakMap from object-like key.\x0a\x09\x09\x09if ( ! isObjectLike( dependant ) ) {\x0a\x09\x09\x09\x09isUniqueByDependants = false;\x0a\x09\x09\x09\x09break;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Does current segment of cache already have a WeakMap?\x0a\x09\x09\x09if ( caches.has( dependant ) ) {\x0a\x09\x09\x09\x09// Traverse into nested WeakMap.\x0a\x09\x09\x09\x09caches = caches.get( dependant );\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09// Create, set, and traverse into a new one.\x0a\x09\x09\x09\x09map = new WeakMap();\x0a\x09\x09\x09\x09caches.set( dependant, map );\x0a\x09\x09\x09\x09caches = map;\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09// We use an arbitrary (but consistent) object as key for the last item\x0a\x09\x09// in the WeakMap to serve as our running cache.\x0a\x09\x09if ( ! caches.has( LEAF_KEY ) ) {\x0a\x09\x09\x09cache = createCache();\x0a\x09\x09\x09cache.isUniqueByDependants = isUniqueByDependants;\x0a\x09\x09\x09caches.set( LEAF_KEY, cache );\x0a\x09\x09}\x0a\x0a\x09\x09return caches.get( LEAF_KEY );\x0a\x09}\x0a\x0a\x09// Assign cache handler by availability of WeakMap\x0a\x09getCache = hasWeakMap ? getWeakMapCache : getRootCache;\x0a\x0a\x09/**\x0a\x09 * Resets root memoization cache.\x0a\x09 */\x0a\x09function clear() {\x0a\x09\x09rootCache = hasWeakMap ? new WeakMap() : createCache();\x0a\x09}\x0a\x0a\x09// eslint-disable-next-line jsdoc/check-param-names\x0a\x09/**\x0a\x09 * The augmented selector call, considering first whether dependants have\x0a\x09 * changed before passing it to underlying memoize function.\x0a\x09 *\x0a\x09 * @param {Object} source    Source object for derivation.\x0a\x09 * @param {...*}   extraArgs Additional arguments to pass to selector.\x0a\x09 *\x0a\x09 * @return {*} Selector result.\x0a\x09 */\x0a\x09function callSelector( /* source, ...extraArgs */ ) {\x0a\x09\x09var len = arguments.length,\x0a\x09\x09\x09cache, node, i, args, dependants;\x0a\x0a\x09\x09// Create copy of arguments (avoid leaking deoptimization).\x0a\x09\x09args = new Array( len );\x0a\x09\x09for ( i = 0; i \x3c len; i++ ) {\x0a\x09\x09\x09args[ i ] = arguments[ i ];\x0a\x09\x09}\x0a\x0a\x09\x09dependants = getDependants.apply( null, args );\x0a\x09\x09cache = getCache( dependants );\x0a\x0a\x09\x09// If not guaranteed uniqueness by dependants (primitive type or lack\x0a\x09\x09// of WeakMap support), shallow compare against last dependants and, if\x0a\x09\x09// references have changed, destroy cache to recalculate result.\x0a\x09\x09if ( ! cache.isUniqueByDependants ) {\x0a\x09\x09\x09if ( cache.lastDependants && ! isShallowEqual( dependants, cache.lastDependants, 0 ) ) {\x0a\x09\x09\x09\x09cache.clear();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09cache.lastDependants = dependants;\x0a\x09\x09}\x0a\x0a\x09\x09node = cache.head;\x0a\x09\x09while ( node ) {\x0a\x09\x09\x09// Check whether node arguments match arguments\x0a\x09\x09\x09if ( ! isShallowEqual( node.args, args, 1 ) ) {\x0a\x09\x09\x09\x09node = node.next;\x0a\x09\x09\x09\x09continue;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// At this point we can assume we\x27ve found a match\x0a\x0a\x09\x09\x09// Surface matched node to head if not already\x0a\x09\x09\x09if ( node !== cache.head ) {\x0a\x09\x09\x09\x09// Adjust siblings to point to each other.\x0a\x09\x09\x09\x09node.prev.next = node.next;\x0a\x09\x09\x09\x09if ( node.next ) {\x0a\x09\x09\x09\x09\x09node.next.prev = node.prev;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09node.next = cache.head;\x0a\x09\x09\x09\x09node.prev = null;\x0a\x09\x09\x09\x09cache.head.prev = node;\x0a\x09\x09\x09\x09cache.head = node;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Return immediately\x0a\x09\x09\x09return node.val;\x0a\x09\x09}\x0a\x0a\x09\x09// No cached value found. Continue to insertion phase:\x0a\x0a\x09\x09node = {\x0a\x09\x09\x09// Generate the result from original function\x0a\x09\x09\x09val: selector.apply( null, args ),\x0a\x09\x09};\x0a\x0a\x09\x09// Avoid including the source object in the cache.\x0a\x09\x09args[ 0 ] = null;\x0a\x09\x09node.args = args;\x0a\x0a\x09\x09// Don\x27t need to check whether node is already head, since it would\x0a\x09\x09// have been returned above already if it was\x0a\x0a\x09\x09// Shift existing head down list\x0a\x09\x09if ( cache.head ) {\x0a\x09\x09\x09cache.head.prev = node;\x0a\x09\x09\x09node.next = cache.head;\x0a\x09\x09}\x0a\x0a\x09\x09cache.head = node;\x0a\x0a\x09\x09return node.val;\x0a\x09}\x0a\x0a\x09callSelector.getDependants = getDependants;\x0a\x09callSelector.clear = clear;\x0a\x09clear();\x0a\x0a\x09return callSelector;\x0a});\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 32:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _typeof; });\x0afunction _typeof2(obj) { if (typeof Symbol === \x22function\x22 && typeof Symbol.iterator === \x22symbol\x22) { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \x22function\x22 && obj.constructor === Symbol && obj !== Symbol.prototype ? \x22symbol\x22 : typeof obj; }; } return _typeof2(obj); }\x0a\x0afunction _typeof(obj) {\x0a  if (typeof Symbol === \x22function\x22 && _typeof2(Symbol.iterator) === \x22symbol\x22) {\x0a    _typeof = function _typeof(obj) {\x0a      return _typeof2(obj);\x0a    };\x0a  } else {\x0a    _typeof = function _typeof(obj) {\x0a      return obj && typeof Symbol === \x22function\x22 && obj.constructor === Symbol && obj !== Symbol.prototype ? \x22symbol\x22 : _typeof2(obj);\x0a    };\x0a  }\x0a\x0a  return _typeof(obj);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 34:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _iterableToArray; });\x0afunction _iterableToArray(iter) {\x0a  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \x22[object Arguments]\x22) return Array.from(iter);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 361:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0avar selectors_namespaceObject = {};\x0a__webpack_require__.r(selectors_namespaceObject);\x0a__webpack_require__.d(selectors_namespaceObject, \x22getFormatTypes\x22, function() { return getFormatTypes; });\x0a__webpack_require__.d(selectors_namespaceObject, \x22getFormatType\x22, function() { return getFormatType; });\x0a__webpack_require__.d(selectors_namespaceObject, \x22getFormatTypeForBareElement\x22, function() { return getFormatTypeForBareElement; });\x0a__webpack_require__.d(selectors_namespaceObject, \x22getFormatTypeForClassName\x22, function() { return getFormatTypeForClassName; });\x0avar actions_namespaceObject = {};\x0a__webpack_require__.r(actions_namespaceObject);\x0a__webpack_require__.d(actions_namespaceObject, \x22addFormatTypes\x22, function() { return addFormatTypes; });\x0a__webpack_require__.d(actions_namespaceObject, \x22removeFormatTypes\x22, function() { return removeFormatTypes; });\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22data\x22]}\x0avar external_this_wp_data_ = __webpack_require__(5);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread.js\x0avar objectSpread = __webpack_require__(7);\x0a\x0a// EXTERNAL MODULE: external \x22lodash\x22\x0avar external_lodash_ = __webpack_require__(2);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/store/reducer.js\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a/**\x0a * Reducer managing the format types\x0a *\x0a * @param {Object} state  Current state.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @return {Object} Updated state.\x0a */\x0a\x0afunction reducer_formatTypes() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27ADD_FORMAT_TYPES\x27:\x0a      return Object(objectSpread[\x22a\x22 /* default */])({}, state, Object(external_lodash_[\x22keyBy\x22])(action.formatTypes, \x27name\x27));\x0a\x0a    case \x27REMOVE_FORMAT_TYPES\x27:\x0a      return Object(external_lodash_[\x22omit\x22])(state, action.names);\x0a  }\x0a\x0a  return state;\x0a}\x0a/* harmony default export */ var reducer = (Object(external_this_wp_data_[\x22combineReducers\x22])({\x0a  formatTypes: reducer_formatTypes\x0a}));\x0a\x0a// EXTERNAL MODULE: ./node_modules/rememo/es/rememo.js\x0avar rememo = __webpack_require__(30);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/store/selectors.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a\x0a/**\x0a * Returns all the available format types.\x0a *\x0a * @param {Object} state Data state.\x0a *\x0a * @return {Array} Format types.\x0a */\x0a\x0avar getFormatTypes = Object(rememo[\x22a\x22 /* default */])(function (state) {\x0a  return Object.values(state.formatTypes);\x0a}, function (state) {\x0a  return [state.formatTypes];\x0a});\x0a/**\x0a * Returns a format type by name.\x0a *\x0a * @param {Object} state Data state.\x0a * @param {string} name Format type name.\x0a *\x0a * @return {Object?} Format type.\x0a */\x0a\x0afunction getFormatType(state, name) {\x0a  return state.formatTypes[name];\x0a}\x0a/**\x0a * Gets the format type, if any, that can handle a bare element (without a\x0a * data-format-type attribute), given the tag name of this element.\x0a *\x0a * @param {Object} state              Data state.\x0a * @param {string} bareElementTagName The tag name of the element to find a\x0a *                                    format type for.\x0a * @return {?Object} Format type.\x0a */\x0a\x0afunction getFormatTypeForBareElement(state, bareElementTagName) {\x0a  return Object(external_lodash_[\x22find\x22])(getFormatTypes(state), function (_ref) {\x0a    var tagName = _ref.tagName;\x0a    return bareElementTagName === tagName;\x0a  });\x0a}\x0a/**\x0a * Gets the format type, if any, that can handle an element, given its classes.\x0a *\x0a * @param {Object} state            Data state.\x0a * @param {string} elementClassName The classes of the element to find a format\x0a *                                  type for.\x0a * @return {?Object} Format type.\x0a */\x0a\x0afunction getFormatTypeForClassName(state, elementClassName) {\x0a  return Object(external_lodash_[\x22find\x22])(getFormatTypes(state), function (_ref2) {\x0a    var className = _ref2.className;\x0a\x0a    if (className === null) {\x0a      return false;\x0a    }\x0a\x0a    return \x22 \x22.concat(elementClassName, \x22 \x22).indexOf(\x22 \x22.concat(className, \x22 \x22)) \x3e= 0;\x0a  });\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/store/actions.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Returns an action object used in signalling that format types have been\x0a * added.\x0a *\x0a * @param {Array|Object} formatTypes Format types received.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction addFormatTypes(formatTypes) {\x0a  return {\x0a    type: \x27ADD_FORMAT_TYPES\x27,\x0a    formatTypes: Object(external_lodash_[\x22castArray\x22])(formatTypes)\x0a  };\x0a}\x0a/**\x0a * Returns an action object used to remove a registered format type.\x0a *\x0a * @param {string|Array} names Format name.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction removeFormatTypes(names) {\x0a  return {\x0a    type: \x27REMOVE_FORMAT_TYPES\x27,\x0a    names: Object(external_lodash_[\x22castArray\x22])(names)\x0a  };\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/store/index.js\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0aObject(external_this_wp_data_[\x22registerStore\x22])(\x27core/rich-text\x27, {\x0a  reducer: reducer,\x0a  selectors: selectors_namespaceObject,\x0a  actions: actions_namespaceObject\x0a});\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules\x0avar toConsumableArray = __webpack_require__(17);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/is-format-equal.js\x0a/**\x0a * Optimised equality check for format objects.\x0a *\x0a * @param {?Object} format1 Format to compare.\x0a * @param {?Object} format2 Format to compare.\x0a *\x0a * @return {boolean} True if formats are equal, false if not.\x0a */\x0afunction isFormatEqual(format1, format2) {\x0a  // Both not defined.\x0a  if (format1 === format2) {\x0a    return true;\x0a  } // Either not defined.\x0a\x0a\x0a  if (!format1 || !format2) {\x0a    return false;\x0a  }\x0a\x0a  if (format1.type !== format2.type) {\x0a    return false;\x0a  }\x0a\x0a  var attributes1 = format1.attributes;\x0a  var attributes2 = format2.attributes; // Both not defined.\x0a\x0a  if (attributes1 === attributes2) {\x0a    return true;\x0a  } // Either not defined.\x0a\x0a\x0a  if (!attributes1 || !attributes2) {\x0a    return false;\x0a  }\x0a\x0a  var keys1 = Object.keys(attributes1);\x0a  var keys2 = Object.keys(attributes2);\x0a\x0a  if (keys1.length !== keys2.length) {\x0a    return false;\x0a  }\x0a\x0a  var length = keys1.length; // Optimise for speed.\x0a\x0a  for (var i = 0; i \x3c length; i++) {\x0a    var name = keys1[i];\x0a\x0a    if (attributes1[name] !== attributes2[name]) {\x0a      return false;\x0a    }\x0a  }\x0a\x0a  return true;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/normalise-formats.js\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a/**\x0a * Normalises formats: ensures subsequent adjacent equal formats have the same\x0a * reference.\x0a *\x0a * @param {Object} value Value to normalise formats of.\x0a *\x0a * @return {Object} New value with normalised formats.\x0a */\x0a\x0afunction normaliseFormats(value) {\x0a  var newFormats = value.formats.slice();\x0a  newFormats.forEach(function (formatsAtIndex, index) {\x0a    var formatsAtPreviousIndex = newFormats[index - 1];\x0a\x0a    if (formatsAtPreviousIndex) {\x0a      var newFormatsAtIndex = formatsAtIndex.slice();\x0a      newFormatsAtIndex.forEach(function (format, formatIndex) {\x0a        var previousFormat = formatsAtPreviousIndex[formatIndex];\x0a\x0a        if (isFormatEqual(format, previousFormat)) {\x0a          newFormatsAtIndex[formatIndex] = previousFormat;\x0a        }\x0a      });\x0a      newFormats[index] = newFormatsAtIndex;\x0a    }\x0a  });\x0a  return Object(objectSpread[\x22a\x22 /* default */])({}, value, {\x0a    formats: newFormats\x0a  });\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/apply-format.js\x0a\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Apply a format object to a Rich Text value from the given `startIndex` to the\x0a * given `endIndex`. Indices are retrieved from the selection if none are\x0a * provided.\x0a *\x0a * @param {Object} value        Value to modify.\x0a * @param {Object} format       Format to apply.\x0a * @param {number} [startIndex] Start index.\x0a * @param {number} [endIndex]   End index.\x0a *\x0a * @return {Object} A new value with the format applied.\x0a */\x0a\x0afunction applyFormat(value, format) {\x0a  var startIndex = arguments.length \x3e 2 && arguments[2] !== undefined ? arguments[2] : value.start;\x0a  var endIndex = arguments.length \x3e 3 && arguments[3] !== undefined ? arguments[3] : value.end;\x0a  var formats = value.formats,\x0a      activeFormats = value.activeFormats;\x0a  var newFormats = formats.slice(); // The selection is collapsed.\x0a\x0a  if (startIndex === endIndex) {\x0a    var startFormat = Object(external_lodash_[\x22find\x22])(newFormats[startIndex], {\x0a      type: format.type\x0a    }); // If the caret is at a format of the same type, expand start and end to\x0a    // the edges of the format. This is useful to apply new attributes.\x0a\x0a    if (startFormat) {\x0a      while (Object(external_lodash_[\x22find\x22])(newFormats[startIndex], startFormat)) {\x0a        applyFormats(newFormats, startIndex, format);\x0a        startIndex--;\x0a      }\x0a\x0a      endIndex++;\x0a\x0a      while (Object(external_lodash_[\x22find\x22])(newFormats[endIndex], startFormat)) {\x0a        applyFormats(newFormats, endIndex, format);\x0a        endIndex++;\x0a      }\x0a    }\x0a  } else {\x0a    for (var index = startIndex; index \x3c endIndex; index++) {\x0a      applyFormats(newFormats, index, format);\x0a    }\x0a  }\x0a\x0a  return normaliseFormats(Object(objectSpread[\x22a\x22 /* default */])({}, value, {\x0a    formats: newFormats,\x0a    // Always revise active formats. This serves as a placeholder for new\x0a    // inputs with the format so new input appears with the format applied,\x0a    // and ensures a format of the same type uses the latest values.\x0a    activeFormats: [].concat(Object(toConsumableArray[\x22a\x22 /* default */])(Object(external_lodash_[\x22reject\x22])(activeFormats, {\x0a      type: format.type\x0a    })), [format])\x0a  }));\x0a}\x0a\x0afunction applyFormats(formats, index, format) {\x0a  if (formats[index]) {\x0a    var newFormatsAtIndex = formats[index].filter(function (_ref) {\x0a      var type = _ref.type;\x0a      return type !== format.type;\x0a    });\x0a    newFormatsAtIndex.push(format);\x0a    formats[index] = newFormatsAtIndex;\x0a  } else {\x0a    formats[index] = [format];\x0a  }\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/char-at.js\x0a/**\x0a * Gets the character at the specified index, or returns `undefined` if no\x0a * character was found.\x0a *\x0a * @param {Object} value Value to get the character from.\x0a * @param {string} index Index to use.\x0a *\x0a * @return {string|undefined} A one character long string, or undefined.\x0a */\x0afunction charAt(_ref, index) {\x0a  var text = _ref.text;\x0a  return text[index];\x0a}\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js\x0avar esm_typeof = __webpack_require__(32);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/create-element.js\x0a/**\x0a * Parse the given HTML into a body element.\x0a *\x0a * Note: The current implementation will return a shared reference, reset on\x0a * each call to `createElement`. Therefore, you should not hold a reference to\x0a * the value to operate upon asynchronously, as it may have unexpected results.\x0a *\x0a * @param {HTMLDocument} document The HTML document to use to parse.\x0a * @param {string}       html     The HTML to parse.\x0a *\x0a * @return {HTMLBodyElement} Body element with parsed HTML.\x0a */\x0afunction createElement(_ref, html) {\x0a  var implementation = _ref.implementation;\x0a\x0a  // Because `createHTMLDocument` is an expensive operation, and with this\x0a  // function being internal to `rich-text` (full control in avoiding a risk\x0a  // of asynchronous operations on the shared reference), a single document\x0a  // is reused and reset for each call to the function.\x0a  if (!createElement.body) {\x0a    createElement.body = implementation.createHTMLDocument(\x27\x27).body;\x0a  }\x0a\x0a  createElement.body.innerHTML = html;\x0a  return createElement.body;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/special-characters.js\x0a/**\x0a * Line separator character.\x0a */\x0avar LINE_SEPARATOR = \x22\x5cu2028\x22;\x0avar OBJECT_REPLACEMENT_CHARACTER = \x22\x5cuFFFC\x22;\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/create.js\x0a\x0a\x0a\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0a\x0a/**\x0a * Browser dependencies\x0a */\x0a\x0avar _window$Node = window.Node,\x0a    TEXT_NODE = _window$Node.TEXT_NODE,\x0a    ELEMENT_NODE = _window$Node.ELEMENT_NODE;\x0a\x0afunction createEmptyValue() {\x0a  return {\x0a    formats: [],\x0a    replacements: [],\x0a    text: \x27\x27\x0a  };\x0a}\x0a\x0afunction simpleFindKey(object, value) {\x0a  for (var key in object) {\x0a    if (object[key] === value) {\x0a      return key;\x0a    }\x0a  }\x0a}\x0a\x0afunction toFormat(_ref) {\x0a  var type = _ref.type,\x0a      attributes = _ref.attributes;\x0a  var formatType;\x0a\x0a  if (attributes && attributes.class) {\x0a    formatType = Object(external_this_wp_data_[\x22select\x22])(\x27core/rich-text\x27).getFormatTypeForClassName(attributes.class);\x0a\x0a    if (formatType) {\x0a      // Preserve any additional classes.\x0a      attributes.class = \x22 \x22.concat(attributes.class, \x22 \x22).replace(\x22 \x22.concat(formatType.className, \x22 \x22), \x27 \x27).trim();\x0a\x0a      if (!attributes.class) {\x0a        delete attributes.class;\x0a      }\x0a    }\x0a  }\x0a\x0a  if (!formatType) {\x0a    formatType = Object(external_this_wp_data_[\x22select\x22])(\x27core/rich-text\x27).getFormatTypeForBareElement(type);\x0a  }\x0a\x0a  if (!formatType) {\x0a    return attributes ? {\x0a      type: type,\x0a      attributes: attributes\x0a    } : {\x0a      type: type\x0a    };\x0a  }\x0a\x0a  if (formatType.__experimentalCreatePrepareEditableTree && !formatType.__experimentalCreateOnChangeEditableValue) {\x0a    return null;\x0a  }\x0a\x0a  if (!attributes) {\x0a    return {\x0a      type: formatType.name\x0a    };\x0a  }\x0a\x0a  var registeredAttributes = {};\x0a  var unregisteredAttributes = {};\x0a\x0a  for (var name in attributes) {\x0a    var key = simpleFindKey(formatType.attributes, name);\x0a\x0a    if (key) {\x0a      registeredAttributes[key] = attributes[name];\x0a    } else {\x0a      unregisteredAttributes[name] = attributes[name];\x0a    }\x0a  }\x0a\x0a  return {\x0a    type: formatType.name,\x0a    attributes: registeredAttributes,\x0a    unregisteredAttributes: unregisteredAttributes\x0a  };\x0a}\x0a/**\x0a * Create a RichText value from an `Element` tree (DOM), an HTML string or a\x0a * plain text string, with optionally a `Range` object to set the selection. If\x0a * called without any input, an empty value will be created. If\x0a * `multilineTag` is provided, any content of direct children whose type matches\x0a * `multilineTag` will be separated by two newlines. The optional functions can\x0a * be used to filter out content.\x0a *\x0a * A value will have the following shape, which you are strongly encouraged not\x0a * to modify without the use of helper functions:\x0a *\x0a * ```js\x0a * {\x0a *   text: string,\x0a *   formats: Array,\x0a *   replacements: Array,\x0a *   ?start: number,\x0a *   ?end: number,\x0a * }\x0a * ```\x0a *\x0a * As you can see, text and formatting are separated. `text` holds the text,\x0a * including any replacement characters for objects and lines. `formats`,\x0a * `objects` and `lines` are all sparse arrays of the same length as `text`. It\x0a * holds information about the formatting at the relevant text indices. Finally\x0a * `start` and `end` state which text indices are selected. They are only\x0a * provided if a `Range` was given.\x0a *\x0a * @param {Object}  [$1]                      Optional named arguments.\x0a * @param {Element} [$1.element]              Element to create value from.\x0a * @param {string}  [$1.text]                 Text to create value from.\x0a * @param {string}  [$1.html]                 HTML to create value from.\x0a * @param {Range}   [$1.range]                Range to create value from.\x0a * @param {string}  [$1.multilineTag]         Multiline tag if the structure is\x0a *                                            multiline.\x0a * @param {Array}   [$1.multilineWrapperTags] Tags where lines can be found if\x0a *                                            nesting is possible.\x0a *\x0a * @return {Object} A rich text value.\x0a */\x0a\x0a\x0afunction create() {\x0a  var _ref2 = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {},\x0a      element = _ref2.element,\x0a      text = _ref2.text,\x0a      html = _ref2.html,\x0a      range = _ref2.range,\x0a      multilineTag = _ref2.multilineTag,\x0a      multilineWrapperTags = _ref2.multilineWrapperTags,\x0a      isEditableTree = _ref2.__unstableIsEditableTree;\x0a\x0a  if (typeof text === \x27string\x27 && text.length \x3e 0) {\x0a    return {\x0a      formats: Array(text.length),\x0a      replacements: Array(text.length),\x0a      text: text\x0a    };\x0a  }\x0a\x0a  if (typeof html === \x27string\x27 && html.length \x3e 0) {\x0a    element = createElement(document, html);\x0a  }\x0a\x0a  if (Object(esm_typeof[\x22a\x22 /* default */])(element) !== \x27object\x27) {\x0a    return createEmptyValue();\x0a  }\x0a\x0a  if (!multilineTag) {\x0a    return createFromElement({\x0a      element: element,\x0a      range: range,\x0a      isEditableTree: isEditableTree\x0a    });\x0a  }\x0a\x0a  return createFromMultilineElement({\x0a    element: element,\x0a    range: range,\x0a    multilineTag: multilineTag,\x0a    multilineWrapperTags: multilineWrapperTags,\x0a    isEditableTree: isEditableTree\x0a  });\x0a}\x0a/**\x0a * Helper to accumulate the value\x27s selection start and end from the current\x0a * node and range.\x0a *\x0a * @param {Object} accumulator Object to accumulate into.\x0a * @param {Node}   node        Node to create value with.\x0a * @param {Range}  range       Range to create value with.\x0a * @param {Object} value       Value that is being accumulated.\x0a */\x0a\x0afunction accumulateSelection(accumulator, node, range, value) {\x0a  if (!range) {\x0a    return;\x0a  }\x0a\x0a  var parentNode = node.parentNode;\x0a  var startContainer = range.startContainer,\x0a      startOffset = range.startOffset,\x0a      endContainer = range.endContainer,\x0a      endOffset = range.endOffset;\x0a  var currentLength = accumulator.text.length; // Selection can be extracted from value.\x0a\x0a  if (value.start !== undefined) {\x0a    accumulator.start = currentLength + value.start; // Range indicates that the current node has selection.\x0a  } else if (node === startContainer && node.nodeType === TEXT_NODE) {\x0a    accumulator.start = currentLength + startOffset; // Range indicates that the current node is selected.\x0a  } else if (parentNode === startContainer && node === startContainer.childNodes[startOffset]) {\x0a    accumulator.start = currentLength; // Range indicates that the selection is after the current node.\x0a  } else if (parentNode === startContainer && node === startContainer.childNodes[startOffset - 1]) {\x0a    accumulator.start = currentLength + value.text.length; // Fallback if no child inside handled the selection.\x0a  } else if (node === startContainer) {\x0a    accumulator.start = currentLength;\x0a  } // Selection can be extracted from value.\x0a\x0a\x0a  if (value.end !== undefined) {\x0a    accumulator.end = currentLength + value.end; // Range indicates that the current node has selection.\x0a  } else if (node === endContainer && node.nodeType === TEXT_NODE) {\x0a    accumulator.end = currentLength + endOffset; // Range indicates that the current node is selected.\x0a  } else if (parentNode === endContainer && node === endContainer.childNodes[endOffset - 1]) {\x0a    accumulator.end = currentLength + value.text.length; // Range indicates that the selection is before the current node.\x0a  } else if (parentNode === endContainer && node === endContainer.childNodes[endOffset]) {\x0a    accumulator.end = currentLength; // Fallback if no child inside handled the selection.\x0a  } else if (node === endContainer) {\x0a    accumulator.end = currentLength + endOffset;\x0a  }\x0a}\x0a/**\x0a * Adjusts the start and end offsets from a range based on a text filter.\x0a *\x0a * @param {Node}     node   Node of which the text should be filtered.\x0a * @param {Range}    range  The range to filter.\x0a * @param {Function} filter Function to use to filter the text.\x0a *\x0a * @return {?Object} Object containing range properties.\x0a */\x0a\x0a\x0afunction filterRange(node, range, filter) {\x0a  if (!range) {\x0a    return;\x0a  }\x0a\x0a  var startContainer = range.startContainer,\x0a      endContainer = range.endContainer;\x0a  var startOffset = range.startOffset,\x0a      endOffset = range.endOffset;\x0a\x0a  if (node === startContainer) {\x0a    startOffset = filter(node.nodeValue.slice(0, startOffset)).length;\x0a  }\x0a\x0a  if (node === endContainer) {\x0a    endOffset = filter(node.nodeValue.slice(0, endOffset)).length;\x0a  }\x0a\x0a  return {\x0a    startContainer: startContainer,\x0a    startOffset: startOffset,\x0a    endContainer: endContainer,\x0a    endOffset: endOffset\x0a  };\x0a}\x0a\x0afunction filterString(string) {\x0a  // Reduce any whitespace used for HTML formatting to one space\x0a  // character, because it will also be displayed as such by the browser.\x0a  return string.replace(/[\x5cn\x5cr\x5ct]+/g, \x27 \x27);\x0a}\x0a/**\x0a * Creates a Rich Text value from a DOM element and range.\x0a *\x0a * @param {Object}    $1                      Named argements.\x0a * @param {?Element}  $1.element              Element to create value from.\x0a * @param {?Range}    $1.range                Range to create value from.\x0a * @param {?string}   $1.multilineTag         Multiline tag if the structure is\x0a *                                            multiline.\x0a * @param {?Array}    $1.multilineWrapperTags Tags where lines can be found if\x0a *                                            nesting is possible.\x0a *\x0a * @return {Object} A rich text value.\x0a */\x0a\x0a\x0afunction createFromElement(_ref3) {\x0a  var element = _ref3.element,\x0a      range = _ref3.range,\x0a      multilineTag = _ref3.multilineTag,\x0a      multilineWrapperTags = _ref3.multilineWrapperTags,\x0a      _ref3$currentWrapperT = _ref3.currentWrapperTags,\x0a      currentWrapperTags = _ref3$currentWrapperT === void 0 ? [] : _ref3$currentWrapperT,\x0a      isEditableTree = _ref3.isEditableTree;\x0a  var accumulator = createEmptyValue();\x0a\x0a  if (!element) {\x0a    return accumulator;\x0a  }\x0a\x0a  if (!element.hasChildNodes()) {\x0a    accumulateSelection(accumulator, element, range, createEmptyValue());\x0a    return accumulator;\x0a  }\x0a\x0a  var length = element.childNodes.length; // Optimise for speed.\x0a\x0a  var _loop = function _loop(index) {\x0a    var node = element.childNodes[index];\x0a    var type = node.nodeName.toLowerCase();\x0a\x0a    if (node.nodeType === TEXT_NODE) {\x0a      var text = filterString(node.nodeValue);\x0a      range = filterRange(node, range, filterString);\x0a      accumulateSelection(accumulator, node, range, {\x0a        text: text\x0a      }); // Create a sparse array of the same length as `text`, in which\x0a      // formats can be added.\x0a\x0a      accumulator.formats.length += text.length;\x0a      accumulator.replacements.length += text.length;\x0a      accumulator.text += text;\x0a      return \x22continue\x22;\x0a    }\x0a\x0a    if (node.nodeType !== ELEMENT_NODE) {\x0a      return \x22continue\x22;\x0a    }\x0a\x0a    if (node.getAttribute(\x27data-rich-text-padding\x27) || isEditableTree && type === \x27br\x27 && !node.getAttribute(\x27data-rich-text-line-break\x27)) {\x0a      accumulateSelection(accumulator, node, range, createEmptyValue());\x0a      return \x22continue\x22;\x0a    }\x0a\x0a    if (type === \x27br\x27) {\x0a      accumulateSelection(accumulator, node, range, createEmptyValue());\x0a      mergePair(accumulator, create({\x0a        text: \x27\x5cn\x27\x0a      }));\x0a      return \x22continue\x22;\x0a    }\x0a\x0a    var lastFormats = accumulator.formats[accumulator.formats.length - 1];\x0a    var lastFormat = lastFormats && lastFormats[lastFormats.length - 1];\x0a    var newFormat = toFormat({\x0a      type: type,\x0a      attributes: getAttributes({\x0a        element: node\x0a      })\x0a    });\x0a    var format = isFormatEqual(newFormat, lastFormat) ? lastFormat : newFormat;\x0a\x0a    if (multilineWrapperTags && multilineWrapperTags.indexOf(type) !== -1) {\x0a      var _value = createFromMultilineElement({\x0a        element: node,\x0a        range: range,\x0a        multilineTag: multilineTag,\x0a        multilineWrapperTags: multilineWrapperTags,\x0a        currentWrapperTags: [].concat(Object(toConsumableArray[\x22a\x22 /* default */])(currentWrapperTags), [format]),\x0a        isEditableTree: isEditableTree\x0a      });\x0a\x0a      accumulateSelection(accumulator, node, range, _value);\x0a      mergePair(accumulator, _value);\x0a      return \x22continue\x22;\x0a    }\x0a\x0a    var value = createFromElement({\x0a      element: node,\x0a      range: range,\x0a      multilineTag: multilineTag,\x0a      multilineWrapperTags: multilineWrapperTags,\x0a      isEditableTree: isEditableTree\x0a    });\x0a    accumulateSelection(accumulator, node, range, value);\x0a\x0a    if (!format) {\x0a      mergePair(accumulator, value);\x0a    } else if (value.text.length === 0) {\x0a      if (format.attributes) {\x0a        mergePair(accumulator, {\x0a          formats: [,],\x0a          replacements: [format],\x0a          text: OBJECT_REPLACEMENT_CHARACTER\x0a        });\x0a      }\x0a    } else {\x0a      mergePair(accumulator, Object(objectSpread[\x22a\x22 /* default */])({}, value, {\x0a        formats: Array.from(value.formats, function (formats) {\x0a          return formats ? [format].concat(Object(toConsumableArray[\x22a\x22 /* default */])(formats)) : [format];\x0a        })\x0a      }));\x0a    }\x0a  };\x0a\x0a  for (var index = 0; index \x3c length; index++) {\x0a    var _ret = _loop(index);\x0a\x0a    if (_ret === \x22continue\x22) continue;\x0a  }\x0a\x0a  return accumulator;\x0a}\x0a/**\x0a * Creates a rich text value from a DOM element and range that should be\x0a * multiline.\x0a *\x0a * @param {Object}    $1                      Named argements.\x0a * @param {?Element}  $1.element              Element to create value from.\x0a * @param {?Range}    $1.range                Range to create value from.\x0a * @param {?string}   $1.multilineTag         Multiline tag if the structure is\x0a *                                            multiline.\x0a * @param {?Array}    $1.multilineWrapperTags Tags where lines can be found if\x0a *                                            nesting is possible.\x0a * @param {boolean}   $1.currentWrapperTags   Whether to prepend a line\x0a *                                            separator.\x0a *\x0a * @return {Object} A rich text value.\x0a */\x0a\x0a\x0afunction createFromMultilineElement(_ref4) {\x0a  var element = _ref4.element,\x0a      range = _ref4.range,\x0a      multilineTag = _ref4.multilineTag,\x0a      multilineWrapperTags = _ref4.multilineWrapperTags,\x0a      _ref4$currentWrapperT = _ref4.currentWrapperTags,\x0a      currentWrapperTags = _ref4$currentWrapperT === void 0 ? [] : _ref4$currentWrapperT,\x0a      isEditableTree = _ref4.isEditableTree;\x0a  var accumulator = createEmptyValue();\x0a\x0a  if (!element || !element.hasChildNodes()) {\x0a    return accumulator;\x0a  }\x0a\x0a  var length = element.children.length; // Optimise for speed.\x0a\x0a  for (var index = 0; index \x3c length; index++) {\x0a    var node = element.children[index];\x0a\x0a    if (node.nodeName.toLowerCase() !== multilineTag) {\x0a      continue;\x0a    }\x0a\x0a    var value = createFromElement({\x0a      element: node,\x0a      range: range,\x0a      multilineTag: multilineTag,\x0a      multilineWrapperTags: multilineWrapperTags,\x0a      currentWrapperTags: currentWrapperTags,\x0a      isEditableTree: isEditableTree\x0a    }); // Multiline value text should be separated by a line separator.\x0a\x0a    if (index !== 0 || currentWrapperTags.length \x3e 0) {\x0a      mergePair(accumulator, {\x0a        formats: [,],\x0a        replacements: currentWrapperTags.length \x3e 0 ? [currentWrapperTags] : [,],\x0a        text: LINE_SEPARATOR\x0a      });\x0a    }\x0a\x0a    accumulateSelection(accumulator, node, range, value);\x0a    mergePair(accumulator, value);\x0a  }\x0a\x0a  return accumulator;\x0a}\x0a/**\x0a * Gets the attributes of an element in object shape.\x0a *\x0a * @param {Object}    $1                 Named argements.\x0a * @param {Element}   $1.element         Element to get attributes from.\x0a *\x0a * @return {?Object} Attribute object or `undefined` if the element has no\x0a *                   attributes.\x0a */\x0a\x0a\x0afunction getAttributes(_ref5) {\x0a  var element = _ref5.element;\x0a\x0a  if (!element.hasAttributes()) {\x0a    return;\x0a  }\x0a\x0a  var length = element.attributes.length;\x0a  var accumulator; // Optimise for speed.\x0a\x0a  for (var i = 0; i \x3c length; i++) {\x0a    var _element$attributes$i = element.attributes[i],\x0a        name = _element$attributes$i.name,\x0a        value = _element$attributes$i.value;\x0a\x0a    if (name.indexOf(\x27data-rich-text-\x27) === 0) {\x0a      continue;\x0a    }\x0a\x0a    accumulator = accumulator || {};\x0a    accumulator[name] = value;\x0a  }\x0a\x0a  return accumulator;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/concat.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Concats a pair of rich text values. Not that this mutates `a` and does NOT\x0a * normalise formats!\x0a *\x0a * @param  {Object} a Value to mutate.\x0a * @param  {Object} b Value to add read from.\x0a *\x0a * @return {Object} `a`, mutated.\x0a */\x0a\x0afunction mergePair(a, b) {\x0a  a.formats = a.formats.concat(b.formats);\x0a  a.replacements = a.replacements.concat(b.replacements);\x0a  a.text += b.text;\x0a  return a;\x0a}\x0a/**\x0a * Combine all Rich Text values into one. This is similar to\x0a * `String.prototype.concat`.\x0a *\x0a * @param {...Object} values Objects to combine.\x0a *\x0a * @return {Object} A new value combining all given records.\x0a */\x0a\x0afunction concat() {\x0a  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key \x3c _len; _key++) {\x0a    values[_key] = arguments[_key];\x0a  }\x0a\x0a  return normaliseFormats(values.reduce(mergePair, create()));\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/get-active-formats.js\x0a/**\x0a * Gets the all format objects at the start of the selection.\x0a *\x0a * @param {Object} value Value to inspect.\x0a *\x0a * @return {?Object} Active format objects.\x0a */\x0afunction getActiveFormats(_ref) {\x0a  var formats = _ref.formats,\x0a      start = _ref.start,\x0a      end = _ref.end,\x0a      activeFormats = _ref.activeFormats;\x0a\x0a  if (start === undefined) {\x0a    return [];\x0a  }\x0a\x0a  if (start === end) {\x0a    // For a collapsed caret, it is possible to override the active formats.\x0a    if (activeFormats) {\x0a      return activeFormats;\x0a    }\x0a\x0a    var formatsBefore = formats[start - 1] || [];\x0a    var formatsAfter = formats[start] || []; // By default, select the lowest amount of formats possible (which means\x0a    // the caret is positioned outside the format boundary). The user can\x0a    // then use arrow keys to define `activeFormats`.\x0a\x0a    if (formatsBefore.length \x3c formatsAfter.length) {\x0a      return formatsBefore;\x0a    }\x0a\x0a    return formatsAfter;\x0a  }\x0a\x0a  return formats[start] || [];\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/get-active-format.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Gets the format object by type at the start of the selection. This can be\x0a * used to get e.g. the URL of a link format at the current selection, but also\x0a * to check if a format is active at the selection. Returns undefined if there\x0a * is no format at the selection.\x0a *\x0a * @param {Object} value      Value to inspect.\x0a * @param {string} formatType Format type to look for.\x0a *\x0a * @return {Object|undefined} Active format object of the specified type, or undefined.\x0a */\x0a\x0afunction getActiveFormat(value, formatType) {\x0a  return Object(external_lodash_[\x22find\x22])(getActiveFormats(value), {\x0a    type: formatType\x0a  });\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/get-active-object.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a/**\x0a * Gets the active object, if there is any.\x0a *\x0a * @param {Object} value Value to inspect.\x0a *\x0a * @return {?Object} Active object, or undefined.\x0a */\x0a\x0afunction getActiveObject(_ref) {\x0a  var start = _ref.start,\x0a      end = _ref.end,\x0a      replacements = _ref.replacements,\x0a      text = _ref.text;\x0a\x0a  if (start + 1 !== end || text[start] !== OBJECT_REPLACEMENT_CHARACTER) {\x0a    return;\x0a  }\x0a\x0a  return replacements[start];\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/get-selection-end.js\x0a/**\x0a * Gets the end index of the current selection, or returns `undefined` if no\x0a * selection exists. The selection ends right before the character at this\x0a * index.\x0a *\x0a * @param {Object} value Value to get the selection from.\x0a *\x0a * @return {number|undefined} Index where the selection ends.\x0a */\x0afunction getSelectionEnd(_ref) {\x0a  var end = _ref.end;\x0a  return end;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/get-selection-start.js\x0a/**\x0a * Gets the start index of the current selection, or returns `undefined` if no\x0a * selection exists. The selection starts right before the character at this\x0a * index.\x0a *\x0a * @param {Object} value Value to get the selection from.\x0a *\x0a * @return {number|undefined} Index where the selection starts.\x0a */\x0afunction getSelectionStart(_ref) {\x0a  var start = _ref.start;\x0a  return start;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/get-text-content.js\x0a/**\x0a * Get the textual content of a Rich Text value. This is similar to\x0a * `Element.textContent`.\x0a *\x0a * @param {Object} value Value to use.\x0a *\x0a * @return {string} The text content.\x0a */\x0afunction getTextContent(_ref) {\x0a  var text = _ref.text;\x0a  return text;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/is-collapsed.js\x0a/**\x0a * Check if the selection of a Rich Text value is collapsed or not. Collapsed\x0a * means that no characters are selected, but there is a caret present. If there\x0a * is no selection, `undefined` will be returned. This is similar to\x0a * `window.getSelection().isCollapsed()`.\x0a *\x0a * @param {Object} value The rich text value to check.\x0a *\x0a * @return {boolean|undefined} True if the selection is collapsed, false if not,\x0a *                             undefined if there is no selection.\x0a */\x0afunction isCollapsed(_ref) {\x0a  var start = _ref.start,\x0a      end = _ref.end;\x0a\x0a  if (start === undefined || end === undefined) {\x0a    return;\x0a  }\x0a\x0a  return start === end;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/is-empty.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a/**\x0a * Check if a Rich Text value is Empty, meaning it contains no text or any\x0a * objects (such as images).\x0a *\x0a * @param {Object} value Value to use.\x0a *\x0a * @return {boolean} True if the value is empty, false if not.\x0a */\x0a\x0afunction isEmpty(_ref) {\x0a  var text = _ref.text;\x0a  return text.length === 0;\x0a}\x0a/**\x0a * Check if the current collapsed selection is on an empty line in case of a\x0a * multiline value.\x0a *\x0a * @param  {Object} value Value te check.\x0a *\x0a * @return {boolean} True if the line is empty, false if not.\x0a */\x0a\x0afunction isEmptyLine(_ref2) {\x0a  var text = _ref2.text,\x0a      start = _ref2.start,\x0a      end = _ref2.end;\x0a\x0a  if (start !== end) {\x0a    return false;\x0a  }\x0a\x0a  if (text.length === 0) {\x0a    return true;\x0a  }\x0a\x0a  if (start === 0 && text.slice(0, 1) === LINE_SEPARATOR) {\x0a    return true;\x0a  }\x0a\x0a  if (start === text.length && text.slice(-1) === LINE_SEPARATOR) {\x0a    return true;\x0a  }\x0a\x0a  return text.slice(start - 1, end + 1) === \x22\x22.concat(LINE_SEPARATOR).concat(LINE_SEPARATOR);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/join.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Combine an array of Rich Text values into one, optionally separated by\x0a * `separator`, which can be a Rich Text value, HTML string, or plain text\x0a * string. This is similar to `Array.prototype.join`.\x0a *\x0a * @param {Array\x3cObject\x3e} values      An array of values to join.\x0a * @param {string|Object} [separator] Separator string or value.\x0a *\x0a * @return {Object} A new combined value.\x0a */\x0a\x0afunction join(values) {\x0a  var separator = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : \x27\x27;\x0a\x0a  if (typeof separator === \x27string\x27) {\x0a    separator = create({\x0a      text: separator\x0a    });\x0a  }\x0a\x0a  return normaliseFormats(values.reduce(function (accumlator, _ref) {\x0a    var formats = _ref.formats,\x0a        replacements = _ref.replacements,\x0a        text = _ref.text;\x0a    return {\x0a      formats: accumlator.formats.concat(separator.formats, formats),\x0a      replacements: accumlator.replacements.concat(separator.replacements, replacements),\x0a      text: accumlator.text + separator.text + text\x0a    };\x0a  }));\x0a}\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\x0avar defineProperty = __webpack_require__(15);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\x0avar esm_extends = __webpack_require__(19);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22element\x22]}\x0avar external_this_wp_element_ = __webpack_require__(0);\x0a\x0a// EXTERNAL MODULE: ./node_modules/memize/index.js\x0avar memize = __webpack_require__(41);\x0avar memize_default = /*#__PURE__*/__webpack_require__.n(memize);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22hooks\x22]}\x0avar external_this_wp_hooks_ = __webpack_require__(26);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22compose\x22]}\x0avar external_this_wp_compose_ = __webpack_require__(6);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/register-format-type.js\x0a\x0a\x0a\x0a\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a\x0a\x0a/**\x0a * Shared reference to an empty array for cases where it is important to avoid\x0a * returning a new array reference on every invocation, as in a connected or\x0a * other pure component which performs `shouldComponentUpdate` check on props.\x0a * This should be used as a last resort, since the normalized data should be\x0a * maintained by the reducer result in state.\x0a *\x0a * @type {Array}\x0a */\x0a\x0avar EMPTY_ARRAY = [];\x0a/**\x0a * Registers a new format provided a unique name and an object defining its\x0a * behavior.\x0a *\x0a * @param {string}   name                 Format name.\x0a * @param {Object}   settings             Format settings.\x0a * @param {string}   settings.tagName     The HTML tag this format will wrap the selection with.\x0a * @param {string}   [settings.className] A class to match the format.\x0a * @param {string}   settings.title       Name of the format.\x0a * @param {Function} settings.edit        Should return a component for the user to interact with the new registered format.\x0a *\x0a * @return {WPFormat|undefined} The format, if it has been successfully registered;\x0a *                              otherwise `undefined`.\x0a */\x0a\x0afunction registerFormatType(name, settings) {\x0a  settings = Object(objectSpread[\x22a\x22 /* default */])({\x0a    name: name\x0a  }, settings);\x0a\x0a  if (typeof settings.name !== \x27string\x27) {\x0a    window.console.error(\x27Format names must be strings.\x27);\x0a    return;\x0a  }\x0a\x0a  if (!/^[a-z][a-z0-9-]*\x5c/[a-z][a-z0-9-]*$/.test(settings.name)) {\x0a    window.console.error(\x27Format names must contain a namespace prefix, include only lowercase alphanumeric characters or dashes, and start with a letter. Example: my-plugin/my-custom-format\x27);\x0a    return;\x0a  }\x0a\x0a  if (Object(external_this_wp_data_[\x22select\x22])(\x27core/rich-text\x27).getFormatType(settings.name)) {\x0a    window.console.error(\x27Format \x22\x27 + settings.name + \x27\x22 is already registered.\x27);\x0a    return;\x0a  }\x0a\x0a  if (typeof settings.tagName !== \x27string\x27 || settings.tagName === \x27\x27) {\x0a    window.console.error(\x27Format tag names must be a string.\x27);\x0a    return;\x0a  }\x0a\x0a  if ((typeof settings.className !== \x27string\x27 || settings.className === \x27\x27) && settings.className !== null) {\x0a    window.console.error(\x27Format class names must be a string, or null to handle bare elements.\x27);\x0a    return;\x0a  }\x0a\x0a  if (!/^[_a-zA-Z]+[a-zA-Z0-9-]*$/.test(settings.className)) {\x0a    window.console.error(\x27A class name must begin with a letter, followed by any number of hyphens, letters, or numbers.\x27);\x0a    return;\x0a  }\x0a\x0a  if (settings.className === null) {\x0a    var formatTypeForBareElement = Object(external_this_wp_data_[\x22select\x22])(\x27core/rich-text\x27).getFormatTypeForBareElement(settings.tagName);\x0a\x0a    if (formatTypeForBareElement) {\x0a      window.console.error(\x22Format \x5c\x22\x22.concat(formatTypeForBareElement.name, \x22\x5c\x22 is already registered to handle bare tag name \x5c\x22\x22).concat(settings.tagName, \x22\x5c\x22.\x22));\x0a      return;\x0a    }\x0a  } else {\x0a    var formatTypeForClassName = Object(external_this_wp_data_[\x22select\x22])(\x27core/rich-text\x27).getFormatTypeForClassName(settings.className);\x0a\x0a    if (formatTypeForClassName) {\x0a      window.console.error(\x22Format \x5c\x22\x22.concat(formatTypeForClassName.name, \x22\x5c\x22 is already registered to handle class name \x5c\x22\x22).concat(settings.className, \x22\x5c\x22.\x22));\x0a      return;\x0a    }\x0a  }\x0a\x0a  if (!(\x27title\x27 in settings) || settings.title === \x27\x27) {\x0a    window.console.error(\x27The format \x22\x27 + settings.name + \x27\x22 must have a title.\x27);\x0a    return;\x0a  }\x0a\x0a  if (\x27keywords\x27 in settings && settings.keywords.length \x3e 3) {\x0a    window.console.error(\x27The format \x22\x27 + settings.name + \x27\x22 can have a maximum of 3 keywords.\x27);\x0a    return;\x0a  }\x0a\x0a  if (typeof settings.title !== \x27string\x27) {\x0a    window.console.error(\x27Format titles must be strings.\x27);\x0a    return;\x0a  }\x0a\x0a  Object(external_this_wp_data_[\x22dispatch\x22])(\x27core/rich-text\x27).addFormatTypes(settings);\x0a  var getFunctionStackMemoized = memize_default()(function () {\x0a    var previousStack = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_ARRAY;\x0a    var newFunction = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a    return [].concat(Object(toConsumableArray[\x22a\x22 /* default */])(previousStack), [newFunction]);\x0a  });\x0a\x0a  if (settings.__experimentalCreatePrepareEditableTree) {\x0a    Object(external_this_wp_hooks_[\x22addFilter\x22])(\x27experimentalRichText\x27, name, function (OriginalComponent) {\x0a      var Component = OriginalComponent;\x0a\x0a      if (settings.__experimentalCreatePrepareEditableTree || settings.__experimentalCreateFormatToValue || settings.__experimentalCreateValueToFormat) {\x0a        Component = function Component(props) {\x0a          var additionalProps = {};\x0a\x0a          if (settings.__experimentalCreatePrepareEditableTree) {\x0a            additionalProps.prepareEditableTree = getFunctionStackMemoized(props.prepareEditableTree, settings.__experimentalCreatePrepareEditableTree(props[\x22format_\x22.concat(name)], {\x0a              richTextIdentifier: props.identifier,\x0a              blockClientId: props.clientId\x0a            }));\x0a          }\x0a\x0a          if (settings.__experimentalCreateOnChangeEditableValue) {\x0a            var dispatchProps = Object.keys(props).reduce(function (accumulator, propKey) {\x0a              var propValue = props[propKey];\x0a              var keyPrefix = \x22format_\x22.concat(name, \x22_dispatch_\x22);\x0a\x0a              if (propKey.startsWith(keyPrefix)) {\x0a                var realKey = propKey.replace(keyPrefix, \x27\x27);\x0a                accumulator[realKey] = propValue;\x0a              }\x0a\x0a              return accumulator;\x0a            }, {});\x0a            additionalProps.onChangeEditableValue = getFunctionStackMemoized(props.onChangeEditableValue, settings.__experimentalCreateOnChangeEditableValue(Object(objectSpread[\x22a\x22 /* default */])({}, props[\x22format_\x22.concat(name)], dispatchProps), {\x0a              richTextIdentifier: props.identifier,\x0a              blockClientId: props.clientId\x0a            }));\x0a          }\x0a\x0a          return Object(external_this_wp_element_[\x22createElement\x22])(OriginalComponent, Object(esm_extends[\x22a\x22 /* default */])({}, props, additionalProps));\x0a        };\x0a      }\x0a\x0a      var hocs = [];\x0a\x0a      if (settings.__experimentalGetPropsForEditableTreePreparation) {\x0a        hocs.push(Object(external_this_wp_data_[\x22withSelect\x22])(function (sel, _ref) {\x0a          var clientId = _ref.clientId,\x0a              identifier = _ref.identifier;\x0a          return Object(defineProperty[\x22a\x22 /* default */])({}, \x22format_\x22.concat(name), settings.__experimentalGetPropsForEditableTreePreparation(sel, {\x0a            richTextIdentifier: identifier,\x0a            blockClientId: clientId\x0a          }));\x0a        }));\x0a      }\x0a\x0a      if (settings.__experimentalGetPropsForEditableTreeChangeHandler) {\x0a        hocs.push(Object(external_this_wp_data_[\x22withDispatch\x22])(function (disp, _ref3) {\x0a          var clientId = _ref3.clientId,\x0a              identifier = _ref3.identifier;\x0a\x0a          var dispatchProps = settings.__experimentalGetPropsForEditableTreeChangeHandler(disp, {\x0a            richTextIdentifier: identifier,\x0a            blockClientId: clientId\x0a          });\x0a\x0a          return Object(external_lodash_[\x22mapKeys\x22])(dispatchProps, function (value, key) {\x0a            return \x22format_\x22.concat(name, \x22_dispatch_\x22).concat(key);\x0a          });\x0a        }));\x0a      }\x0a\x0a      return Object(external_this_wp_compose_[\x22compose\x22])(hocs)(Component);\x0a    });\x0a  }\x0a\x0a  return settings;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/remove-format.js\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Remove any format object from a Rich Text value by type from the given\x0a * `startIndex` to the given `endIndex`. Indices are retrieved from the\x0a * selection if none are provided.\x0a *\x0a * @param {Object} value        Value to modify.\x0a * @param {string} formatType   Format type to remove.\x0a * @param {number} [startIndex] Start index.\x0a * @param {number} [endIndex]   End index.\x0a *\x0a * @return {Object} A new value with the format applied.\x0a */\x0a\x0afunction removeFormat(value, formatType) {\x0a  var startIndex = arguments.length \x3e 2 && arguments[2] !== undefined ? arguments[2] : value.start;\x0a  var endIndex = arguments.length \x3e 3 && arguments[3] !== undefined ? arguments[3] : value.end;\x0a  var formats = value.formats,\x0a      activeFormats = value.activeFormats;\x0a  var newFormats = formats.slice(); // If the selection is collapsed, expand start and end to the edges of the\x0a  // format.\x0a\x0a  if (startIndex === endIndex) {\x0a    var format = Object(external_lodash_[\x22find\x22])(newFormats[startIndex], {\x0a      type: formatType\x0a    });\x0a\x0a    if (format) {\x0a      while (Object(external_lodash_[\x22find\x22])(newFormats[startIndex], format)) {\x0a        filterFormats(newFormats, startIndex, formatType);\x0a        startIndex--;\x0a      }\x0a\x0a      endIndex++;\x0a\x0a      while (Object(external_lodash_[\x22find\x22])(newFormats[endIndex], format)) {\x0a        filterFormats(newFormats, endIndex, formatType);\x0a        endIndex++;\x0a      }\x0a    }\x0a  } else {\x0a    for (var i = startIndex; i \x3c endIndex; i++) {\x0a      if (newFormats[i]) {\x0a        filterFormats(newFormats, i, formatType);\x0a      }\x0a    }\x0a  }\x0a\x0a  return normaliseFormats(Object(objectSpread[\x22a\x22 /* default */])({}, value, {\x0a    formats: newFormats,\x0a    activeFormats: Object(external_lodash_[\x22reject\x22])(activeFormats, {\x0a      type: formatType\x0a    })\x0a  }));\x0a}\x0a\x0afunction filterFormats(formats, index, formatType) {\x0a  var newFormats = formats[index].filter(function (_ref) {\x0a    var type = _ref.type;\x0a    return type !== formatType;\x0a  });\x0a\x0a  if (newFormats.length) {\x0a    formats[index] = newFormats;\x0a  } else {\x0a    delete formats[index];\x0a  }\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/insert.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Insert a Rich Text value, an HTML string, or a plain text string, into a\x0a * Rich Text value at the given `startIndex`. Any content between `startIndex`\x0a * and `endIndex` will be removed. Indices are retrieved from the selection if\x0a * none are provided.\x0a *\x0a * @param {Object}        value         Value to modify.\x0a * @param {Object|string} valueToInsert Value to insert.\x0a * @param {number}        [startIndex]  Start index.\x0a * @param {number}        [endIndex]    End index.\x0a *\x0a * @return {Object} A new value with the value inserted.\x0a */\x0a\x0afunction insert(value, valueToInsert) {\x0a  var startIndex = arguments.length \x3e 2 && arguments[2] !== undefined ? arguments[2] : value.start;\x0a  var endIndex = arguments.length \x3e 3 && arguments[3] !== undefined ? arguments[3] : value.end;\x0a  var formats = value.formats,\x0a      replacements = value.replacements,\x0a      text = value.text;\x0a\x0a  if (typeof valueToInsert === \x27string\x27) {\x0a    valueToInsert = create({\x0a      text: valueToInsert\x0a    });\x0a  }\x0a\x0a  var index = startIndex + valueToInsert.text.length;\x0a  return normaliseFormats({\x0a    formats: formats.slice(0, startIndex).concat(valueToInsert.formats, formats.slice(endIndex)),\x0a    replacements: replacements.slice(0, startIndex).concat(valueToInsert.replacements, replacements.slice(endIndex)),\x0a    text: text.slice(0, startIndex) + valueToInsert.text + text.slice(endIndex),\x0a    start: index,\x0a    end: index\x0a  });\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/remove.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Remove content from a Rich Text value between the given `startIndex` and\x0a * `endIndex`. Indices are retrieved from the selection if none are provided.\x0a *\x0a * @param {Object} value        Value to modify.\x0a * @param {number} [startIndex] Start index.\x0a * @param {number} [endIndex]   End index.\x0a *\x0a * @return {Object} A new value with the content removed.\x0a */\x0a\x0afunction remove_remove(value, startIndex, endIndex) {\x0a  return insert(value, create(), startIndex, endIndex);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/replace.js\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a/**\x0a * Search a Rich Text value and replace the match(es) with `replacement`. This\x0a * is similar to `String.prototype.replace`.\x0a *\x0a * @param {Object}         value        The value to modify.\x0a * @param {RegExp|string}  pattern      A RegExp object or literal. Can also be\x0a *                                      a string. It is treated as a verbatim\x0a *                                      string and is not interpreted as a\x0a *                                      regular expression. Only the first\x0a *                                      occurrence will be replaced.\x0a * @param {Function|string} replacement The match or matches are replaced with\x0a *                                      the specified or the value returned by\x0a *                                      the specified function.\x0a *\x0a * @return {Object} A new value with replacements applied.\x0a */\x0a\x0afunction replace(_ref, pattern, replacement) {\x0a  var formats = _ref.formats,\x0a      replacements = _ref.replacements,\x0a      text = _ref.text,\x0a      start = _ref.start,\x0a      end = _ref.end;\x0a  text = text.replace(pattern, function (match) {\x0a    for (var _len = arguments.length, rest = new Array(_len \x3e 1 ? _len - 1 : 0), _key = 1; _key \x3c _len; _key++) {\x0a      rest[_key - 1] = arguments[_key];\x0a    }\x0a\x0a    var offset = rest[rest.length - 2];\x0a    var newText = replacement;\x0a    var newFormats;\x0a    var newReplacements;\x0a\x0a    if (typeof newText === \x27function\x27) {\x0a      newText = replacement.apply(void 0, [match].concat(rest));\x0a    }\x0a\x0a    if (Object(esm_typeof[\x22a\x22 /* default */])(newText) === \x27object\x27) {\x0a      newFormats = newText.formats;\x0a      newReplacements = newText.replacements;\x0a      newText = newText.text;\x0a    } else {\x0a      newFormats = Array(newText.length);\x0a      newReplacements = Array(newText.length);\x0a\x0a      if (formats[offset]) {\x0a        newFormats = newFormats.fill(formats[offset]);\x0a      }\x0a    }\x0a\x0a    formats = formats.slice(0, offset).concat(newFormats, formats.slice(offset + match.length));\x0a    replacements = replacements.slice(0, offset).concat(newReplacements, replacements.slice(offset + match.length));\x0a\x0a    if (start) {\x0a      start = end = offset + newText.length;\x0a    }\x0a\x0a    return newText;\x0a  });\x0a  return normaliseFormats({\x0a    formats: formats,\x0a    replacements: replacements,\x0a    text: text,\x0a    start: start,\x0a    end: end\x0a  });\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/insert-line-break.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a/**\x0a * Inserts a line break at the given or selected position.\x0a *\x0a * @param {Object} value Value to modify.\x0a *\x0a * @return {Object} The value with the line break inserted.\x0a */\x0a\x0afunction insertLineBreak(value) {\x0a  return insert(value, \x27\x5cn\x27);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/insert-line-separator.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * Insert a line break character into a Rich Text value at the given\x0a * `startIndex`. Any content between `startIndex` and `endIndex` will be\x0a * removed. Indices are retrieved from the selection if none are provided.\x0a *\x0a * @param {Object} value        Value to modify.\x0a * @param {number} [startIndex] Start index.\x0a * @param {number} [endIndex]   End index.\x0a *\x0a * @return {Object} A new value with the value inserted.\x0a */\x0a\x0afunction insertLineSeparator(value) {\x0a  var startIndex = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : value.start;\x0a  var endIndex = arguments.length \x3e 2 && arguments[2] !== undefined ? arguments[2] : value.end;\x0a  var beforeText = getTextContent(value).slice(0, startIndex);\x0a  var previousLineSeparatorIndex = beforeText.lastIndexOf(LINE_SEPARATOR);\x0a  var previousLineSeparatorFormats = value.replacements[previousLineSeparatorIndex];\x0a  var replacements = [,];\x0a\x0a  if (previousLineSeparatorFormats) {\x0a    replacements = [previousLineSeparatorFormats];\x0a  }\x0a\x0a  var valueToInsert = {\x0a    formats: [,],\x0a    replacements: replacements,\x0a    text: LINE_SEPARATOR\x0a  };\x0a  return insert(value, valueToInsert, startIndex, endIndex);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/insert-object.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0avar insert_object_OBJECT_REPLACEMENT_CHARACTER = \x22\x5cuFFFC\x22;\x0a/**\x0a * Insert a format as an object into a Rich Text value at the given\x0a * `startIndex`. Any content between `startIndex` and `endIndex` will be\x0a * removed. Indices are retrieved from the selection if none are provided.\x0a *\x0a * @param {Object} value          Value to modify.\x0a * @param {Object} formatToInsert Format to insert as object.\x0a * @param {number} [startIndex]   Start index.\x0a * @param {number} [endIndex]     End index.\x0a *\x0a * @return {Object} A new value with the object inserted.\x0a */\x0a\x0afunction insertObject(value, formatToInsert, startIndex, endIndex) {\x0a  var valueToInsert = {\x0a    formats: [,],\x0a    replacements: [formatToInsert],\x0a    text: insert_object_OBJECT_REPLACEMENT_CHARACTER\x0a  };\x0a  return insert(value, valueToInsert, startIndex, endIndex);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/slice.js\x0a\x0a\x0a/**\x0a * Slice a Rich Text value from `startIndex` to `endIndex`. Indices are\x0a * retrieved from the selection if none are provided. This is similar to\x0a * `String.prototype.slice`.\x0a *\x0a * @param {Object} value        Value to modify.\x0a * @param {number} [startIndex] Start index.\x0a * @param {number} [endIndex]   End index.\x0a *\x0a * @return {Object} A new extracted value.\x0a */\x0afunction slice(value) {\x0a  var startIndex = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : value.start;\x0a  var endIndex = arguments.length \x3e 2 && arguments[2] !== undefined ? arguments[2] : value.end;\x0a  var formats = value.formats,\x0a      replacements = value.replacements,\x0a      text = value.text;\x0a\x0a  if (startIndex === undefined || endIndex === undefined) {\x0a    return Object(objectSpread[\x22a\x22 /* default */])({}, value);\x0a  }\x0a\x0a  return {\x0a    formats: formats.slice(startIndex, endIndex),\x0a    replacements: replacements.slice(startIndex, endIndex),\x0a    text: text.slice(startIndex, endIndex)\x0a  };\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/split.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a/**\x0a * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\x0a * split at the given separator. This is similar to `String.prototype.split`.\x0a * Indices are retrieved from the selection if none are provided.\x0a *\x0a * @param {Object}        value    Value to modify.\x0a * @param {number|string} [string] Start index, or string at which to split.\x0a * @param {number}        [endStr] End index.\x0a *\x0a * @return {Array} An array of new values.\x0a */\x0a\x0afunction split(_ref, string) {\x0a  var formats = _ref.formats,\x0a      replacements = _ref.replacements,\x0a      text = _ref.text,\x0a      start = _ref.start,\x0a      end = _ref.end;\x0a\x0a  if (typeof string !== \x27string\x27) {\x0a    return splitAtSelection.apply(void 0, arguments);\x0a  }\x0a\x0a  var nextStart = 0;\x0a  return text.split(string).map(function (substring) {\x0a    var startIndex = nextStart;\x0a    var value = {\x0a      formats: formats.slice(startIndex, startIndex + substring.length),\x0a      replacements: replacements.slice(startIndex, startIndex + substring.length),\x0a      text: substring\x0a    };\x0a    nextStart += string.length + substring.length;\x0a\x0a    if (start !== undefined && end !== undefined) {\x0a      if (start \x3e= startIndex && start \x3c nextStart) {\x0a        value.start = start - startIndex;\x0a      } else if (start \x3c startIndex && end \x3e startIndex) {\x0a        value.start = 0;\x0a      }\x0a\x0a      if (end \x3e= startIndex && end \x3c nextStart) {\x0a        value.end = end - startIndex;\x0a      } else if (start \x3c nextStart && end \x3e nextStart) {\x0a        value.end = substring.length;\x0a      }\x0a    }\x0a\x0a    return value;\x0a  });\x0a}\x0a\x0afunction splitAtSelection(_ref2) {\x0a  var formats = _ref2.formats,\x0a      replacements = _ref2.replacements,\x0a      text = _ref2.text,\x0a      start = _ref2.start,\x0a      end = _ref2.end;\x0a  var startIndex = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : start;\x0a  var endIndex = arguments.length \x3e 2 && arguments[2] !== undefined ? arguments[2] : end;\x0a  var before = {\x0a    formats: formats.slice(0, startIndex),\x0a    replacements: replacements.slice(0, startIndex),\x0a    text: text.slice(0, startIndex)\x0a  };\x0a  var after = {\x0a    formats: formats.slice(endIndex),\x0a    replacements: replacements.slice(endIndex),\x0a    text: text.slice(endIndex),\x0a    start: 0,\x0a    end: 0\x0a  };\x0a  return [// Ensure newlines are trimmed.\x0a  replace(before, /\x5cu2028+$/, \x27\x27), replace(after, /^\x5cu2028+/, \x27\x27)];\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/get-format-type.js\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a/**\x0a * Returns a registered format type.\x0a *\x0a * @param {string} name Format name.\x0a *\x0a * @return {?Object} Format type.\x0a */\x0a\x0afunction get_format_type_getFormatType(name) {\x0a  return Object(external_this_wp_data_[\x22select\x22])(\x27core/rich-text\x27).getFormatType(name);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/to-tree.js\x0a\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * Converts a format object to information that can be used to create an element\x0a * from (type, attributes and object).\x0a *\x0a * @param  {Object}  $1                        Named parameters.\x0a * @param  {string}  $1.type                   The format type.\x0a * @param  {Object}  $1.attributes             The format attributes.\x0a * @param  {Object}  $1.unregisteredAttributes The unregistered format\x0a *                                             attributes.\x0a * @param  {boolean} $1.object                 Wether or not it is an object\x0a *                                             format.\x0a * @param  {boolean} $1.boundaryClass          Wether or not to apply a boundary\x0a *                                             class.\x0a * @return {Object}                            Information to be used for\x0a *                                             element creation.\x0a */\x0a\x0afunction fromFormat(_ref) {\x0a  var type = _ref.type,\x0a      attributes = _ref.attributes,\x0a      unregisteredAttributes = _ref.unregisteredAttributes,\x0a      object = _ref.object,\x0a      boundaryClass = _ref.boundaryClass;\x0a  var formatType = get_format_type_getFormatType(type);\x0a  var elementAttributes = {};\x0a\x0a  if (boundaryClass) {\x0a    elementAttributes[\x27data-rich-text-format-boundary\x27] = \x27true\x27;\x0a  }\x0a\x0a  if (!formatType) {\x0a    if (attributes) {\x0a      elementAttributes = Object(objectSpread[\x22a\x22 /* default */])({}, attributes, elementAttributes);\x0a    }\x0a\x0a    return {\x0a      type: type,\x0a      attributes: elementAttributes,\x0a      object: object\x0a    };\x0a  }\x0a\x0a  elementAttributes = Object(objectSpread[\x22a\x22 /* default */])({}, unregisteredAttributes, elementAttributes);\x0a\x0a  for (var name in attributes) {\x0a    var key = formatType.attributes ? formatType.attributes[name] : false;\x0a\x0a    if (key) {\x0a      elementAttributes[key] = attributes[name];\x0a    } else {\x0a      elementAttributes[name] = attributes[name];\x0a    }\x0a  }\x0a\x0a  if (formatType.className) {\x0a    if (elementAttributes.class) {\x0a      elementAttributes.class = \x22\x22.concat(formatType.className, \x22 \x22).concat(elementAttributes.class);\x0a    } else {\x0a      elementAttributes.class = formatType.className;\x0a    }\x0a  }\x0a\x0a  return {\x0a    type: formatType.tagName,\x0a    object: formatType.object,\x0a    attributes: elementAttributes\x0a  };\x0a}\x0a\x0avar padding = {\x0a  type: \x27br\x27,\x0a  attributes: {\x0a    \x27data-rich-text-padding\x27: \x27true\x27\x0a  },\x0a  object: true\x0a};\x0afunction toTree(_ref2) {\x0a  var value = _ref2.value,\x0a      multilineTag = _ref2.multilineTag,\x0a      createEmpty = _ref2.createEmpty,\x0a      append = _ref2.append,\x0a      getLastChild = _ref2.getLastChild,\x0a      getParent = _ref2.getParent,\x0a      isText = _ref2.isText,\x0a      getText = _ref2.getText,\x0a      remove = _ref2.remove,\x0a      appendText = _ref2.appendText,\x0a      onStartIndex = _ref2.onStartIndex,\x0a      onEndIndex = _ref2.onEndIndex,\x0a      isEditableTree = _ref2.isEditableTree;\x0a  var formats = value.formats,\x0a      replacements = value.replacements,\x0a      text = value.text,\x0a      start = value.start,\x0a      end = value.end;\x0a  var formatsLength = formats.length + 1;\x0a  var tree = createEmpty();\x0a  var multilineFormat = {\x0a    type: multilineTag\x0a  };\x0a  var activeFormats = getActiveFormats(value);\x0a  var deepestActiveFormat = activeFormats[activeFormats.length - 1];\x0a  var lastSeparatorFormats;\x0a  var lastCharacterFormats;\x0a  var lastCharacter; // If we\x27re building a multiline tree, start off with a multiline element.\x0a\x0a  if (multilineTag) {\x0a    append(append(tree, {\x0a      type: multilineTag\x0a    }), \x27\x27);\x0a    lastCharacterFormats = lastSeparatorFormats = [multilineFormat];\x0a  } else {\x0a    append(tree, \x27\x27);\x0a  }\x0a\x0a  var _loop = function _loop(i) {\x0a    var character = text.charAt(i);\x0a    var shouldInsertPadding = isEditableTree && ( // Pad the line if the line is empty.\x0a    !lastCharacter || lastCharacter === LINE_SEPARATOR || // Pad the line if the previous character is a line break, otherwise\x0a    // the line break won\x27t be visible.\x0a    lastCharacter === \x27\x5cn\x27);\x0a    var characterFormats = formats[i]; // Set multiline tags in queue for building the tree.\x0a\x0a    if (multilineTag) {\x0a      if (character === LINE_SEPARATOR) {\x0a        characterFormats = lastSeparatorFormats = (replacements[i] || []).reduce(function (accumulator, format) {\x0a          accumulator.push(format, multilineFormat);\x0a          return accumulator;\x0a        }, [multilineFormat]);\x0a      } else {\x0a        characterFormats = [].concat(Object(toConsumableArray[\x22a\x22 /* default */])(lastSeparatorFormats), Object(toConsumableArray[\x22a\x22 /* default */])(characterFormats || []));\x0a      }\x0a    }\x0a\x0a    var pointer = getLastChild(tree);\x0a\x0a    if (shouldInsertPadding && character === LINE_SEPARATOR) {\x0a      var node = pointer;\x0a\x0a      while (!isText(node)) {\x0a        node = getLastChild(node);\x0a      }\x0a\x0a      append(getParent(node), padding);\x0a      append(getParent(node), \x27\x27);\x0a    } // Set selection for the start of line.\x0a\x0a\x0a    if (lastCharacter === LINE_SEPARATOR) {\x0a      var _node = pointer;\x0a\x0a      while (!isText(_node)) {\x0a        _node = getLastChild(_node);\x0a      }\x0a\x0a      if (onStartIndex && start === i) {\x0a        onStartIndex(tree, _node);\x0a      }\x0a\x0a      if (onEndIndex && end === i) {\x0a        onEndIndex(tree, _node);\x0a      }\x0a    }\x0a\x0a    if (characterFormats) {\x0a      characterFormats.forEach(function (format, formatIndex) {\x0a        if (pointer && lastCharacterFormats && format === lastCharacterFormats[formatIndex] && ( // Do not reuse the last element if the character is a\x0a        // line separator.\x0a        character !== LINE_SEPARATOR || characterFormats.length - 1 !== formatIndex)) {\x0a          pointer = getLastChild(pointer);\x0a          return;\x0a        }\x0a\x0a        var type = format.type,\x0a            attributes = format.attributes,\x0a            unregisteredAttributes = format.unregisteredAttributes;\x0a        var boundaryClass = isEditableTree && character !== LINE_SEPARATOR && format === deepestActiveFormat;\x0a        var parent = getParent(pointer);\x0a        var newNode = append(parent, fromFormat({\x0a          type: type,\x0a          attributes: attributes,\x0a          unregisteredAttributes: unregisteredAttributes,\x0a          boundaryClass: boundaryClass\x0a        }));\x0a\x0a        if (isText(pointer) && getText(pointer).length === 0) {\x0a          remove(pointer);\x0a        }\x0a\x0a        pointer = append(newNode, \x27\x27);\x0a      });\x0a    } // No need for further processing if the character is a line separator.\x0a\x0a\x0a    if (character === LINE_SEPARATOR) {\x0a      lastCharacterFormats = characterFormats;\x0a      lastCharacter = character;\x0a      return \x22continue\x22;\x0a    } // If there is selection at 0, handle it before characters are inserted.\x0a\x0a\x0a    if (i === 0) {\x0a      if (onStartIndex && start === 0) {\x0a        onStartIndex(tree, pointer);\x0a      }\x0a\x0a      if (onEndIndex && end === 0) {\x0a        onEndIndex(tree, pointer);\x0a      }\x0a    }\x0a\x0a    if (character === OBJECT_REPLACEMENT_CHARACTER) {\x0a      pointer = append(getParent(pointer), fromFormat(Object(objectSpread[\x22a\x22 /* default */])({}, replacements[i], {\x0a        object: true\x0a      }))); // Ensure pointer is text node.\x0a\x0a      pointer = append(getParent(pointer), \x27\x27);\x0a    } else if (character === \x27\x5cn\x27) {\x0a      pointer = append(getParent(pointer), {\x0a        type: \x27br\x27,\x0a        attributes: isEditableTree ? {\x0a          \x27data-rich-text-line-break\x27: \x27true\x27\x0a        } : undefined,\x0a        object: true\x0a      }); // Ensure pointer is text node.\x0a\x0a      pointer = append(getParent(pointer), \x27\x27);\x0a    } else if (!isText(pointer)) {\x0a      pointer = append(getParent(pointer), character);\x0a    } else {\x0a      appendText(pointer, character);\x0a    }\x0a\x0a    if (onStartIndex && start === i + 1) {\x0a      onStartIndex(tree, pointer);\x0a    }\x0a\x0a    if (onEndIndex && end === i + 1) {\x0a      onEndIndex(tree, pointer);\x0a    }\x0a\x0a    if (shouldInsertPadding && i === text.length) {\x0a      append(getParent(pointer), padding);\x0a    }\x0a\x0a    lastCharacterFormats = characterFormats;\x0a    lastCharacter = character;\x0a  };\x0a\x0a  for (var i = 0; i \x3c formatsLength; i++) {\x0a    var _ret = _loop(i);\x0a\x0a    if (_ret === \x22continue\x22) continue;\x0a  }\x0a\x0a  return tree;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/to-dom.js\x0a\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Browser dependencies\x0a */\x0a\x0avar to_dom_TEXT_NODE = window.Node.TEXT_NODE;\x0a/**\x0a * Creates a path as an array of indices from the given root node to the given\x0a * node.\x0a *\x0a * @param {Node}        node     Node to find the path of.\x0a * @param {HTMLElement} rootNode Root node to find the path from.\x0a * @param {Array}       path     Initial path to build on.\x0a *\x0a * @return {Array} The path from the root node to the node.\x0a */\x0a\x0afunction createPathToNode(node, rootNode, path) {\x0a  var parentNode = node.parentNode;\x0a  var i = 0;\x0a\x0a  while (node = node.previousSibling) {\x0a    i++;\x0a  }\x0a\x0a  path = [i].concat(Object(toConsumableArray[\x22a\x22 /* default */])(path));\x0a\x0a  if (parentNode !== rootNode) {\x0a    path = createPathToNode(parentNode, rootNode, path);\x0a  }\x0a\x0a  return path;\x0a}\x0a/**\x0a * Gets a node given a path (array of indices) from the given node.\x0a *\x0a * @param {HTMLElement} node Root node to find the wanted node in.\x0a * @param {Array}       path Path (indices) to the wanted node.\x0a *\x0a * @return {Object} Object with the found node and the remaining offset (if any).\x0a */\x0a\x0a\x0afunction getNodeByPath(node, path) {\x0a  path = Object(toConsumableArray[\x22a\x22 /* default */])(path);\x0a\x0a  while (node && path.length \x3e 1) {\x0a    node = node.childNodes[path.shift()];\x0a  }\x0a\x0a  return {\x0a    node: node,\x0a    offset: path[0]\x0a  };\x0a}\x0a/**\x0a * Returns a new instance of a DOM tree upon which RichText operations can be\x0a * applied.\x0a *\x0a * Note: The current implementation will return a shared reference, reset on\x0a * each call to `createEmpty`. Therefore, you should not hold a reference to\x0a * the value to operate upon asynchronously, as it may have unexpected results.\x0a *\x0a * @return {WPRichTextTree} RichText tree.\x0a */\x0a\x0a\x0avar to_dom_createEmpty = function createEmpty() {\x0a  return createElement(document, \x27\x27);\x0a};\x0a\x0afunction to_dom_append(element, child) {\x0a  if (typeof child === \x27string\x27) {\x0a    child = element.ownerDocument.createTextNode(child);\x0a  }\x0a\x0a  var _child = child,\x0a      type = _child.type,\x0a      attributes = _child.attributes;\x0a\x0a  if (type) {\x0a    child = element.ownerDocument.createElement(type);\x0a\x0a    for (var key in attributes) {\x0a      child.setAttribute(key, attributes[key]);\x0a    }\x0a  }\x0a\x0a  return element.appendChild(child);\x0a}\x0a\x0afunction to_dom_appendText(node, text) {\x0a  node.appendData(text);\x0a}\x0a\x0afunction to_dom_getLastChild(_ref) {\x0a  var lastChild = _ref.lastChild;\x0a  return lastChild;\x0a}\x0a\x0afunction to_dom_getParent(_ref2) {\x0a  var parentNode = _ref2.parentNode;\x0a  return parentNode;\x0a}\x0a\x0afunction to_dom_isText(_ref3) {\x0a  var nodeType = _ref3.nodeType;\x0a  return nodeType === to_dom_TEXT_NODE;\x0a}\x0a\x0afunction to_dom_getText(_ref4) {\x0a  var nodeValue = _ref4.nodeValue;\x0a  return nodeValue;\x0a}\x0a\x0afunction to_dom_remove(node) {\x0a  return node.parentNode.removeChild(node);\x0a}\x0a\x0afunction prepareFormats() {\x0a  var prepareEditableTree = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : [];\x0a  var value = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a  return prepareEditableTree.reduce(function (accumlator, fn) {\x0a    return fn(accumlator, value.text);\x0a  }, value.formats);\x0a}\x0a\x0afunction toDom(_ref5) {\x0a  var value = _ref5.value,\x0a      multilineTag = _ref5.multilineTag,\x0a      prepareEditableTree = _ref5.prepareEditableTree,\x0a      _ref5$isEditableTree = _ref5.isEditableTree,\x0a      isEditableTree = _ref5$isEditableTree === void 0 ? true : _ref5$isEditableTree;\x0a  var startPath = [];\x0a  var endPath = [];\x0a  var tree = toTree({\x0a    value: Object(objectSpread[\x22a\x22 /* default */])({}, value, {\x0a      formats: prepareFormats(prepareEditableTree, value)\x0a    }),\x0a    multilineTag: multilineTag,\x0a    createEmpty: to_dom_createEmpty,\x0a    append: to_dom_append,\x0a    getLastChild: to_dom_getLastChild,\x0a    getParent: to_dom_getParent,\x0a    isText: to_dom_isText,\x0a    getText: to_dom_getText,\x0a    remove: to_dom_remove,\x0a    appendText: to_dom_appendText,\x0a    onStartIndex: function onStartIndex(body, pointer) {\x0a      startPath = createPathToNode(pointer, body, [pointer.nodeValue.length]);\x0a    },\x0a    onEndIndex: function onEndIndex(body, pointer) {\x0a      endPath = createPathToNode(pointer, body, [pointer.nodeValue.length]);\x0a    },\x0a    isEditableTree: isEditableTree\x0a  });\x0a  return {\x0a    body: tree,\x0a    selection: {\x0a      startPath: startPath,\x0a      endPath: endPath\x0a    }\x0a  };\x0a}\x0a/**\x0a * Create an `Element` tree from a Rich Text value and applies the difference to\x0a * the `Element` tree contained by `current`. If a `multilineTag` is provided,\x0a * text separated by two new lines will be wrapped in an `Element` of that type.\x0a *\x0a * @param {Object}      $1                        Named arguments.\x0a * @param {Object}      $1.value                  Value to apply.\x0a * @param {HTMLElement} $1.current                The live root node to apply the element tree to.\x0a * @param {string}      [$1.multilineTag]         Multiline tag.\x0a * @param {Array}       [$1.multilineWrapperTags] Tags where lines can be found if nesting is possible.\x0a */\x0a\x0afunction apply(_ref6) {\x0a  var value = _ref6.value,\x0a      current = _ref6.current,\x0a      multilineTag = _ref6.multilineTag,\x0a      prepareEditableTree = _ref6.prepareEditableTree,\x0a      __unstableDomOnly = _ref6.__unstableDomOnly;\x0a\x0a  // Construct a new element tree in memory.\x0a  var _toDom = toDom({\x0a    value: value,\x0a    multilineTag: multilineTag,\x0a    prepareEditableTree: prepareEditableTree\x0a  }),\x0a      body = _toDom.body,\x0a      selection = _toDom.selection;\x0a\x0a  applyValue(body, current);\x0a\x0a  if (value.start !== undefined && !__unstableDomOnly) {\x0a    applySelection(selection, current);\x0a  }\x0a}\x0afunction applyValue(future, current) {\x0a  var i = 0;\x0a  var futureChild;\x0a\x0a  while (futureChild = future.firstChild) {\x0a    var currentChild = current.childNodes[i];\x0a\x0a    if (!currentChild) {\x0a      current.appendChild(futureChild);\x0a    } else if (!currentChild.isEqualNode(futureChild)) {\x0a      if (currentChild.nodeName !== futureChild.nodeName || currentChild.nodeType === to_dom_TEXT_NODE && currentChild.data !== futureChild.data) {\x0a        current.replaceChild(futureChild, currentChild);\x0a      } else {\x0a        var currentAttributes = currentChild.attributes;\x0a        var futureAttributes = futureChild.attributes;\x0a\x0a        if (currentAttributes) {\x0a          for (var ii = 0; ii \x3c currentAttributes.length; ii++) {\x0a            var name = currentAttributes[ii].name;\x0a\x0a            if (!futureChild.getAttribute(name)) {\x0a              currentChild.removeAttribute(name);\x0a            }\x0a          }\x0a        }\x0a\x0a        if (futureAttributes) {\x0a          for (var _ii = 0; _ii \x3c futureAttributes.length; _ii++) {\x0a            var _futureAttributes$_ii = futureAttributes[_ii],\x0a                name = _futureAttributes$_ii.name,\x0a                value = _futureAttributes$_ii.value;\x0a\x0a            if (currentChild.getAttribute(name) !== value) {\x0a              currentChild.setAttribute(name, value);\x0a            }\x0a          }\x0a        }\x0a\x0a        applyValue(futureChild, currentChild);\x0a        future.removeChild(futureChild);\x0a      }\x0a    } else {\x0a      future.removeChild(futureChild);\x0a    }\x0a\x0a    i++;\x0a  }\x0a\x0a  while (current.childNodes[i]) {\x0a    current.removeChild(current.childNodes[i]);\x0a  }\x0a}\x0a/**\x0a * Returns true if two ranges are equal, or false otherwise. Ranges are\x0a * considered equal if their start and end occur in the same container and\x0a * offset.\x0a *\x0a * @param {Range} a First range object to test.\x0a * @param {Range} b First range object to test.\x0a *\x0a * @return {boolean} Whether the two ranges are equal.\x0a */\x0a\x0afunction isRangeEqual(a, b) {\x0a  return a.startContainer === b.startContainer && a.startOffset === b.startOffset && a.endContainer === b.endContainer && a.endOffset === b.endOffset;\x0a}\x0a\x0afunction applySelection(_ref7, current) {\x0a  var startPath = _ref7.startPath,\x0a      endPath = _ref7.endPath;\x0a\x0a  var _getNodeByPath = getNodeByPath(current, startPath),\x0a      startContainer = _getNodeByPath.node,\x0a      startOffset = _getNodeByPath.offset;\x0a\x0a  var _getNodeByPath2 = getNodeByPath(current, endPath),\x0a      endContainer = _getNodeByPath2.node,\x0a      endOffset = _getNodeByPath2.offset;\x0a\x0a  var selection = window.getSelection();\x0a  var ownerDocument = current.ownerDocument;\x0a  var range = ownerDocument.createRange();\x0a  range.setStart(startContainer, startOffset);\x0a  range.setEnd(endContainer, endOffset);\x0a\x0a  if (selection.rangeCount \x3e 0) {\x0a    // If the to be added range and the live range are the same, there\x27s no\x0a    // need to remove the live range and add the equivalent range.\x0a    if (isRangeEqual(range, selection.getRangeAt(0))) {\x0a      // Set back focus if focus is lost.\x0a      if (ownerDocument.activeElement !== current) {\x0a        current.focus();\x0a      }\x0a\x0a      return;\x0a    }\x0a\x0a    selection.removeAllRanges();\x0a  }\x0a\x0a  selection.addRange(range);\x0a}\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22escapeHtml\x22]}\x0avar external_this_wp_escapeHtml_ = __webpack_require__(69);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/to-html-string.js\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Create an HTML string from a Rich Text value. If a `multilineTag` is\x0a * provided, text separated by a line separator will be wrapped in it.\x0a *\x0a * @param {Object} $1                        Named argements.\x0a * @param {Object} $1.value                  Rich text value.\x0a * @param {string} [$1.multilineTag]         Multiline tag.\x0a *\x0a * @return {string} HTML string.\x0a */\x0a\x0afunction toHTMLString(_ref) {\x0a  var value = _ref.value,\x0a      multilineTag = _ref.multilineTag;\x0a  var tree = toTree({\x0a    value: value,\x0a    multilineTag: multilineTag,\x0a    createEmpty: to_html_string_createEmpty,\x0a    append: to_html_string_append,\x0a    getLastChild: to_html_string_getLastChild,\x0a    getParent: to_html_string_getParent,\x0a    isText: to_html_string_isText,\x0a    getText: to_html_string_getText,\x0a    remove: to_html_string_remove,\x0a    appendText: to_html_string_appendText\x0a  });\x0a  return createChildrenHTML(tree.children);\x0a}\x0a\x0afunction to_html_string_createEmpty() {\x0a  return {};\x0a}\x0a\x0afunction to_html_string_getLastChild(_ref2) {\x0a  var children = _ref2.children;\x0a  return children && children[children.length - 1];\x0a}\x0a\x0afunction to_html_string_append(parent, object) {\x0a  if (typeof object === \x27string\x27) {\x0a    object = {\x0a      text: object\x0a    };\x0a  }\x0a\x0a  object.parent = parent;\x0a  parent.children = parent.children || [];\x0a  parent.children.push(object);\x0a  return object;\x0a}\x0a\x0afunction to_html_string_appendText(object, text) {\x0a  object.text += text;\x0a}\x0a\x0afunction to_html_string_getParent(_ref3) {\x0a  var parent = _ref3.parent;\x0a  return parent;\x0a}\x0a\x0afunction to_html_string_isText(_ref4) {\x0a  var text = _ref4.text;\x0a  return typeof text === \x27string\x27;\x0a}\x0a\x0afunction to_html_string_getText(_ref5) {\x0a  var text = _ref5.text;\x0a  return text;\x0a}\x0a\x0afunction to_html_string_remove(object) {\x0a  var index = object.parent.children.indexOf(object);\x0a\x0a  if (index !== -1) {\x0a    object.parent.children.splice(index, 1);\x0a  }\x0a\x0a  return object;\x0a}\x0a\x0afunction createElementHTML(_ref6) {\x0a  var type = _ref6.type,\x0a      attributes = _ref6.attributes,\x0a      object = _ref6.object,\x0a      children = _ref6.children;\x0a  var attributeString = \x27\x27;\x0a\x0a  for (var key in attributes) {\x0a    if (!Object(external_this_wp_escapeHtml_[\x22isValidAttributeName\x22])(key)) {\x0a      continue;\x0a    }\x0a\x0a    attributeString += \x22 \x22.concat(key, \x22=\x5c\x22\x22).concat(Object(external_this_wp_escapeHtml_[\x22escapeAttribute\x22])(attributes[key]), \x22\x5c\x22\x22);\x0a  }\x0a\x0a  if (object) {\x0a    return \x22\x3c\x22.concat(type).concat(attributeString, \x22\x3e\x22);\x0a  }\x0a\x0a  return \x22\x3c\x22.concat(type).concat(attributeString, \x22\x3e\x22).concat(createChildrenHTML(children), \x22\x3c/\x22).concat(type, \x22\x3e\x22);\x0a}\x0a\x0afunction createChildrenHTML() {\x0a  var children = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : [];\x0a  return children.map(function (child) {\x0a    return child.text === undefined ? createElementHTML(child) : Object(external_this_wp_escapeHtml_[\x22escapeHTML\x22])(child.text);\x0a  }).join(\x27\x27);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/toggle-format.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * Toggles a format object to a Rich Text value at the current selection.\x0a *\x0a * @param {Object} value  Value to modify.\x0a * @param {Object} format Format to apply or remove.\x0a *\x0a * @return {Object} A new value with the format applied or removed.\x0a */\x0a\x0afunction toggleFormat(value, format) {\x0a  if (getActiveFormat(value, format.type)) {\x0a    return removeFormat(value, format.type);\x0a  }\x0a\x0a  return applyFormat(value, format);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/unregister-format-type.js\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a/**\x0a * Unregisters a format.\x0a *\x0a * @param {string} name Format name.\x0a *\x0a * @return {WPFormat|undefined} The previous format value, if it has been successfully\x0a *                              unregistered; otherwise `undefined`.\x0a */\x0a\x0afunction unregisterFormatType(name) {\x0a  var oldFormat = Object(external_this_wp_data_[\x22select\x22])(\x27core/rich-text\x27).getFormatType(name);\x0a\x0a  if (!oldFormat) {\x0a    window.console.error(\x22Format \x22.concat(name, \x22 is not registered.\x22));\x0a    return;\x0a  }\x0a\x0a  if (oldFormat.__experimentalCreatePrepareEditableTree && oldFormat.__experimentalGetPropsForEditableTreePreparation) {\x0a    Object(external_this_wp_hooks_[\x22removeFilter\x22])(\x27experimentalRichText\x27, name);\x0a  }\x0a\x0a  Object(external_this_wp_data_[\x22dispatch\x22])(\x27core/rich-text\x27).removeFormatTypes(name);\x0a  return oldFormat;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/get-line-index.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a/**\x0a * Gets the currently selected line index, or the first line index if the\x0a * selection spans over multiple items.\x0a *\x0a * @param {Object}  value      Value to get the line index from.\x0a * @param {boolean} startIndex Optional index that should be contained by the\x0a *                             line. Defaults to the selection start of the\x0a *                             value.\x0a *\x0a * @return {?boolean} The line index. Undefined if not found.\x0a */\x0a\x0afunction getLineIndex(_ref) {\x0a  var start = _ref.start,\x0a      text = _ref.text;\x0a  var startIndex = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : start;\x0a  var index = startIndex;\x0a\x0a  while (index--) {\x0a    if (text[index] === LINE_SEPARATOR) {\x0a      return index;\x0a    }\x0a  }\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/indent-list-items.js\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Gets the line index of the first previous list item with higher indentation.\x0a *\x0a * @param {Object} value      Value to search.\x0a * @param {number} lineIndex  Line index of the list item to compare with.\x0a *\x0a * @return {boolean} The line index.\x0a */\x0a\x0afunction getTargetLevelLineIndex(_ref, lineIndex) {\x0a  var text = _ref.text,\x0a      replacements = _ref.replacements;\x0a  var startFormats = replacements[lineIndex] || [];\x0a  var index = lineIndex;\x0a\x0a  while (index-- \x3e= 0) {\x0a    if (text[index] !== LINE_SEPARATOR) {\x0a      continue;\x0a    }\x0a\x0a    var formatsAtIndex = replacements[index] || []; // Return the first line index that is one level higher. If the level is\x0a    // lower or equal, there is no result.\x0a\x0a    if (formatsAtIndex.length === startFormats.length + 1) {\x0a      return index;\x0a    } else if (formatsAtIndex.length \x3c= startFormats.length) {\x0a      return;\x0a    }\x0a  }\x0a}\x0a/**\x0a * Indents any selected list items if possible.\x0a *\x0a * @param {Object} value      Value to change.\x0a * @param {Object} rootFormat Root format.\x0a *\x0a * @return {Object} The changed value.\x0a */\x0a\x0a\x0afunction indentListItems(value, rootFormat) {\x0a  var lineIndex = getLineIndex(value); // There is only one line, so the line cannot be indented.\x0a\x0a  if (lineIndex === undefined) {\x0a    return value;\x0a  }\x0a\x0a  var text = value.text,\x0a      replacements = value.replacements,\x0a      end = value.end;\x0a  var previousLineIndex = getLineIndex(value, lineIndex);\x0a  var formatsAtLineIndex = replacements[lineIndex] || [];\x0a  var formatsAtPreviousLineIndex = replacements[previousLineIndex] || []; // The the indentation of the current line is greater than previous line,\x0a  // then the line cannot be furter indented.\x0a\x0a  if (formatsAtLineIndex.length \x3e formatsAtPreviousLineIndex.length) {\x0a    return value;\x0a  }\x0a\x0a  var newFormats = replacements.slice();\x0a  var targetLevelLineIndex = getTargetLevelLineIndex(value, lineIndex);\x0a\x0a  for (var index = lineIndex; index \x3c end; index++) {\x0a    if (text[index] !== LINE_SEPARATOR) {\x0a      continue;\x0a    } // Get the previous list, and if there\x27s a child list, take over the\x0a    // formats. If not, duplicate the last level and create a new level.\x0a\x0a\x0a    if (targetLevelLineIndex) {\x0a      var targetFormats = replacements[targetLevelLineIndex] || [];\x0a      newFormats[index] = targetFormats.concat((newFormats[index] || []).slice(targetFormats.length - 1));\x0a    } else {\x0a      var _targetFormats = replacements[previousLineIndex] || [];\x0a\x0a      var lastformat = _targetFormats[_targetFormats.length - 1] || rootFormat;\x0a      newFormats[index] = _targetFormats.concat([lastformat], (newFormats[index] || []).slice(_targetFormats.length));\x0a    }\x0a  }\x0a\x0a  return Object(objectSpread[\x22a\x22 /* default */])({}, value, {\x0a    replacements: newFormats\x0a  });\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/get-parent-line-index.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a/**\x0a * Gets the index of the first parent list. To get the parent list formats, we\x0a * go through every list item until we find one with exactly one format type\x0a * less.\x0a *\x0a * @param {Object} value     Value to search.\x0a * @param {number} lineIndex Line index of a child list item.\x0a *\x0a * @return {Array} The parent list line index.\x0a */\x0a\x0afunction getParentLineIndex(_ref, lineIndex) {\x0a  var text = _ref.text,\x0a      replacements = _ref.replacements;\x0a  var startFormats = replacements[lineIndex] || [];\x0a  var index = lineIndex;\x0a\x0a  while (index-- \x3e= 0) {\x0a    if (text[index] !== LINE_SEPARATOR) {\x0a      continue;\x0a    }\x0a\x0a    var formatsAtIndex = replacements[index] || [];\x0a\x0a    if (formatsAtIndex.length === startFormats.length - 1) {\x0a      return index;\x0a    }\x0a  }\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/get-last-child-index.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a/**\x0a * Gets the line index of the last child in the list.\x0a *\x0a * @param {Object} value     Value to search.\x0a * @param {number} lineIndex Line index of a list item in the list.\x0a *\x0a * @return {Array} The index of the last child.\x0a */\x0a\x0afunction getLastChildIndex(_ref, lineIndex) {\x0a  var text = _ref.text,\x0a      replacements = _ref.replacements;\x0a  var lineFormats = replacements[lineIndex] || []; // Use the given line index in case there are no next children.\x0a\x0a  var childIndex = lineIndex; // `lineIndex` could be `undefined` if it\x27s the first line.\x0a\x0a  for (var index = lineIndex || 0; index \x3c text.length; index++) {\x0a    // We\x27re only interested in line indices.\x0a    if (text[index] !== LINE_SEPARATOR) {\x0a      continue;\x0a    }\x0a\x0a    var formatsAtIndex = replacements[index] || []; // If the amout of formats is equal or more, store it, then return the\x0a    // last one if the amount of formats is less.\x0a\x0a    if (formatsAtIndex.length \x3e= lineFormats.length) {\x0a      childIndex = index;\x0a    } else {\x0a      return childIndex;\x0a    }\x0a  } // If the end of the text is reached, return the last child index.\x0a\x0a\x0a  return childIndex;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/outdent-list-items.js\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0a/**\x0a * Outdents any selected list items if possible.\x0a *\x0a * @param {Object} value Value to change.\x0a *\x0a * @return {Object} The changed value.\x0a */\x0a\x0afunction outdentListItems(value) {\x0a  var text = value.text,\x0a      replacements = value.replacements,\x0a      start = value.start,\x0a      end = value.end;\x0a  var startingLineIndex = getLineIndex(value, start); // Return early if the starting line index cannot be further outdented.\x0a\x0a  if (replacements[startingLineIndex] === undefined) {\x0a    return value;\x0a  }\x0a\x0a  var newFormats = replacements.slice(0);\x0a  var parentFormats = replacements[getParentLineIndex(value, startingLineIndex)] || [];\x0a  var endingLineIndex = getLineIndex(value, end);\x0a  var lastChildIndex = getLastChildIndex(value, endingLineIndex); // Outdent all list items from the starting line index until the last child\x0a  // index of the ending list. All children of the ending list need to be\x0a  // outdented, otherwise they\x27ll be orphaned.\x0a\x0a  for (var index = startingLineIndex; index \x3c= lastChildIndex; index++) {\x0a    // Skip indices that are not line separators.\x0a    if (text[index] !== LINE_SEPARATOR) {\x0a      continue;\x0a    } // In the case of level 0, the formats at the index are undefined.\x0a\x0a\x0a    var currentFormats = newFormats[index] || []; // Omit the indentation level where the selection starts.\x0a\x0a    newFormats[index] = parentFormats.concat(currentFormats.slice(parentFormats.length + 1));\x0a\x0a    if (newFormats[index].length === 0) {\x0a      delete newFormats[index];\x0a    }\x0a  }\x0a\x0a  return Object(objectSpread[\x22a\x22 /* default */])({}, value, {\x0a    replacements: newFormats\x0a  });\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/change-list-type.js\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * Changes the list type of the selected indented list, if any. Looks at the\x0a * currently selected list item and takes the parent list, then changes the list\x0a * type of this list. When multiple lines are selected, the parent lists are\x0a * takes and changed.\x0a *\x0a * @param {Object} value     Value to change.\x0a * @param {Object} newFormat The new list format object. Choose between\x0a *                           `{ type: \x27ol\x27 }` and `{ type: \x27ul\x27 }`.\x0a *\x0a * @return {Object} The changed value.\x0a */\x0a\x0afunction changeListType(value, newFormat) {\x0a  var text = value.text,\x0a      replacements = value.replacements,\x0a      start = value.start,\x0a      end = value.end;\x0a  var startingLineIndex = getLineIndex(value, start);\x0a  var startLineFormats = replacements[startingLineIndex] || [];\x0a  var endLineFormats = replacements[getLineIndex(value, end)] || [];\x0a  var startIndex = getParentLineIndex(value, startingLineIndex);\x0a  var newReplacements = replacements.slice();\x0a  var startCount = startLineFormats.length - 1;\x0a  var endCount = endLineFormats.length - 1;\x0a  var changed;\x0a\x0a  for (var index = startIndex + 1 || 0; index \x3c text.length; index++) {\x0a    if (text[index] !== LINE_SEPARATOR) {\x0a      continue;\x0a    }\x0a\x0a    if ((newReplacements[index] || []).length \x3c= startCount) {\x0a      break;\x0a    }\x0a\x0a    if (!newReplacements[index]) {\x0a      continue;\x0a    }\x0a\x0a    changed = true;\x0a    newReplacements[index] = newReplacements[index].map(function (format, i) {\x0a      return i \x3c startCount || i \x3e endCount ? format : newFormat;\x0a    });\x0a  }\x0a\x0a  if (!changed) {\x0a    return value;\x0a  }\x0a\x0a  return Object(objectSpread[\x22a\x22 /* default */])({}, value, {\x0a    replacements: newReplacements\x0a  });\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/update-formats.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a/**\x0a * Efficiently updates all the formats from `start` (including) until `end`\x0a * (excluding) with the active formats. Mutates `value`.\x0a *\x0a * @param  {Object} $1         Named paramentes.\x0a * @param  {Object} $1.value   Value te update.\x0a * @param  {number} $1.start   Index to update from.\x0a * @param  {number} $1.end     Index to update until.\x0a * @param  {Array}  $1.formats Replacement formats.\x0a *\x0a * @return {Object} Mutated value.\x0a */\x0a\x0afunction updateFormats(_ref) {\x0a  var value = _ref.value,\x0a      start = _ref.start,\x0a      end = _ref.end,\x0a      formats = _ref.formats;\x0a  var formatsBefore = value.formats[start - 1] || [];\x0a  var formatsAfter = value.formats[end] || []; // First, fix the references. If any format right before or after are\x0a  // equal, the replacement format should use the same reference.\x0a\x0a  value.activeFormats = formats.map(function (format, index) {\x0a    if (formatsBefore[index]) {\x0a      if (isFormatEqual(format, formatsBefore[index])) {\x0a        return formatsBefore[index];\x0a      }\x0a    } else if (formatsAfter[index]) {\x0a      if (isFormatEqual(format, formatsAfter[index])) {\x0a        return formatsAfter[index];\x0a      }\x0a    }\x0a\x0a    return format;\x0a  });\x0a\x0a  while (--end \x3e= start) {\x0a    if (value.activeFormats.length \x3e 0) {\x0a      value.formats[end] = value.activeFormats;\x0a    } else {\x0a      delete value.formats[end];\x0a    }\x0a  }\x0a\x0a  return value;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/rich-text/build-module/index.js\x0a/* concated harmony reexport applyFormat */__webpack_require__.d(__webpack_exports__, \x22applyFormat\x22, function() { return applyFormat; });\x0a/* concated harmony reexport charAt */__webpack_require__.d(__webpack_exports__, \x22charAt\x22, function() { return charAt; });\x0a/* concated harmony reexport concat */__webpack_require__.d(__webpack_exports__, \x22concat\x22, function() { return concat; });\x0a/* concated harmony reexport create */__webpack_require__.d(__webpack_exports__, \x22create\x22, function() { return create; });\x0a/* concated harmony reexport getActiveFormat */__webpack_require__.d(__webpack_exports__, \x22getActiveFormat\x22, function() { return getActiveFormat; });\x0a/* concated harmony reexport getActiveObject */__webpack_require__.d(__webpack_exports__, \x22getActiveObject\x22, function() { return getActiveObject; });\x0a/* concated harmony reexport getSelectionEnd */__webpack_require__.d(__webpack_exports__, \x22getSelectionEnd\x22, function() { return getSelectionEnd; });\x0a/* concated harmony reexport getSelectionStart */__webpack_require__.d(__webpack_exports__, \x22getSelectionStart\x22, function() { return getSelectionStart; });\x0a/* concated harmony reexport getTextContent */__webpack_require__.d(__webpack_exports__, \x22getTextContent\x22, function() { return getTextContent; });\x0a/* concated harmony reexport isCollapsed */__webpack_require__.d(__webpack_exports__, \x22isCollapsed\x22, function() { return isCollapsed; });\x0a/* concated harmony reexport isEmpty */__webpack_require__.d(__webpack_exports__, \x22isEmpty\x22, function() { return isEmpty; });\x0a/* concated harmony reexport isEmptyLine */__webpack_require__.d(__webpack_exports__, \x22isEmptyLine\x22, function() { return isEmptyLine; });\x0a/* concated harmony reexport join */__webpack_require__.d(__webpack_exports__, \x22join\x22, function() { return join; });\x0a/* concated harmony reexport registerFormatType */__webpack_require__.d(__webpack_exports__, \x22registerFormatType\x22, function() { return registerFormatType; });\x0a/* concated harmony reexport removeFormat */__webpack_require__.d(__webpack_exports__, \x22removeFormat\x22, function() { return removeFormat; });\x0a/* concated harmony reexport remove */__webpack_require__.d(__webpack_exports__, \x22remove\x22, function() { return remove_remove; });\x0a/* concated harmony reexport replace */__webpack_require__.d(__webpack_exports__, \x22replace\x22, function() { return replace; });\x0a/* concated harmony reexport insert */__webpack_require__.d(__webpack_exports__, \x22insert\x22, function() { return insert; });\x0a/* concated harmony reexport insertLineBreak */__webpack_require__.d(__webpack_exports__, \x22insertLineBreak\x22, function() { return insertLineBreak; });\x0a/* concated harmony reexport insertLineSeparator */__webpack_require__.d(__webpack_exports__, \x22insertLineSeparator\x22, function() { return insertLineSeparator; });\x0a/* concated harmony reexport insertObject */__webpack_require__.d(__webpack_exports__, \x22insertObject\x22, function() { return insertObject; });\x0a/* concated harmony reexport slice */__webpack_require__.d(__webpack_exports__, \x22slice\x22, function() { return slice; });\x0a/* concated harmony reexport split */__webpack_require__.d(__webpack_exports__, \x22split\x22, function() { return split; });\x0a/* concated harmony reexport apply */__webpack_require__.d(__webpack_exports__, \x22apply\x22, function() { return apply; });\x0a/* concated harmony reexport unstableToDom */__webpack_require__.d(__webpack_exports__, \x22unstableToDom\x22, function() { return toDom; });\x0a/* concated harmony reexport toHTMLString */__webpack_require__.d(__webpack_exports__, \x22toHTMLString\x22, function() { return toHTMLString; });\x0a/* concated harmony reexport toggleFormat */__webpack_require__.d(__webpack_exports__, \x22toggleFormat\x22, function() { return toggleFormat; });\x0a/* concated harmony reexport LINE_SEPARATOR */__webpack_require__.d(__webpack_exports__, \x22LINE_SEPARATOR\x22, function() { return LINE_SEPARATOR; });\x0a/* concated harmony reexport unregisterFormatType */__webpack_require__.d(__webpack_exports__, \x22unregisterFormatType\x22, function() { return unregisterFormatType; });\x0a/* concated harmony reexport indentListItems */__webpack_require__.d(__webpack_exports__, \x22indentListItems\x22, function() { return indentListItems; });\x0a/* concated harmony reexport outdentListItems */__webpack_require__.d(__webpack_exports__, \x22outdentListItems\x22, function() { return outdentListItems; });\x0a/* concated harmony reexport changeListType */__webpack_require__.d(__webpack_exports__, \x22changeListType\x22, function() { return changeListType; });\x0a/* concated harmony reexport __unstableUpdateFormats */__webpack_require__.d(__webpack_exports__, \x22__unstableUpdateFormats\x22, function() { return updateFormats; });\x0a/* concated harmony reexport __unstableGetActiveFormats */__webpack_require__.d(__webpack_exports__, \x22__unstableGetActiveFormats\x22, function() { return getActiveFormats; });\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 41:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0amodule.exports = function memize( fn, options ) {\x0a\x09var size = 0,\x0a\x09\x09maxSize, head, tail;\x0a\x0a\x09if ( options && options.maxSize ) {\x0a\x09\x09maxSize = options.maxSize;\x0a\x09}\x0a\x0a\x09function memoized( /* ...args */ ) {\x0a\x09\x09var node = head,\x0a\x09\x09\x09len = arguments.length,\x0a\x09\x09\x09args, i;\x0a\x0a\x09\x09searchCache: while ( node ) {\x0a\x09\x09\x09// Perform a shallow equality test to confirm that whether the node\x0a\x09\x09\x09// under test is a candidate for the arguments passed. Two arrays\x0a\x09\x09\x09// are shallowly equal if their length matches and each entry is\x0a\x09\x09\x09// strictly equal between the two sets. Avoid abstracting to a\x0a\x09\x09\x09// function which could incur an arguments leaking deoptimization.\x0a\x0a\x09\x09\x09// Check whether node arguments match arguments length\x0a\x09\x09\x09if ( node.args.length !== arguments.length ) {\x0a\x09\x09\x09\x09node = node.next;\x0a\x09\x09\x09\x09continue;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Check whether node arguments match arguments values\x0a\x09\x09\x09for ( i = 0; i \x3c len; i++ ) {\x0a\x09\x09\x09\x09if ( node.args[ i ] !== arguments[ i ] ) {\x0a\x09\x09\x09\x09\x09node = node.next;\x0a\x09\x09\x09\x09\x09continue searchCache;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// At this point we can assume we\x27ve found a match\x0a\x0a\x09\x09\x09// Surface matched node to head if not already\x0a\x09\x09\x09if ( node !== head ) {\x0a\x09\x09\x09\x09// As tail, shift to previous. Must only shift if not also\x0a\x09\x09\x09\x09// head, since if both head and tail, there is no previous.\x0a\x09\x09\x09\x09if ( node === tail ) {\x0a\x09\x09\x09\x09\x09tail = node.prev;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Adjust siblings to point to each other. If node was tail,\x0a\x09\x09\x09\x09// this also handles new tail\x27s empty `next` assignment.\x0a\x09\x09\x09\x09node.prev.next = node.next;\x0a\x09\x09\x09\x09if ( node.next ) {\x0a\x09\x09\x09\x09\x09node.next.prev = node.prev;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09node.next = head;\x0a\x09\x09\x09\x09node.prev = null;\x0a\x09\x09\x09\x09head.prev = node;\x0a\x09\x09\x09\x09head = node;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Return immediately\x0a\x09\x09\x09return node.val;\x0a\x09\x09}\x0a\x0a\x09\x09// No cached value found. Continue to insertion phase:\x0a\x0a\x09\x09// Create a copy of arguments (avoid leaking deoptimization)\x0a\x09\x09args = new Array( len );\x0a\x09\x09for ( i = 0; i \x3c len; i++ ) {\x0a\x09\x09\x09args[ i ] = arguments[ i ];\x0a\x09\x09}\x0a\x0a\x09\x09node = {\x0a\x09\x09\x09args: args,\x0a\x0a\x09\x09\x09// Generate the result from original function\x0a\x09\x09\x09val: fn.apply( null, args )\x0a\x09\x09};\x0a\x0a\x09\x09// Don\x27t need to check whether node is already head, since it would\x0a\x09\x09// have been returned above already if it was\x0a\x0a\x09\x09// Shift existing head down list\x0a\x09\x09if ( head ) {\x0a\x09\x09\x09head.prev = node;\x0a\x09\x09\x09node.next = head;\x0a\x09\x09} else {\x0a\x09\x09\x09// If no head, follows that there\x27s no tail (at initial or reset)\x0a\x09\x09\x09tail = node;\x0a\x09\x09}\x0a\x0a\x09\x09// Trim tail if we\x27re reached max size and are pending cache insertion\x0a\x09\x09if ( size === maxSize ) {\x0a\x09\x09\x09tail = tail.prev;\x0a\x09\x09\x09tail.next = null;\x0a\x09\x09} else {\x0a\x09\x09\x09size++;\x0a\x09\x09}\x0a\x0a\x09\x09head = node;\x0a\x0a\x09\x09return node.val;\x0a\x09}\x0a\x0a\x09memoized.clear = function() {\x0a\x09\x09head = null;\x0a\x09\x09tail = null;\x0a\x09\x09size = 0;\x0a\x09};\x0a\x0a\x09if ( false ) {}\x0a\x0a\x09return memoized;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 5:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22data\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 6:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22compose\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 69:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22escapeHtml\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 7:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _objectSpread; });\x0a/* harmony import */ var _defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);\x0a\x0afunction _objectSpread(target) {\x0a  for (var i = 1; i \x3c arguments.length; i++) {\x0a    var source = arguments[i] != null ? arguments[i] : {};\x0a    var ownKeys = Object.keys(source);\x0a\x0a    if (typeof Object.getOwnPropertySymbols === \x27function\x27) {\x0a      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\x0a        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\x0a      }));\x0a    }\x0a\x0a    ownKeys.forEach(function (key) {\x0a      Object(_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22])(target, key, source[key]);\x0a    });\x0a  }\x0a\x0a  return target;\x0a}\x0a\x0a/***/ })\x0a\x0a/******/ });is._localea'}