var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:12:19 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Wed, 27 Mar 2019 22:31:52 GMT\x0aETag: \x22725c-5851b01102600-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-6706/6707\x0aContent-Length: 6707\x0aKeep-Alive: timeout=5, max=70\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/*!\x0a * clipboard.js v2.0.4\x0a * https://zenorocha.github.io/clipboard.js\x0a * \x0a * Licensed MIT \xc2\xa9 Zeno Rocha\x0a */\x0a(function webpackUniversalModuleDefinition(root, factory) {\x0a\x09if(typeof exports === \x27object\x27 && typeof module === \x27object\x27)\x0a\x09\x09module.exports = factory();\x0a\x09else if(typeof define === \x27function\x27 && define.amd)\x0a\x09\x09define([], factory);\x0a\x09else if(typeof exports === \x27object\x27)\x0a\x09\x09exports[\x22ClipboardJS\x22] = factory();\x0a\x09else\x0a\x09\x09root[\x22ClipboardJS\x22] = factory();\x0a})(this, function() {\x0areturn /******/ (function(modules) { // webpackBootstrap\x0a/******/ \x09// The module cache\x0a/******/ \x09var installedModules = {};\x0a/******/\x0a/******/ \x09// The require function\x0a/******/ \x09function __webpack_require__(moduleId) {\x0a/******/\x0a/******/ \x09\x09// Check if module is in cache\x0a/******/ \x09\x09if(installedModules[moduleId]) {\x0a/******/ \x09\x09\x09return installedModules[moduleId].exports;\x0a/******/ \x09\x09}\x0a/******/ \x09\x09// Create a new module (and put it into the cache)\x0a/******/ \x09\x09var module = installedModules[moduleId] = {\x0a/******/ \x09\x09\x09i: moduleId,\x0a/******/ \x09\x09\x09l: false,\x0a/******/ \x09\x09\x09exports: {}\x0a/******/ \x09\x09};\x0a/******/\x0a/******/ \x09\x09// Execute the module function\x0a/******/ \x09\x09modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\x0a/******/\x0a/******/ \x09\x09// Flag the module as loaded\x0a/******/ \x09\x09module.l = true;\x0a/******/\x0a/******/ \x09\x09// Return the exports of the module\x0a/******/ \x09\x09return module.exports;\x0a/******/ \x09}\x0a/******/\x0a/******/\x0a/******/ \x09// expose the modules object (__webpack_modules__)\x0a/******/ \x09__webpack_require__.m = modules;\x0a/******/\x0a/******/ \x09// expose the module cache\x0a/******/ \x09__webpack_require__.c = installedModules;\x0a/******/\x0a/******/ \x09// define getter function for harmony exports\x0a/******/ \x09__webpack_require__.d = function(exports, name, getter) {\x0a/******/ \x09\x09if(!__webpack_require__.o(exports, name)) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, name, { enumerable: true, get: getter });\x0a/******/ \x09\x09}\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// define __esModule on exports\x0a/******/ \x09__webpack_require__.r = function(exports) {\x0a/******/ \x09\x09if(typeof Symbol !== \x27undefined\x27 && Symbol.toStringTag) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, Symbol.toStringTag, { value: \x27Module\x27 });\x0a/******/ \x09\x09}\x0a/******/ \x09\x09Object.defineProperty(exports, \x27__esModule\x27, { value: true });\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// create a fake namespace object\x0a/******/ \x09// mode & 1: value is a module id, require it\x0a/******/ \x09// mode & 2: merge all properties of value into the ns\x0a/******/ \x09// mode & 4: return value when already ns object\x0a/******/ \x09// mode & 8|1: behave like require\x0a/******/ \x09__webpack_require__.t = function(value, mode) {\x0a/******/ \x09\x09if(mode & 1) value = __webpack_require__(value);\x0a/******/ \x09\x09if(mode & 8) return value;\x0a/******/ \x09\x09if((mode & 4) && typeof value === \x27object\x27 && value && value.__esModule) return value;\x0a/******/ \x09\x09var ns = Object.create(null);\x0a/******/ \x09\x09__webpack_require__.r(ns);\x0a/******/ \x09\x09Object.defineProperty(ns, \x27default\x27, { enumerable: true, value: value });\x0a/******/ \x09\x09if(mode & 2 && typeof value != \x27string\x27) for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\x0a/******/ \x09\x09return ns;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// getDefaultExport function for compatibility with non-harmony modules\x0a/******/ \x09__webpack_require__.n = function(module) {\x0a/******/ \x09\x09var getter = module && module.__esModule ?\x0a/******/ \x09\x09\x09function getDefault() { return module[\x27default\x27]; } :\x0a/******/ \x09\x09\x09function getModuleExports() { return module; };\x0a/******/ \x09\x09__webpack_require__.d(getter, \x27a\x27, getter);\x0a/******/ \x09\x09return getter;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// Object.prototype.hasOwnProperty.call\x0a/******/ \x09__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\x0a/******/\x0a/******/ \x09// __webpack_public_path__\x0a/******/ \x09__webpack_require__.p = \x22\x22;\x0a/******/\x0a/******/\x0a/******/ \x09// Load entry module and return exports\x0a/******/ \x09return __webpack_require__(__webpack_require__.s = 0);\x0a/******/ })\x0a/************************************************************************/\x0a/******/ ([\x0a/* 0 */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0avar _typeof = typeof Symbol === \x22function\x22 && typeof Symbol.iterator === \x22symbol\x22 ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \x22function\x22 && obj.constructor === Symbol && obj !== Symbol.prototype ? \x22symbol\x22 : typeof obj; };\x0a\x0avar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i \x3c props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\x22value\x22 in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\x0a\x0avar _clipboardAction = __webpack_require__(1);\x0a\x0avar _clipboardAction2 = _interopRequireDefault(_clipboardAction);\x0a\x0avar _tinyEmitter = __webpack_require__(3);\x0a\x0avar _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);\x0a\x0avar _goodListener = __webpack_require__(4);\x0a\x0avar _goodListener2 = _interopRequireDefault(_goodListener);\x0a\x0afunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\x0a\x0afunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\x22Cannot call a class as a function\x22); } }\x0a\x0afunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\x22this hasn\x27t been initialised - super() hasn\x27t been called\x22); } return call && (typeof call === \x22object\x22 || typeof call === \x22function\x22) ? call : self; }\x0a\x0afunction _inherits(subClass, superClass) { if (typeof superClass !== \x22function\x22 && superClass !== null) { throw new TypeError(\x22Super expression must either be null or a function, not \x22 + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\x0a\x0a/**\x0a * Base class which takes one or more elements, adds event listeners to them,\x0a * and instantiates a new `ClipboardAction` on each click.\x0a */\x0avar Clipboard = function (_Emitter) {\x0a    _inherits(Clipboard, _Emitter);\x0a\x0a    /**\x0a     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\x0a     * @param {Object} options\x0a     */\x0a    function Clipboard(trigger, options) {\x0a        _classCallCheck(this, Clipboard);\x0a\x0a        var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));\x0a\x0a        _this.resolveOptions(options);\x0a        _this.listenClick(trigger);\x0a        return _this;\x0a    }\x0a\x0a    /**\x0a     * Defines if attributes would be resolved using internal setter functions\x0a     * or custom functions that were passed in the constructor.\x0a     * @param {Object} options\x0a     */\x0a\x0a\x0a    _createClass(Clipboard, [{\x0a        key: \x27resolveOptions\x27,\x0a        value: function resolveOptions() {\x0a            var options = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a\x0a            this.action = typeof options.action === \x27function\x27 ? options.action : this.defaultAction;\x0a            this.target = typeof options.target === \x27function\x27 ? options.target : this.defaultTarget;\x0a            this.text = typeof options.text === \x27function\x27 ? options.text : this.defaultText;\x0a            this.container = _typeof(options.container) === \x27object\x27 ? options.container : document.body;\x0a        }\x0a\x0a        /**\x0a         * Adds a click event listener to the passed trigger.\x0a         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\x0a         */\x0a\x0a    }, {\x0a        key: \x27listenClick\x27,\x0a        value: function listenClick(trigger) {\x0a            var _this2 = this;\x0a\x0a            this.listener = (0, _goodListener2.default)(trigger, \x27click\x27, function (e) {\x0a                return _this2.onClick(e);\x0a            });\x0a        }\x0a\x0a        /**\x0a         * Defines a new `ClipboardAction` on each click event.\x0a         * @param {Event} e\x0a         */\x0a\x0a    }, {\x0a        key: \x27onClick\x27,\x0a        value: function onClick(e) {\x0a            var trigger = e.delegateTarget || e.currentTarget;\x0a\x0a            if (this.clipboardAction) {\x0a                this.clipboardAction = null;\x0a            }\x0a\x0a            this.clipboardAction = new _clipboardAction2.default({\x0a                action: this.action(trigger),\x0a                target: this.target(trigger),\x0a                text: this.text(trigger),\x0a                container: this.container,\x0a                trigger: trigger,\x0a                emitter: this\x0a            });\x0a        }\x0a\x0a        /**\x0a         * Default `action` lookup function.\x0a         * @param {Element} trigger\x0a         */\x0a\x0a    }, {\x0a        key: \x27defaultAction\x27,\x0a        value: function defaultAction(trigger) {\x0a            return getAttributeValue(\x27action\x27, trigger);\x0a        }\x0a\x0a        /**\x0a         * Default `target` lookup function.\x0a         * @param {Element} trigger\x0a         */\x0a\x0a    }, {\x0a        key: \x27defaultTarget\x27,\x0a        value: function defaultTarget(trigger) {\x0a            var selector = getAttributeValue(\x27target\x27, trigger);\x0a\x0a            if (selector) {\x0a                return document.querySelector(selector);\x0a            }\x0a        }\x0a\x0a        /**\x0a         * Returns the support of the given action, or all actions if no action is\x0a         * given.\x0a         * @param {String} [action]\x0a         */\x0a\x0a    }, {\x0a        key: \x27defaultText\x27,\x0a\x0a\x0a        /**\x0a         * Default `text` lookup function.\x0a         * @param {Element} trigger\x0a         */\x0a        value: function defaultText(trigger) {\x0a            return getAttributeValue(\x27text\x27, trigger);\x0a        }\x0a\x0a        /**\x0a         * Destroy lifecycle.\x0a         */\x0a\x0a    }, {\x0a        key: \x27destroy\x27,\x0a        value: function destroy() {\x0a            this.listener.destroy();\x0a\x0a            if (this.clipboardAction) {\x0a                this.clipboardAction.destroy();\x0a                this.clipboardAction = null;\x0a            }\x0a        }\x0a    }], [{\x0a        key: \x27isSupported\x27,\x0a        value: function isSupported() {\x0a            var action = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : [\x27copy\x27, \x27cut\x27];\x0a\x0a            var actions = typeof action === \x27string\x27 ? [action] : action;\x0a            var support = !!document.queryCommandSupported;\x0a\x0a            actions.forEach(function (action) {\x0a                support = support && !!document.queryCommandSupported(action);\x0a            });\x0a\x0a            return support;\x0a        }\x0a    }]);\x0a\x0a    return Clipboard;\x0a}(_tinyEmitter2.default);\x0a\x0a/**\x0a * Helper function to retrieve attribute value.\x0a * @param {String} suffix\x0a * @param {Element} element\x0a */\x0a\x0a\x0afunction getAttributeValue(suffix, element) {\x0a    var attribute = \x27data-clipboard-\x27 + suffix;\x0a\x0a    if (!element.hasAttribute(attribute)) {\x0a        return;\x0a    }\x0a\x0a    return element.getAttribute(attribute);\x0a}\x0a\x0amodule.exports = Clipboard;\x0a\x0a/***/ }),\x0a/* 1 */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0avar _typeof = typeof Symbol === \x22function\x22 && typeof Symbol.iterator === \x22symbol\x22 ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \x22function\x22 && obj.constructor === Symbol && obj !== Symbol.prototype ? \x22symbol\x22 : typeof obj; };\x0a\x0avar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i \x3c props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\x22value\x22 in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\x0a\x0avar _select = __webpack_require__(2);\x0a\x0avar _select2 = _interopRequireDefault(_select);\x0a\x0afunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\x0a\x0afunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\x22Cannot call a class as a function\x22); } }\x0a\x0a/**\x0a * Inner class which performs selection from either `text` or `target`\x0a * properties and then executes copy or cut operations.\x0a */\x0avar ClipboardAction = function () {\x0a    /**\x0a     * @param {Object} options\x0a     */\x0a    function ClipboardAction(options) {\x0a        _classCallCheck(this, ClipboardAction);\x0a\x0a        this.resolveOptions(options);\x0a        this.initSelection();\x0a    }\x0a\x0a    /**\x0a     * Defines base properties passed from constructor.\x0a     * @param {Object} options\x0a     */\x0a\x0a\x0a    _createClass(ClipboardAction, [{\x0a        key: \x27resolveOptions\x27,\x0a        value: function resolveOptions() {\x0a            var options = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a\x0a            this.action = options.action;\x0a            this.container = options.container;\x0a            this.emitter = options.emitter;\x0a            this.target = options.target;\x0a            this.text = options.text;\x0a            this.trigger = options.trigger;\x0a\x0a            this.selectedText = \x27\x27;\x0a        }\x0a\x0a        /**\x0a         * Decides which selection strategy is going to be applied based\x0a         * on the existence of `text` and `target` properties.\x0a         */\x0a\x0a    }, {\x0a        key: \x27initSelection\x27,\x0a        value: function initSelection() {\x0a            if (this.text) {\x0a                this.selectFake();\x0a            } else if (this.target) {\x0a                this.selectTarget();\x0a            }\x0a        }\x0a\x0a        /**\x0a         * Creates a fake textarea element, sets its value from `text` property,\x0a         * and makes a selection on it.\x0a         */\x0a\x0a    }, {\x0a        key: \x27selectFake\x27,\x0a        value: function selectFake() {\x0a            var _this = this;\x0a\x0a            var isRTL = document.documentElement.getAttribute(\x27dir\x27) == \x27rtl\x27;\x0a\x0a            this.removeFake();\x0a\x0a            this.fakeHandlerCallback = function () {\x0a                return _this.removeFake();\x0a            };\x0a            this.fakeHandler = this.container.addEventListener(\x27click\x27, this.fakeHandlerCallback) || true;\x0a\x0a            this.fakeElem = document.createElement(\x27textarea\x27);\x0a            // Prevent zooming on iOS\x0a            this.fakeElem.style.fontSize = \x2712pt\x27;\x0a            // Reset box model\x0a            this.fakeElem.style.border = \x270\x27;\x0a            this.fakeElem.style.padding = \x270\x27;\x0a            this.fakeElem.style.margin = \x270\x27;\x0a            // Move element out of screen horizontally\x0a            this.fakeElem.style.position = \x27absolute\x27;\x0a            this.fakeElem.style[isRTL ? \x27right\x27 : \x27left\x27] = \x27-9999px\x27;\x0a            // Move element to the same position vertically\x0a            var yPosition = window.pageYOffset || document.documentElement.scrollTop;\x0a            this.fakeElem.style.top = yPosition + \x27px\x27;\x0a\x0a            this.fakeElem.setAttribute(\x27readonly\x27, \x27\x27);\x0a            this.fakeElem.value = this.text;\x0a\x0a            this.container.appendChild(this.fakeElem);\x0a\x0a            this.selectedText = (0, _select2.default)(this.fakeElem);\x0a            this.copyText();\x0a        }\x0a\x0a        /**\x0a         * Only removes the fake element after another click event, that way\x0a         * a user can hit `Ctrl+C` to copy because selection still exists.\x0a         */\x0a\x0a    }, {\x0a        key: \x27removeFake\x27,\x0a        value: function removeFake() {\x0a            if (this.fakeHandler) {\x0a                this.container.removeEventListener(\x27click\x27, this.fakeHandlerCallback);\x0a                this.fakeHandler = null;\x0a                this.fakeHandlerCallback = null;\x0a            }\x0a\x0a            if (this.fakeElem) {\x0a                this.container.removeChild(this.fakeElem);\x0a                this.fakeElem = null;\x0a            }\x0a        }\x0a\x0a        /**\x0a         * Selects the content from element passed on `target` property.\x0a         */\x0a\x0a    }, {\x0a        key: \x27selectTarget\x27,\x0a        value: function selectTarget() {\x0a            this.selectedText = (0, _select2.default)(this.target);\x0a            this.copyText();\x0a        }\x0a\x0a        /**\x0a         * Executes the copy operation based on the current selection.\x0a         */\x0a\x0a    }, {\x0a        key: \x27copyText\x27,\x0a        value: function copyText() {\x0a            var succeeded = void 0;\x0a\x0a            try {\x0a                succeeded = document.execCommand(this.action);\x0a            } catch (err) {\x0a                succeeded = false;\x0a            }\x0a\x0a            this.handleResult(succeeded);\x0a        }\x0a\x0a        /**\x0a         * Fires an event based on the copy operation result.\x0a         * @param {Boolean} succeeded\x0a         */\x0a\x0a    }, {\x0a        key: \x27handleResult\x27,\x0a        value: function handleResult(succeeded) {\x0a            this.emitter.emit(succeeded ? \x27success\x27 : \x27error\x27, {\x0a                action: this.action,\x0a                text: this.selectedText,\x0a                trigger: this.trigger,\x0a                clearSelection: this.clearSelection.bind(this)\x0a            });\x0a        }\x0a\x0a        /**\x0a         * Moves focus away from `target` and back to the trigger, removes current selection.\x0a         */\x0a\x0a    }, {\x0a        key: \x27clearSelection\x27,\x0a        value: function clearSelection() {\x0a            if (this.trigger) {\x0a                this.trigger.focus();\x0a            }\x0a\x0a            window.getSelection().removeAllRanges();\x0a        }\x0a\x0a        /**\x0a         * Sets the `action` to be performed which can be either \x27copy\x27 or \x27cut\x27.\x0a         * @param {String} action\x0a         */\x0a\x0a    }, {\x0a        key: \x27destroy\x27,\x0a\x0a\x0a        /**\x0a         * Destroy lifecycle.\x0a         */\x0a        value: function destroy() {\x0a            this.removeFake();\x0a        }\x0a    }, {\x0a        key: \x27action\x27,\x0a        set: function set() {\x0a            var action = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : \x27copy\x27;\x0a\x0a            this._action = action;\x0a\x0a            if (this._action !== \x27copy\x27 && this._action !== \x27cut\x27) {\x0a                throw new Error(\x27Invalid \x22action\x22 value, use either \x22copy\x22 or \x22cut\x22\x27);\x0a            }\x0a        }\x0a\x0a        /**\x0a         * Gets the `action` property.\x0a         * @return {String}\x0a         */\x0a        ,\x0a        get: function get() {\x0a            return this._action;\x0a        }\x0a\x0a        /**\x0a         * Sets the `target` property using an element\x0a         * that will be have its content copied.\x0a         * @param {Element} target\x0a         */\x0a\x0a    }, {\x0a        key: \x27target\x27,\x0a        set: function set(target) {\x0a            if (target !== undefined) {\x0a                if (target && (typeof target === \x27undefined\x27 ? \x27undefined\x27 : _typeof(target)) === \x27object\x27 && target.nodeType === 1) {\x0a                    if (this.action === \x27copy\x27 && target.hasAttribute(\x27disabled\x27)) {\x0a                        throw new Error(\x27Invalid \x22target\x22 attribute. Please use \x22readonly\x22 instead of \x22disabled\x22 attribute\x27);\x0a                    }\x0a\x0a                    if (this.action === \x27cut\x27 && (target.hasAttribute(\x27readonly\x27) || target.hasAttribute(\x27disabled\x27))) {\x0a                        throw new Error(\x27Invalid \x22target\x22 attribute. You can\x5c\x27t cut text from elements with \x22readonly\x22 or \x22disabled\x22 attributes\x27);\x0a                    }\x0a\x0a                    this._target = target;\x0a                } else {\x0a                    throw new Error(\x27Invalid \x22target\x22 value, use a valid Element\x27);\x0a                }\x0a            }\x0a        }\x0a\x0a        /**\x0a         * Gets the `target` property.\x0a         * @return {String|HTMLElement}\x0a         */\x0a        ,\x0a        get: function get() {\x0a            return this._target;\x0a        }\x0a    }]);\x0a\x0a    return ClipboardAction;\x0a}();\x0a\x0amodule.exports = ClipboardAction;\x0a\x0a/***/ }),\x0a/* 2 */\x0a/***/ (function(module, exports) {\x0a\x0afunction select(element) {\x0a    var selectedText;\x0a\x0a    if (element.nodeName === \x27SELECT\x27) {\x0a        element.focus();\x0a\x0a        selectedText = element.value;\x0a    }\x0a    else if (element.nodeName === \x27INPUT\x27 || element.nodeName === \x27TEXTAREA\x27) {\x0a        var isReadOnly = element.hasAttribute(\x27readonly\x27);\x0a\x0a        if (!isReadOnly) {\x0a            element.setAttribute(\x27readonly\x27, \x27\x27);\x0a        }\x0a\x0a        element.select();\x0a        element.setSelectionRange(0, element.value.length);\x0a\x0a        if (!isReadOnly) {\x0a            element.removeAttribute(\x27readonly\x27);\x0a        }\x0a\x0a        selectedText = element.value;\x0a    }\x0a    else {\x0a        if (element.hasAttribute(\x27contenteditable\x27)) {\x0a            element.focus();\x0a        }\x0a\x0a        var selection = window.getSelection();\x0a        var range = document.createRange();\x0a\x0a        range.selectNodeContents(element);\x0a        selection.removeAllRanges();\x0a        selection.addRange(range);\x0a\x0a        selectedText = selection.toString();\x0a    }\x0a\x0a    return selectedText;\x0a}\x0a\x0amodule.exports = select;\x0a\x0a\x0a/***/ }),\x0a/* 3 */\x0a/***/ (function(module, exports) {\x0a\x0afunction E () {\x0a  // Keep this empty so it\x27s easier to inherit from\x0a  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\x0a}\x0a\x0aE.prototype = {\x0a  on: function (name, callback, ctx) {\x0a    var e = this.e || (this.e = {});\x0a\x0a    (e[name] || (e[name] = [])).push({\x0a      fn: callback,\x0a      ctx: ctx\x0a    });\x0a\x0a    return this;\x0a  },\x0a\x0a  once: function (name, callback, ctx) {\x0a    var self = this;\x0a    function listener () {\x0a      self.off(name, listener);\x0a      callback.apply(ctx, arguments);\x0a    };\x0a\x0a    listener._ = callback\x0a    return this.on(name, listener, ctx);\x0a  },\x0a\x0a  emit: function (name) {\x0a    var data = [].slice.call(arguments, 1);\x0a    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\x0a    var i = 0;\x0a    var len = evtArr.length;\x0a\x0a    for (i; i \x3c len; i++) {\x0a      evtArr[i].fn.apply(evtArr[i].ctx, data);\x0a    }\x0a\x0a    return this;\x0a  },\x0a\x0a  off: function (name, callback) {\x0a    var e = this.e || (this.e = {});\x0a    var evts = e[name];\x0a    var liveEvents = [];\x0a\x0a    if (evts && callback) {\x0a      for (var i = 0, len = evts.length; i \x3c len; i++) {\x0a        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\x0a          liveEvents.push(evts[i]);\x0a      }\x0a    }\x0a\x0a    // Remove event from queue to prevent memory leak\x0a    // Suggested by https://github.com/lazd\x0a    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\x0a\x0a    (liveEvents.length)\x0a      ? e[name] = liveEvents\x0a      : delete e[name];\x0a\x0a    return this;\x0a  }\x0a};\x0a\x0amodule.exports = E;\x0a\x0a\x0a/***/ }),\x0a/* 4 */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar is = __webpack_require__(5);\x0avar delegate = __webpack_require__(6);\x0a\x0a/**\x0a * Validates all params and calls the right\x0a * listener function based on its target type.\x0a *\x0a * @param {String|HTMLElement|HTMLCollection|NodeList} target\x0a * @param {String} type\x0a * @param {Function} callback\x0a * @return {Object}\x0a */\x0afunction listen(target, type, callback) {\x0a    if (!target && !type && !callback) {\x0a        throw new Error(\x27Missing required arguments\x27);\x0a    }\x0a\x0a    if (!is.string(type)) {\x0a        throw new TypeError(\x27Second argument must be a String\x27);\x0a    }\x0a\x0a    if (!is.fn(callback)) {\x0a        throw new TypeError(\x27Third argument must be a Function\x27);\x0a    }\x0a\x0a    if (is.node(target)) {\x0a        return listenNode(target, type, callback);\x0a    }\x0a    else if (is.nodeList(target)) {\x0a        return listenNodeList(target, type, callback);\x0a    }\x0a    else if (is.string(target)) {\x0a        return listenSelector(target, type, callback);\x0a    }\x0a    else {\x0a        throw new TypeError(\x27First argument must be a String, HTMLElement, HTMLCollection, or NodeList\x27);\x0a    }\x0a}\x0a\x0a/**\x0a * Adds an event listener to a HTML element\x0a * and returns a remove listener function.\x0a *\x0a * @param {HTMLElement} node\x0a * @param {String} type\x0a * @param {Function} callback\x0a * @return {Object}\x0a */\x0afunction listenNode(node, type, callback) {\x0a    node.addEventListener(type, callback);\x0a\x0a    return {\x0a        destroy: function() {\x0a            node.removeEventListener(type, callback);\x0a        }\x0a    }\x0a}\x0a\x0a/**\x0a * Add an event listener to a list of HTML elements\x0a * and returns a remove listener function.\x0a *\x0a * @param {NodeList|HTMLCollection} nodeList\x0a * @param {String} type\x0a * @param {Function} callback\x0a * @return {Object}\x0a */\x0afunction listenNodeList(nodeList, type, callback) {\x0a    Array.prototype.forEach.call(nodeList, function(node) {\x0a        node.addEventListener(type, callback);\x0a    });\x0a\x0a    return {\x0a        destroy: function() {\x0a            Array.prototype.forEach.call(nodeList, function(node) {\x0a                node.removeEventListener(type, callback);\x0a            });\x0a        }\x0a    }\x0a}\x0a\x0a/**\x0a * Add an event listener to a selector\x0a * and returns a remove listener function.\x0a *\x0a * @param {String} selector\x0a * @param {String} type\x0a * @param {Function} callback\x0a * @return {Object}\x0a */\x0afunction listenSelector(selector, type, callback) {\x0a    return delegate(document.body, selector, type, callback);\x0a}\x0a\x0amodule.exports = listen;\x0a\x0a\x0a/***/ }),\x0a/* 5 */\x0a/***/ (function(module, exports) {\x0a\x0a/**\x0a * Check if argument is a HTML element.\x0a *\x0a * @param {Object} value\x0a * @return {Boolean}\x0a */\x0aexports.node = function(value) {\x0a    return value !== undefined\x0a        && value instanceof HTMLElement\x0a        && value.nodeType === 1;\x0a};\x0a\x0a/**\x0a * Check if argument is a list of HTML elements.\x0a *\x0a * @param {Object} value\x0a * @return {Boolean}\x0a */\x0aexports.nodeList = function(value) {\x0a    var type = Object.prototype.toString.call(value);\x0a\x0a    return value !== undefined\x0a        && (type === \x27[object NodeList]\x27 || type === \x27[object HTMLCollection]\x27)\x0a        && (\x27length\x27 in value)\x0a        && (value.length === 0 || exports.node(value[0]));\x0a};\x0a\x0a/**\x0a * Check if argument is a string.\x0a *\x0a * @param {Object} value\x0a * @return {Boolean}\x0a */\x0aexports.string = function(value) {\x0a    return typeof value === \x27string\x27\x0a        || value instanceof String;\x0a};\x0a\x0a/**\x0a * Check if argument is a function.\x0a *\x0a * @param {Object} value\x0a * @return {Boolean}\x0a */\x0aexports.fn = function(value) {\x0a    var type = Object.prototype.toString.call(value);\x0a\x0a    return type === \x27[object Function]\x27;\x0a};\x0a\x0a\x0a/***/ }),\x0a/* 6 */\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar closest = __webpack_require__(7);\x0a\x0a/**\x0a * Delegates event to a selector.\x0a *\x0a * @param {Element} element\x0a * @param {String} selector\x0a * @param {String} type\x0a * @param {Function} callback\x0a * @param {Boolean} useCapture\x0a * @return {Object}\x0a */\x0afunction _delegate(element, selector, type, callback, useCapture) {\x0a    var listenerFn = listener.apply(this, arguments);\x0a\x0a    element.addEventListener(type, listenerFn, useCapture);\x0a\x0a    return {\x0a        destroy: function() {\x0a            element.removeEventListener(type, listenerFn, useCapture);\x0a        }\x0a    }\x0a}\x0a\x0a/**\x0a * Delegates event to a selector.\x0a *\x0a * @param {Element|String|Array} [elements]\x0a * @param {String} selector\x0a * @param {String} type\x0a * @param {Function} callback\x0a * @param {Boolean} useCapture\x0a * @return {Object}\x0a */\x0afunction delegate(elements, selector, type, callback, useCapture) {\x0a    // Handle the regular Element usage\x0a    if (typeof elements.addEventListener === \x27function\x27) {\x0a        return _delegate.apply(null, arguments);\x0a    }\x0a\x0a    // Handle Element-less usage, it defaults to global delegation\x0a    if (typeof type === \x27function\x27) {\x0a        // Use `document` as the first parameter, then apply arguments\x0a        // This is a short way to .unshift `arguments` without running into deoptimizations\x0a        return _delegate.bind(null, document).apply(null, arguments);\x0a    }\x0a\x0a    // Handle Selector-based usage\x0a    if (typeof elements === \x27string\x27) {\x0a        elements = document.querySelectorAll(elements);\x0a    }\x0a\x0a    // Handle Array-like based usage\x0a    return Array.prototype.map.call(elements, function (element) {\x0a        return _delegate(element, selector, type, callback, useCapture);\x0a    });\x0a}\x0a\x0a/**\x0a * Finds closest match and invokes callback.\x0a *\x0a * @param {Element} element\x0a * @param {String} selector\x0a * @param {String} type\x0a * @param {Function} callback\x0a * @return {Function}\x0a */\x0afunction listener(element, selector, type, callback) {\x0a    return function(e) {\x0a        e.delegateTarget = closest(e.target, selector);\x0a\x0a        if (e.delegateTarget) {\x0a            callback.call(element, e);\x0a        }\x0a    }\x0a}\x0a\x0amodule.exports = delegate;\x0a\x0a\x0a/***/ }),\x0a/* 7 */\x0a/***/ (function(module, exports) {\x0a\x0avar DOCUMENT_NODE_TYPE = 9;\x0a\x0a/**\x0a * A polyfill for Element.matches()\x0a */\x0aif (typeof Element !== \x27undefined\x27 && !Element.prototype.matches) {\x0a    var proto = Element.prototype;\x0a\x0a    proto.matches = proto.matchesSelector ||\x0a                    proto.mozMatchesSelector ||\x0a                    proto.msMatchesSelector ||\x0a                    proto.oMatchesSelector ||\x0a                    proto.webkitMatchesSelector;\x0a}\x0a\x0a/**\x0a * Finds the closest parent that matches a selector.\x0a *\x0a * @param {Element} element\x0a * @param {String} selector\x0a * @return {Function}\x0a */\x0afunction closest (element, selector) {\x0a    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {\x0a        if (typeof element.matches === \x27function\x27 &&\x0a            element.matches(selector)) {\x0a          return element;\x0a        }\x0a        element = element.parentNode;\x0a    }\x0a}\x0a\x0amodule.exports = closest;\x0a\x0a\x0a/***/ })\x0a/******/ ]);\x0a});\x03'}