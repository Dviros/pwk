var res = {'data':'HTTP/1.1 200 OK\x0aDate: Sun, 20 Sep 2020 15:05:14 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 21 Mar 2019 12:48:00 GMT\x0aETag: \x22c0bbb-5849a25f20000-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aKeep-Alive: timeout=5, max=30\x0aConnection: Keep-Alive\x0aTransfer-Encoding: chunked\x0aContent-Type: application/javascript\x0a\x0a/** @license React v16.8.4\x0a * react-dom.development.js\x0a *\x0a * Copyright (c) Facebook, Inc. and its affiliates.\x0a *\x0a * This source code is licensed under the MIT license found in the\x0a * LICENSE file in the root directory of this source tree.\x0a */\x0a\x0a\x27use strict\x27;\x0a\x0a(function (global, factory) {\x0a\x09typeof exports === \x27object\x27 && typeof module !== \x27undefined\x27 ? module.exports = factory(require(\x27react\x27)) :\x0a\x09typeof define === \x27function\x27 && define.amd ? define([\x27react\x27], factory) :\x0a\x09(global.ReactDOM = factory(global.React));\x0a}(this, (function (React) { \x27use strict\x27;\x0a\x0a/**\x0a * Use invariant() to assert state which your program assumes to be true.\x0a *\x0a * Provide sprintf-style format (only %s is supported) and arguments\x0a * to provide information about what broke and what you were\x0a * expecting.\x0a *\x0a * The invariant message will be stripped in production, but the invariant\x0a * will remain to ensure logic does not differ in production.\x0a */\x0a\x0avar validateFormat = function () {};\x0a\x0a{\x0a  validateFormat = function (format) {\x0a    if (format === undefined) {\x0a      throw new Error(\x27invariant requires an error message argument\x27);\x0a    }\x0a  };\x0a}\x0a\x0afunction invariant(condition, format, a, b, c, d, e, f) {\x0a  validateFormat(format);\x0a\x0a  if (!condition) {\x0a    var error = void 0;\x0a    if (format === undefined) {\x0a      error = new Error(\x27Minified exception occurred; use the non-minified dev environment \x27 + \x27for the full error message and additional helpful warnings.\x27);\x0a    } else {\x0a      var args = [a, b, c, d, e, f];\x0a      var argIndex = 0;\x0a      error = new Error(format.replace(/%s/g, function () {\x0a        return args[argIndex++];\x0a      }));\x0a      error.name = \x27Invariant Violation\x27;\x0a    }\x0a\x0a    error.framesToPop = 1; // we don\x27t care about invariant\x27s own frame\x0a    throw error;\x0a  }\x0a}\x0a\x0a// Relying on the `invariant()` implementation lets us\x0a// preserve the format and params in the www builds.\x0a\x0a!React ? invariant(false, \x27ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.\x27) : void 0;\x0a\x0avar invokeGuardedCallbackImpl = function (name, func, context, a, b, c, d, e, f) {\x0a  var funcArgs = Array.prototype.slice.call(arguments, 3);\x0a  try {\x0a    func.apply(context, funcArgs);\x0a  } catch (error) {\x0a    this.onError(error);\x0a  }\x0a};\x0a\x0a{\x0a  // In DEV mode, we swap out invokeGuardedCallback for a special version\x0a  // that plays more nicely with the browser\x27s DevTools. The idea is to preserve\x0a  // \x22Pause on exceptions\x22 behavior. Because React wraps all user-provided\x0a  // functions in invokeGuardedCallback, and the production version of\x0a  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\x0a  // like caught exceptions, and the DevTools won\x27t pause unless the developer\x0a  // takes the extra step of enabling pause on caught exceptions. This is\x0a  // unintuitive, though, because even though React has caught the error, from\x0a  // the developer\x27s perspective, the error is uncaught.\x0a  //\x0a  // To preserve the expected \x22Pause on exceptions\x22 behavior, we don\x27t use a\x0a  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\x0a  // DOM node, and call the user-provided callback from inside an event handler\x0a  // for that fake event. If the callback throws, the error is \x22captured\x22 using\x0a  // a global event handler. But because the error happens in a different\x0a  // event loop context, it does not interrupt the normal program flow.\x0a  // Effectively, this gives us try-catch behavior without actually using\x0a  // try-catch. Neat!\x0a\x0a  // Check that the browser supports the APIs we need to implement our special\x0a  // DEV version of invokeGuardedCallback\x0a  if (typeof window !== \x27undefined\x27 && typeof window.dispatchEvent === \x27function\x27 && typeof document !== \x27undefined\x27 && typeof document.createEvent === \x27function\x27) {\x0a    var fakeNode = document.createElement(\x27react\x27);\x0a\x0a    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\x0a      // If document doesn\x27t exist we know for sure we will crash in this method\x0a      // when we call document.createEvent(). However this can cause confusing\x0a      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\x0a      // So we preemptively throw with a better message instead.\x0a      !(typeof document !== \x27undefined\x27) ? invariant(false, \x27The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.\x27) : void 0;\x0a      var evt = document.createEvent(\x27Event\x27);\x0a\x0a      // Keeps track of whether the user-provided callback threw an error. We\x0a      // set this to true at the beginning, then set it to false right after\x0a      // calling the function. If the function errors, `didError` will never be\x0a      // set to false. This strategy works even if the browser is flaky and\x0a      // fails to call our global error handler, because it doesn\x27t rely on\x0a      // the error event at all.\x0a      var didError = true;\x0a\x0a      // Keeps track of the value of window.event so that we can reset it\x0a      // during the callback to let user code access window.event in the\x0a      // browsers that support it.\x0a      var windowEvent = window.event;\x0a\x0a      // Keeps track of the descriptor of window.event to restore it after event\x0a      // dispatching: https://github.com/facebook/react/issues/13688\x0a      var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, \x27event\x27);\x0a\x0a      // Create an event handler for our fake event. We will synchronously\x0a      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\x0a      // call the user-provided callback.\x0a      var funcArgs = Array.prototype.slice.call(arguments, 3);\x0a      function callCallback() {\x0a        // We immediately remove the callback from event listeners so that\x0a        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\x0a        // nested call would trigger the fake event handlers of any call higher\x0a        // in the stack.\x0a        fakeNode.removeEventListener(evtType, callCallback, false);\x0a\x0a        // We check for window.hasOwnProperty(\x27event\x27) to prevent the\x0a        // window.event assignment in both IE \x3c= 10 as they throw an error\x0a        // \x22Member not found\x22 in strict mode, and in Firefox which does not\x0a        // support window.event.\x0a        if (typeof window.event !== \x27undefined\x27 && window.hasOwnProperty(\x27event\x27)) {\x0a          window.event = windowEvent;\x0a        }\x0a\x0a        func.apply(context, funcArgs);\x0a        didError = false;\x0a      }\x0a\x0a      // Create a global error event handler. We use this to capture the value\x0a      // that was thrown. It\x27s possible that this error handler will fire more\x0a      // than once; for example, if non-React code also calls `dispatchEvent`\x0a      // and a handler for that event throws. We should be resilient to most of\x0a      // those cases. Even if our error event handler fires more than once, the\x0a      // last error event is always used. If the callback actually does error,\x0a      // we know that the last error event is the correct one, because it\x27s not\x0a      // possible for anything else to have happened in between our callback\x0a      // erroring and the code that follows the `dispatchEvent` call below. If\x0a      // the callback doesn\x27t error, but the error event was fired, we know to\x0a      // ignore it because `didError` will be false, as described above.\x0a      var error = void 0;\x0a      // Use this to track whether the error event is ever called.\x0a      var didSetError = false;\x0a      var isCrossOriginError = false;\x0a\x0a      function handleWindowError(event) {\x0a        error = event.error;\x0a        didSetError = true;\x0a        if (error === null && event.colno === 0 && event.lineno === 0) {\x0a          isCrossOriginError = true;\x0a        }\x0a        if (event.defaultPrevented) {\x0a          // Some other error handler has prevented default.\x0a          // Browsers silence the error report if this happens.\x0a          // We\x27ll remember this to later decide whether to log it or not.\x0a          if (error != null && typeof error === \x27object\x27) {\x0a            try {\x0a              error._suppressLogging = true;\x0a            } catch (inner) {\x0a              // Ignore.\x0a            }\x0a          }\x0a        }\x0a      }\x0a\x0a      // Create a fake event type.\x0a      var evtType = \x27react-\x27 + (name ? name : \x27invokeguardedcallback\x27);\x0a\x0a      // Attach our event handlers\x0a      window.addEventListener(\x27error\x27, handleWindowError);\x0a      fakeNode.addEventListener(evtType, callCallback, false);\x0a\x0a      // Synchronously dispatch our fake event. If the user-provided function\x0a      // errors, it will trigger our global error handler.\x0a      evt.initEvent(evtType, false, false);\x0a      fakeNode.dispatchEvent(evt);\x0a\x0a      if (windowEventDescriptor) {\x0a        Object.defineProperty(window, \x27event\x27, windowEventDescriptor);\x0a      }\x0a\x0a      if (didError) {\x0a        if (!didSetError) {\x0a          // The callback errored, but the error event never fired.\x0a          error = new Error(\x27An error was thrown inside one of your components, but React \x27 + \x22doesn\x27t know what it was. This is likely due to browser \x22 + \x27flakiness. React does its best to preserve the \x22Pause on \x27 + \x27exceptions\x22 behavior of the DevTools, which requires some \x27 + \x22DEV-mode only tricks. It\x27s possible that these don\x27t work in \x22 + \x27your browser. Try triggering the error in production mode, \x27 + \x27or switching to a modern browser. If you suspect that this is \x27 + \x27actually an issue with React, please file an issue.\x27);\x0a        } else if (isCrossOriginError) {\x0a          error = new Error(\x22A cross-origin error was thrown. React doesn\x27t have access to \x22 + \x27the actual error object in development. \x27 + \x27See https://fb.me/react-crossorigin-error for more information.\x27);\x0a        }\x0a        this.onError(error);\x0a      }\x0a\x0a      // Remove our event listeners\x0a      window.removeEventListener(\x27error\x27, handleWindowError);\x0a    };\x0a\x0a    invokeGuardedCallbackImpl = invokeGuardedCallbackDev;\x0a  }\x0a}\x0a\x0avar invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\x0a\x0a// Used by Fiber to simulate a try-catch.\x0avar hasError = false;\x0avar caughtError = null;\x0a\x0a// Used by event system to capture/rethrow the first error.\x0avar hasRethrowError = false;\x0avar rethrowError = null;\x0a\x0avar reporter = {\x0a  onError: function (error) {\x0a    hasError = true;\x0a    caughtError = error;\x0a  }\x0a};\x0a\x0a/**\x0a * Call a function while guarding against errors that happens within it.\x0a * Returns an error if it throws, otherwise null.\x0a *\x0a * In production, this is implemented using a try-catch. The reason we don\x27t\x0a * use a try-catch directly is so that we can swap out a different\x0a * implementation in DEV mode.\x0a *\x0a * @param {String} name of the guard to use for logging or debugging\x0a * @param {Function} func The function to invoke\x0a * @param {*} context The context to use when calling the function\x0a * @param {...*} args Arguments for function\x0a */\x0afunction invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\x0a  hasError = false;\x0a  caughtError = null;\x0a  invokeGuardedCallbackImpl$1.apply(reporter, arguments);\x0a}\x0a\x0a/**\x0a * Same as invokeGuardedCallback, but instead of returning an error, it stores\x0a * it in a global so it can be rethrown by `rethrowCaughtError` later.\x0a * TODO: See if caughtError and rethrowError can be unified.\x0a *\x0a * @param {String} name of the guard to use for logging or debugging\x0a * @param {Function} func The function to invoke\x0a * @param {*} context The context to use when calling the function\x0a * @param {...*} args Arguments for function\x0a */\x0afunction invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {\x0a  invokeGuardedCallback.apply(this, arguments);\x0a  if (hasError) {\x0a    var error = clearCaughtError();\x0a    if (!hasRethrowError) {\x0a      hasRethrowError = true;\x0a      rethrowError = error;\x0a    }\x0a  }\x0a}\x0a\x0a/**\x0a * During execution of guarded functions we will capture the first error which\x0a * we will rethrow to be handled by the top level error handler.\x0a */\x0afunction rethrowCaughtError() {\x0a  if (hasRethrowError) {\x0a    var error = rethrowError;\x0a    hasRethrowError = false;\x0a    rethrowError = null;\x0a    throw error;\x0a  }\x0a}\x0a\x0afunction hasCaughtError() {\x0a  return hasError;\x0a}\x0a\x0afunction clearCaughtError() {\x0a  if (hasError) {\x0a    var error = caughtError;\x0a    hasError = false;\x0a    caughtError = null;\x0a    return error;\x0a  } else {\x0a    invariant(false, \x27clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.\x27);\x0a  }\x0a}\x0a\x0a/**\x0a * Injectable ordering of event plugins.\x0a */\x0avar eventPluginOrder = null;\x0a\x0a/**\x0a * Injectable mapping from names to event plugin modules.\x0a */\x0avar namesToPlugins = {};\x0a\x0a/**\x0a * Recomputes the plugin list using the injected plugins and plugin ordering.\x0a *\x0a * @private\x0a */\x0afunction recomputePluginOrdering() {\x0a  if (!eventPluginOrder) {\x0a    // Wait until an `eventPluginOrder` is injected.\x0a    return;\x0a  }\x0a  for (var pluginName in namesToPlugins) {\x0a    var pluginModule = namesToPlugins[pluginName];\x0a    var pluginIndex = eventPluginOrder.indexOf(pluginName);\x0a    !(pluginIndex \x3e -1) ? invariant(false, \x27EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.\x27, pluginName) : void 0;\x0a    if (plugins[pluginIndex]) {\x0a      continue;\x0a    }\x0a    !pluginModule.extractEvents ? invariant(false, \x27EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.\x27, pluginName) : void 0;\x0a    plugins[pluginIndex] = pluginModule;\x0a    var publishedEvents = pluginModule.eventTypes;\x0a    for (var eventName in publishedEvents) {\x0a      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, \x27EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.\x27, eventName, pluginName) : void 0;\x0a    }\x0a  }\x0a}\x0a\x0a/**\x0a * Publishes an event so that it can be dispatched by the supplied plugin.\x0a *\x0a * @param {object} dispatchConfig Dispatch configuration for the event.\x0a * @param {object} PluginModule Plugin publishing the event.\x0a * @return {boolean} True if the event was successfully published.\x0a * @private\x0a */\x0afunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\x0a  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, \x27EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.\x27, eventName) : void 0;\x0a  eventNameDispatchConfigs[eventName] = dispatchConfig;\x0a\x0a  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\x0a  if (phasedRegistrationNames) {\x0a    for (var phaseName in phasedRegistrationNames) {\x0a      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\x0a        var phasedRegistrationName = phasedRegistrationNames[phaseName];\x0a        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\x0a      }\x0a    }\x0a    return true;\x0a  } else if (dispatchConfig.registrationName) {\x0a    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\x0a    return true;\x0a  }\x0a  return false;\x0a}\x0a\x0a/**\x0a * Publishes a registration name that is used to identify dispatched events.\x0a *\x0a * @param {string} registrationName Registration name to add.\x0a * @param {object} PluginModule Plugin publishing the event.\x0a * @private\x0a */\x0afunction publishRegistrationName(registrationName, pluginModule, eventName) {\x0a  !!registrationNameModules[registrationName] ? invariant(false, \x27EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.\x27, registrationName) : void 0;\x0a  registrationNameModules[registrationName] = pluginModule;\x0a  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\x0a\x0a  {\x0a    var lowerCasedName = registrationName.toLowerCase();\x0a    possibleRegistrationNames[lowerCasedName] = registrationName;\x0a\x0a    if (registrationName === \x27onDoubleClick\x27) {\x0a      possibleRegistrationNames.ondblclick = registrationName;\x0a    }\x0a  }\x0a}\x0a\x0a/**\x0a * Registers plugins so that they can extract and dispatch events.\x0a *\x0a * @see {EventPluginHub}\x0a */\x0a\x0a/**\x0a * Ordered list of injected plugins.\x0a */\x0avar plugins = [];\x0a\x0a/**\x0a * Mapping from event name to dispatch config\x0a */\x0avar eventNameDispatchConfigs = {};\x0a\x0a/**\x0a * Mapping from registration name to plugin module\x0a */\x0avar registrationNameModules = {};\x0a\x0a/**\x0a * Mapping from registration name to event name\x0a */\x0avar registrationNameDependencies = {};\x0a\x0a/**\x0a * Mapping from lowercase registration names to the properly cased version,\x0a * used to warn in the case of missing event handlers. Available\x0a * only in true.\x0a * @type {Object}\x0a */\x0avar possibleRegistrationNames = {};\x0a// Trust the developer to only use possibleRegistrationNames in true\x0a\x0a/**\x0a * Injects an ordering of plugins (by plugin name). This allows the ordering\x0a * to be decoupled from injection of the actual plugins so that ordering is\x0a * always deterministic regardless of packaging, on-the-fly injection, etc.\x0a *\x0a * @param {array} InjectedEventPluginOrder\x0a * @internal\x0a * @see {EventPluginHub.injection.injectEventPluginOrder}\x0a */\x0afunction injectEventPluginOrder(injectedEventPluginOrder) {\x0a  !!eventPluginOrder ? invariant(false, \x27EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.\x27) : void 0;\x0a  // Clone the ordering so it cannot be dynamically mutated.\x0a  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\x0a  recomputePluginOrdering();\x0a}\x0a\x0a/**\x0a * Injects plugins to be used by `EventPluginHub`. The plugin names must be\x0a * in the ordering injected by `injectEventPluginOrder`.\x0a *\x0a * Plugins can be injected as part of page initialization or on-the-fly.\x0a *\x0a * @param {object} injectedNamesToPlugins Map from names to plugin modules.\x0a * @internal\x0a * @see {EventPluginHub.injection.injectEventPluginsByName}\x0a */\x0afunction injectEventPluginsByName(injectedNamesToPlugins) {\x0a  var isOrderingDirty = false;\x0a  for (var pluginName in injectedNamesToPlugins) {\x0a    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\x0a      continue;\x0a    }\x0a    var pluginModule = injectedNamesToPlugins[pluginName];\x0a    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\x0a      !!namesToPlugins[pluginName] ? invariant(false, \x27EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.\x27, pluginName) : void 0;\x0a      namesToPlugins[pluginName] = pluginModule;\x0a      isOrderingDirty = true;\x0a    }\x0a  }\x0a  if (isOrderingDirty) {\x0a    recomputePluginOrdering();\x0a  }\x0a}\x0a\x0a/**\x0a * Similar to invariant but only logs a warning if the condition is not met.\x0a * This can be used to log issues in development environments in critical\x0a * paths. Removing the logging code for production environments will keep the\x0a * same logic and follow the same code paths.\x0a */\x0a\x0avar warningWithoutStack = function () {};\x0a\x0a{\x0a  warningWithoutStack = function (condition, format) {\x0a    for (var _len = arguments.length, args = Array(_len \x3e 2 ? _len - 2 : 0), _key = 2; _key \x3c _len; _key++) {\x0a      args[_key - 2] = arguments[_key];\x0a    }\x0a\x0a    if (format === undefined) {\x0a      throw new Error(\x27`warningWithoutStack(condition, format, ...args)` requires a warning \x27 + \x27message argument\x27);\x0a    }\x0a    if (args.length \x3e 8) {\x0a      // Check before the condition to catch violations early.\x0a      throw new Error(\x27warningWithoutStack() currently supports at most 8 arguments.\x27);\x0a    }\x0a    if (condition) {\x0a      return;\x0a    }\x0a    if (typeof console !== \x27undefined\x27) {\x0a      var argsWithFormat = args.map(function (item) {\x0a        return \x27\x27 + item;\x0a      });\x0a      argsWithFormat.unshift(\x27Warning: \x27 + format);\x0a\x0a      // We intentionally don\x27t use spread (or .apply) directly because it\x0a      // breaks IE9: https://github.com/facebook/react/issues/13610\x0a      Function.prototype.apply.call(console.error, console, argsWithFormat);\x0a    }\x0a    try {\x0a      // --- Welcome to debugging React ---\x0a      // This error was thrown as a convenience so that you can use this stack\x0a      // to find the callsite that caused this warning to fire.\x0a      var argIndex = 0;\x0a      var message = \x27Warning: \x27 + format.replace(/%s/g, function () {\x0a        return args[argIndex++];\x0a      });\x0a      throw new Error(message);\x0a    } catch (x) {}\x0a  };\x0a}\x0a\x0avar warningWithoutStack$1 = warningWithoutStack;\x0a\x0avar getFiberCurrentPropsFromNode = null;\x0avar getInstanceFromNode = null;\x0avar getNodeFromInstance = null;\x0a\x0afunction setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\x0a  getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\x0a  getInstanceFromNode = getInstanceFromNodeImpl;\x0a  getNodeFromInstance = getNodeFromInstanceImpl;\x0a  {\x0a    !(getNodeFromInstance && getInstanceFromNode) ? warningWithoutStack$1(false, \x27EventPluginUtils.setComponentTree(...): Injected \x27 + \x27module is missing getNodeFromInstance or getInstanceFromNode.\x27) : void 0;\x0a  }\x0a}\x0a\x0avar validateEventDispatches = void 0;\x0a{\x0a  validateEventDispatches = function (event) {\x0a    var dispatchListeners = event._dispatchListeners;\x0a    var dispatchInstances = event._dispatchInstances;\x0a\x0a    var listenersIsArr = Array.isArray(dispatchListeners);\x0a    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\x0a\x0a    var instancesIsArr = Array.isArray(dispatchInstances);\x0a    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\x0a\x0a    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, \x27EventPluginUtils: Invalid `event`.\x27) : void 0;\x0a  };\x0a}\x0a\x0a/**\x0a * Dispatch the event to the listener.\x0a * @param {SyntheticEvent} event SyntheticEvent to handle\x0a * @param {function} listener Application-level callback\x0a * @param {*} inst Internal component instance\x0a */\x0afunction executeDispatch(event, listener, inst) {\x0a  var type = event.type || \x27unknown-event\x27;\x0a  event.currentTarget = getNodeFromInstance(inst);\x0a  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\x0a  event.currentTarget = null;\x0a}\x0a\x0a/**\x0a * Standard/simple iteration through an event\x27s collected dispatches.\x0a */\x0afunction executeDispatchesInOrder(event) {\x0a  var dispatchListeners = event._dispatchListeners;\x0a  var dispatchInstances = event._dispatchInstances;\x0a  {\x0a    validateEventDispatches(event);\x0a  }\x0a  if (Array.isArray(dispatchListeners)) {\x0a    for (var i = 0; i \x3c dispatchListeners.length; i++) {\x0a      if (event.isPropagationStopped()) {\x0a        break;\x0a      }\x0a      // Listeners and Instances are two parallel arrays that are always in sync.\x0a      executeDispatch(event, dispatchListeners[i], dispatchInstances[i]);\x0a    }\x0a  } else if (dispatchListeners) {\x0a    executeDispatch(event, dispatchListeners, dispatchInstances);\x0a  }\x0a  event._dispatchListeners = null;\x0a  event._dispatchInstances = null;\x0a}\x0a\x0a/**\x0a * @see executeDispatchesInOrderStopAtTrueImpl\x0a */\x0a\x0a\x0a/**\x0a * Execution of a \x22direct\x22 dispatch - there must be at most one dispatch\x0a * accumulated on the event or it is considered an error. It doesn\x27t really make\x0a * sense for an event with multiple dispatches (bubbled) to keep track of the\x0a * return values at each dispatch execution, but it does tend to make sense when\x0a * dealing with \x22direct\x22 dispatches.\x0a *\x0a * @return {*} The return value of executing the single dispatch.\x0a */\x0a\x0a\x0a/**\x0a * @param {SyntheticEvent} event\x0a * @return {boolean} True iff number of dispatches accumulated is greater than 0.\x0a */\x0a\x0a/**\x0a * Accumulates items that must not be null or undefined into the first one. This\x0a * is used to conserve memory by avoiding array allocations, and thus sacrifices\x0a * API cleanness. Since `current` can be null before being passed in and not\x0a * null after this function, make sure to assign it back to `current`:\x0a *\x0a * `a = accumulateInto(a, b);`\x0a *\x0a * This API should be sparingly used. Try `accumulate` for something cleaner.\x0a *\x0a * @return {*|array\x3c*\x3e} An accumulation of items.\x0a */\x0a\x0afunction accumulateInto(current, next) {\x0a  !(next != null) ? invariant(false, \x27accumulateInto(...): Accumulated items must not be null or undefined.\x27) : void 0;\x0a\x0a  if (current == null) {\x0a    return next;\x0a  }\x0a\x0a  // Both are not empty. Warning: Never call x.concat(y) when you are not\x0a  // certain that x is an Array (x could be a string with concat method).\x0a  if (Array.isArray(current)) {\x0a    if (Array.isArray(next)) {\x0a      current.push.apply(current, next);\x0a      return current;\x0a    }\x0a    current.push(next);\x0a    return current;\x0a  }\x0a\x0a  if (Array.isArray(next)) {\x0a    // A bit too dangerous to mutate `next`.\x0a    return [current].concat(next);\x0a  }\x0a\x0a  return [current, next];\x0a}\x0a\x0a/**\x0a * @param {array} arr an \x22accumulation\x22 of items which is either an Array or\x0a * a single item. Useful when paired with the `accumulate` module. This is a\x0a * simple utility that allows us to reason about a collection of items, but\x0a * handling the case when there is exactly one item (and we do not need to\x0a * allocate an array).\x0a * @param {function} cb Callback invoked with each element or a collection.\x0a * @param {?} [scope] Scope used as `this` in a callback.\x0a */\x0afunction forEachAccumulated(arr, cb, scope) {\x0a  if (Array.isArray(arr)) {\x0a    arr.forEach(cb, scope);\x0a  } else if (arr) {\x0a    cb.call(scope, arr);\x0a  }\x0a}\x0a\x0a/**\x0a * Internal queue of events that have accumulated their dispatches and are\x0a * waiting to have their dispatches executed.\x0a */\x0avar eventQueue = null;\x0a\x0a/**\x0a * Dispatches an event and releases it back into the pool, unless persistent.\x0a *\x0a * @param {?object} event Synthetic event to be dispatched.\x0a * @private\x0a */\x0avar executeDispatchesAndRelease = function (event) {\x0a  if (event) {\x0a    executeDispatchesInOrder(event);\x0a\x0a    if (!event.isPersistent()) {\x0a      event.constructor.release(event);\x0a    }\x0a  }\x0a};\x0avar executeDispatchesAndReleaseTopLevel = function (e) {\x0a  return executeDispatchesAndRelease(e);\x0a};\x0a\x0afunction isInteractive(tag) {\x0a  return tag === \x27button\x27 || tag === \x27input\x27 || tag === \x27select\x27 || tag === \x27textarea\x27;\x0a}\x0a\x0afunction shouldPreventMouseEvent(name, type, props) {\x0a  switch (name) {\x0a    case \x27onClick\x27:\x0a    case \x27onClickCapture\x27:\x0a    case \x27onDoubleClick\x27:\x0a    case \x27onDoubleClickCapture\x27:\x0a    case \x27onMouseDown\x27:\x0a    case \x27onMouseDownCapture\x27:\x0a    case \x27onMouseMove\x27:\x0a    case \x27onMouseMoveCapture\x27:\x0a    case \x27onMouseUp\x27:\x0a    case \x27onMouseUpCapture\x27:\x0a      return !!(props.disabled && isInteractive(type));\x0a    default:\x0a      return false;\x0a  }\x0a}\x0a\x0a/**\x0a * This is a unified interface for event plugins to be installed and configured.\x0a *\x0a * Event plugins can implement the following properties:\x0a *\x0a *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\x0a *     Required. When a top-level event is fired, this method is expected to\x0a *     extract synthetic events that will in turn be queued and dispatched.\x0a *\x0a *   `eventTypes` {object}\x0a *     Optional, plugins that fire events must publish a mapping of registration\x0a *     names that are used to register listeners. Values of this mapping must\x0a *     be objects that contain `registrationName` or `phasedRegistrationNames`.\x0a *\x0a *   `executeDispatch` {function(object, function, string)}\x0a *     Optional, allows plugins to override how an event gets dispatched. By\x0a *     default, the listener is simply invoked.\x0a *\x0a * Each plugin that is injected into `EventsPluginHub` is immediately operable.\x0a *\x0a * @public\x0a */\x0a\x0a/**\x0a * Methods for injecting dependencies.\x0a */\x0avar injection = {\x0a  /**\x0a   * @param {array} InjectedEventPluginOrder\x0a   * @public\x0a   */\x0a  injectEventPluginOrder: injectEventPluginOrder,\x0a\x0a  /**\x0a   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\x0a   */\x0a  injectEventPluginsByName: injectEventPluginsByName\x0a};\x0a\x0a/**\x0a * @param {object} inst The instance, which is the source of events.\x0a * @param {string} registrationName Name of listener (e.g. `onClick`).\x0a * @return {?function} The stored callback.\x0a */\x0afunction getListener(inst, registrationName) {\x0a  var listener = void 0;\x0a\x0a  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\x0a  // live here; needs to be moved to a better place soon\x0a  var stateNode = inst.stateNode;\x0a  if (!stateNode) {\x0a    // Work in progress (ex: onload events in incremental mode).\x0a    return null;\x0a  }\x0a  var props = getFiberCurrentPropsFromNode(stateNode);\x0a  if (!props) {\x0a    // Work in progress.\x0a    return null;\x0a  }\x0a  listener = props[registrationName];\x0a  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\x0a    return null;\x0a  }\x0a  !(!listener || typeof listener === \x27function\x27) ? invariant(false, \x27Expected `%s` listener to be a function, instead got a value of `%s` type.\x27, registrationName, typeof listener) : void 0;\x0a  return listener;\x0a}\x0a\x0a/**\x0a * Allows registered plugins an opportunity to extract events from top-level\x0a * native browser events.\x0a *\x0a * @return {*} An accumulation of synthetic events.\x0a * @internal\x0a */\x0afunction extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\x0a  var events = null;\x0a  for (var i = 0; i \x3c plugins.length; i++) {\x0a    // Not every plugin in the ordering may be loaded at runtime.\x0a    var possiblePlugin = plugins[i];\x0a    if (possiblePlugin) {\x0a      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\x0a      if (extractedEvents) {\x0a        events = accumulateInto(events, extractedEvents);\x0a      }\x0a    }\x0a  }\x0a  return events;\x0a}\x0a\x0afunction runEventsInBatch(events) {\x0a  if (events !== null) {\x0a    eventQueue = accumulateInto(eventQueue, events);\x0a  }\x0a\x0a  // Set `eventQueue` to null before processing it so that we can tell if more\x0a  // events get enqueued while processing.\x0a  var processingEventQueue = eventQueue;\x0a  eventQueue = null;\x0a\x0a  if (!processingEventQueue) {\x0a    return;\x0a  }\x0a\x0a  forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\x0a  !!eventQueue ? invariant(false, \x27processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.\x27) : void 0;\x0a  // This would be a good time to rethrow if any of the event handlers threw.\x0a  rethrowCaughtError();\x0a}\x0a\x0afunction runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\x0a  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\x0a  runEventsInBatch(events);\x0a}\x0a\x0avar FunctionComponent = 0;\x0avar ClassComponent = 1;\x0avar IndeterminateComponent = 2; // Before we know whether it is function or class\x0avar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\x0avar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\x0avar HostComponent = 5;\x0avar HostText = 6;\x0avar Fragment = 7;\x0avar Mode = 8;\x0avar ContextConsumer = 9;\x0avar ContextProvider = 10;\x0avar ForwardRef = 11;\x0avar Profiler = 12;\x0avar SuspenseComponent = 13;\x0avar MemoComponent = 14;\x0avar SimpleMemoComponent = 15;\x0avar LazyComponent = 16;\x0avar IncompleteClassComponent = 17;\x0avar DehydratedSuspenseComponent = 18;\x0a\x0avar randomKey = Math.random().toString(36).slice(2);\x0avar internalInstanceKey = \x27__reactInternalInstance$\x27 + randomKey;\x0avar internalEventHandlersKey = \x27__reactEventHandlers$\x27 + randomKey;\x0a\x0afunction precacheFiberNode(hostInst, node) {\x0a  node[internalInstanceKey] = hostInst;\x0a}\x0a\x0a/**\x0a * Given a DOM node, return the closest ReactDOMComponent or\x0a * ReactDOMTextComponent instance ancestor.\x0a */\x0afunction getClosestInstanceFromNode(node) {\x0a  if (node[internalInstanceKey]) {\x0a    return node[internalInstanceKey];\x0a  }\x0a\x0a  while (!node[internalInstanceKey]) {\x0a    if (node.parentNode) {\x0a      node = node.parentNode;\x0a    } else {\x0a      // Top of the tree. This node must not be part of a React tree (or is\x0a      // unmounted, potentially).\x0a      return null;\x0a    }\x0a  }\x0a\x0a  var inst = node[internalInstanceKey];\x0a  if (inst.tag === HostComponent || inst.tag === HostText) {\x0a    // In Fiber, this will always be the deepest root.\x0a    return inst;\x0a  }\x0a\x0a  return null;\x0a}\x0a\x0a/**\x0a * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\x0a * instance, or null if the node was not rendered by this React.\x0a */\x0afunction getInstanceFromNode$1(node) {\x0a  var inst = node[internalInstanceKey];\x0a  if (inst) {\x0a    if (inst.tag === HostComponent || inst.tag === HostText) {\x0a      return inst;\x0a    } else {\x0a      return null;\x0a    }\x0a  }\x0a  return null;\x0a}\x0a\x0a/**\x0a * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\x0a * DOM node.\x0a */\x0afunction getNodeFromInstance$1(inst) {\x0a  if (inst.tag === HostComponent || inst.tag === HostText) {\x0a    // In Fiber this, is just the state node right now. We assume it will be\x0a    // a host component or host text.\x0a    return inst.stateNode;\x0a  }\x0a\x0a  // Without this first invariant, passing a non-DOM-component triggers the next\x0a  // invariant for a missing parent, which is super confusing.\x0a  invariant(false, \x27getNodeFromInstance: Invalid argument.\x27);\x0a}\x0a\x0afunction getFiberCurrentPropsFromNode$1(node) {\x0a  return node[internalEventHandlersKey] || null;\x0a}\x0a\x0afunction updateFiberProps(node, props) {\x0a  node[internalEventHandlersKey] = props;\x0a}\x0a\x0afunction getParent(inst) {\x0a  do {\x0a    inst = inst.return;\x0a    // TODO: If this is a HostRoot we might want to bail out.\x0a    // That is depending on if we want nested subtrees (layers) to bubble\x0a    // events to their parent. We could also go through parentNode on the\x0a    // host node but that wouldn\x27t work for React Native and doesn\x27t let us\x0a    // do the portal feature.\x0a  } while (inst && inst.tag !== HostComponent);\x0a  if (inst) {\x0a    return inst;\x0a  }\x0a  return null;\x0a}\x0a\x0a/**\x0a * Return the lowest common ancestor of A and B, or null if they are in\x0a * different trees.\x0a */\x0afunction getLowestCommonAncestor(instA, instB) {\x0a  var depthA = 0;\x0a  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\x0a    depthA++;\x0a  }\x0a  var depthB = 0;\x0a  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\x0a    depthB++;\x0a  }\x0a\x0a  // If A is deeper, crawl up.\x0a  while (depthA - depthB \x3e 0) {\x0a    instA = getParent(instA);\x0a    depthA--;\x0a  }\x0a\x0a  // If B is deeper, crawl up.\x0a  while (depthB - depthA \x3e 0) {\x0a    instB = getParent(instB);\x0a    depthB--;\x0a  }\x0a\x0a  // Walk in lockstep until we find a match.\x0a  var depth = depthA;\x0a  while (depth--) {\x0a    if (instA === instB || instA === instB.alternate) {\x0a      return instA;\x0a    }\x0a    instA = getParent(instA);\x0a    instB = getParent(instB);\x0a  }\x0a  return null;\x0a}\x0a\x0a/**\x0a * Return if A is an ancestor of B.\x0a */\x0a\x0a\x0a/**\x0a * Return the parent instance of the passed-in instance.\x0a */\x0a\x0a\x0a/**\x0a * Simulates the traversal of a two-phase, capture/bubble event dispatch.\x0a */\x0afunction traverseTwoPhase(inst, fn, arg) {\x0a  var path = [];\x0a  while (inst) {\x0a    path.push(inst);\x0a    inst = getParent(inst);\x0a  }\x0a  var i = void 0;\x0a  for (i = path.length; i-- \x3e 0;) {\x0a    fn(path[i], \x27captured\x27, arg);\x0a  }\x0a  for (i = 0; i \x3c path.length; i++) {\x0a    fn(path[i], \x27bubbled\x27, arg);\x0a  }\x0a}\x0a\x0a/**\x0a * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\x0a * should would receive a `mouseEnter` or `mouseLeave` event.\x0a *\x0a * Does not invoke the callback on the nearest common ancestor because nothing\x0a * \x22entered\x22 or \x22left\x22 that element.\x0a */\x0afunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\x0a  var common = from && to ? getLowestCommonAncestor(from, to) : null;\x0a  var pathFrom = [];\x0a  while (true) {\x0a    if (!from) {\x0a      break;\x0a    }\x0a    if (from === common) {\x0a      break;\x0a    }\x0a    var alternate = from.alternate;\x0a    if (alternate !== null && alternate === common) {\x0a      break;\x0a    }\x0a    pathFrom.push(from);\x0a    from = getParent(from);\x0a  }\x0a  var pathTo = [];\x0a  while (true) {\x0a    if (!to) {\x0a      break;\x0a    }\x0a    if (to === common) {\x0a      break;\x0a    }\x0a    var _alternate = to.alternate;\x0a    if (_alternate !== null && _alternate === common) {\x0a      break;\x0a    }\x0a    pathTo.push(to);\x0a    to = getParent(to);\x0a  }\x0a  for (var i = 0; i \x3c pathFrom.length; i++) {\x0a    fn(pathFrom[i], \x27bubbled\x27, argFrom);\x0a  }\x0a  for (var _i = pathTo.length; _i-- \x3e 0;) {\x0a    fn(pathTo[_i], \x27captured\x27, argTo);\x0a  }\x0a}\x0a\x0a/**\x0a * Some event types have a notion of different registration names for different\x0a * \x22phases\x22 of propagation. This finds listeners by a given phase.\x0a */\x0afunction listenerAtPhase(inst, event, propagationPhase) {\x0a  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\x0a  return getListener(inst, registrationName);\x0a}\x0a\x0a/**\x0a * A small set of propagation patterns, each of which will accept a small amount\x0a * of information, and generate a set of \x22dispatch ready event objects\x22 - which\x0a * are sets of events that have already been annotated with a set of dispatched\x0a * listener functions/ids. The API is designed this way to discourage these\x0a * propagation strategies from actually executing the dispatches, since we\x0a * always want to collect the entire set of dispatches before executing even a\x0a * single one.\x0a */\x0a\x0a/**\x0a * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\x0a * here, allows us to not have to bind or create functions for each event.\x0a * Mutating the event\x27s members allows us to not have to create a wrapping\x0a * \x22dispatch\x22 object that pairs the event with the listener.\x0a */\x0afunction accumulateDirectionalDispatches(inst, phase, event) {\x0a  {\x0a    !inst ? warningWithoutStack$1(false, \x27Dispatching inst must not be null\x27) : void 0;\x0a  }\x0a  var listener = listenerAtPhase(inst, event, phase);\x0a  if (listener) {\x0a    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\x0a    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\x0a  }\x0a}\x0a\x0a/**\x0a * Collect dispatches (must be entirely collected before dispatching - see unit\x0a * tests). Lazily allocate the array to conserve memory.  We must loop through\x0a * each event and perform the traversal for each one. We cannot perform a\x0a * single traversal for the entire collection of events because each event may\x0a * have a different target.\x0a */\x0afunction accumulateTwoPhaseDispatchesSingle(event) {\x0a  if (event && event.dispatchConfig.phasedRegistrationNames) {\x0a    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\x0a  }\x0a}\x0a\x0a/**\x0a * Accumulates without regard to direction, does not look for phased\x0a * registration names. Same as `accumulateDirectDispatchesSingle` but without\x0a * requiring that the `dispatchMarker` be the same as the dispatched ID.\x0a */\x0afunction accumulateDispatches(inst, ignoredDirection, event) {\x0a  if (inst && event && event.dispatchConfig.registrationName) {\x0a    var registrationName = event.dispatchConfig.registrationName;\x0a    var listener = getListener(inst, registrationName);\x0a    if (listener) {\x0a      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\x0a      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\x0a    }\x0a  }\x0a}\x0a\x0a/**\x0a * Accumulates dispatches on an `SyntheticEvent`, but only for the\x0a * `dispatchMarker`.\x0a * @param {SyntheticEvent} event\x0a */\x0afunction accumulateDirectDispatchesSingle(event) {\x0a  if (event && event.dispatchConfig.registrationName) {\x0a    accumulateDispatches(event._targetInst, null, event);\x0a  }\x0a}\x0a\x0afunction accumulateTwoPhaseDispatches(events) {\x0a  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\x0a}\x0a\x0a\x0a\x0afunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\x0a  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\x0a}\x0a\x0afunction accumulateDirectDispatches(events) {\x0a  forEachAccumulated(events, accumulateDirectDispatchesSingle);\x0a}\x0a\x0avar canUseDOM = !!(typeof window !== \x27undefined\x27 && window.document && window.document.createElement);\x0a\x0a// Do not uses the below two methods directly!\x0a// Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.\x0a// (It is the only module that is allowed to access these methods.)\x0a\x0afunction unsafeCastStringToDOMTopLevelType(topLevelType) {\x0a  return topLevelType;\x0a}\x0a\x0afunction unsafeCastDOMTopLevelTypeToString(topLevelType) {\x0a  return topLevelType;\x0a}\x0a\x0a/**\x0a * Generate a mapping of standard vendor prefixes using the defined style property and event name.\x0a *\x0a * @param {string} styleProp\x0a * @param {string} eventName\x0a * @returns {object}\x0a */\x0afunction makePrefixMap(styleProp, eventName) {\x0a  var prefixes = {};\x0a\x0a  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\x0a  prefixes[\x27Webkit\x27 + styleProp] = \x27webkit\x27 + eventName;\x0a  prefixes[\x27Moz\x27 + styleProp] = \x27moz\x27 + eventName;\x0a\x0a  return prefixes;\x0a}\x0a\x0a/**\x0a * A list of event names to a configurable list of vendor prefixes.\x0a */\x0avar vendorPrefixes = {\x0a  animationend: makePrefixMap(\x27Animation\x27, \x27AnimationEnd\x27),\x0a  animationiteration: makePrefixMap(\x27Animation\x27, \x27AnimationIteration\x27),\x0a  animationstart: makePrefixMap(\x27Animation\x27, \x27AnimationStart\x27),\x0a  transitionend: makePrefixMap(\x27Transition\x27, \x27TransitionEnd\x27)\x0a};\x0a\x0a/**\x0a * Event names that have already been detected and prefixed (if applicable).\x0a */\x0avar prefixedEventNames = {};\x0a\x0a/**\x0a * Element to check for prefixes on.\x0a */\x0avar style = {};\x0a\x0a/**\x0a * Bootstrap if a DOM exists.\x0a */\x0aif (canUseDOM) {\x0a  style = document.createElement(\x27div\x27).style;\x0a\x0a  // On some platforms, in particular some releases of Android 4.x,\x0a  // the un-prefixed \x22animation\x22 and \x22transition\x22 properties are defined on the\x0a  // style object but the events that fire will still be prefixed, so we need\x0a  // to check if the un-prefixed events are usable, and if not remove them from the map.\x0a  if (!(\x27AnimationEvent\x27 in window)) {\x0a    delete vendorPrefixes.animationend.animation;\x0a    delete vendorPrefixes.animationiteration.animation;\x0a    delete vendorPrefixes.animationstart.animation;\x0a  }\x0a\x0a  // Same as above\x0a  if (!(\x27TransitionEvent\x27 in window)) {\x0a    delete vendorPrefixes.transitionend.transition;\x0a  }\x0a}\x0a\x0a/**\x0a * Attempts to determine the correct vendor prefixed event name.\x0a *\x0a * @param {string} eventName\x0a * @returns {string}\x0a */\x0afunction getVendorPrefixedEventName(eventName) {\x0a  if (prefixedEventNames[eventName]) {\x0a    return prefixedEventNames[eventName];\x0a  } else if (!vendorPrefixes[eventName]) {\x0a    return eventName;\x0a  }\x0a\x0a  var prefixMap = vendorPrefixes[eventName];\x0a\x0a  for (var styleProp in prefixMap) {\x0a    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\x0a      return prefixedEventNames[eventName] = prefixMap[styleProp];\x0a    }\x0a  }\x0a\x0a  return eventName;\x0a}\x0a\x0a/**\x0a * To identify top level events in ReactDOM, we use constants defined by this\x0a * module. This is the only module that uses the unsafe* methods to express\x0a * that the constants actually correspond to the browser event names. This lets\x0a * us save some bundle size by avoiding a top level type -\x3e event name map.\x0a * The rest of ReactDOM code should import top level types from this file.\x0a */\x0avar TOP_ABORT = unsafeCastStringToDOMTopLevelType(\x27abort\x27);\x0avar TOP_ANIMATION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(\x27animationend\x27));\x0avar TOP_ANIMATION_ITERATION = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(\x27animationiteration\x27));\x0avar TOP_ANIMATION_START = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(\x27animationstart\x27));\x0avar TOP_BLUR = unsafeCastStringToDOMTopLevelType(\x27blur\x27);\x0avar TOP_CAN_PLAY = unsafeCastStringToDOMTopLevelType(\x27canplay\x27);\x0avar TOP_CAN_PLAY_THROUGH = unsafeCastStringToDOMTopLevelType(\x27canplaythrough\x27);\x0avar TOP_CANCEL = unsafeCastStringToDOMTopLevelType(\x27cancel\x27);\x0avar TOP_CHANGE = unsafeCastStringToDOMTopLevelType(\x27change\x27);\x0avar TOP_CLICK = unsafeCastStringToDOMTopLevelType(\x27click\x27);\x0avar TOP_CLOSE = unsafeCastStringToDOMTopLevelType(\x27close\x27);\x0avar TOP_COMPOSITION_END = unsafeCastStringToDOMTopLevelType(\x27compositionend\x27);\x0avar TOP_COMPOSITION_START = unsafeCastStringToDOMTopLevelType(\x27compositionstart\x27);\x0avar TOP_COMPOSITION_UPDATE = unsafeCastStringToDOMTopLevelType(\x27compositionupdate\x27);\x0avar TOP_CONTEXT_MENU = unsafeCastStringToDOMTopLevelType(\x27contextmenu\x27);\x0avar TOP_COPY = unsafeCastStringToDOMTopLevelType(\x27copy\x27);\x0avar TOP_CUT = unsafeCastStringToDOMTopLevelType(\x27cut\x27);\x0avar TOP_DOUBLE_CLICK = unsafeCastStringToDOMTopLevelType(\x27dblclick\x27);\x0avar TOP_AUX_CLICK = unsafeCastStringToDOMTopLevelType(\x27auxclick\x27);\x0avar TOP_DRAG = unsafeCastStringToDOMTopLevelType(\x27drag\x27);\x0avar TOP_DRAG_END = unsafeCastStringToDOMTopLevelType(\x27dragend\x27);\x0avar TOP_DRAG_ENTER = unsafeCastStringToDOMTopLevelType(\x27dragenter\x27);\x0avar TOP_DRAG_EXIT = unsafeCastStringToDOMTopLevelType(\x27dragexit\x27);\x0avar TOP_DRAG_LEAVE = unsafeCastStringToDOMTopLevelType(\x27dragleave\x27);\x0avar TOP_DRAG_OVER = unsafeCastStringToDOMTopLevelType(\x27dragover\x27);\x0avar TOP_DRAG_START = unsafeCastStringToDOMTopLevelType(\x27dragstart\x27);\x0avar TOP_DROP = unsafeCastStringToDOMTopLevelType(\x27drop\x27);\x0avar TOP_DURATION_CHANGE = unsafeCastStringToDOMTopLevelType(\x27durationchange\x27);\x0avar TOP_EMPTIED = unsafeCastStringToDOMTopLevelType(\x27emptied\x27);\x0avar TOP_ENCRYPTED = unsafeCastStringToDOMTopLevelType(\x27encrypted\x27);\x0avar TOP_ENDED = unsafeCastStringToDOMTopLevelType(\x27ended\x27);\x0avar TOP_ERROR = unsafeCastStringToDOMTopLevelType(\x27error\x27);\x0avar TOP_FOCUS = unsafeCastStringToDOMTopLevelType(\x27focus\x27);\x0avar TOP_GOT_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType(\x27gotpointercapture\x27);\x0avar TOP_INPUT = unsafeCastStringToDOMTopLevelType(\x27input\x27);\x0avar TOP_INVALID = unsafeCastStringToDOMTopLevelType(\x27invalid\x27);\x0avar TOP_KEY_DOWN = unsafeCastStringToDOMTopLevelType(\x27keydown\x27);\x0avar TOP_KEY_PRESS = unsafeCastStringToDOMTopLevelType(\x27keypress\x27);\x0avar TOP_KEY_UP = unsafeCastStringToDOMTopLevelType(\x27keyup\x27);\x0avar TOP_LOAD = unsafeCastStringToDOMTopLevelType(\x27load\x27);\x0avar TOP_LOAD_START = unsafeCastStringToDOMTopLevelType(\x27loadstart\x27);\x0avar TOP_LOADED_DATA = unsafeCastStringToDOMTopLevelType(\x27loadeddata\x27);\x0avar TOP_LOADED_METADATA = unsafeCastStringToDOMTopLevelType(\x27loadedmetadata\x27);\x0avar TOP_LOST_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType(\x27lostpointercapture\x27);\x0avar TOP_MOUSE_DOWN = unsafeCastStringToDOMTopLevelType(\x27mousedown\x27);\x0avar TOP_MOUSE_MOVE = unsafeCastStringToDOMTopLevelType(\x27mousemove\x27);\x0avar TOP_MOUSE_OUT = unsafeCastStringToDOMTopLevelType(\x27mouseout\x27);\x0avar TOP_MOUSE_OVER = unsafeCastStringToDOMTopLevelType(\x27mouseover\x27);\x0avar TOP_MOUSE_UP = unsafeCastStringToDOMTopLevelType(\x27mouseup\x27);\x0avar TOP_PASTE = unsafeCastStringToDOMTopLevelType(\x27paste\x27);\x0avar TOP_PAUSE = unsafeCastStringToDOMTopLevelType(\x27pause\x27);\x0avar TOP_PLAY = unsafeCastStringToDOMTopLevelType(\x27play\x27);\x0avar TOP_PLAYING = unsafeCastStringToDOMTopLevelType(\x27playing\x27);\x0avar TOP_POINTER_CANCEL = unsafeCastStringToDOMTopLevelType(\x27pointercancel\x27);\x0avar TOP_POINTER_DOWN = unsafeCastStringToDOMTopLevelType(\x27pointerdown\x27);\x0a\x0a\x0avar TOP_POINTER_MOVE = unsafeCastStringToDOMTopLevelType(\x27pointermove\x27);\x0avar TOP_POINTER_OUT = unsafeCastStringToDOMTopLevelType(\x27pointerout\x27);\x0avar TOP_POINTER_OVER = unsafeCastStringToDOMTopLevelType(\x27pointerover\x27);\x0avar TOP_POINTER_UP = unsafeCastStringToDOMTopLevelType(\x27pointerup\x27);\x0avar TOP_PROGRESS = unsafeCastStringToDOMTopLevelType(\x27progress\x27);\x0avar TOP_RATE_CHANGE = unsafeCastStringToDOMTopLevelType(\x27ratechange\x27);\x0avar TOP_RESET = unsafeCastStringToDOMTopLevelType(\x27reset\x27);\x0avar TOP_SCROLL = unsafeCastStringToDOMTopLevelType(\x27scroll\x27);\x0avar TOP_SEEKED = unsafeCastStringToDOMTopLevelType(\x27seeked\x27);\x0avar TOP_SEEKING = unsafeCastStringToDOMTopLevelType(\x27seeking\x27);\x0avar TOP_SELECTION_CHANGE = unsafeCastStringToDOMTopLevelType(\x27selectionchange\x27);\x0avar TOP_STALLED = unsafeCastStringToDOMTopLevelType(\x27stalled\x27);\x0avar TOP_SUBMIT = unsafeCastStringToDOMTopLevelType(\x27submit\x27);\x0avar TOP_SUSPEND = unsafeCastStringToDOMTopLevelType(\x27suspend\x27);\x0avar TOP_TEXT_INPUT = unsafeCastStringToDOMTopLevelType(\x27textInput\x27);\x0avar TOP_TIME_UPDATE = unsafeCastStringToDOMTopLevelType(\x27timeupdate\x27);\x0avar TOP_TOGGLE = unsafeCastStringToDOMTopLevelType(\x27toggle\x27);\x0avar TOP_TOUCH_CANCEL = unsafeCastStringToDOMTopLevelType(\x27touchcancel\x27);\x0avar TOP_TOUCH_END = unsafeCastStringToDOMTopLevelType(\x27touchend\x27);\x0avar TOP_TOUCH_MOVE = unsafeCastStringToDOMTopLevelType(\x27touchmove\x27);\x0avar TOP_TOUCH_START = unsafeCastStringToDOMTopLevelType(\x27touchstart\x27);\x0avar TOP_TRANSITION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName(\x27transitionend\x27));\x0avar TOP_VOLUME_CHANGE = unsafeCastStringToDOMTopLevelType(\x27volumechange\x27);\x0avar TOP_WAITING = unsafeCastStringToDOMTopLevelType(\x27waiting\x27);\x0avar TOP_WHEEL = unsafeCastStringToDOMTopLevelType(\x27wheel\x27);\x0a\x0a// List of events that need to be individually attached to media elements.\x0a// Note that events in this list will *not* be listened to at the top level\x0a// unless they\x27re explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.\x0avar mediaEventTypes = [TOP_ABORT, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_VOLUME_CHANGE, TOP_WAITING];\x0a\x0afunction getRawEventName(topLevelType) {\x0a  return unsafeCastDOMTopLevelTypeToString(topLevelType);\x0a}\x0a\x0a/**\x0a * These variables store information about text content of a target node,\x0a * allowing comparison of content before and after a given event.\x0a *\x0a * Identify the node where selection currently begins, then observe\x0a * both its text content and its current position in the DOM. Since the\x0a * browser may natively replace the target node during composition, we can\x0a * use its position to find its replacement.\x0a *\x0a *\x0a */\x0a\x0avar root = null;\x0avar startText = null;\x0avar fallbackText = null;\x0a\x0afunction initialize(nativeEventTarget) {\x0a  root = nativeEventTarget;\x0a  startText = getText();\x0a  return true;\x0a}\x0a\x0afunction reset() {\x0a  root = null;\x0a  startText = null;\x0a  fallbackText = null;\x0a}\x0a\x0afunction getData() {\x0a  if (fallbackText) {\x0a    return fallbackText;\x0a  }\x0a\x0a  var start = void 0;\x0a  var startValue = startText;\x0a  var startLength = startValue.length;\x0a  var end = void 0;\x0a  var endValue = getText();\x0a  var endLength = endValue.length;\x0a\x0a  for (start = 0; start \x3c startLength; start++) {\x0a    if (startValue[start] !== endValue[start]) {\x0a      break;\x0a    }\x0a  }\x0a\x0a  var minEnd = startLength - start;\x0a  for (end = 1; end \x3c= minEnd; end++) {\x0a    if (startValue[startLength - end] !== endValue[endLength - end]) {\x0a      break;\x0a    }\x0a  }\x0a\x0a  var sliceTail = end \x3e 1 ? 1 - end : undefined;\x0a  fallbackText = endValue.slice(start, sliceTail);\x0a  return fallbackText;\x0a}\x0a\x0afunction getText() {\x0a  if (\x27value\x27 in root) {\x0a    return root.value;\x0a  }\x0a  return root.textContent;\x0a}\x0a\x0avar ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\x0a\x0avar _assign = ReactInternals.assign;\x0a\x0a/* eslint valid-typeof: 0 */\x0a\x0avar EVENT_POOL_SIZE = 10;\x0a\x0a/**\x0a * @interface Event\x0a * @see http://www.w3.org/TR/DOM-Level-3-Events/\x0a */\x0avar EventInterface = {\x0a  type: null,\x0a  target: null,\x0a  // currentTarget is set when dispatching; no use in copying it here\x0a  currentTarget: function () {\x0a    return null;\x0a  },\x0a  eventPhase: null,\x0a  bubbles: null,\x0a  cancelable: null,\x0a  timeStamp: function (event) {\x0a    return event.timeStamp || Date.now();\x0a  },\x0a  defaultPrevented: null,\x0a  isTrusted: null\x0a};\x0a\x0afunction functionThatReturnsTrue() {\x0a  return true;\x0a}\x0a\x0afunction functionThatReturnsFalse() {\x0a  return false;\x0a}\x0a\x0a/**\x0a * Synthetic events are dispatched by event plugins, typically in response to a\x0a * top-level event delegation handler.\x0a *\x0a * These systems should generally use pooling to reduce the frequency of garbage\x0a * collection. The system should check `isPersistent` to determine whether the\x0a * event should be released into the pool after being dispatched. Users that\x0a * need a persisted event should invoke `persist`.\x0a *\x0a * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\x0a * normalizing browser quirks. Subclasses do not necessarily have to implement a\x0a * DOM interface; custom application-specific events can also subclass this.\x0a *\x0a * @param {object} dispatchConfig Configuration used to dispatch this event.\x0a * @param {*} targetInst Marker identifying the event target.\x0a * @param {object} nativeEvent Native browser event.\x0a * @param {DOMEventTarget} nativeEventTarget Target node.\x0a */\x0afunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\x0a  {\x0a    // these have a getter/setter for warnings\x0a    delete this.nativeEvent;\x0a    delete this.preventDefault;\x0a    delete this.stopPropagation;\x0a    delete this.isDefaultPrevented;\x0a    delete this.isPropagationStopped;\x0a  }\x0a\x0a  this.dispatchConfig = dispatchConfig;\x0a  this._targetInst = targetInst;\x0a  this.nativeEvent = nativeEvent;\x0a\x0a  var Interface = this.constructor.Interface;\x0a  for (var propName in Interface) {\x0a    if (!Interface.hasOwnProperty(propName)) {\x0a      continue;\x0a    }\x0a    {\x0a      delete this[propName]; // this has a getter/setter for warnings\x0a    }\x0a    var normalize = Interface[propName];\x0a    if (normalize) {\x0a      this[propName] = normalize(nativeEvent);\x0a    } else {\x0a      if (propName === \x27target\x27) {\x0a        this.target = nativeEventTarget;\x0a      } else {\x0a        this[propName] = nativeEvent[propName];\x0a      }\x0a    }\x0a  }\x0a\x0a  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\x0a  if (defaultPrevented) {\x0a    this.isDefaultPrevented = functionThatReturnsTrue;\x0a  } else {\x0a    this.isDefaultPrevented = functionThatReturnsFalse;\x0a  }\x0a  this.isPropagationStopped = functionThatReturnsFalse;\x0a  return this;\x0a}\x0a\x0a_assign(SyntheticEvent.prototype, {\x0a  preventDefault: function () {\x0a    this.defaultPrevented = true;\x0a    var event = this.nativeEvent;\x0a    if (!event) {\x0a      return;\x0a    }\x0a\x0a    if (event.preventDefault) {\x0a      event.preventDefault();\x0a    } else if (typeof event.returnValue !== \x27unknown\x27) {\x0a      event.returnValue = false;\x0a    }\x0a    this.isDefaultPrevented = functionThatReturnsTrue;\x0a  },\x0a\x0a  stopPropagation: function () {\x0a    var event = this.nativeEvent;\x0a    if (!event) {\x0a      return;\x0a    }\x0a\x0a    if (event.stopPropagation) {\x0a      event.stopPropagation();\x0a    } else if (typeof event.cancelBubble !== \x27unknown\x27) {\x0a      // The ChangeEventPlugin registers a \x22propertychange\x22 event for\x0a      // IE. This event does not support bubbling or cancelling, and\x0a      // any references to cancelBubble throw \x22Member not found\x22.  A\x0a      // typeof check of \x22unknown\x22 circumvents this issue (and is also\x0a      // IE specific).\x0a      event.cancelBubble = true;\x0a    }\x0a\x0a    this.isPropagationStopped = functionThatReturnsTrue;\x0a  },\x0a\x0a  /**\x0a   * We release all dispatched `SyntheticEvent`s after each event loop, adding\x0a   * them back into the pool. This allows a way to hold onto a reference that\x0a   * won\x27t be added back into the pool.\x0a   */\x0a  persist: function () {\x0a    this.isPersistent = functionThatReturnsTrue;\x0a  },\x0a\x0a  /**\x0a   * Checks if this event should be released back into the pool.\x0a   *\x0a   * @return {boolean} True if this should not be released, false otherwise.\x0a   */\x0a  isPersistent: functionThatReturnsFalse,\x0a\x0a  /**\x0a   * `PooledClass` looks for `destructor` on each instance it releases.\x0a   */\x0a  destructor: function () {\x0a    var Interface = this.constructor.Interface;\x0a    for (var propName in Interface) {\x0a      {\x0a        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\x0a      }\x0a    }\x0a    this.dispatchConfig = null;\x0a    this._targetInst = null;\x0a    this.nativeEvent = null;\x0a    this.isDefaultPrevented = functionThatReturnsFalse;\x0a    this.isPropagationStopped = functionThatReturnsFalse;\x0a    this._dispatchListeners = null;\x0a    this._dispatchInstances = null;\x0a    {\x0a      Object.defineProperty(this, \x27nativeEvent\x27, getPooledWarningPropertyDefinition(\x27nativeEvent\x27, null));\x0a      Object.defineProperty(this, \x27isDefaultPrevented\x27, getPooledWarningPropertyDefinition(\x27isDefaultPrevented\x27, functionThatReturnsFalse));\x0a      Object.defineProperty(this, \x27isPropagationStopped\x27, getPooledWarningPropertyDefinition(\x27isPropagationStopped\x27, functionThatReturnsFalse));\x0a      Object.defineProperty(this, \x27preventDefault\x27, getPooledWarningPropertyDefinition(\x27preventDefault\x27, function () {}));\x0a      Object.defineProperty(this, \x27stopPropagation\x27, getPooledWarningPropertyDefinition(\x27stopPropagation\x27, function () {}));\x0a    }\x0a  }\x0a});\x0a\x0aSyntheticEvent.Interface = EventInterface;\x0a\x0a/**\x0a * Helper to reduce boilerplate when creating subclasses.\x0a */\x0aSyntheticEvent.extend = function (Interface) {\x0a  var Super = this;\x0a\x0a  var E = function () {};\x0a  E.prototype = Super.prototype;\x0a  var prototype = new E();\x0a\x0a  function Class() {\x0a    return Super.apply(this, arguments);\x0a  }\x0a  _assign(prototype, Class.prototype);\x0a  Class.prototype = prototype;\x0a  Class.prototype.constructor = Class;\x0a\x0a  Class.Interface = _assign({}, Super.Interface, Interface);\x0a  Class.extend = Super.extend;\x0a  addEventPoolingTo(Class);\x0a\x0a  return Class;\x0a};\x0a\x0aaddEventPoolingTo(SyntheticEvent);\x0a\x0a/**\x0a * Helper to nullify syntheticEvent instance properties when destructing\x0a *\x0a * @param {String} propName\x0a * @param {?object} getVal\x0a * @return {object} defineProperty object\x0a */\x0afunction getPooledWarningPropertyDefinition(propName, getVal) {\x0a  var isFunction = typeof getVal === \x27function\x27;\x0a  return {\x0a    configurable: true,\x0a    set: set,\x0a    get: get\x0a  };\x0a\x0a  function set(val) {\x0a    var action = isFunction ? \x27setting the method\x27 : \x27setting the property\x27;\x0a    warn(action, \x27This is effectively a no-op\x27);\x0a    return val;\x0a  }\x0a\x0a  function get() {\x0a    var action = isFunction ? \x27accessing the method\x27 : \x27accessing the property\x27;\x0a    var result = isFunction ? \x27This is a no-op function\x27 : \x27This is set to null\x27;\x0a    warn(action, result);\x0a    return getVal;\x0a  }\x0a\x0a  function warn(action, result) {\x0a    var warningCondition = false;\x0a    !warningCondition ? warningWithoutStack$1(false, \x22This synthetic event is reused for performance reasons. If you\x27re seeing this, \x22 + \x22you\x27re %s `%s` on a released/nullified synthetic event. %s. \x22 + \x27If you must keep the original synthetic event around, use event.persist(). \x27 + \x27See https://fb.me/react-event-pooling for more information.\x27, action, propName, result) : void 0;\x0a  }\x0a}\x0a\x0afunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\x0a  var EventConstructor = this;\x0a  if (EventConstructor.eventPool.length) {\x0a    var instance = EventConstructor.eventPool.pop();\x0a    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\x0a    return instance;\x0a  }\x0a  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\x0a}\x0a\x0afunction releasePooledEvent(event) {\x0a  var EventConstructor = this;\x0a  !(event instanceof EventConstructor) ? invariant(false, \x27Trying to release an event instance into a pool of a different type.\x27) : void 0;\x0a  event.destructor();\x0a  if (EventConstructor.eventPool.length \x3c EVENT_POOL_SIZE) {\x0a    EventConstructor.eventPool.push(event);\x0a  }\x0a}\x0a\x0afunction addEventPoolingTo(EventConstructor) {\x0a  EventConstructor.eventPool = [];\x0a  EventConstructor.getPooled = getPooledEvent;\x0a  EventConstructor.release = releasePooledEvent;\x0a}\x0a\x0a/**\x0a * @interface Event\x0a * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\x0a */\x0avar SyntheticCompositionEvent = SyntheticEvent.extend({\x0a  data: null\x0a});\x0a\x0a/**\x0a * @interface Event\x0a * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\x0a *      /#events-inputevents\x0a */\x0avar SyntheticInputEvent = SyntheticEvent.extend({\x0a  data: null\x0a});\x0a\x0avar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\x0avar START_KEYCODE = 229;\x0a\x0avar canUseCompositionEvent = canUseDOM && \x27CompositionEvent\x27 in window;\x0a\x0avar documentMode = null;\x0aif (canUseDOM && \x27documentMode\x27 in document) {\x0a  documentMode = document.documentMode;\x0a}\x0a\x0a// Webkit offers a very useful `textInput` event that can be used to\x0a// directly represent `beforeInput`. The IE `textinput` event is not as\x0a// useful, so we don\x27t use it.\x0avar canUseTextInputEvent = canUseDOM && \x27TextEvent\x27 in window && !documentMode;\x0a\x0a// In IE9+, we have access to composition events, but the data supplied\x0a// by the native compositionend event may be incorrect. Japanese ideographic\x0a// spaces, for instance (\x5cu3000) are not recorded correctly.\x0avar useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode \x3e 8 && documentMode \x3c= 11);\x0a\x0avar SPACEBAR_CODE = 32;\x0avar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\x0a\x0a// Events and their corresponding property names.\x0avar eventTypes = {\x0a  beforeInput: {\x0a    phasedRegistrationNames: {\x0a      bubbled: \x27onBeforeInput\x27,\x0a      captured: \x27onBeforeInputCapture\x27\x0a    },\x0a    dependencies: [TOP_COMPOSITION_END, TOP_KEY_PRESS, TOP_TEXT_INPUT, TOP_PASTE]\x0a  },\x0a  compositionEnd: {\x0a    phasedRegistrationNames: {\x0a      bubbled: \x27onCompositionEnd\x27,\x0a      captured: \x27onCompositionEndCapture\x27\x0a    },\x0a    dependencies: [TOP_BLUR, TOP_COMPOSITION_END, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\x0a  },\x0a  compositionStart: {\x0a    phasedRegistrationNames: {\x0a      bubbled: \x27onCompositionStart\x27,\x0a      captured: \x27onCompositionStartCapture\x27\x0a    },\x0a    dependencies: [TOP_BLUR, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\x0a  },\x0a  compositionUpdate: {\x0a    phasedRegistrationNames: {\x0a      bubbled: \x27onCompositionUpdate\x27,\x0a      captured: \x27onCompositionUpdateCapture\x27\x0a    },\x0a    dependencies: [TOP_BLUR, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\x0a  }\x0a};\x0a\x0a// Track whether we\x27ve ever handled a keypress on the space key.\x0avar hasSpaceKeypress = false;\x0a\x0a/**\x0a * Return whether a native keypress event is assumed to be a command.\x0a * This is required because Firefox fires `keypress` events for key commands\x0a * (cut, copy, select-all, etc.) even though no character is inserted.\x0a */\x0afunction isKeypressCommand(nativeEvent) {\x0a  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\x0a  // ctrlKey && altKey is equivalent to AltGr, and is not a command.\x0a  !(nativeEvent.ctrlKey && nativeEvent.altKey);\x0a}\x0a\x0a/**\x0a * Translate native top level events into event types.\x0a *\x0a * @param {string} topLevelType\x0a * @return {object}\x0a */\x0afunction getCompositionEventType(topLevelType) {\x0a  switch (topLevelType) {\x0a    case TOP_COMPOSITION_START:\x0a      return eventTypes.compositionStart;\x0a    case TOP_COMPOSITION_END:\x0a      return eventTypes.compositionEnd;\x0a    case TOP_COMPOSITION_UPDATE:\x0a      return eventTypes.compositionUpdate;\x0a  }\x0a}\x0a\x0a/**\x0a * Does our fallback best-guess model think this event signifies that\x0a * composition has begun?\x0a *\x0a * @param {string} topLevelType\x0a * @param {object} nativeEvent\x0a * @return {boolean}\x0a */\x0afunction isFallbackCompositionStart(topLevelType, nativeEvent) {\x0a  return topLevelType === TOP_KEY_DOWN && nativeEvent.keyCode === START_KEYCODE;\x0a}\x0a\x0a/**\x0a * Does our fallback mode think that this event is the end of composition?\x0a *\x0a * @param {string} topLevelType\x0a * @param {object} nativeEvent\x0a * @return {boolean}\x0a */\x0afunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\x0a  switch (topLevelType) {\x0a    case TOP_KEY_UP:\x0a      // Command keys insert or clear IME input.\x0a      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\x0a    case TOP_KEY_DOWN:\x0a      // Expect IME keyCode on each keydown. If we get any other\x0a      // code we must have exited earlier.\x0a      return nativeEvent.keyCode !== START_KEYCODE;\x0a    case TOP_KEY_PRESS:\x0a    case TOP_MOUSE_DOWN:\x0a    case TOP_BLUR:\x0a      // Events are not possible without cancelling IME.\x0a      return true;\x0a    default:\x0a      return false;\x0a  }\x0a}\x0a\x0a/**\x0a * Google Input Tools provides composition data via a CustomEvent,\x0a * with the `data` property populated in the `detail` object. If this\x0a * is available on the event object, use it. If not, this is a plain\x0a * composition event and we have nothing special to extract.\x0a *\x0a * @param {object} nativeEvent\x0a * @return {?string}\x0a */\x0afunction getDataFromCustomEvent(nativeEvent) {\x0a  var detail = nativeEvent.detail;\x0a  if (typeof detail === \x27object\x27 && \x27data\x27 in detail) {\x0a    return detail.data;\x0a  }\x0a  return null;\x0a}\x0a\x0a/**\x0a * Check if a composition event was triggered by Korean IME.\x0a * Our fallback mode does not work well with IE\x27s Korean IME,\x0a * so just use native composition events when Korean IME is used.\x0a * Although CompositionEvent.locale property is deprecated,\x0a * it is available in IE, where our fallback mode is enabled.\x0a *\x0a * @param {object} nativeEvent\x0a * @return {boolean}\x0a */\x0afunction isUsingKoreanIME(nativeEvent) {\x0a  return nativeEvent.locale === \x27ko\x27;\x0a}\x0a\x0a// Track the current IME composition status, if any.\x0avar isComposing = false;\x0a\x0a/**\x0a * @return {?object} A SyntheticCompositionEvent.\x0a */\x0afunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\x0a  var eventType = void 0;\x0a  var fallbackData = void 0;\x0a\x0a  if (canUseCompositionEvent) {\x0a    eventType = getCompositionEventType(topLevelType);\x0a  } else if (!isComposing) {\x0a    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\x0a      eventType = eventTypes.compositionStart;\x0a    }\x0a  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\x0a    eventType = eventTypes.compositionEnd;\x0a  }\x0a\x0a  if (!eventType) {\x0a    return null;\x0a  }\x0a\x0a  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\x0a    // The current composition is stored statically and must not be\x0a    // overwritten while composition continues.\x0a    if (!isComposing && eventType === eventTypes.compositionStart) {\x0a      isComposing = initialize(nativeEventTarget);\x0a    } else if (eventType === eventTypes.compositionEnd) {\x0a      if (isComposing) {\x0a        fallbackData = getData();\x0a      }\x0a    }\x0a  }\x0a\x0a  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\x0a\x0a  if (fallbackData) {\x0a    // Inject data generated from fallback path into the synthetic event.\x0a    // This matches the property of native CompositionEventInterface.\x0a    event.data = fallbackData;\x0a  } else {\x0a    var customData = getDataFromCustomEvent(nativeEvent);\x0a    if (customData !== null) {\x0a      event.data = customData;\x0a    }\x0a  }\x0a\x0a  accumulateTwoPhaseDispatches(event);\x0a  return event;\x0a}\x0a\x0a/**\x0a * @param {TopLevelType} topLevelType Number from `TopLevelType`.\x0a * @param {object} nativeEvent Native browser event.\x0a * @return {?string} The string corresponding to this `beforeInput` event.\x0a */\x0afunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\x0a  switch (topLevelType) {\x0a    case TOP_COMPOSITION_END:\x0a      return getDataFromCustomEvent(nativeEvent);\x0a    case TOP_KEY_PRESS:\x0a      /**\x0a       * If native `textInput` events are available, our goal is to make\x0a       * use of them. However, there is a special case: the spacebar key.\x0a       * In Webkit, preventing default on a spacebar `textInput` event\x0a       * cancels character insertion, but it *also* causes the browser\x0a       * to fall back to its default spacebar behavior of scrolling the\x0a       * page.\x0a       *\x0a       * Tracking at:\x0a       * https://code.google.com/p/chromium/issues/detail?id=355103\x0a       *\x0a       * To avoid this issue, use the keypress event as if no `textInput`\x0a       * event is available.\x0a       */\x0a      var which = nativeEvent.which;\x0a      if (which !== SPACEBAR_CODE) {\x0a        return null;\x0a      }\x0a\x0a      hasSpaceKeypress = true;\x0a      return SPACEBAR_CHAR;\x0a\x0a    case TOP_TEXT_INPUT:\x0a      // Record the characters to be added to the DOM.\x0a      var chars = nativeEvent.data;\x0a\x0a      // If it\x27s a spacebar character, assume that we have already handled\x0a      // it at the keypress level and bail immediately. Android Chrome\x0a      // doesn\x27t give us keycodes, so we need to ignore it.\x0a      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\x0a        return null;\x0a      }\x0a\x0a      return chars;\x0a\x0a    default:\x0a      // For other native event types, do nothing.\x0a      return null;\x0a  }\x0a}\x0a\x0a/**\x0a * For browsers that do not provide the `textInput` event, extract the\x0a * appropriate string to use for SyntheticInputEvent.\x0a *\x0a * @param {number} topLevelType Number from `TopLevelEventTypes`.\x0a * @param {object} nativeEvent Native browser event.\x0a * @return {?string} The fallback string for this `beforeInput` event.\x0a */\x0afunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\x0a  // If we are currently composing (IME) and using a fallback to do so,\x0a  // try to extract the composed characters from the fallback object.\x0a  // If composition event is available, we extract a string only at\x0a  // compositionevent, otherwise extract it at fallback events.\x0a  if (isComposing) {\x0a    if (topLevelType === TOP_COMPOSITION_END || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\x0a      var chars = getData();\x0a      reset();\x0a      isComposing = false;\x0a      return chars;\x0a    }\x0a    return null;\x0a  }\x0a\x0a  switch (topLevelType) {\x0a    case TOP_PASTE:\x0a      // If a paste event occurs after a keypress, throw out the input\x0a      // chars. Paste events should not lead to BeforeInput events.\x0a      return null;\x0a    case TOP_KEY_PRESS:\x0a      /**\x0a       * As of v27, Firefox may fire keypress events even when no character\x0a       * will be inserted. A few possibilities:\x0a       *\x0a       * - `which` is `0`. Arrow keys, Esc key, etc.\x0a       *\x0a       * - `which` is the pressed key code, but no char is available.\x0a       *   Ex: \x27AltGr + d` in Polish. There is no modified character for\x0a       *   this key combination and no character is inserted into the\x0a       *   document, but FF fires the keypress for char code `100` anyway.\x0a       *   No `input` event will occur.\x0a       *\x0a       * - `which` is the pressed key code, but a command combination is\x0a       *   being used. Ex: `Cmd+C`. No character is inserted, and no\x0a       *   `input` event will occur.\x0a       */\x0a      if (!isKeypressCommand(nativeEvent)) {\x0a        // IE fires the `keypress` event when a user types an emoji via\x0a        // Touch keyboard of Windows.  In such a case, the `char` property\x0a        // holds an emoji character like `\x5cuD83D\x5cuDE0A`.  Because its length\x0a        // is 2, the property `which` does not represent an emoji correctly.\x0a        // In such a case, we directly return the `char` property instead of\x0a        // using `which`.\x0a        if (nativeEvent.char && nativeEvent.char.length \x3e 1) {\x0a          return nativeEvent.char;\x0a        } else if (nativeEvent.which) {\x0a          return String.fromCharCode(nativeEvent.which);\x0a        }\x0a      }\x0a      return null;\x0a    case TOP_COMPOSITION_END:\x0a      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\x0a    default:\x0a      return null;\x0a  }\x0a}\x0a\x0a/**\x0a * Extract a SyntheticInputEvent for `beforeInput`, based on either native\x0a * `textInput` or fallback behavior.\x0a *\x0a * @return {?object} A SyntheticInputEvent.\x0a */\x0afunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\x0a  var chars = void 0;\x0a\x0a  if (canUseTextInputEvent) {\x0a    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\x0a  } else {\x0a    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\x0a  }\x0a\x0a  // If no characters are being inserted, no BeforeInput event should\x0a  // be fired.\x0a  if (!chars) {\x0a    return null;\x0a  }\x0a\x0a  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\x0a\x0a  event.data = chars;\x0a  accumulateTwoPhaseDispatches(event);\x0a  return event;\x0a}\x0a\x0a/**\x0a * Create an `onBeforeInput` event to match\x0a * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\x0a *\x0a * This event plugin is based on the native `textInput` event\x0a * available in Chrome, Safari, Opera, and IE. This event fires after\x0a * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\x0a *\x0a * `beforeInput` is spec\x27d but not implemented in any browsers, and\x0a * the `input` event does not provide any useful information about what has\x0a * actually been added, contrary to the spec. Thus, `textInput` is the best\x0a * available event to identify the characters that have actually been inserted\x0a * into the target node.\x0a *\x0a * This plugin is also responsible for emitting `composition` events, thus\x0a * allowing us to share composition fallback code for both `beforeInput` and\x0a * `composition` event types.\x0a */\x0avar BeforeInputEventPlugin = {\x0a  eventTypes: eventTypes,\x0a\x0a  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\x0a    var composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\x0a\x0a    var beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\x0a\x0a    if (composition === null) {\x0a      return beforeInput;\x0a    }\x0a\x0a    if (beforeInput === null) {\x0a      return composition;\x0a    }\x0a\x0a    return [composition, beforeInput];\x0a  }\x0a};\x0a\x0a// Use to restore controlled state after a change event has fired.\x0a\x0avar restoreImpl = null;\x0avar restoreTarget = null;\x0avar restoreQueue = null;\x0a\x0afunction restoreStateOfTarget(target) {\x0a  // We perform this translation at the end of the event loop so that we\x0a  // always receive the correct fiber here\x0a  var internalInstance = getInstanceFromNode(target);\x0a  if (!internalInstance) {\x0a    // Unmounted\x0a    return;\x0a  }\x0a  !(typeof restoreImpl === \x27function\x27) ? invariant(false, \x27setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.\x27) : void 0;\x0a  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\x0a  restoreImpl(internalInstance.stateNode, internalInstance.type, props);\x0a}\x0a\x0afunction setRestoreImplementation(impl) {\x0a  restoreImpl = impl;\x0a}\x0a\x0afunction enqueueStateRestore(target) {\x0a  if (restoreTarget) {\x0a    if (restoreQueue) {\x0a      restoreQueue.push(target);\x0a    } else {\x0a      restoreQueue = [target];\x0a    }\x0a  } else {\x0a    restoreTarget = target;\x0a  }\x0a}\x0a\x0afunction needsStateRestore() {\x0a  return restoreTarget !== null || restoreQueue !== null;\x0a}\x0a\x0afunction restoreStateIfNeeded() {\x0a  if (!restoreTarget) {\x0a    return;\x0a  }\x0a  var target = restoreTarget;\x0a  var queuedTargets = restoreQueue;\x0a  restoreTarget = null;\x0a  restoreQueue = null;\x0a\x0a  restoreStateOfTarget(target);\x0a  if (queuedTargets) {\x0a    for (var i = 0; i \x3c queuedTargets.length; i++) {\x0a      restoreStateOfTarget(queuedTargets[i]);\x0a    }\x0a  }\x0a}\x0a\x0a// Used as a way to call batchedUpdates when we don\x27t have a reference to\x0a// the renderer. Such as when we\x27re dispatching events or if third party\x0a// libraries need to call batchedUpdates. Eventually, this API will go away when\x0a// everything is batched by default. We\x27ll then have a similar API to opt-out of\x0a// scheduled work and instead do synchronous work.\x0a\x0a// Defaults\x0avar _batchedUpdatesImpl = function (fn, bookkeeping) {\x0a  return fn(bookkeeping);\x0a};\x0avar _interactiveUpdatesImpl = function (fn, a, b) {\x0a  return fn(a, b);\x0a};\x0avar _flushInteractiveUpdatesImpl = function () {};\x0a\x0avar isBatching = false;\x0afunction batchedUpdates(fn, bookkeeping) {\x0a  if (isBatching) {\x0a    // If we are currently inside another batch, we need to wait until it\x0a    // fully completes before restoring state.\x0a    return fn(bookkeeping);\x0a  }\x0a  isBatching = true;\x0a  try {\x0a    return _batchedUpdatesImpl(fn, bookkeeping);\x0a  } finally {\x0a    // Here we wait until all updates have propagated, which is important\x0a    // when using controlled components within layers:\x0a    // https://github.com/facebook/react/issues/1698\x0a    // Then we restore state of any controlled component.\x0a    isBatching = false;\x0a    var controlledComponentsHavePendingUpdates = needsStateRestore();\x0a    if (controlledComponentsHavePendingUpdates) {\x0a      // If a controlled event was fired, we may need to restore the state of\x0a      // the DOM node back to the controlled value. This is necessary when React\x0a      // bails out of the update without touching the DOM.\x0a      _flushInteractiveUpdatesImpl();\x0a      restoreStateIfNeeded();\x0a    }\x0a  }\x0a}\x0a\x0afunction interactiveUpdates(fn, a, b) {\x0a  return _interactiveUpdatesImpl(fn, a, b);\x0a}\x0a\x0a\x0a\x0afunction setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {\x0a  _batchedUpdatesImpl = batchedUpdatesImpl;\x0a  _interactiveUpdatesImpl = interactiveUpdatesImpl;\x0a  _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;\x0a}\x0a\x0a/**\x0a * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\x0a */\x0avar supportedInputTypes = {\x0a  color: true,\x0a  date: true,\x0a  datetime: true,\x0a  \x27datetime-local\x27: true,\x0a  email: true,\x0a  month: true,\x0a  number: true,\x0a  password: true,\x0a  range: true,\x0a  search: true,\x0a  tel: true,\x0a  text: true,\x0a  time: true,\x0a  url: true,\x0a  week: true\x0a};\x0a\x0afunction isTextInputElement(elem) {\x0a  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\x0a\x0a  if (nodeName === \x27input\x27) {\x0a    return !!supportedInputTypes[elem.type];\x0a  }\x0a\x0a  if (nodeName === \x27textarea\x27) {\x0a    return true;\x0a  }\x0a\x0a  return false;\x0a}\x0a\x0a/**\x0a * HTML nodeType values that represent the type of the node\x0a */\x0a\x0avar ELEMENT_NODE = 1;\x0avar TEXT_NODE = 3;\x0avar COMMENT_NODE = 8;\x0avar DOCUMENT_NODE = 9;\x0avar DOCUMENT_FRAGMENT_NODE = 11;\x0a\x0a/**\x0a * Gets the target node from a native browser event by accounting for\x0a * inconsistencies in browser DOM APIs.\x0a *\x0a * @param {object} nativeEvent Native browser event.\x0a * @return {DOMEventTarget} Target node.\x0a */\x0afunction getEventTarget(nativeEvent) {\x0a  // Fallback to nativeEvent.srcElement for IE9\x0a  // https://github.com/facebook/react/issues/12506\x0a  var target = nativeEvent.target || nativeEvent.srcElement || window;\x0a\x0a  // Normalize SVG \x3cuse\x3e element events #4963\x0a  if (target.correspondingUseElement) {\x0a    target = target.correspondingUseElement;\x0a  }\x0a\x0a  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\x0a  // @see http://www.quirksmode.org/js/events_properties.html\x0a  return target.nodeType === TEXT_NODE ? target.parentNode : target;\x0a}\x0a\x0a/**\x0a * Checks if an event is supported in the current execution environment.\x0a *\x0a * NOTE: This will not work correctly for non-generic events such as `change`,\x0a * `reset`, `load`, `error`, and `select`.\x0a *\x0a * Borrows from Modernizr.\x0a *\x0a * @param {string} eventNameSuffix Event name, e.g. \x22click\x22.\x0a * @return {boolean} True if the event is supported.\x0a * @internal\x0a * @license Modernizr 3.0.0pre (Custom Build) | MIT\x0a */\x0afunction isEventSupported(eventNameSuffix) {\x0a  if (!canUseDOM) {\x0a    return false;\x0a  }\x0a\x0a  var eventName = \x27on\x27 + eventNameSuffix;\x0a  var isSupported = eventName in document;\x0a\x0a  if (!isSupported) {\x0a    var element = document.createElement(\x27div\x27);\x0a    element.setAttribute(eventName, \x27return;\x27);\x0a    isSupported = typeof element[eventName] === \x27function\x27;\x0a  }\x0a\x0a  return isSupported;\x0a}\x0a\x0afunction isCheckable(elem) {\x0a  var type = elem.type;\x0a  var nodeName = elem.nodeName;\x0a  return nodeName && nodeName.toLowerCase() === \x27input\x27 && (type === \x27checkbox\x27 || type === \x27radio\x27);\x0a}\x0a\x0afunction getTracker(node) {\x0a  return node._valueTracker;\x0a}\x0a\x0afunction detachTracker(node) {\x0a  node._valueTracker = null;\x0a}\x0a\x0afunction getValueFromNode(node) {\x0a  var value = \x27\x27;\x0a  if (!node) {\x0a    return value;\x0a  }\x0a\x0a  if (isCheckable(node)) {\x0a    value = node.checked ? \x27true\x27 : \x27false\x27;\x0a  } else {\x0a    value = node.value;\x0a  }\x0a\x0a  return value;\x0a}\x0a\x0afunction trackValueOnNode(node) {\x0a  var valueField = isCheckable(node) ? \x27checked\x27 : \x27value\x27;\x0a  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\x0a\x0a  var currentValue = \x27\x27 + node[valueField];\x0a\x0a  // if someone has already defined a value or Safari, then bail\x0a  // and don\x27t track value will cause over reporting of changes,\x0a  // but it\x27s better then a hard failure\x0a  // (needed for certain tests that spyOn input values and Safari)\x0a  if (node.hasOwnProperty(valueField) || typeof descriptor === \x27undefined\x27 || typeof descriptor.get !== \x27function\x27 || typeof descriptor.set !== \x27function\x27) {\x0a    return;\x0a  }\x0a  var get = descriptor.get,\x0a      set = descriptor.set;\x0a\x0a  Object.defineProperty(node, valueField, {\x0a    configurable: true,\x0a    get: function () {\x0a      return get.call(this);\x0a    },\x0a    set: function (value) {\x0a      currentValue = \x27\x27 + value;\x0a      set.call(this, value);\x0a    }\x0a  });\x0a  // We could\x27ve passed this the first time\x0a  // but it triggers a bug in IE11 and Edge 14/15.\x0a  // Calling defineProperty() again should be equivalent.\x0a  // https://github.com/facebook/react/issues/11768\x0a  Object.defineProperty(node, valueField, {\x0a    enumerable: descriptor.enumerable\x0a  });\x0a\x0a  var tracker = {\x0a    getValue: function () {\x0a      return currentValue;\x0a    },\x0a    setValue: function (value) {\x0a      currentValue = \x27\x27 + value;\x0a    },\x0a    stopTracking: function () {\x0a      detachTracker(node);\x0a      delete node[valueField];\x0a    }\x0a  };\x0a  return tracker;\x0a}\x0a\x0afunction track(node) {\x0a  if (getTracker(node)) {\x0a    return;\x0a  }\x0a\x0a  // TODO: Once it\x27s just Fiber we can move this to node._wrapperState\x0a  node._valueTracker = trackValueOnNode(node);\x0a}\x0a\x0afunction updateValueIfChanged(node) {\x0a  if (!node) {\x0a    return false;\x0a  }\x0a\x0a  var tracker = getTracker(node);\x0a  // if there is no tracker at this point it\x27s unlikely\x0a  // that trying again will succeed\x0a  if (!tracker) {\x0a    return true;\x0a  }\x0a\x0a  var lastValue = tracker.getValue();\x0a  var nextValue = getValueFromNode(node);\x0a  if (nextValue !== lastValue) {\x0a    tracker.setValue(nextValue);\x0a    return true;\x0a  }\x0a  return false;\x0a}\x0a\x0avar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\x0a\x0a// Prevent newer renderers from RTE when used with older react package versions.\x0a// Current owner and dispatcher used to share the same ref,\x0a// but PR #14548 split them out to better support the react-debug-tools package.\x0aif (!ReactSharedInternals.hasOwnProperty(\x27ReactCurrentDispatcher\x27)) {\x0a  ReactSharedInternals.ReactCurrentDispatcher = {\x0a    current: null\x0a  };\x0a}\x0a\x0avar BEFORE_SLASH_RE = /^(.*)[\x5c\x5c\x5c/]/;\x0a\x0avar describeComponentFrame = function (name, source, ownerName) {\x0a  var sourceInfo = \x27\x27;\x0a  if (source) {\x0a    var path = source.fileName;\x0a    var fileName = path.replace(BEFORE_SLASH_RE, \x27\x27);\x0a    {\x0a      // In DEV, include code for a common special case:\x0a      // prefer \x22folder/index.js\x22 instead of just \x22index.js\x22.\x0a      if (/^index\x5c./.test(fileName)) {\x0a        var match = path.match(BEFORE_SLASH_RE);\x0a        if (match) {\x0a          var pathBeforeSlash = match[1];\x0a          if (pathBeforeSlash) {\x0a            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, \x27\x27);\x0a            fileName = folderName + \x27/\x27 + fileName;\x0a          }\x0a        }\x0a      }\x0a    }\x0a    sourceInfo = \x27 (at \x27 + fileName + \x27:\x27 + source.lineNumber + \x27)\x27;\x0a  } else if (ownerName) {\x0a    sourceInfo = \x27 (created by \x27 + ownerName + \x27)\x27;\x0a  }\x0a  return \x27\x5cn    in \x27 + (name || \x27Unknown\x27) + sourceInfo;\x0a};\x0a\x0a// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\x0a// nor polyfill, then a plain number is used for performance.\x0avar hasSymbol = typeof Symbol === \x27function\x27 && Symbol.for;\x0a\x0avar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\x27react.element\x27) : 0xeac7;\x0avar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\x27react.portal\x27) : 0xeaca;\x0avar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\x27react.fragment\x27) : 0xeacb;\x0avar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\x27react.strict_mode\x27) : 0xeacc;\x0avar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\x27react.profiler\x27) : 0xead2;\x0avar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\x27react.provider\x27) : 0xeacd;\x0avar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\x27react.context\x27) : 0xeace;\x0a\x0avar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\x27react.concurrent_mode\x27) : 0xeacf;\x0avar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\x27react.forward_ref\x27) : 0xead0;\x0avar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\x27react.suspense\x27) : 0xead1;\x0avar REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\x27react.memo\x27) : 0xead3;\x0avar REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\x27react.lazy\x27) : 0xead4;\x0a\x0avar MAYBE_ITERATOR_SYMBOL = typeof Symbol === \x27function\x27 && Symbol.iterator;\x0avar FAUX_ITERATOR_SYMBOL = \x27@@iterator\x27;\x0a\x0afunction getIteratorFn(maybeIterable) {\x0a  if (maybeIterable === null || typeof maybeIterable !== \x27object\x27) {\x0a    return null;\x0a  }\x0a  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\x0a  if (typeof maybeIterator === \x27function\x27) {\x0a    return maybeIterator;\x0a  }\x0a  return null;\x0a}\x0a\x0avar Pending = 0;\x0avar Resolved = 1;\x0avar Rejected = 2;\x0a\x0afunction refineResolvedLazyComponent(lazyComponent) {\x0a  return lazyComponent._status === Resolved ? lazyComponent._result : null;\x0a}\x0a\x0afunction getWrappedName(outerType, innerType, wrapperName) {\x0a  var functionName = innerType.displayName || innerType.name || \x27\x27;\x0a  return outerType.displayName || (functionName !== \x27\x27 ? wrapperName + \x27(\x27 + functionName + \x27)\x27 : wrapperName);\x0a}\x0a\x0afunction getComponentName(type) {\x0a  if (type == null) {\x0a    // Host root, text node or just invalid type.\x0a    return null;\x0a  }\x0a  {\x0a    if (typeof type.tag === \x27number\x27) {\x0a      warningWithoutStack$1(false, \x27Received an unexpected object in getComponentName(). \x27 + \x27This is likely a bug in React. Please file an issue.\x27);\x0a    }\x0a  }\x0a  if (typeof type === \x27function\x27) {\x0a    return type.displayName || type.name || null;\x0a  }\x0a  if (typeof type === \x27string\x27) {\x0a    return type;\x0a  }\x0a  switch (type) {\x0a    case REACT_CONCURRENT_MODE_TYPE:\x0a      return \x27ConcurrentMode\x27;\x0a    case REACT_FRAGMENT_TYPE:\x0a      return \x27Fragment\x27;\x0a    case REACT_PORTAL_TYPE:\x0a      return \x27Portal\x27;\x0a    case REACT_PROFILER_TYPE:\x0a      return \x27Profiler\x27;\x0a    case REACT_STRICT_MODE_TYPE:\x0a      return \x27StrictMode\x27;\x0a    case REACT_SUSPENSE_TYPE:\x0a      return \x27Suspense\x27;\x0a  }\x0a  if (typeof type === \x27object\x27) {\x0a    switch (type.$$typeof) {\x0a      case REACT_CONTEXT_TYPE:\x0a        return \x27Context.Consumer\x27;\x0a      case REACT_PROVIDER_TYPE:\x0a        return \x27Context.Provider\x27;\x0a      case REACT_FORWARD_REF_TYPE:\x0a        return getWrappedName(type, type.render, \x27ForwardRef\x27);\x0a      case REACT_MEMO_TYPE:\x0a        return getComponentName(type.type);\x0a      case REACT_LAZY_TYPE:\x0a        {\x0a          var thenable = type;\x0a          var resolvedThenable = refineResolvedLazyComponent(thenable);\x0a          if (resolvedThenable) {\x0a            return getComponentName(resolvedThenable);\x0a          }\x0a        }\x0a    }\x0a  }\x0a  return null;\x0a}\x0a\x0avar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\x0a\x0afunction describeFiber(fiber) {\x0a  switch (fiber.tag) {\x0a    case HostRoot:\x0a    case HostPortal:\x0a    case HostText:\x0a    case Fragment:\x0a    case ContextProvider:\x0a    case ContextConsumer:\x0a      return \x27\x27;\x0a    default:\x0a      var owner = fiber._debugOwner;\x0a      var source = fiber._debugSource;\x0a      var name = getComponentName(fiber.type);\x0a      var ownerName = null;\x0a      if (owner) {\x0a        ownerName = getComponentName(owner.type);\x0a      }\x0a      return describeComponentFrame(name, source, ownerName);\x0a  }\x0a}\x0a\x0afunction getStackByFiberInDevAndProd(workInProgress) {\x0a  var info = \x27\x27;\x0a  var node = workInProgress;\x0a  do {\x0a    info += describeFiber(node);\x0a    node = node.return;\x0a  } while (node);\x0a  return info;\x0a}\x0a\x0avar current = null;\x0avar phase = null;\x0a\x0afunction getCurrentFiberOwnerNameInDevOrNull() {\x0a  {\x0a    if (current === null) {\x0a      return null;\x0a    }\x0a    var owner = current._debugOwner;\x0a    if (owner !== null && typeof owner !== \x27undefined\x27) {\x0a      return getComponentName(owner.type);\x0a    }\x0a  }\x0a  return null;\x0a}\x0a\x0afunction getCurrentFiberStackInDev() {\x0a  {\x0a    if (current === null) {\x0a      return \x27\x27;\x0a    }\x0a    // Safe because if current fiber exists, we are reconciling,\x0a    // and it is guaranteed to be the work-in-progress version.\x0a    return getStackByFiberInDevAndProd(current);\x0a  }\x0a  return \x27\x27;\x0a}\x0a\x0afunction resetCurrentFiber() {\x0a  {\x0a    ReactDebugCurrentFrame.getCurrentStack = null;\x0a    current = null;\x0a    phase = null;\x0a  }\x0a}\x0a\x0afunction setCurrentFiber(fiber) {\x0a  {\x0a    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;\x0a    current = fiber;\x0a    phase = null;\x0a  }\x0a}\x0a\x0afunction setCurrentPhase(lifeCyclePhase) {\x0a  {\x0a    phase = lifeCyclePhase;\x0a  }\x0a}\x0a\x0a/**\x0a * Similar to invariant but only logs a warning if the condition is not met.\x0a * This can be used to log issues in development environments in critical\x0a * paths. Removing the logging code for production environments will keep the\x0a * same logic and follow the same code paths.\x0a */\x0a\x0avar warning = warningWithoutStack$1;\x0a\x0a{\x0a  warning = function (condition, format) {\x0a    if (condition) {\x0a      return;\x0a    }\x0a    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\x0a    var stack = ReactDebugCurrentFrame.getStackAddendum();\x0a    // eslint-disable-next-line react-internal/warning-and-invariant-args\x0a\x0a    for (var _len = arguments.length, args = Array(_len \x3e 2 ? _len - 2 : 0), _key = 2; _key \x3c _len; _key++) {\x0a      args[_key - 2] = arguments[_key];\x0a    }\x0a\x0a    warningWithoutStack$1.apply(undefined, [false, format + \x27%s\x27].concat(args, [stack]));\x0a  };\x0a}\x0a\x0avar warning$1 = warning;\x0a\x0a// A reserved attribute.\x0a// It is handled by React separately and shouldn\x27t be written to the DOM.\x0avar RESERVED = 0;\x0a\x0a// A simple string attribute.\x0a// Attributes that aren\x27t in the whitelist are presumed to have this type.\x0avar STRING = 1;\x0a\x0a// A string attribute that accepts booleans in React. In HTML, these are called\x0a// \x22enumerated\x22 attributes with \x22true\x22 and \x22false\x22 as possible values.\x0a// When true, it should be set to a \x22true\x22 string.\x0a// When false, it should be set to a \x22false\x22 string.\x0avar BOOLEANISH_STRING = 2;\x0a\x0a// A real boolean attribute.\x0a// When true, it should be present (set either to an empty string or its name).\x0a// When false, it should be omitted.\x0avar BOOLEAN = 3;\x0a\x0a// An attribute that can be used as a flag as well as with a value.\x0a// When true, it should be present (set either to an empty string or its name).\x0a// When false, it should be omitted.\x0a// For any other value, should be present with that value.\x0avar OVERLOADED_BOOLEAN = 4;\x0a\x0a// An attribute that must be numeric or parse as a numeric.\x0a// When falsy, it should be removed.\x0avar NUMERIC = 5;\x0a\x0a// An attribute that must be positive numeric or parse as a positive numeric.\x0a// When falsy, it should be removed.\x0avar POSITIVE_NUMERIC = 6;\x0a\x0a/* eslint-disable max-len */\x0avar ATTRIBUTE_NAME_START_CHAR = \x27:A-Z_a-z\x5c\x5cu00C0-\x5c\x5cu00D6\x5c\x5cu00D8-\x5c\x5cu00F6\x5c\x5cu00F8-\x5c\x5cu02FF\x5c\x5cu0370-\x5c\x5cu037D\x5c\x5cu037F-\x5c\x5cu1FFF\x5c\x5cu200C-\x5c\x5cu200D\x5c\x5cu2070-\x5c\x5cu218F\x5c\x5cu2C00-\x5c\x5cu2FEF\x5c\x5cu3001-\x5c\x5cuD7FF\x5c\x5cuF900-\x5c\x5cuFDCF\x5c\x5cuFDF0-\x5c\x5cuFFFD\x27;\x0a/* eslint-enable max-len */\x0avar ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \x27\x5c\x5c-.0-9\x5c\x5cu00B7\x5c\x5cu0300-\x5c\x5cu036F\x5c\x5cu203F-\x5c\x5cu2040\x27;\x0a\x0a\x0avar ROOT_ATTRIBUTE_NAME = \x27data-reactroot\x27;\x0avar VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\x27^[\x27 + ATTRIBUTE_NAME_START_CHAR + \x27][\x27 + ATTRIBUTE_NAME_CHAR + \x27]*$\x27);\x0a\x0avar hasOwnProperty = Object.prototype.hasOwnProperty;\x0avar illegalAttributeNameCache = {};\x0avar validatedAttributeNameCache = {};\x0a\x0afunction isAttributeNameSafe(attributeName) {\x0a  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\x0a    return true;\x0a  }\x0a  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\x0a    return false;\x0a  }\x0a  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\x0a    validatedAttributeNameCache[attributeName] = true;\x0a    return true;\x0a  }\x0a  illegalAttributeNameCache[attributeName] = true;\x0a  {\x0a    warning$1(false, \x27Invalid attribute name: `%s`\x27, attributeName);\x0a  }\x0a  return false;\x0a}\x0a\x0afunction shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {\x0a  if (propertyInfo !== null) {\x0a    return propertyInfo.type === RESERVED;\x0a  }\x0a  if (isCustomComponentTag) {\x0a    return false;\x0a  }\x0a  if (name.length \x3e 2 && (name[0] === \x27o\x27 || name[0] === \x27O\x27) && (name[1] === \x27n\x27 || name[1] === \x27N\x27)) {\x0a    return true;\x0a  }\x0a  return false;\x0a}\x0a\x0afunction shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\x0a  if (propertyInfo !== null && propertyInfo.type === RESERVED) {\x0a    return false;\x0a  }\x0a  switch (typeof value) {\x0a    case \x27function\x27:\x0a    // $FlowIssue symbol is perfectly valid here\x0a    case \x27symbol\x27:\x0a      // eslint-disable-line\x0a      return true;\x0a    case \x27boolean\x27:\x0a      {\x0a        if (isCustomComponentTag) {\x0a          return false;\x0a        }\x0a        if (propertyInfo !== null) {\x0a          return !propertyInfo.acceptsBooleans;\x0a        } else {\x0a          var prefix = name.toLowerCase().slice(0, 5);\x0a          return prefix !== \x27data-\x27 && prefix !== \x27aria-\x27;\x0a        }\x0a      }\x0a    default:\x0a      return false;\x0a  }\x0a}\x0a\x0afunction shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {\x0a  if (value === null || typeof value === \x27undefined\x27) {\x0a    return true;\x0a  }\x0a  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {\x0a    return true;\x0a  }\x0a  if (isCustomComponentTag) {\x0a    return false;\x0a  }\x0a  if (propertyInfo !== null) {\x0a    switch (propertyInfo.type) {\x0a      case BOOLEAN:\x0a        return !value;\x0a      case OVERLOADED_BOOLEAN:\x0a        return value === false;\x0a      case NUMERIC:\x0a        return isNaN(value);\x0a      case POSITIVE_NUMERIC:\x0a        return isNaN(value) || value \x3c 1;\x0a    }\x0a  }\x0a  return false;\x0a}\x0a\x0afunction getPropertyInfo(name) {\x0a  return properties.hasOwnProperty(name) ? properties[name] : null;\x0a}\x0a\x0afunction PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace) {\x0a  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\x0a  this.attributeName = attributeName;\x0a  this.attributeNamespace = attributeNamespace;\x0a  this.mustUseProperty = mustUseProperty;\x0a  this.propertyName = name;\x0a  this.type = type;\x0a}\x0a\x0a// When adding attributes to this list, be sure to also add them to\x0a// the `possibleStandardNames` module to ensure casing and incorrect\x0a// name warnings.\x0avar properties = {};\x0a\x0a// These props are reserved by React. They shouldn\x27t be written to the DOM.\x0a[\x27children\x27, \x27dangerouslySetInnerHTML\x27,\x0a// TODO: This prevents the assignment of defaultValue to regular\x0a// elements (not just inputs). Now that ReactDOMInput assigns to the\x0a// defaultValue property -- do we need this?\x0a\x27defaultValue\x27, \x27defaultChecked\x27, \x27innerHTML\x27, \x27suppressContentEditableWarning\x27, \x27suppressHydrationWarning\x27, \x27style\x27].forEach(function (name) {\x0a  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty\x0a  name, // attributeName\x0a  null);\x0a} // attributeNamespace\x0a);\x0a\x0a// A few React string attributes have a different name.\x0a// This is a mapping from React prop names to the attribute names.\x0a[[\x27acceptCharset\x27, \x27accept-charset\x27], [\x27className\x27, \x27class\x27], [\x27htmlFor\x27, \x27for\x27], [\x27httpEquiv\x27, \x27http-equiv\x27]].forEach(function (_ref) {\x0a  var name = _ref[0],\x0a      attributeName = _ref[1];\x0a\x0a  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\x0a  attributeName, // attributeName\x0a  null);\x0a} // attributeNamespace\x0a);\x0a\x0a// These are \x22enumerated\x22 HTML attributes that accept \x22true\x22 and \x22false\x22.\x0a// In React, we let users pass `true` and `false` even though technically\x0a// these aren\x27t boolean attributes (they are coerced to strings).\x0a[\x27contentEditable\x27, \x27draggable\x27, \x27spellCheck\x27, \x27value\x27].forEach(function (name) {\x0a  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\x0a  name.toLowerCase(), // attributeName\x0a  null);\x0a} // attributeNamespace\x0a);\x0a\x0a// These are \x22enumerated\x22 SVG attributes that accept \x22true\x22 and \x22false\x22.\x0a// In React, we let users pass `true` and `false` even though technically\x0a// these aren\x27t boolean attributes (they are coerced to strings).\x0a// Since these are SVG attributes, their attribute names are case-sensitive.\x0a[\x27autoReverse\x27, \x27externalResourcesRequired\x27, \x27focusable\x27, \x27preserveAlpha\x27].forEach(function (name) {\x0a  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\x0a  name, // attributeName\x0a  null);\x0a} // attributeNamespace\x0a);\x0a\x0a// These are HTML boolean attributes.\x0a[\x27allowFullScreen\x27, \x27async\x27,\x0a// Note: there is a special case that prevents it from being written to the DOM\x0a// on the client side because the browsers are inconsistent. Instead we call focus().\x0a\x27autoFocus\x27, \x27autoPlay\x27, \x27controls\x27, \x27default\x27, \x27defer\x27, \x27disabled\x27, \x27formNoValidate\x27, \x27hidden\x27, \x27loop\x27, \x27noModule\x27, \x27noValidate\x27, \x27open\x27, \x27playsInline\x27, \x27readOnly\x27, \x27required\x27, \x27reversed\x27, \x27scoped\x27, \x27seamless\x27,\x0a// Microdata\x0a\x27itemScope\x27].forEach(function (name) {\x0a  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty\x0a  name.toLowerCase(), // attributeName\x0a  null);\x0a} // attributeNamespace\x0a);\x0a\x0a// These are the few React props that we set as DOM properties\x0a// rather than attributes. These are all booleans.\x0a[\x27checked\x27,\x0a// Note: `option.selected` is not updated if `select.multiple` is\x0a// disabled with `removeAttribute`. We have special logic for handling this.\x0a\x27multiple\x27, \x27muted\x27, \x27selected\x27].forEach(function (name) {\x0a  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty\x0a  name, // attributeName\x0a  null);\x0a} // attributeNamespace\x0a);\x0a\x0a// These are HTML attributes that are \x22overloaded booleans\x22: they behave like\x0a// booleans, but can also accept a string value.\x0a[\x27capture\x27, \x27download\x27].forEach(function (name) {\x0a  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty\x0a  name, // attributeName\x0a  null);\x0a} // attributeNamespace\x0a);\x0a\x0a// These are HTML attributes that must be positive numbers.\x0a[\x27cols\x27, \x27rows\x27, \x27size\x27, \x27span\x27].forEach(function (name) {\x0a  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty\x0a  name, // attributeName\x0a  null);\x0a} // attributeNamespace\x0a);\x0a\x0a// These are HTML attributes that must be numbers.\x0a[\x27rowSpan\x27, \x27start\x27].forEach(function (name) {\x0a  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty\x0a  name.toLowerCase(), // attributeName\x0a  null);\x0a} // attributeNamespace\x0a);\x0a\x0avar CAMELIZE = /[\x5c-\x5c:]([a-z])/g;\x0avar capitalize = function (token) {\x0a  return token[1].toUpperCase();\x0a};\x0a\x0a// This is a list of all SVG attributes that need special casing, namespacing,\x0a// or boolean value assignment. Regular attributes that just accept strings\x0a// and have the same names are omitted, just like in the HTML whitelist.\x0a// Some of these attributes can be hard to find. This list was created by\x0a// scrapping the MDN documentation.\x0a[\x27accent-height\x27, \x27alignment-baseline\x27, \x27arabic-form\x27, \x27baseline-shift\x27, \x27cap-height\x27, \x27clip-path\x27, \x27clip-rule\x27, \x27color-interpolation\x27, \x27color-interpolation-filters\x27, \x27color-profile\x27, \x27color-rendering\x27, \x27dominant-baseline\x27, \x27enable-background\x27, \x27fill-opacity\x27, \x27fill-rule\x27, \x27flood-color\x27, \x27flood-opacity\x27, \x27font-family\x27, \x27font-size\x27, \x27font-size-adjust\x27, \x27font-stretch\x27, \x27font-style\x27, \x27font-variant\x27, \x27font-weight\x27, \x27glyph-name\x27, \x27glyph-orientation-horizontal\x27, \x27glyph-orientation-vertical\x27, \x27horiz-adv-x\x27, \x27horiz-origin-x\x27, \x27image-rendering\x27, \x27letter-spacing\x27, \x27lighting-color\x27, \x27marker-end\x27, \x27marker-mid\x27, \x27marker-start\x27, \x27overline-position\x27, \x27overline-thickness\x27, \x27paint-order\x27, \x27panose-1\x27, \x27pointer-events\x27, \x27rendering-intent\x27, \x27shape-rendering\x27, \x27stop-color\x27, \x27stop-opacity\x27, \x27strikethrough-position\x27, \x27strikethrough-thickness\x27, \x27stroke-dasharray\x27, \x27stroke-dashoffset\x27, \x27stroke-linecap\x27, \x27stroke-linejoin\x27, \x27stroke-miterlimit\x27, \x27stroke-opacity\x27, \x27stroke-width\x27, \x27text-anchor\x27, \x27text-decoration\x27, \x27text-rendering\x27, \x27underline-position\x27, \x27underline-thickness\x27, \x27unicode-bidi\x27, \x27unicode-range\x27, \x27units-per-em\x27, \x27v-alphabetic\x27, \x27v-hanging\x27, \x27v-ideographic\x27, \x27v-mathematical\x27, \x27vector-effect\x27, \x27vert-adv-y\x27, \x27vert-origin-x\x27, \x27vert-origin-y\x27, \x27word-spacing\x27, \x27writing-mode\x27, \x27xmlns:xlink\x27, \x27x-height\x27].forEach(function (attributeName) {\x0a  var name = attributeName.replace(CAMELIZE, capitalize);\x0a  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\x0a  attributeName, null);\x0a} // attributeNamespace\x0a);\x0a\x0a// String SVG attributes with the xlink namespace.\x0a[\x27xlink:actuate\x27, \x27xlink:arcrole\x27, \x27xlink:href\x27, \x27xlink:role\x27, \x27xlink:show\x27, \x27xlink:title\x27, \x27xlink:type\x27].forEach(function (attributeName) {\x0a  var name = attributeName.replace(CAMELIZE, capitalize);\x0a  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\x0a  attributeName, \x27http://www.w3.org/1999/xlink\x27);\x0a});\x0a\x0a// String SVG attributes with the xml namespace.\x0a[\x27xml:base\x27, \x27xml:lang\x27, \x27xml:space\x27].forEach(function (attributeName) {\x0a  var name = attributeName.replace(CAMELIZE, capitalize);\x0a  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\x0a  attributeName, \x27http://www.w3.org/XML/1998/namespace\x27);\x0a});\x0a\x0a// These attribute exists both in HTML and SVG.\x0a// The attribute name is case-sensitive in SVG so we can\x27t just use\x0a// the React name like we do for attributes that exist only in HTML.\x0a[\x27tabIndex\x27, \x27crossOrigin\x27].forEach(function (attributeName) {\x0a  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty\x0a  attributeName.toLowerCase(), // attributeName\x0a  null);\x0a} // attributeNamespace\x0a);\x0a\x0a/**\x0a * Get the value for a property on a node. Only used in DEV for SSR validation.\x0a * The \x22expected\x22 argument is used as a hint of what the expected value is.\x0a * Some properties have multiple equivalent values.\x0a */\x0afunction getValueForProperty(node, name, expected, propertyInfo) {\x0a  {\x0a    if (propertyInfo.mustUseProperty) {\x0a      var propertyName = propertyInfo.propertyName;\x0a\x0a      return node[propertyName];\x0a    } else {\x0a      var attributeName = propertyInfo.attributeName;\x0a\x0a      var stringValue = null;\x0a\x0a      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\x0a        if (node.hasAttribute(attributeName)) {\x0a          var value = node.getAttribute(attributeName);\x0a          if (value === \x27\x27) {\x0a            return true;\x0a          }\x0a          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\x0a            return value;\x0a          }\x0a          if (value === \x27\x27 + expected) {\x0a            return expected;\x0a          }\x0a          return value;\x0a        }\x0a      } else if (node.hasAttribute(attributeName)) {\x0a        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\x0a          // We had an attribute but shouldn\x27t have had one, so read it\x0a          // for the error message.\x0a          return node.getAttribute(attributeName);\x0a        }\x0a        if (propertyInfo.type === BOOLEAN) {\x0a          // If this was a boolean, it doesn\x27t matter what the value is\x0a          // the fact that we have it is the same as the expected.\x0a          return expected;\x0a        }\x0a        // Even if this property uses a namespace we use getAttribute\x0a        // because we assume its namespaced name is the same as our config.\x0a        // To use getAttributeNS we need the local name which we don\x27t have\x0a        // in our config atm.\x0a        stringValue = node.getAttribute(attributeName);\x0a      }\x0a\x0a      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\x0a        return stringValue === null ? expected : stringValue;\x0a      } else if (stringValue === \x27\x27 + expected) {\x0a        return expected;\x0a      } else {\x0a        return stringValue;\x0a      }\x0a    }\x0a  }\x0a}\x0a\x0a/**\x0a * Get the value for a attribute on a node. Only used in DEV for SSR validation.\x0a * The third argument is used as a hint of what the expected value is. Some\x0a * attributes have multiple equivalent values.\x0a */\x0afunction getValueForAttribute(node, name, expected) {\x0a  {\x0a    if (!isAttributeNameSafe(name)) {\x0a      return;\x0a    }\x0a    if (!node.hasAttribute(name)) {\x0a      return expected === undefined ? undefined : null;\x0a    }\x0a    var value = node.getAttribute(name);\x0a    if (value === \x27\x27 + expected) {\x0a      return expected;\x0a    }\x0a    return value;\x0a  }\x0a}\x0a\x0a/**\x0a * Sets the value for a property on a node.\x0a *\x0a * @param {DOMElement} node\x0a * @param {string} name\x0a * @param {*} value\x0a */\x0afunction setValueForProperty(node, name, value, isCustomComponentTag) {\x0a  var propertyInfo = getPropertyInfo(name);\x0a  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\x0a    return;\x0a  }\x0a  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\x0a    value = null;\x0a  }\x0a  // If the prop isn\x27t in the special list, treat it as a simple attribute.\x0a  if (isCustomComponentTag || propertyInfo === null) {\x0a    if (isAttributeNameSafe(name)) {\x0a      var _attributeName = name;\x0a      if (value === null) {\x0a        node.removeAttribute(_attributeName);\x0a      } else {\x0a        node.setAttribute(_attributeName, \x27\x27 + value);\x0a      }\x0a    }\x0a    return;\x0a  }\x0a  var mustUseProperty = propertyInfo.mustUseProperty;\x0a\x0a  if (mustUseProperty) {\x0a    var propertyName = propertyInfo.propertyName;\x0a\x0a    if (value === null) {\x0a      var type = propertyInfo.type;\x0a\x0a      node[propertyName] = type === BOOLEAN ? false : \x27\x27;\x0a    } else {\x0a      // Contrary to `setAttribute`, object properties are properly\x0a      // `toString`ed by IE8/9.\x0a      node[propertyName] = value;\x0a    }\x0a    return;\x0a  }\x0a  // The rest are treated as attributes with special cases.\x0a  var attributeName = propertyInfo.attributeName,\x0a      attributeNamespace = propertyInfo.attributeNamespace;\x0a\x0a  if (value === null) {\x0a    node.removeAttribute(attributeName);\x0a  } else {\x0a    var _type = propertyInfo.type;\x0a\x0a    var attributeValue = void 0;\x0a    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {\x0a      attributeValue = \x27\x27;\x0a    } else {\x0a      // `setAttribute` with objects becomes only `[object]` in IE8/9,\x0a      // (\x27\x27 + value) makes it output the correct toString()-value.\x0a      attributeValue = \x27\x27 + value;\x0a    }\x0a    if (attributeNamespace) {\x0a      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\x0a    } else {\x0a      node.setAttribute(attributeName, attributeValue);\x0a    }\x0a  }\x0a}\x0a\x0a// Flow does not allow string concatenation of most non-string types. To work\x0a// around this limitation, we use an opaque type that can only be obtained by\x0a// passing the value through getToStringValue first.\x0afunction toString(value) {\x0a  return \x27\x27 + value;\x0a}\x0a\x0afunction getToStringValue(value) {\x0a  switch (typeof value) {\x0a    case \x27boolean\x27:\x0a    case \x27number\x27:\x0a    case \x27object\x27:\x0a    case \x27string\x27:\x0a    case \x27undefined\x27:\x0a      return value;\x0a    default:\x0a      // function, symbol are assigned as empty strings\x0a      return \x27\x27;\x0a  }\x0a}\x0a\x0a/**\x0a * Copyright (c) 2013-present, Facebook, Inc.\x0a *\x0a * This source code is licensed under the MIT license found in the\x0a * LICENSE file in the root directory of this source tree.\x0a */\x0a\x0a\x0a\x0avar ReactPropTypesSecret$1 = \x27SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\x27;\x0a\x0avar ReactPropTypesSecret_1 = ReactPropTypesSecret$1;\x0a\x0a/**\x0a * Copyright (c) 2013-present, Facebook, Inc.\x0a *\x0a * This source code is licensed under the MIT license found in the\x0a * LICENSE file in the root directory of this source tree.\x0a */\x0a\x0a\x0a\x0avar printWarning = function() {};\x0a\x0a{\x0a  var ReactPropTypesSecret = ReactPropTypesSecret_1;\x0a  var loggedTypeFailures = {};\x0a\x0a  printWarning = function(text) {\x0a    var message = \x27Warning: \x27 + text;\x0a    if (typeof console !== \x27undefined\x27) {\x0a      console.error(message);\x0a    }\x0a    try {\x0a      // --- Welcome to debugging React ---\x0a      // This error was thrown as a convenience so that you can use this stack\x0a      // to find the callsite that caused this warning to fire.\x0a      throw new Error(message);\x0a    } catch (x) {}\x0a  };\x0a}\x0a\x0a/**\x0a * Assert that the values match with the type specs.\x0a * Error messages are memorized and will only be shown once.\x0a *\x0a * @param {object} typeSpecs Map of name to a ReactPropType\x0a * @param {object} values Runtime values that need to be type-checked\x0a * @param {string} location e.g. \x22prop\x22, \x22context\x22, \x22child context\x22\x0a * @param {string} componentName Name of the component for error messages.\x0a * @param {?Function} getStack Returns the component stack.\x0a * @private\x0a */\x0afunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\x0a  {\x0a    for (var typeSpecName in typeSpecs) {\x0a      if (typeSpecs.hasOwnProperty(typeSpecName)) {\x0a        var error;\x0a        // Prop type validation may throw. In case they do, we don\x27t want to\x0a        // fail the render phase where it didn\x27t fail before. So we log it.\x0a        // After these have been cleaned up, we\x27ll let them throw.\x0a        try {\x0a          // This is intentionally an invariant that gets caught. It\x27s the same\x0a          // behavior as without this statement except with a better message.\x0a          if (typeof typeSpecs[typeSpecName] !== \x27function\x27) {\x0a            var err = Error(\x0a              (componentName || \x27React class\x27) + \x27: \x27 + location + \x27 type `\x27 + typeSpecName + \x27` is invalid; \x27 +\x0a              \x27it must be a function, usually from the `prop-types` package, but received `\x27 + typeof typeSpecs[typeSpecName] + \x27`.\x27\x0a            );\x0a            err.name = \x27Invariant Violation\x27;\x0a            throw err;\x0a          }\x0a          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\x0a        } catch (ex) {\x0a          error = ex;\x0a        }\x0a        if (error && !(error instanceof Error)) {\x0a          printWarning(\x0a            (componentName || \x27React class\x27) + \x27: type specification of \x27 +\x0a            location + \x27 `\x27 + typeSpecName + \x27` is invalid; the type checker \x27 +\x0a            \x27function must return `null` or an `Error` but returned a \x27 + typeof error + \x27. \x27 +\x0a            \x27You may have forgotten to pass an argument to the type checker \x27 +\x0a            \x27creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \x27 +\x0a            \x27shape all require an argument).\x27\x0a          );\x0a\x0a        }\x0a        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\x0a          // Only monitor this failure once because there tends to be a lot of the\x0a          // same error.\x0a          loggedTypeFailures[error.message] = true;\x0a\x0a          var stack = getStack ? getStack() : \x27\x27;\x0a\x0a          printWarning(\x0a            \x27Failed \x27 + location + \x27 type: \x27 + error.message + (stack != null ? stack : \x27\x27)\x0a          );\x0a        }\x0a      }\x0a    }\x0a  }\x0a}\x0a\x0avar checkPropTypes_1 = checkPropTypes;\x0a\x0avar ReactDebugCurrentFrame$1 = null;\x0a\x0avar ReactControlledValuePropTypes = {\x0a  checkPropTypes: null\x0a};\x0a\x0a{\x0a  ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\x0a\x0a  var hasReadOnlyValue = {\x0a    button: true,\x0a    checkbox: true,\x0a    image: true,\x0a    hidden: true,\x0a    radio: true,\x0a    reset: true,\x0a    submit: true\x0a  };\x0a\x0a  var propTypes = {\x0a    value: function (props, propName, componentName) {\x0a      if (hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled || props[propName] == null) {\x0a        return null;\x0a      }\x0a      return new Error(\x27You provided a `value` prop to a form field without an \x27 + \x27`onChange` handler. This will render a read-only field. If \x27 + \x27the field should be mutable use `defaultValue`. Otherwise, \x27 + \x27set either `onChange` or `readOnly`.\x27);\x0a    },\x0a    checked: function (props, propName, componentName) {\x0a      if (props.onChange || props.readOnly || props.disabled || props[propName] == null) {\x0a        return null;\x0a      }\x0a      return new Error(\x27You provided a `checked` prop to a form field without an \x27 + \x27`onChange` handler. This will render a read-only field. If \x27 + \x27the field should be mutable use `defaultChecked`. Otherwise, \x27 + \x27set either `onChange` or `readOnly`.\x27);\x0a    }\x0a  };\x0a\x0a  /**\x0a   * Provide a linked `value` attribute for controlled forms. You should not use\x0a   * this outside of the ReactDOM controlled form components.\x0a   */\x0a  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props) {\x0a    checkPropTypes_1(propTypes, props, \x27prop\x27, tagName, ReactDebugCurrentFrame$1.getStackAddendum);\x0a  };\x0a}\x0a\x0avar enableUserTimingAPI = true;\x0a\x0a// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\x0avar debugRenderPhaseSideEffects = false;\x0a\x0a// In some cases, StrictMode should also double-render lifecycles.\x0a// This can be confusing for tests though,\x0a// And it can be bad for performance in production.\x0a// This feature flag can be used to control the behavior:\x0avar debugRenderPhaseSideEffectsForStrictMode = true;\x0a\x0a// To preserve the \x22Pause on caught exceptions\x22 behavior of the debugger, we\x0a// replay the begin phase of a failed component inside invokeGuardedCallback.\x0avar replayFailedUnitOfWorkWithInvokeGuardedCallback = true;\x0a\x0a// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\x0avar warnAboutDeprecatedLifecycles = false;\x0a\x0a// Gather advanced timing metrics for Profiler subtrees.\x0avar enableProfilerTimer = true;\x0a\x0a// Trace which interactions trigger each commit.\x0avar enableSchedulerTracing = true;\x0a\x0a// Only used in www builds.\x0avar enableSuspenseServerRenderer = false; // TODO: true? Here it might just be false.\x0a\x0a// Only used in www builds.\x0a\x0a\x0a// Only used in www builds.\x0a\x0a\x0a// React Fire: prevent the value and checked attributes from syncing\x0a// with their related DOM properties\x0avar disableInputAttributeSyncing = false;\x0a\x0a// These APIs will no longer be \x22unstable\x22 in the upcoming 16.7 release,\x0a// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.\x0avar enableStableConcurrentModeAPIs = false;\x0a\x0avar warnAboutShorthandPropertyCollision = false;\x0a\x0a// TODO: direct imports like some-package/src/* are bad. Fix me.\x0avar didWarnValueDefaultValue = false;\x0avar didWarnCheckedDefaultChecked = false;\x0avar didWarnControlledToUncontrolled = false;\x0avar didWarnUncontrolledToControlled = false;\x0a\x0afunction isControlled(props) {\x0a  var usesChecked = props.type === \x27checkbox\x27 || props.type === \x27radio\x27;\x0a  return usesChecked ? props.checked != null : props.value != null;\x0a}\x0a\x0a/**\x0a * Implements an \x3cinput\x3e host component that allows setting these optional\x0a * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\x0a *\x0a * If `checked` or `value` are not supplied (or null/undefined), user actions\x0a * that affect the checked state or value will trigger updates to the element.\x0a *\x0a * If they are supplied (and not null/undefined), the rendered element will not\x0a * trigger updates to the element. Instead, the props must change in order for\x0a * the rendered element to be updated.\x0a *\x0a * The rendered element will be initialized as unchecked (or `defaultChecked`)\x0a * with an empty value (or `defaultValue`).\x0a *\x0a * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\x0a */\x0a\x0afunction getHostProps(element, props) {\x0a  var node = element;\x0a  var checked = props.checked;\x0a\x0a  var hostProps = _assign({}, props, {\x0a    defaultChecked: undefined,\x0a    defaultValue: undefined,\x0a    value: undefined,\x0a    checked: checked != null ? checked : node._wrapperState.initialChecked\x0a  });\x0a\x0a  return hostProps;\x0a}\x0a\x0afunction initWrapperState(element, props) {\x0a  {\x0a    ReactControlledValuePropTypes.checkPropTypes(\x27input\x27, props);\x0a\x0a    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\x0a      warning$1(false, \x27%s contains an input of type %s with both checked and defaultChecked props. \x27 + \x27Input elements must be either controlled or uncontrolled \x27 + \x27(specify either the checked prop, or the defaultChecked prop, but not \x27 + \x27both). Decide between using a controlled or uncontrolled input \x27 + \x27element and remove one of these props. More info: \x27 + \x27https://fb.me/react-controlled-components\x27, getCurrentFiberOwnerNameInDevOrNull() || \x27A component\x27, props.type);\x0a      didWarnCheckedDefaultChecked = true;\x0a    }\x0a    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\x0a      warning$1(false, \x27%s contains an input of type %s with both value and defaultValue props. \x27 + \x27Input elements must be either controlled or uncontrolled \x27 + \x27(specify either the value prop, or the defaultValue prop, but not \x27 + \x27both). Decide between using a controlled or uncontrolled input \x27 + \x27element and remove one of these props. More info: \x27 + \x27https://fb.me/react-controlled-components\x27, getCurrentFiberOwnerNameInDevOrNull() || \x27A component\x27, props.type);\x0a      didWarnValueDefaultValue = true;\x0a    }\x0a  }\x0a\x0a  var node = element;\x0a  var defaultValue = props.defaultValue == null ? \x27\x27 : props.defaultValue;\x0a\x0a  node._wrapperState = {\x0a    initialChecked: props.checked != null ? props.checked : props.defaultChecked,\x0a    initialValue: getToStringValue(props.value != null ? props.value : defaultValue),\x0a    controlled: isControlled(props)\x0a  };\x0a}\x0a\x0afunction updateChecked(element, props) {\x0a  var node = element;\x0a  var checked = props.checked;\x0a  if (checked != null) {\x0a    setValueForProperty(node, \x27checked\x27, checked, false);\x0a  }\x0a}\x0a\x0afunction updateWrapper(element, props) {\x0a  var node = element;\x0a  {\x0a    var _controlled = isControlled(props);\x0a\x0a    if (!node._wrapperState.controlled && _controlled && !didWarnUncontrolledToControlled) {\x0a      warning$1(false, \x27A component is changing an uncontrolled input of type %s to be controlled. \x27 + \x27Input elements should not switch from uncontrolled to controlled (or vice versa). \x27 + \x27Decide between using a controlled or uncontrolled input \x27 + \x27element for the lifetime of the component. More info: https://fb.me/react-controlled-components\x27, props.type);\x0a      didWarnUncontrolledToControlled = true;\x0a    }\x0a    if (node._wrapperState.controlled && !_controlled && !didWarnControlledToUncontrolled) {\x0a      warning$1(false, \x27A component is changing a controlled input of type %s to be uncontrolled. \x27 + \x27Input elements should not switch from controlled to uncontrolled (or vice versa). \x27 + \x27Decide between using a controlled or uncontrolled input \x27 + \x27element for the lifetime of the component. More info: https://fb.me/react-controlled-components\x27, props.type);\x0a      didWarnControlledToUncontrolled = true;\x0a    }\x0a  }\x0a\x0a  updateChecked(element, props);\x0a\x0a  var value = getToStringValue(props.value);\x0a  var type = props.type;\x0a\x0a  if (value != null) {\x0a    if (type === \x27number\x27) {\x0a      if (value === 0 && node.value === \x27\x27 ||\x0a      // We explicitly want to coerce to number here if possible.\x0a      // eslint-disable-next-line\x0a      node.value != value) {\x0a        node.value = toString(value);\x0a      }\x0a    } else if (node.value !== toString(value)) {\x0a      node.value = toString(value);\x0a    }\x0a  } else if (type === \x27submit\x27 || type === \x27reset\x27) {\x0a    // Submit/reset inputs need the attribute removed completely to avoid\x0a    // blank-text buttons.\x0a    node.removeAttribute(\x27value\x27);\x0a    return;\x0a  }\x0a\x0a  if (disableInputAttributeSyncing) {\x0a    // When not syncing the value attribute, React only assigns a new value\x0a    // whenever the defaultValue React prop has changed. When not present,\x0a    // React does nothing\x0a    if (props.hasOwnProperty(\x27defaultValue\x27)) {\x0a      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\x0a    }\x0a  } else {\x0a    // When syncing the value attribute, the value comes from a cascade of\x0a    // properties:\x0a    //  1. The value React property\x0a    //  2. The defaultValue React property\x0a    //  3. Otherwise there should be no change\x0a    if (props.hasOwnProperty(\x27value\x27)) {\x0a      setDefaultValue(node, props.type, value);\x0a    } else if (props.hasOwnProperty(\x27defaultValue\x27)) {\x0a      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\x0a    }\x0a  }\x0a\x0a  if (disableInputAttributeSyncing) {\x0a    // When not syncing the checked attribute, the attribute is directly\x0a    // controllable from the defaultValue React property. It needs to be\x0a    // updated as new props come in.\x0a    if (props.defaultChecked == null) {\x0a      node.removeAttribute(\x27checked\x27);\x0a    } else {\x0a      node.defaultChecked = !!props.defaultChecked;\x0a    }\x0a  } else {\x0a    // When syncing the checked attribute, it only changes when it needs\x0a    // to be removed, such as transitioning from a checkbox into a text input\x0a    if (props.checked == null && props.defaultChecked != null) {\x0a      node.defaultChecked = !!props.defaultChecked;\x0a    }\x0a  }\x0a}\x0a\x0afunction postMountWrapper(element, props, isHydrating) {\x0a  var node = element;\x0a\x0a  // Do not assign value if it is already set. This prevents user text input\x0a  // from being lost during SSR hydration.\x0a  if (props.hasOwnProperty(\x27value\x27) || props.hasOwnProperty(\x27defaultValue\x27)) {\x0a    var type = props.type;\x0a    var isButton = type === \x27submit\x27 || type === \x27reset\x27;\x0a\x0a    // Avoid setting value attribute on submit/reset inputs as it overrides the\x0a    // default value provided by the browser. See: #12872\x0a    if (isButton && (props.value === undefined || props.value === null)) {\x0a      return;\x0a    }\x0a\x0a    var _initialValue = toString(node._wrapperState.initialValue);\x0a\x0a    // Do not assign value if it is already set. This prevents user text input\x0a    // from being lost during SSR hydration.\x0a    if (!isHydrating) {\x0a      if (disableInputAttributeSyncing) {\x0a        var value = getToStringValue(props.value);\x0a\x0a        // When not syncing the value attribute, the value property points\x0a        // directly to the React prop. Only assign it if it exists.\x0a        if (value != null) {\x0a          // Always assign on buttons so that it is possible to assign an\x0a          // empty string to clear button text.\x0a          //\x0a          // Otherwise, do not re-assign the value property if is empty. This\x0a          // potentially avoids a DOM write and prevents Firefox (~60.0.1) from\x0a          // prematurely marking required inputs as invalid. Equality is compared\x0a          // to the current value in case the browser provided value is not an\x0a          // empty string.\x0a          if (isButton || value !== node.value) {\x0a            node.value = toString(value);\x0a          }\x0a        }\x0a      } else {\x0a        // When syncing the value attribute, the value property should use\x0a        // the wrapperState._initialValue property. This uses:\x0a        //\x0a        //   1. The value React property when present\x0a        //   2. The defaultValue React property when present\x0a        //   3. An empty string\x0a        if (_initialValue !== node.value) {\x0a          node.value = _initialValue;\x0a        }\x0a      }\x0a    }\x0a\x0a    if (disableInputAttributeSyncing) {\x0a      // When not syncing the value attribute, assign the value attribute\x0a      // directly from the defaultValue React property (when present)\x0a      var defaultValue = getToStringValue(props.defaultValue);\x0a      if (defaultValue != null) {\x0a        node.defaultValue = toString(defaultValue);\x0a      }\x0a    } else {\x0a      // Otherwise, the value attribute is synchronized to the property,\x0a      // so we assign defaultValue to the same thing as the value property\x0a      // assignment step above.\x0a      node.defaultValue = _initialValue;\x0a    }\x0a  }\x0a\x0a  // Normally, we\x27d just do `node.checked = node.checked` upon initial mount, less this bug\x0a  // this is needed to work around a chrome bug where setting defaultChecked\x0a  // will sometimes influence the value of checked (even after detachment).\x0a  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\x0a  // We need to temporarily unset name to avoid disrupting radio button groups.\x0a  var name = node.name;\x0a  if (name !== \x27\x27) {\x0a    node.name = \x27\x27;\x0a  }\x0a\x0a  if (disableInputAttributeSyncing) {\x0a    // When not syncing the checked attribute, the checked property\x0a    // never gets assigned. It must be manually set. We don\x27t want\x0a    // to do this when hydrating so that existing user input isn\x27t\x0a    // modified\x0a    if (!isHydrating) {\x0a      updateChecked(element, props);\x0a    }\x0a\x0a    // Only assign the checked attribute if it is defined. This saves\x0a    // a DOM write when controlling the checked attribute isn\x27t needed\x0a    // (text inputs, submit/reset)\x0a    if (props.hasOwnProperty(\x27defaultChecked\x27)) {\x0a      node.defaultChecked = !node.defaultChecked;\x0a      node.defaultChecked = !!props.defaultChecked;\x0a    }\x0a  } else {\x0a    // When syncing the checked attribute, both the checked property and\x0a    // attribute are assigned at the same time using defaultChecked. This uses:\x0a    //\x0a    //   1. The checked React property when present\x0a    //   2. The defaultChecked React property when present\x0a    //   3. Otherwise, false\x0a    node.defaultChecked = !node.defaultChecked;\x0a    node.defaultChecked = !!node._wrapperState.initialChecked;\x0a  }\x0a\x0a  if (name !== \x27\x27) {\x0a    node.name = name;\x0a  }\x0a}\x0a\x0afunction restoreControlledState(element, props) {\x0a  var node = element;\x0a  updateWrapper(node, props);\x0a  updateNamedCousins(node, props);\x0a}\x0a\x0afunction updateNamedCousins(rootNode, props) {\x0a  var name = props.name;\x0a  if (props.type === \x27radio\x27 && name != null) {\x0a    var queryRoot = rootNode;\x0a\x0a    while (queryRoot.parentNode) {\x0a      queryRoot = queryRoot.parentNode;\x0a    }\x0a\x0a    // If `rootNode.form` was non-null, then we could try `form.elements`,\x0a    // but that sometimes behaves strangely in IE8. We could also try using\x0a    // `form.getElementsByName`, but that will only return direct children\x0a    // and won\x27t include inputs that use the HTML5 `form=` attribute. Since\x0a    // the input might not even be in a form. It might not even be in the\x0a    // document. Let\x27s just use the local `querySelectorAll` to ensure we don\x27t\x0a    // miss anything.\x0a    var group = queryRoot.querySelectorAll(\x27input[name=\x27 + JSON.stringify(\x27\x27 + name) + \x27][type=\x22radio\x22]\x27);\x0a\x0a    for (var i = 0; i \x3c group.length; i++) {\x0a      var otherNode = group[i];\x0a      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\x0a        continue;\x0a      }\x0a      // This will throw if radio buttons rendered by different copies of React\x0a      // and the same name are rendered into the same form (same as #1939).\x0a      // That\x27s probably okay; we don\x27t support it just as we don\x27t support\x0a      // mixing React radio buttons with non-React ones.\x0a      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);\x0a      !otherProps ? invariant(false, \x27ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.\x27) : void 0;\x0a\x0a      // We need update the tracked value on the named cousin since the value\x0a      // was changed but the input saw no event or value set\x0a      updateValueIfChanged(otherNode);\x0a\x0a      // If this is a controlled radio button group, forcing the input that\x0a      // was previously checked to update will cause it to be come re-checked\x0a      // as appropriate.\x0a      updateWrapper(otherNode, otherProps);\x0a    }\x0a  }\x0a}\x0a\x0a// In Chrome, assigning defaultValue to certain input types triggers input validation.\x0a// For number inputs, the display value loses trailing decimal points. For email inputs,\x0a// Chrome raises \x22The specified value \x3cx\x3e is not a valid email address\x22.\x0a//\x0a// Here we check to see if the defaultValue has actually changed, avoiding these problems\x0a// when the user is inputting text\x0a//\x0a// https://github.com/facebook/react/issues/7253\x0afunction setDefaultValue(node, type, value) {\x0a  if (\x0a  // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\x0a  type !== \x27number\x27 || node.ownerDocument.activeElement !== node) {\x0a    if (value == null) {\x0a      node.defaultValue = toString(node._wrapperState.initialValue);\x0a    } else if (node.defaultValue !== toString(value)) {\x0a      node.defaultValue = toString(value);\x0a    }\x0a  }\x0a}\x0a\x0avar eventTypes$1 = {\x0a  change: {\x0a    phasedRegistrationNames: {\x0a      bubbled: \x27onChange\x27,\x0a      captured: \x27onChangeCapture\x27\x0a    },\x0a    dependencies: [TOP_BLUR, TOP_CHANGE, TOP_CLICK, TOP_FOCUS, TOP_INPUT, TOP_KEY_DOWN, TOP_KEY_UP, TOP_SELECTION_CHANGE]\x0a  }\x0a};\x0a\x0afunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\x0a  var event = SyntheticEvent.getPooled(eventTypes$1.change, inst, nativeEvent, target);\x0a  event.type = \x27change\x27;\x0a  // Flag this event loop as needing state restore.\x0a  enqueueStateRestore(target);\x0a  accumulateTwoPhaseDispatches(event);\x0a  return event;\x0a}\x0a/**\x0a * For IE shims\x0a */\x0avar activeElement = null;\x0avar activeElementInst = null;\x0a\x0a/**\x0a * SECTION: handle `change` event\x0a */\x0afunction shouldUseChangeEvent(elem) {\x0a  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\x0a  return nodeName === \x27select\x27 || nodeName === \x27input\x27 && elem.type === \x27file\x27;\x0a}\x0a\x0afunction manualDispatchChangeEvent(nativeEvent) {\x0a  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\x0a\x0a  // If change and propertychange bubbled, we\x27d just bind to it like all the\x0a  // other events and have it go through ReactBrowserEventEmitter. Since it\x0a  // doesn\x27t, we manually listen for the events and so we have to enqueue and\x0a  // process the abstract event manually.\x0a  //\x0a  // Batching is necessary here in order to ensure that all event handlers run\x0a  // before the next rerender (including event handlers attached to ancestor\x0a  // elements instead of directly on the input). Without this, controlled\x0a  // components don\x27t work properly in conjunction with event bubbling because\x0a  // the component is rerendered and the value reverted before all the event\x0a  // handlers can run. See https://github.com/facebook/react/issues/708.\x0a  batchedUpdates(runEventInBatch, event);\x0a}\x0a\x0afunction runEventInBatch(event) {\x0a  runEventsInBatch(event);\x0a}\x0a\x0afunction getInstIfValueChanged(targetInst) {\x0a  var targetNode = getNodeFromInstance$1(targetInst);\x0a  if (updateValueIfChanged(targetNode)) {\x0a    return targetInst;\x0a  }\x0a}\x0a\x0afunction getTargetInstForChangeEvent(topLevelType, targetInst) {\x0a  if (topLevelType === TOP_CHANGE) {\x0a    return targetInst;\x0a  }\x0a}\x0a\x0a/**\x0a * SECTION: handle `input` event\x0a */\x0avar isInputEventSupported = false;\x0aif (canUseDOM) {\x0a  // IE9 claims to support the input event but fails to trigger it when\x0a  // deleting text, so we ignore its input events.\x0a  isInputEventSupported = isEventSupported(\x27input\x27) && (!document.documentMode || document.documentMode \x3e 9);\x0a}\x0a\x0a/**\x0a * (For IE \x3c=9) Starts tracking propertychange events on the passed-in element\x0a * and override the value property so that we can distinguish user events from\x0a * value changes in JS.\x0a */\x0afunction startWatchingForValueChange(target, targetInst) {\x0a  activeElement = target;\x0a  activeElementInst = targetInst;\x0a  activeElement.attachEvent(\x27onpropertychange\x27, handlePropertyChange);\x0a}\x0a\x0a/**\x0a * (For IE \x3c=9) Removes the event listeners from the currently-tracked element,\x0a * if any exists.\x0a */\x0afunction stopWatchingForValueChange() {\x0a  if (!activeElement) {\x0a    return;\x0a  }\x0a  activeElement.detachEvent(\x27onpropertychange\x27, handlePropertyChange);\x0a  activeElement = null;\x0a  activeElementInst = null;\x0a}\x0a\x0a/**\x0a * (For IE \x3c=9) Handles a propertychange event, sending a `change` event if\x0a * the value of the active element has changed.\x0a */\x0afunction handlePropertyChange(nativeEvent) {\x0a  if (nativeEvent.propertyName !== \x27value\x27) {\x0a    return;\x0a  }\x0a  if (getInstIfValueChanged(activeElementInst)) {\x0a    manualDispatchChangeEvent(nativeEvent);\x0a  }\x0a}\x0a\x0afunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\x0a  if (topLevelType === TOP_FOCUS) {\x0a    // In IE9, propertychange fires for most input events but is buggy and\x0a    // doesn\x27t fire when text is deleted, but conveniently, selectionchange\x0a    // appears to fire in all of the remaining cases so we catch those and\x0a    // forward the event if the value has changed\x0a    // In either case, we don\x27t want to call the event handler if the value\x0a    // is changed from JS so we redefine a setter for `.value` that updates\x0a    // our activeElementValue variable, allowing us to ignore those changes\x0a    //\x0a    // stopWatching() should be a noop here but we call it just in case we\x0a    // missed a blur event somehow.\x0a    stopWatchingForValueChange();\x0a    startWatchingForValueChange(target, targetInst);\x0a  } else if (topLevelType === TOP_BLUR) {\x0a    stopWatchingForValueChange();\x0a  }\x0a}\x0a\x0a// For IE8 and IE9.\x0afunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\x0a  if (topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {\x0a    // On the selectionchange event, the target is just document which isn\x27t\x0a    // helpful for us so just check activeElement instead.\x0a    //\x0a    // 99% of the time, keydown and keyup aren\x27t necessary. IE8 fails to fire\x0a    // propertychange on the first input event after setting `value` from a\x0a    // script and fires only keydown, keypress, keyup. Catching keyup usually\x0a    // gets it and catching keydown lets us fire an event for the first\x0a    // keystroke if user does a key repeat (it\x27ll be a little delayed: right\x0a    // before the second keystroke). Other input methods (e.g., paste) seem to\x0a    // fire selectionchange normally.\x0a    return getInstIfValueChanged(activeElementInst);\x0a  }\x0a}\x0a\x0a/**\x0a * SECTION: handle `click` event\x0a */\x0afunction shouldUseClickEvent(elem) {\x0a  // Use the `click` event to detect changes to checkbox and radio inputs.\x0a  // This approach works across all browsers, whereas `change` does not fire\x0a  // until `blur` in IE8.\x0a  var nodeName = elem.nodeName;\x0a  return nodeName && nodeName.toLowerCase() === \x27input\x27 && (elem.type === \x27checkbox\x27 || elem.type === \x27radio\x27);\x0a}\x0a\x0afunction getTargetInstForClickEvent(topLevelType, targetInst) {\x0a  if (topLevelType === TOP_CLICK) {\x0a    return getInstIfValueChanged(targetInst);\x0a  }\x0a}\x0a\x0afunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\x0a  if (topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {\x0a    return getInstIfValueChanged(targetInst);\x0a  }\x0a}\x0a\x0afunction handleControlledInputBlur(node) {\x0a  var state = node._wrapperState;\x0a\x0a  if (!state || !state.controlled || node.type !== \x27number\x27) {\x0a    return;\x0a  }\x0a\x0a  if (!disableInputAttributeSyncing) {\x0a    // If controlled, assign the value attribute to the current value on blur\x0a    setDefaultValue(node, \x27number\x27, node.value);\x0a  }\x0a}\x0a\x0a/**\x0a * This plugin creates an `onChange` event that normalizes change events\x0a * across form elements. This event fires at a time when it\x27s possible to\x0a * change the element\x27s value without seeing a flicker.\x0a *\x0a * Supported elements are:\x0a * - input (see `isTextInputElement`)\x0a * - textarea\x0a * - select\x0a */\x0avar ChangeEventPlugin = {\x0a  eventTypes: eventTypes$1,\x0a\x0a  _isInputEventSupported: isInputEventSupported,\x0a\x0a  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\x0a    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\x0a\x0a    var getTargetInstFunc = void 0,\x0a        handleEventFunc = void 0;\x0a    if (shouldUseChangeEvent(targetNode)) {\x0a      getTargetInstFunc = getTargetInstForChangeEvent;\x0a    } else if (isTextInputElement(targetNode)) {\x0a      if (isInputEventSupported) {\x0a        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\x0a      } else {\x0a        getTargetInstFunc = getTargetInstForInputEventPolyfill;\x0a        handleEventFunc = handleEventsForInputEventPolyfill;\x0a      }\x0a    } else if (shouldUseClickEvent(targetNode)) {\x0a      getTargetInstFunc = getTargetInstForClickEvent;\x0a    }\x0a\x0a    if (getTargetInstFunc) {\x0a      var inst = getTargetInstFunc(topLevelType, targetInst);\x0a      if (inst) {\x0a        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\x0a        return event;\x0a      }\x0a    }\x0a\x0a    if (handleEventFunc) {\x0a      handleEventFunc(topLevelType, targetNode, targetInst);\x0a    }\x0a\x0a    // When blurring, set the value attribute for number inputs\x0a    if (topLevelType === TOP_BLUR) {\x0a      handleControlledInputBlur(targetNode);\x0a    }\x0a  }\x0a};\x0a\x0a/**\x0a * Module that is injectable into `EventPluginHub`, that specifies a\x0a * deterministic ordering of `EventPlugin`s. A convenient way to reason about\x0a * plugins, without having to package every one of them. This is better than\x0a * having plugins be ordered in the same order that they are injected because\x0a * that ordering would be influenced by the packaging order.\x0a * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\x0a * preventing default on events is convenient in `SimpleEventPlugin` handlers.\x0a */\x0avar DOMEventPluginOrder = [\x27ResponderEventPlugin\x27, \x27SimpleEventPlugin\x27, \x27EnterLeaveEventPlugin\x27, \x27ChangeEventPlugin\x27, \x27SelectEventPlugin\x27, \x27BeforeInputEventPlugin\x27];\x0a\x0avar SyntheticUIEvent = SyntheticEvent.extend({\x0a  view: null,\x0a  detail: null\x0a});\x0a\x0avar modifierKeyToProp = {\x0a  Alt: \x27altKey\x27,\x0a  Control: \x27ctrlKey\x27,\x0a  Meta: \x27metaKey\x27,\x0a  Shift: \x27shiftKey\x27\x0a};\x0a\x0a// Older browsers (Safari \x3c= 10, iOS Safari \x3c= 10.2) do not support\x0a// getModifierState. If getModifierState is not supported, we map it to a set of\x0a// modifier keys exposed by the event. In this case, Lock-keys are not supported.\x0a/**\x0a * Translation from modifier key to the associated property in the event.\x0a * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\x0a */\x0a\x0afunction modifierStateGetter(keyArg) {\x0a  var syntheticEvent = this;\x0a  var nativeEvent = syntheticEvent.nativeEvent;\x0a  if (nativeEvent.getModifierState) {\x0a    return nativeEvent.getModifierState(keyArg);\x0a  }\x0a  var keyProp = modifierKeyToProp[keyArg];\x0a  return keyProp ? !!nativeEvent[keyProp] : false;\x0a}\x0a\x0afunction getEventModifierState(nativeEvent) {\x0a  return modifierStateGetter;\x0a}\x0a\x0avar previousScreenX = 0;\x0avar previousScreenY = 0;\x0a// Use flags to signal movementX/Y has already been set\x0avar isMovementXSet = false;\x0avar isMovementYSet = false;\x0a\x0a/**\x0a * @interface MouseEvent\x0a * @see http://www.w3.org/TR/DOM-Level-3-Events/\x0a */\x0avar SyntheticMouseEvent = SyntheticUIEvent.extend({\x0a  screenX: null,\x0a  screenY: null,\x0a  clientX: null,\x0a  clientY: null,\x0a  pageX: null,\x0a  pageY: null,\x0a  ctrlKey: null,\x0a  shiftKey: null,\x0a  altKey: null,\x0a  metaKey: null,\x0a  getModifierState: getEventModifierState,\x0a  button: null,\x0a  buttons: null,\x0a  relatedTarget: function (event) {\x0a    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\x0a  },\x0a  movementX: function (event) {\x0a    if (\x27movementX\x27 in event) {\x0a      return event.movementX;\x0a    }\x0a\x0a    var screenX = previousScreenX;\x0a    previousScreenX = event.screenX;\x0a\x0a    if (!isMovementXSet) {\x0a      isMovementXSet = true;\x0a      return 0;\x0a    }\x0a\x0a    return event.type === \x27mousemove\x27 ? event.screenX - screenX : 0;\x0a  },\x0a  movementY: function (event) {\x0a    if (\x27movementY\x27 in event) {\x0a      return event.movementY;\x0a    }\x0a\x0a    var screenY = previousScreenY;\x0a    previousScreenY = event.screenY;\x0a\x0a    if (!isMovementYSet) {\x0a      isMovementYSet = true;\x0a      return 0;\x0a    }\x0a\x0a    return event.type === \x27mousemove\x27 ? event.screenY - screenY : 0;\x0a  }\x0a});\x0a\x0a/**\x0a * @interface PointerEvent\x0a * @see http://www.w3.org/TR/pointerevents/\x0a */\x0avar SyntheticPointerEvent = SyntheticMouseEvent.extend({\x0a  pointerId: null,\x0a  width: null,\x0a  height: null,\x0a  pressure: null,\x0a  tangentialPressure: null,\x0a  tiltX: null,\x0a  tiltY: null,\x0a  twist: null,\x0a  pointerType: null,\x0a  isPrimary: null\x0a});\x0a\x0avar eventTypes$2 = {\x0a  mouseEnter: {\x0a    registrationName: \x27onMouseEnter\x27,\x0a    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]\x0a  },\x0a  mouseLeave: {\x0a    registrationName: \x27onMouseLeave\x27,\x0a    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]\x0a  },\x0a  pointerEnter: {\x0a    registrationName: \x27onPointerEnter\x27,\x0a    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]\x0a  },\x0a  pointerLeave: {\x0a    registrationName: \x27onPointerLeave\x27,\x0a    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]\x0a  }\x0a};\x0a\x0avar EnterLeaveEventPlugin = {\x0a  eventTypes: eventTypes$2,\x0a\x0a  /**\x0a   * For almost every interaction we care about, there will be both a top-level\x0a   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\x0a   * we do not extract duplicate events. However, moving the mouse into the\x0a   * browser from outside will not fire a `mouseout` event. In this case, we use\x0a   * the `mouseover` top-level event.\x0a   */\x0a  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\x0a    var isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;\x0a    var isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;\x0a\x0a    if (isOverEvent && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\x0a      return null;\x0a    }\x0a\x0a    if (!isOutEvent && !isOverEvent) {\x0a      // Must not be a mouse or pointer in or out - ignoring.\x0a      return null;\x0a    }\x0a\x0a    var win = void 0;\x0a    if (nativeEventTarget.window === nativeEventTarget) {\x0a      // `nativeEventTarget` is probably a window object.\x0a      win = nativeEventTarget;\x0a    } else {\x0a      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\x0a      var doc = nativeEventTarget.ownerDocument;\x0a      if (doc) {\x0a        win = doc.defaultView || doc.parentWindow;\x0a      } else {\x0a        win = window;\x0a      }\x0a    }\x0a\x0a    var from = void 0;\x0a    var to = void 0;\x0a    if (isOutEvent) {\x0a      from = targetInst;\x0a      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\x0a      to = related ? getClosestInstanceFromNode(related) : null;\x0a    } else {\x0a      // Moving to a node from outside the window.\x0a      from = null;\x0a      to = targetInst;\x0a    }\x0a\x0a    if (from === to) {\x0a      // Nothing pertains to our managed components.\x0a      return null;\x0a    }\x0a\x0a    var eventInterface = void 0,\x0a        leaveEventType = void 0,\x0a        enterEventType = void 0,\x0a        eventTypePrefix = void 0;\x0a\x0a    if (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {\x0a      eventInterface = SyntheticMouseEvent;\x0a      leaveEventType = eventTypes$2.mouseLeave;\x0a      enterEventType = eventTypes$2.mouseEnter;\x0a      eventTypePrefix = \x27mouse\x27;\x0a    } else if (topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {\x0a      eventInterface = SyntheticPointerEvent;\x0a      leaveEventType = eventTypes$2.pointerLeave;\x0a      enterEventType = eventTypes$2.pointerEnter;\x0a      eventTypePrefix = \x27pointer\x27;\x0a    }\x0a\x0a    var fromNode = from == null ? win : getNodeFromInstance$1(from);\x0a    var toNode = to == null ? win : getNodeFromInstance$1(to);\x0a\x0a    var leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);\x0a    leave.type = eventTypePrefix + \x27leave\x27;\x0a    leave.target = fromNode;\x0a    leave.relatedTarget = toNode;\x0a\x0a    var enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);\x0a    enter.type = eventTypePrefix + \x27enter\x27;\x0a    enter.target = toNode;\x0a    enter.relatedTarget = fromNode;\x0a\x0a    accumulateEnterLeaveDispatches(leave, enter, from, to);\x0a\x0a    return [leave, enter];\x0a  }\x0a};\x0a\x0a/**\x0a * inlined Object.is polyfill to avoid requiring consumers ship their own\x0a * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\x0a */\x0afunction is(x, y) {\x0a  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\x0a  ;\x0a}\x0a\x0avar hasOwnProperty$1 = Object.prototype.hasOwnProperty;\x0a\x0a/**\x0a * Performs equality by iterating through keys on an object and returning false\x0a * when any key has values which are not strictly equal between the arguments.\x0a * Returns true when the values of all keys are strictly equal.\x0a */\x0afunction shallowEqual(objA, objB) {\x0a  if (is(objA, objB)) {\x0a    return true;\x0a  }\x0a\x0a  if (typeof objA !== \x27object\x27 || objA === null || typeof objB !== \x27object\x27 || objB === null) {\x0a    return false;\x0a  }\x0a\x0a  var keysA = Object.keys(objA);\x0a  var keysB = Object.keys(objB);\x0a\x0a  if (keysA.length !== keysB.length) {\x0a    return false;\x0a  }\x0a\x0a  // Test for A\x27s keys different from B.\x0a  for (var i = 0; i \x3c keysA.length; i++) {\x0a    if (!hasOwnProperty$1.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\x0a      return false;\x0a    }\x0a  }\x0a\x0a  return true;\x0a}\x0a\x0a/**\x0a * `ReactInstanceMap` maintains a mapping from a public facing stateful\x0a * instance (key) and the internal representation (value). This allows public\x0a * methods to accept the user facing instance as an argument and map them back\x0a * to internal methods.\x0a *\x0a * Note that this module is currently shared and assumed to be stateless.\x0a * If this becomes an actual Map, that will break.\x0a */\x0a\x0a/**\x0a * This API should be called `delete` but we\x27d have to make sure to always\x0a * transform these to strings for IE support. When this transform is fully\x0a * supported we can rename it.\x0a */\x0a\x0a\x0afunction get(key) {\x0a  return key._reactInternalFiber;\x0a}\x0a\x0afunction has(key) {\x0a  return key._reactInternalFiber !== undefined;\x0a}\x0a\x0afunction set(key, value) {\x0a  key._reactInternalFiber = value;\x0a}\x0a\x0a// Don\x27t change these two values. They\x27re used by React Dev Tools.\x0avar NoEffect = /*              */0;\x0avar PerformedWork = /*         */1;\x0a\x0a// You can change the rest (and add more).\x0avar Placement = /*             */2;\x0avar Update = /*                */4;\x0avar PlacementAndUpdate = /*    */6;\x0avar Deletion = /*              */8;\x0avar ContentReset = /*          */16;\x0avar Callback = /*              */32;\x0avar DidCapture = /*            */64;\x0avar Ref = /*                   */128;\x0avar Snapshot = /*              */256;\x0avar Passive = /*               */512;\x0a\x0a// Passive & Update & Callback & Ref & Snapshot\x0avar LifecycleEffectMask = /*   */932;\x0a\x0a// Union of all host effects\x0avar HostEffectMask = /*        */1023;\x0a\x0avar Incomplete = /*            */1024;\x0avar ShouldCapture = /*         */2048;\x0a\x0avar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\x0a\x0avar MOUNTING = 1;\x0avar MOUNTED = 2;\x0avar UNMOUNTED = 3;\x0a\x0afunction isFiberMountedImpl(fiber) {\x0a  var node = fiber;\x0a  if (!fiber.alternate) {\x0a    // If there is no alternate, this might be a new tree that isn\x27t inserted\x0a    // yet. If it is, then it will have a pending insertion effect on it.\x0a    if ((node.effectTag & Placement) !== NoEffect) {\x0a      return MOUNTING;\x0a    }\x0a    while (node.return) {\x0a      node = node.return;\x0a      if ((node.effectTag & Placement) !== NoEffect) {\x0a        return MOUNTING;\x0a      }\x0a    }\x0a  } else {\x0a    while (node.return) {\x0a      node = node.return;\x0a    }\x0a  }\x0a  if (node.tag === HostRoot) {\x0a    // TODO: Check if this was a nested HostRoot when used with\x0a    // renderContainerIntoSubtree.\x0a    return MOUNTED;\x0a  }\x0a  // If we didn\x27t hit the root, that means that we\x27re in an disconnected tree\x0a  // that has been unmounted.\x0a  return UNMOUNTED;\x0a}\x0a\x0afunction isFiberMounted(fiber) {\x0a  return isFiberMountedImpl(fiber) === MOUNTED;\x0a}\x0a\x0afunction isMounted(component) {\x0a  {\x0a    var owner = ReactCurrentOwner$1.current;\x0a    if (owner !== null && owner.tag === ClassComponent) {\x0a      var ownerFiber = owner;\x0a      var instance = ownerFiber.stateNode;\x0a      !instance._warnedAboutRefsInRender ? warningWithoutStack$1(false, \x27%s is accessing isMounted inside its render() function. \x27 + \x27render() should be a pure function of props and state. It should \x27 + \x27never access something that requires stale data from the previous \x27 + \x27render, such as refs. Move this logic to componentDidMount and \x27 + \x27componentDidUpdate instead.\x27, getComponentName(ownerFiber.type) || \x27A component\x27) : void 0;\x0a      instance._warnedAboutRefsInRender = true;\x0a    }\x0a  }\x0a\x0a  var fiber = get(component);\x0a  if (!fiber) {\x0a    return false;\x0a  }\x0a  return isFiberMountedImpl(fiber) === MOUNTED;\x0a}\x0a\x0afunction assertIsMounted(fiber) {\x0a  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, \x27Unable to find node on an unmounted component.\x27) : void 0;\x0a}\x0a\x0afunction findCurrentFiberUsingSlowPath(fiber) {\x0a  var alternate = fiber.alternate;\x0a  if (!alternate) {\x0a    // If there is no alternate, then we only need to check if it is mounted.\x0a    var state = isFiberMountedImpl(fiber);\x0a    !(state !== UNMOUNTED) ? invariant(false, \x27Unable to find node on an unmounted component.\x27) : void 0;\x0a    if (state === MOUNTING) {\x0a      return null;\x0a    }\x0a    return fiber;\x0a  }\x0a  // If we have two possible branches, we\x27ll walk backwards up to the root\x0a  // to see what path the root points to. On the way we may hit one of the\x0a  // special cases and we\x27ll deal with them.\x0a  var a = fiber;\x0a  var b = alternate;\x0a  while (true) {\x0a    var parentA = a.return;\x0a    var parentB = parentA ? parentA.alternate : null;\x0a    if (!parentA || !parentB) {\x0a      // We\x27re at the root.\x0a      break;\x0a    }\x0a\x0a    // If both copies of the parent fiber point to the same child, we can\x0a    // assume that the child is current. This happens when we bailout on low\x0a    // priority: the bailed out fiber\x27s child reuses the current child.\x0a    if (parentA.child === parentB.child) {\x0a      var child = parentA.child;\x0a      while (child) {\x0a        if (child === a) {\x0a          // We\x27ve determined that A is the current branch.\x0a          assertIsMounted(parentA);\x0a          return fiber;\x0a        }\x0a        if (child === b) {\x0a          // We\x27ve determined that B is the current branch.\x0a          assertIsMounted(parentA);\x0a          return alternate;\x0a        }\x0a        child = child.sibling;\x0a      }\x0a      // We should never have an alternate for any mounting node. So the only\x0a      // way this could possibly happen is if this was unmounted, if at all.\x0a      invariant(false, \x27Unable to find node on an unmounted component.\x27);\x0a    }\x0a\x0a    if (a.return !== b.return) {\x0a      // The return pointer of A and the return pointer of B point to different\x0a      // fibers. We assume that return pointers never criss-cross, so A must\x0a      // belong to the child set of A.return, and B must belong to the child\x0a      // set of B.return.\x0a      a = parentA;\x0a      b = parentB;\x0a    } else {\x0a      // The return pointers point to the same fiber. We\x27ll have to use the\x0a      // default, slow path: scan the child sets of each parent alternate to see\x0a      // which child belongs to which set.\x0a      //\x0a      // Search parent A\x27s child set\x0a      var didFindChild = false;\x0a      var _child = parentA.child;\x0a      while (_child) {\x0a        if (_child === a) {\x0a          didFindChild = true;\x0a          a = parentA;\x0a          b = parentB;\x0a          break;\x0a        }\x0a        if (_child === b) {\x0a          didFindChild = true;\x0a          b = parentA;\x0a          a = parentB;\x0a          break;\x0a        }\x0a        _child = _child.sibling;\x0a      }\x0a      if (!didFindChild) {\x0a        // Search parent B\x27s child set\x0a        _child = parentB.child;\x0a        while (_child) {\x0a          if (_child === a) {\x0a            didFindChild = true;\x0a            a = parentB;\x0a            b = parentA;\x0a            break;\x0a          }\x0a          if (_child === b) {\x0a            didFindChild = true;\x0a            b = parentB;\x0a            a = parentA;\x0a            break;\x0a          }\x0a          _child = _child.sibling;\x0a        }\x0a        !didFindChild ? invariant(false, \x27Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\x27) : void 0;\x0a      }\x0a    }\x0a\x0a    !(a.alternate === b) ? invariant(false, \x27Return fibers should always be each others\x5c\x27 alternates. This error is likely caused by a bug in React. Please file an issue.\x27) : void 0;\x0a  }\x0a  // If the root is not a host container, we\x27re in a disconnected tree. I.e.\x0a  // unmounted.\x0a  !(a.tag === HostRoot) ? invariant(false, \x27Unable to find node on an unmounted component.\x27) : void 0;\x0a  if (a.stateNode.current === a) {\x0a    // We\x27ve determined that A is the current branch.\x0a    return fiber;\x0a  }\x0a  // Otherwise B has to be current branch.\x0a  return alternate;\x0a}\x0a\x0afunction findCurrentHostFiber(parent) {\x0a  var currentParent = findCurrentFiberUsingSlowPath(parent);\x0a  if (!currentParent) {\x0a    return null;\x0a  }\x0a\x0a  // Next we\x27ll drill down this component to find the first HostComponent/Text.\x0a  var node = currentParent;\x0a  while (true) {\x0a    if (node.tag === HostComponent || node.tag === HostText) {\x0a      return node;\x0a    } else if (node.child) {\x0a      node.child.return = node;\x0a      node = node.child;\x0a      continue;\x0a    }\x0a    if (node === currentParent) {\x0a      return null;\x0a    }\x0a    while (!node.sibling) {\x0a      if (!node.return || node.return === currentParent) {\x0a        return null;\x0a      }\x0a      node = node.return;\x0a    }\x0a    node.sibling.return = node.return;\x0a    node = node.sibling;\x0a  }\x0a  // Flow needs the return null here, but ESLint complains about it.\x0a  // eslint-disable-next-line no-unreachable\x0a  return null;\x0a}\x0a\x0afunction findCurrentHostFiberWithNoPortals(parent) {\x0a  var currentParent = findCurrentFiberUsingSlowPath(parent);\x0a  if (!currentParent) {\x0a    return null;\x0a  }\x0a\x0a  // Next we\x27ll drill down this component to find the first HostComponent/Text.\x0a  var node = currentParent;\x0a  while (true) {\x0a    if (node.tag === HostComponent || node.tag === HostText) {\x0a      return node;\x0a    } else if (node.child && node.tag !== HostPortal) {\x0a      node.child.return = node;\x0a      node = node.child;\x0a      continue;\x0a    }\x0a    if (node === currentParent) {\x0a      return null;\x0a    }\x0a    while (!node.sibling) {\x0a      if (!node.return || node.return === currentParent) {\x0a        return null;\x0a      }\x0a      node = node.return;\x0a    }\x0a    node.sibling.return = node.return;\x0a    node = node.sibling;\x0a  }\x0a  // Flow needs the return null here, but ESLint complains about it.\x0a  // eslint-disable-next-line no-unreachable\x0a  return null;\x0a}\x0a\x0afunction addEventBubbleListener(element, eventType, listener) {\x0a  element.addEventListener(eventType, listener, false);\x0a}\x0a\x0afunction addEventCaptureListener(element, eventType, listener) {\x0a  element.addEventListener(eventType, listener, true);\x0a}\x0a\x0a/**\x0a * @interface Event\x0a * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\x0a * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\x0a */\x0avar SyntheticAnimationEvent = SyntheticEvent.extend({\x0a  animationName: null,\x0a  elapsedTime: null,\x0a  pseudoElement: null\x0a});\x0a\x0a/**\x0a * @interface Event\x0a * @see http://www.w3.org/TR/clipboard-apis/\x0a */\x0avar SyntheticClipboardEvent = SyntheticEvent.extend({\x0a  clipboardData: function (event) {\x0a    return \x27clipboardData\x27 in event ? event.clipboardData : window.clipboardData;\x0a  }\x0a});\x0a\x0a/**\x0a * @interface FocusEvent\x0a * @see http://www.w3.org/TR/DOM-Level-3-Events/\x0a */\x0avar SyntheticFocusEvent = SyntheticUIEvent.extend({\x0a  relatedTarget: null\x0a});\x0a\x0a/**\x0a * `charCode` represents the actual \x22character code\x22 and is safe to use with\x0a * `String.fromCharCode`. As such, only keys that correspond to printable\x0a * characters produce a valid `charCode`, the only exception to this is Enter.\x0a * The Tab-key is considered non-printable and does not have a `charCode`,\x0a * presumably because it does not produce a tab-character in browsers.\x0a *\x0a * @param {object} nativeEvent Native browser event.\x0a * @return {number} Normalized `charCode` property.\x0a */\x0afunction getEventCharCode(nativeEvent) {\x0a  var charCode = void 0;\x0a  var keyCode = nativeEvent.keyCode;\x0a\x0a  if (\x27charCode\x27 in nativeEvent) {\x0a    charCode = nativeEvent.charCode;\x0a\x0a    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\x0a    if (charCode === 0 && keyCode === 13) {\x0a      charCode = 13;\x0a    }\x0a  } else {\x0a    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\x0a    charCode = keyCode;\x0a  }\x0a\x0a  // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\x0a  // report Enter as charCode 10 when ctrl is pressed.\x0a  if (charCode === 10) {\x0a    charCode = 13;\x0a  }\x0a\x0a  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\x0a  // Must not discard the (non-)printable Enter-key.\x0a  if (charCode \x3e= 32 || charCode === 13) {\x0a    return charCode;\x0a  }\x0a\x0a  return 0;\x0a}\x0a\x0a/**\x0a * Normalization of deprecated HTML5 `key` values\x0a * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\x0a */\x0avar normalizeKey = {\x0a  Esc: \x27Escape\x27,\x0a  Spacebar: \x27 \x27,\x0a  Left: \x27ArrowLeft\x27,\x0a  Up: \x27ArrowUp\x27,\x0a  Right: \x27ArrowRight\x27,\x0a  Down: \x27ArrowDown\x27,\x0a  Del: \x27Delete\x27,\x0a  Win: \x27OS\x27,\x0a  Menu: \x27ContextMenu\x27,\x0a  Apps: \x27ContextMenu\x27,\x0a  Scroll: \x27ScrollLock\x27,\x0a  MozPrintableKey: \x27Unidentified\x27\x0a};\x0a\x0a/**\x0a * Translation from legacy `keyCode` to HTML5 `key`\x0a * Only special keys supported, all others depend on keyboard layout or browser\x0a * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\x0a */\x0avar translateToKey = {\x0a  \x278\x27: \x27Backspace\x27,\x0a  \x279\x27: \x27Tab\x27,\x0a  \x2712\x27: \x27Clear\x27,\x0a  \x2713\x27: \x27Enter\x27,\x0a  \x2716\x27: \x27Shift\x27,\x0a  \x2717\x27: \x27Control\x27,\x0a  \x2718\x27: \x27Alt\x27,\x0a  \x2719\x27: \x27Pause\x27,\x0a  \x2720\x27: \x27CapsLock\x27,\x0a  \x2727\x27: \x27Escape\x27,\x0a  \x2732\x27: \x27 \x27,\x0a  \x2733\x27: \x27PageUp\x27,\x0a  \x2734\x27: \x27PageDown\x27,\x0a  \x2735\x27: \x27End\x27,\x0a  \x2736\x27: \x27Home\x27,\x0a  \x2737\x27: \x27ArrowLeft\x27,\x0a  \x2738\x27: \x27ArrowUp\x27,\x0a  \x2739\x27: \x27ArrowRight\x27,\x0a  \x2740\x27: \x27ArrowDown\x27,\x0a  \x2745\x27: \x27Insert\x27,\x0a  \x2746\x27: \x27Delete\x27,\x0a  \x27112\x27: \x27F1\x27,\x0a  \x27113\x27: \x27F2\x27,\x0a  \x27114\x27: \x27F3\x27,\x0a  \x27115\x27: \x27F4\x27,\x0a  \x27116\x27: \x27F5\x27,\x0a  \x27117\x27: \x27F6\x27,\x0a  \x27118\x27: \x27F7\x27,\x0a  \x27119\x27: \x27F8\x27,\x0a  \x27120\x27: \x27F9\x27,\x0a  \x27121\x27: \x27F10\x27,\x0a  \x27122\x27: \x27F11\x27,\x0a  \x27123\x27: \x27F12\x27,\x0a  \x27144\x27: \x27NumLock\x27,\x0a  \x27145\x27: \x27ScrollLock\x27,\x0a  \x27224\x27: \x27Meta\x27\x0a};\x0a\x0a/**\x0a * @param {object} nativeEvent Native browser event.\x0a * @return {string} Normalized `key` property.\x0a */\x0afunction getEventKey(nativeEvent) {\x0a  if (nativeEvent.key) {\x0a    // Normalize inconsistent values reported by browsers due to\x0a    // implementations of a working draft specification.\x0a\x0a    // FireFox implements `key` but returns `MozPrintableKey` for all\x0a    // printable characters (normalized to `Unidentified`), ignore it.\x0a    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\x0a    if (key !== \x27Unidentified\x27) {\x0a      return key;\x0a    }\x0a  }\x0a\x0a  // Browser does not implement `key`, polyfill as much of it as we can.\x0a  if (nativeEvent.type === \x27keypress\x27) {\x0a    var charCode = getEventCharCode(nativeEvent);\x0a\x0a    // The enter-key is technically both printable and non-printable and can\x0a    // thus be captured by `keypress`, no other non-printable key should.\x0a    return charCode === 13 ? \x27Enter\x27 : String.fromCharCode(charCode);\x0a  }\x0a  if (nativeEvent.type === \x27keydown\x27 || nativeEvent.type === \x27keyup\x27) {\x0a    // While user keyboard layout determines the actual meaning of each\x0a    // `keyCode` value, almost all function keys have a universal value.\x0a    return translateToKey[nativeEvent.keyCode] || \x27Unidentified\x27;\x0a  }\x0a  return \x27\x27;\x0a}\x0a\x0a/**\x0a * @interface KeyboardEvent\x0a * @see http://www.w3.org/TR/DOM-Level-3-Events/\x0a */\x0avar SyntheticKeyboardEvent = SyntheticUIEvent.extend({\x0a  key: getEventKey,\x0a  location: null,\x0a  ctrlKey: null,\x0a  shiftKey: null,\x0a  altKey: null,\x0a  metaKey: null,\x0a  repeat: null,\x0a  locale: null,\x0a  getModifierState: getEventModifierState,\x0a  // Legacy Interface\x0a  charCode: function (event) {\x0a    // `charCode` is the result of a KeyPress event and represents the value of\x0a    // the actual printable character.\x0a\x0a    // KeyPress is deprecated, but its replacement is not yet final and not\x0a    // implemented in any major browser. Only KeyPress has charCode.\x0a    if (event.type === \x27keypress\x27) {\x0a      return getEventCharCode(event);\x0a    }\x0a    return 0;\x0a  },\x0a  keyCode: function (event) {\x0a    // `keyCode` is the result of a KeyDown/Up event and represents the value of\x0a    // physical keyboard key.\x0a\x0a    // The actual meaning of the value depends on the users\x27 keyboard layout\x0a    // which cannot be detected. Assuming that it is a US keyboard layout\x0a    // provides a surprisingly accurate mapping for US and European users.\x0a    // Due to this, it is left to the user to implement at this time.\x0a    if (event.type === \x27keydown\x27 || event.type === \x27keyup\x27) {\x0a      return event.keyCode;\x0a    }\x0a    return 0;\x0a  },\x0a  which: function (event) {\x0a    // `which` is an alias for either `keyCode` or `charCode` depending on the\x0a    // type of the event.\x0a    if (event.type === \x27keypress\x27) {\x0a      return getEventCharCode(event);\x0a    }\x0a    if (event.type === \x27keydown\x27 || event.type === \x27keyup\x27) {\x0a      return event.keyCode;\x0a    }\x0a    return 0;\x0a  }\x0a});\x0a\x0a/**\x0a * @interface DragEvent\x0a * @see http://www.w3.org/TR/DOM-Level-3-Events/\x0a */\x0avar SyntheticDragEvent = SyntheticMouseEvent.extend({\x0a  dataTransfer: null\x0a});\x0a\x0a/**\x0a * @interface TouchEvent\x0a * @see http://www.w3.org/TR/touch-events/\x0a */\x0avar SyntheticTouchEvent = SyntheticUIEvent.extend({\x0a  touches: null,\x0a  targetTouches: null,\x0a  changedTouches: null,\x0a  altKey: null,\x0a  metaKey: null,\x0a  ctrlKey: null,\x0a  shiftKey: null,\x0a  getModifierState: getEventModifierState\x0a});\x0a\x0a/**\x0a * @interface Event\x0a * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\x0a * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\x0a */\x0avar SyntheticTransitionEvent = SyntheticEvent.extend({\x0a  propertyName: null,\x0a  elapsedTime: null,\x0a  pseudoElement: null\x0a});\x0a\x0a/**\x0a * @interface WheelEvent\x0a * @see http://www.w3.org/TR/DOM-Level-3-Events/\x0a */\x0avar SyntheticWheelEvent = SyntheticMouseEvent.extend({\x0a  deltaX: function (event) {\x0a    return \x27deltaX\x27 in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\x0a    \x27wheelDeltaX\x27 in event ? -event.wheelDeltaX : 0;\x0a  },\x0a  deltaY: function (event) {\x0a    return \x27deltaY\x27 in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\x0a    \x27wheelDeltaY\x27 in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE\x3c9 and normalize (down is positive).\x0a    \x27wheelDelta\x27 in event ? -event.wheelDelta : 0;\x0a  },\x0a\x0a  deltaZ: null,\x0a\x0a  // Browsers without \x22deltaMode\x22 is reporting in raw wheel delta where one\x0a  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\x0a  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\x0a  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\x0a  deltaMode: null\x0a});\x0a\x0a/**\x0a * Turns\x0a * [\x27abort\x27, ...]\x0a * into\x0a * eventTypes = {\x0a *   \x27abort\x27: {\x0a *     phasedRegistrationNames: {\x0a *       bubbled: \x27onAbort\x27,\x0a *       captured: \x27onAbortCapture\x27,\x0a *     },\x0a *     dependencies: [TOP_ABORT],\x0a *   },\x0a *   ...\x0a * };\x0a * topLevelEventsToDispatchConfig = new Map([\x0a *   [TOP_ABORT, { sameConfig }],\x0a * ]);\x0a */\x0a\x0avar interactiveEventTypeNames = [[TOP_BLUR, \x27blur\x27], [TOP_CANCEL, \x27cancel\x27], [TOP_CLICK, \x27click\x27], [TOP_CLOSE, \x27close\x27], [TOP_CONTEXT_MENU, \x27contextMenu\x27], [TOP_COPY, \x27copy\x27], [TOP_CUT, \x27cut\x27], [TOP_AUX_CLICK, \x27auxClick\x27], [TOP_DOUBLE_CLICK, \x27doubleClick\x27], [TOP_DRAG_END, \x27dragEnd\x27], [TOP_DRAG_START, \x27dragStart\x27], [TOP_DROP, \x27drop\x27], [TOP_FOCUS, \x27focus\x27], [TOP_INPUT, \x27input\x27], [TOP_INVALID, \x27invalid\x27], [TOP_KEY_DOWN, \x27keyDown\x27], [TOP_KEY_PRESS, \x27keyPress\x27], [TOP_KEY_UP, \x27keyUp\x27], [TOP_MOUSE_DOWN, \x27mouseDown\x27], [TOP_MOUSE_UP, \x27mouseUp\x27], [TOP_PASTE, \x27paste\x27], [TOP_PAUSE, \x27pause\x27], [TOP_PLAY, \x27play\x27], [TOP_POINTER_CANCEL, \x27pointerCancel\x27], [TOP_POINTER_DOWN, \x27pointerDown\x27], [TOP_POINTER_UP, \x27pointerUp\x27], [TOP_RATE_CHANGE, \x27rateChange\x27], [TOP_RESET, \x27reset\x27], [TOP_SEEKED, \x27seeked\x27], [TOP_SUBMIT, \x27submit\x27], [TOP_TOUCH_CANCEL, \x27touchCancel\x27], [TOP_TOUCH_END, \x27touchEnd\x27], [TOP_TOUCH_START, \x27touchStart\x27], [TOP_VOLUME_CHANGE, \x27volumeChange\x27]];\x0avar nonInteractiveEventTypeNames = [[TOP_ABORT, \x27abort\x27], [TOP_ANIMATION_END, \x27animationEnd\x27], [TOP_ANIMATION_ITERATION, \x27animationIteration\x27], [TOP_ANIMATION_START, \x27animationStart\x27], [TOP_CAN_PLAY, \x27canPlay\x27], [TOP_CAN_PLAY_THROUGH, \x27canPlayThrough\x27], [TOP_DRAG, \x27drag\x27], [TOP_DRAG_ENTER, \x27dragEnter\x27], [TOP_DRAG_EXIT, \x27dragExit\x27], [TOP_DRAG_LEAVE, \x27dragLeave\x27], [TOP_DRAG_OVER, \x27dragOver\x27], [TOP_DURATION_CHANGE, \x27durationChange\x27], [TOP_EMPTIED, \x27emptied\x27], [TOP_ENCRYPTED, \x27encrypted\x27], [TOP_ENDED, \x27ended\x27], [TOP_ERROR, \x27error\x27], [TOP_GOT_POINTER_CAPTURE, \x27gotPointerCapture\x27], [TOP_LOAD, \x27load\x27], [TOP_LOADED_DATA, \x27loadedData\x27], [TOP_LOADED_METADATA, \x27loadedMetadata\x27], [TOP_LOAD_START, \x27loadStart\x27], [TOP_LOST_POINTER_CAPTURE, \x27lostPointerCapture\x27], [TOP_MOUSE_MOVE, \x27mouseMove\x27], [TOP_MOUSE_OUT, \x27mouseOut\x27], [TOP_MOUSE_OVER, \x27mouseOver\x27], [TOP_PLAYING, \x27playing\x27], [TOP_POINTER_MOVE, \x27pointerMove\x27], [TOP_POINTER_OUT, \x27pointerOut\x27], [TOP_POINTER_OVER, \x27pointerOver\x27], [TOP_PROGRESS, \x27progress\x27], [TOP_SCROLL, \x27scroll\x27], [TOP_SEEKING, \x27seeking\x27], [TOP_STALLED, \x27stalled\x27], [TOP_SUSPEND, \x27suspend\x27], [TOP_TIME_UPDATE, \x27timeUpdate\x27], [TOP_TOGGLE, \x27toggle\x27], [TOP_TOUCH_MOVE, \x27touchMove\x27], [TOP_TRANSITION_END, \x27transitionEnd\x27], [TOP_WAITING, \x27waiting\x27], [TOP_WHEEL, \x27wheel\x27]];\x0a\x0avar eventTypes$4 = {};\x0avar topLevelEventsToDispatchConfig = {};\x0a\x0afunction addEventTypeNameToConfig(_ref, isInteractive) {\x0a  var topEvent = _ref[0],\x0a      event = _ref[1];\x0a\x0a  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\x0a  var onEvent = \x27on\x27 + capitalizedEvent;\x0a\x0a  var type = {\x0a    phasedRegistrationNames: {\x0a      bubbled: onEvent,\x0a      captured: onEvent + \x27Capture\x27\x0a    },\x0a    dependencies: [topEvent],\x0a    isInteractive: isInteractive\x0a  };\x0a  eventTypes$4[event] = type;\x0a  topLevelEventsToDispatchConfig[topEvent] = type;\x0a}\x0a\x0ainteractiveEventTypeNames.forEach(function (eventTuple) {\x0a  addEventTypeNameToConfig(eventTuple, true);\x0a});\x0anonInteractiveEventTypeNames.forEach(function (eventTuple) {\x0a  addEventTypeNameToConfig(eventTuple, false);\x0a});\x0a\x0a// Only used in DEV for exhaustiveness validation.\x0avar knownHTMLTopLevelTypes = [TOP_ABORT, TOP_CANCEL, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_CLOSE, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_INPUT, TOP_INVALID, TOP_LOAD, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_RESET, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUBMIT, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_TOGGLE, TOP_VOLUME_CHANGE, TOP_WAITING];\x0a\x0avar SimpleEventPlugin = {\x0a  eventTypes: eventTypes$4,\x0a\x0a  isInteractiveTopLevelEventType: function (topLevelType) {\x0a    var config = topLevelEventsToDispatchConfig[topLevelType];\x0a    return config !== undefined && config.isInteractive === true;\x0a  },\x0a\x0a\x0a  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\x0a    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\x0a    if (!dispatchConfig) {\x0a      return null;\x0a    }\x0a    var EventConstructor = void 0;\x0a    switch (topLevelType) {\x0a      case TOP_KEY_PRESS:\x0a        // Firefox creates a keypress event for function keys too. This removes\x0a        // the unwanted keypress events. Enter is however both printable and\x0a        // non-printable. One would expect Tab to be as well (but it isn\x27t).\x0a        if (getEventCharCode(nativeEvent) === 0) {\x0a          return null;\x0a        }\x0a      /* falls through */\x0a      case TOP_KEY_DOWN:\x0a      case TOP_KEY_UP:\x0a        EventConstructor = SyntheticKeyboardEvent;\x0a        break;\x0a      case TOP_BLUR:\x0a      case TOP_FOCUS:\x0a        EventConstructor = SyntheticFocusEvent;\x0a        break;\x0a      case TOP_CLICK:\x0a        // Firefox creates a click event on right mouse clicks. This removes the\x0a        // unwanted click events.\x0a        if (nativeEvent.button === 2) {\x0a          return null;\x0a        }\x0a      /* falls through */\x0a      case TOP_AUX_CLICK:\x0a      case TOP_DOUBLE_CLICK:\x0a      case TOP_MOUSE_DOWN:\x0a      case TOP_MOUSE_MOVE:\x0a      case TOP_MOUSE_UP:\x0a      // TODO: Disabled elements should not respond to mouse events\x0a      /* falls through */\x0a      case TOP_MOUSE_OUT:\x0a      case TOP_MOUSE_OVER:\x0a      case TOP_CONTEXT_MENU:\x0a        EventConstructor = SyntheticMouseEvent;\x0a        break;\x0a      case TOP_DRAG:\x0a      case TOP_DRAG_END:\x0a      case TOP_DRAG_ENTER:\x0a      case TOP_DRAG_EXIT:\x0a      case TOP_DRAG_LEAVE:\x0a      case TOP_DRAG_OVER:\x0a      case TOP_DRAG_START:\x0a      case TOP_DROP:\x0a        EventConstructor = SyntheticDragEvent;\x0a        break;\x0a      case TOP_TOUCH_CANCEL:\x0a      case TOP_TOUCH_END:\x0a      case TOP_TOUCH_MOVE:\x0a      case TOP_TOUCH_START:\x0a        EventConstructor = SyntheticTouchEvent;\x0a        break;\x0a      case TOP_ANIMATION_END:\x0a      case TOP_ANIMATION_ITERATION:\x0a      case TOP_ANIMATION_START:\x0a        EventConstructor = SyntheticAnimationEvent;\x0a        break;\x0a      case TOP_TRANSITION_END:\x0a        EventConstructor = SyntheticTransitionEvent;\x0a        break;\x0a      case TOP_SCROLL:\x0a        EventConstructor = SyntheticUIEvent;\x0a        break;\x0a      case TOP_WHEEL:\x0a        EventConstructor = SyntheticWheelEvent;\x0a        break;\x0a      case TOP_COPY:\x0a      case TOP_CUT:\x0a      case TOP_PASTE:\x0a        EventConstructor = SyntheticClipboardEvent;\x0a        break;\x0a      case TOP_GOT_POINTER_CAPTURE:\x0a      case TOP_LOST_POINTER_CAPTURE:\x0a      case TOP_POINTER_CANCEL:\x0a      case TOP_POINTER_DOWN:\x0a      case TOP_POINTER_MOVE:\x0a      case TOP_POINTER_OUT:\x0a      case TOP_POINTER_OVER:\x0a      case TOP_POINTER_UP:\x0a        EventConstructor = SyntheticPointerEvent;\x0a        break;\x0a      default:\x0a        {\x0a          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {\x0a            warningWithoutStack$1(false, \x27SimpleEventPlugin: Unhandled event type, `%s`. This warning \x27 + \x27is likely caused by a bug in React. Please file an issue.\x27, topLevelType);\x0a          }\x0a        }\x0a        // HTML Events\x0a        // @see http://www.w3.org/TR/html5/index.html#events-0\x0a        EventConstructor = SyntheticEvent;\x0a        break;\x0a    }\x0a    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\x0a    accumulateTwoPhaseDispatches(event);\x0a    return event;\x0a  }\x0a};\x0a\x0avar isInteractiveTopLevelEventType = SimpleEventPlugin.isInteractiveTopLevelEventType;\x0a\x0a\x0avar CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\x0avar callbackBookkeepingPool = [];\x0a\x0a/**\x0a * Find the deepest React component completely containing the root of the\x0a * passed-in instance (for use when entire React trees are nested within each\x0a * other). If React trees are not nested, returns null.\x0a */\x0afunction findRootContainerNode(inst) {\x0a  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\x0a  // traversal, but caching is difficult to do correctly without using a\x0a  // mutation observer to listen for all DOM changes.\x0a  while (inst.return) {\x0a    inst = inst.return;\x0a  }\x0a  if (inst.tag !== HostRoot) {\x0a    // This can happen if we\x27re in a detached tree.\x0a    return null;\x0a  }\x0a  return inst.stateNode.containerInfo;\x0a}\x0a\x0a// Used to store ancestor hierarchy in top level callback\x0afunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\x0a  if (callbackBookkeepingPool.length) {\x0a    var instance = callbackBookkeepingPool.pop();\x0a    instance.topLevelType = topLevelType;\x0a    instance.nativeEvent = nativeEvent;\x0a    instance.targetInst = targetInst;\x0a    return instance;\x0a  }\x0a  return {\x0a    topLevelType: topLevelType,\x0a    nativeEvent: nativeEvent,\x0a    targetInst: targetInst,\x0a    ancestors: []\x0a  };\x0a}\x0a\x0afunction releaseTopLevelCallbackBookKeeping(instance) {\x0a  instance.topLevelType = null;\x0a  instance.nativeEvent = null;\x0a  instance.targetInst = null;\x0a  instance.ancestors.length = 0;\x0a  if (callbackBookkeepingPool.length \x3c CALLBACK_BOOKKEEPING_POOL_SIZE) {\x0a    callbackBookkeepingPool.push(instance);\x0a  }\x0a}\x0a\x0afunction handleTopLevel(bookKeeping) {\x0a  var targetInst = bookKeeping.targetInst;\x0a\x0a  // Loop through the hierarchy, in case there\x27s any nested components.\x0a  // It\x27s important that we build the array of ancestors before calling any\x0a  // event handlers, because event handlers can modify the DOM, leading to\x0a  // inconsistencies with ReactMount\x27s node cache. See #1105.\x0a  var ancestor = targetInst;\x0a  do {\x0a    if (!ancestor) {\x0a      bookKeeping.ancestors.push(ancestor);\x0a      break;\x0a    }\x0a    var root = findRootContainerNode(ancestor);\x0a    if (!root) {\x0a      break;\x0a    }\x0a    bookKeeping.ancestors.push(ancestor);\x0a    ancestor = getClosestInstanceFromNode(root);\x0a  } while (ancestor);\x0a\x0a  for (var i = 0; i \x3c bookKeeping.ancestors.length; i++) {\x0a    targetInst = bookKeeping.ancestors[i];\x0a    runExtractedEventsInBatch(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\x0a  }\x0a}\x0a\x0a// TODO: can we stop exporting these?\x0avar _enabled = true;\x0a\x0afunction setEnabled(enabled) {\x0a  _enabled = !!enabled;\x0a}\x0a\x0afunction isEnabled() {\x0a  return _enabled;\x0a}\x0a\x0a/**\x0a * Traps top-level events by using event bubbling.\x0a *\x0a * @param {number} topLevelType Number from `TopLevelEventTypes`.\x0a * @param {object} element Element on which to attach listener.\x0a * @return {?object} An object with a remove function which will forcefully\x0a *                  remove the listener.\x0a * @internal\x0a */\x0afunction trapBubbledEvent(topLevelType, element) {\x0a  if (!element) {\x0a    return null;\x0a  }\x0a  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\x0a\x0a  addEventBubbleListener(element, getRawEventName(topLevelType),\x0a  // Check if interactive and wrap in interactiveUpdates\x0a  dispatch.bind(null, topLevelType));\x0a}\x0a\x0a/**\x0a * Traps a top-level event by using event capturing.\x0a *\x0a * @param {number} topLevelType Number from `TopLevelEventTypes`.\x0a * @param {object} element Element on which to attach listener.\x0a * @return {?object} An object with a remove function which will forcefully\x0a *                  remove the listener.\x0a * @internal\x0a */\x0afunction trapCapturedEvent(topLevelType, element) {\x0a  if (!element) {\x0a    return null;\x0a  }\x0a  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\x0a\x0a  addEventCaptureListener(element, getRawEventName(topLevelType),\x0a  // Check if interactive and wrap in interactiveUpdates\x0a  dispatch.bind(null, topLevelType));\x0a}\x0a\x0afunction dispatchInteractiveEvent(topLevelType, nativeEvent) {\x0a  interactiveUpdates(dispatchEvent, topLevelType, nativeEvent);\x0a}\x0a\x0afunction dispatchEvent(topLevelType, nativeEvent) {\x0a  if (!_enabled) {\x0a    return;\x0a  }\x0a\x0a  var nativeEventTarget = getEventTarget(nativeEvent);\x0a  var targetInst = getClosestInstanceFromNode(nativeEventTarget);\x0a  if (targetInst !== null && typeof targetInst.tag === \x27number\x27 && !isFiberMounted(targetInst)) {\x0a    // If we get an event (ex: img onload) before committing that\x0a    // component\x27s mount, ignore it for now (that is, treat it as if it was an\x0a    // event on a non-React tree). We might also consider queueing events and\x0a    // dispatching them after the mount.\x0a    targetInst = null;\x0a  }\x0a\x0a  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\x0a\x0a  try {\x0a    // Event queue being processed in the same cycle allows\x0a    // `preventDefault`.\x0a    batchedUpdates(handleTopLevel, bookKeeping);\x0a  } finally {\x0a    releaseTopLevelCallbackBookKeeping(bookKeeping);\x0a  }\x0a}\x0a\x0a/**\x0a * Summary of `ReactBrowserEventEmitter` event handling:\x0a *\x0a *  - Top-level delegation is used to trap most native browser events. This\x0a *    may only occur in the main thread and is the responsibility of\x0a *    ReactDOMEventListener, which is injected and can therefore support\x0a *    pluggable event sources. This is the only work that occurs in the main\x0a *    thread.\x0a *\x0a *  - We normalize and de-duplicate events to account for browser quirks. This\x0a *    may be done in the worker thread.\x0a *\x0a *  - Forward these native events (with the associated top-level type used to\x0a *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\x0a *    to extract any synthetic events.\x0a *\x0a *  - The `EventPluginHub` will then process each event by annotating them with\x0a *    \x22dispatches\x22, a sequence of listeners and IDs that care about that event.\x0a *\x0a *  - The `EventPluginHub` then dispatches the events.\x0a *\x0a * Overview of React and the event system:\x0a *\x0a * +------------+    .\x0a * |    DOM     |    .\x0a * +------------+    .\x0a *       |           .\x0a *       v           .\x0a * +------------+    .\x0a * | ReactEvent |    .\x0a * |  Listener  |    .\x0a * +------------+    .                         +-----------+\x0a *       |           .               +--------+|SimpleEvent|\x0a *       |           .               |         |Plugin     |\x0a * +-----|------+    .               v         +-----------+\x0a * |     |      |    .    +--------------+                    +------------+\x0a * |     +-----------.---\x3e|EventPluginHub|                    |    Event   |\x0a * |            |    .    |              |     +-----------+  | Propagators|\x0a * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\x0a * |  Emitter   |    .    |              |\x3c---+|Plugin     |  |other plugin|\x0a * |            |    .    |              |     +-----------+  |  utilities |\x0a * |     +-----------.---\x3e|              |                    +------------+\x0a * |     |      |    .    +--------------+\x0a * +-----|------+    .                ^        +-----------+\x0a *       |           .                |        |Enter/Leave|\x0a *       +           .                +-------+|Plugin     |\x0a * +-------------+   .                         +-----------+\x0a * | application |   .\x0a * |-------------|   .\x0a * |             |   .\x0a * |             |   .\x0a * +-------------+   .\x0a *                   .\x0a *    React Core     .  General Purpose Event Plugin System\x0a */\x0a\x0avar alreadyListeningTo = {};\x0avar reactTopListenersCounter = 0;\x0a\x0a/**\x0a * To ensure no conflicts with other potential React instances on the page\x0a */\x0avar topListenersIDKey = \x27_reactListenersID\x27 + (\x27\x27 + Math.random()).slice(2);\x0a\x0afunction getListeningForDocument(mountAt) {\x0a  // In IE8, `mountAt` is a host object and doesn\x27t have `hasOwnProperty`\x0a  // directly.\x0a  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\x0a    mountAt[topListenersIDKey] = reactTopListenersCounter++;\x0a    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\x0a  }\x0a  return alreadyListeningTo[mountAt[topListenersIDKey]];\x0a}\x0a\x0a/**\x0a * We listen for bubbled touch events on the document object.\x0a *\x0a * Firefox v8.01 (and possibly others) exhibited strange behavior when\x0a * mounting `onmousemove` events at some node that was not the document\x0a * element. The symptoms were that if your mouse is not moving over something\x0a * contained within that mount point (for example on the background) the\x0a * top-level listeners for `onmousemove` won\x27t be called. However, if you\x0a * register the `mousemove` on the document object, then it will of course\x0a * catch all `mousemove`s. This along with iOS quirks, justifies restricting\x0a * top-level listeners to the document object only, at least for these\x0a * movement types of events and possibly all events.\x0a *\x0a * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\x0a *\x0a * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\x0a * they bubble to document.\x0a *\x0a * @param {string} registrationName Name of listener (e.g. `onClick`).\x0a * @param {object} mountAt Container where to mount the listener\x0a */\x0afunction listenTo(registrationName, mountAt) {\x0a  var isListening = getListeningForDocument(mountAt);\x0a  var dependencies = registrationNameDependencies[registrationName];\x0a\x0a  for (var i = 0; i \x3c dependencies.length; i++) {\x0a    var dependency = dependencies[i];\x0a    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\x0a      switch (dependency) {\x0a        case TOP_SCROLL:\x0a          trapCapturedEvent(TOP_SCROLL, mountAt);\x0a          break;\x0a        case TOP_FOCUS:\x0a        case TOP_BLUR:\x0a          trapCapturedEvent(TOP_FOCUS, mountAt);\x0a          trapCapturedEvent(TOP_BLUR, mountAt);\x0a          // We set the flag for a single dependency later in this function,\x0a          // but this ensures we mark both as attached rather than just one.\x0a          isListening[TOP_BLUR] = true;\x0a          isListening[TOP_FOCUS] = true;\x0a          break;\x0a        case TOP_CANCEL:\x0a        case TOP_CLOSE:\x0a          if (isEventSupported(getRawEventName(dependency))) {\x0a            trapCapturedEvent(dependency, mountAt);\x0a          }\x0a          break;\x0a        case TOP_INVALID:\x0a        case TOP_SUBMIT:\x0a        case TOP_RESET:\x0a          // We listen to them on the target DOM elements.\x0a          // Some of them bubble so we don\x27t want them to fire twice.\x0a          break;\x0a        default:\x0a          // By default, listen on the top level to all non-media events.\x0a          // Media events don\x27t bubble so adding the listener wouldn\x27t do anything.\x0a          var isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1;\x0a          if (!isMediaEvent) {\x0a            trapBubbledEvent(dependency, mountAt);\x0a          }\x0a          break;\x0a      }\x0a      isListening[dependency] = true;\x0a    }\x0a  }\x0a}\x0a\x0afunction isListeningToAllDependencies(registrationName, mountAt) {\x0a  var isListening = getListeningForDocument(mountAt);\x0a  var dependencies = registrationNameDependencies[registrationName];\x0a  for (var i = 0; i \x3c dependencies.length; i++) {\x0a    var dependency = dependencies[i];\x0a    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\x0a      return false;\x0a    }\x0a  }\x0a  return true;\x0a}\x0a\x0afunction getActiveElement(doc) {\x0a  doc = doc || (typeof document !== \x27undefined\x27 ? document : undefined);\x0a  if (typeof doc === \x27undefined\x27) {\x0a    return null;\x0a  }\x0a  try {\x0a    return doc.activeElement || doc.body;\x0a  } catch (e) {\x0a    return doc.body;\x0a  }\x0a}\x0a\x0a/**\x0a * Given any node return the first leaf node without children.\x0a *\x0a * @param {DOMElement|DOMTextNode} node\x0a * @return {DOMElement|DOMTextNode}\x0a */\x0afunction getLeafNode(node) {\x0a  while (node && node.firstChild) {\x0a    node = node.firstChild;\x0a  }\x0a  return node;\x0a}\x0a\x0a/**\x0a * Get the next sibling within a container. This will walk up the\x0a * DOM if a node\x27s siblings have been exhausted.\x0a *\x0a * @param {DOMElement|DOMTextNode} node\x0a * @return {?DOMElement|DOMTextNode}\x0a */\x0afunction getSiblingNode(node) {\x0a  while (node) {\x0a    if (node.nextSibling) {\x0a      return node.nextSibling;\x0a    }\x0a    node = node.parentNode;\x0a  }\x0a}\x0a\x0a/**\x0a * Get object describing the nodes which contain characters at offset.\x0a *\x0a * @param {DOMElement|DOMTextNode} root\x0a * @param {number} offset\x0a * @return {?object}\x0a */\x0afunction getNodeForCharacterOffset(root, offset) {\x0a  var node = getLeafNode(root);\x0a  var nodeStart = 0;\x0a  var nodeEnd = 0;\x0a\x0a  while (node) {\x0a    if (node.nodeType === TEXT_NODE) {\x0a      nodeEnd = nodeStart + node.textContent.length;\x0a\x0a      if (nodeStart \x3c= offset && nodeEnd \x3e= offset) {\x0a        return {\x0a          node: node,\x0a          offset: offset - nodeStart\x0a        };\x0a      }\x0a\x0a      nodeStart = nodeEnd;\x0a    }\x0a\x0a    node = getLeafNode(getSiblingNode(node));\x0a  }\x0a}\x0a\x0a/**\x0a * @param {DOMElement} outerNode\x0a * @return {?object}\x0a */\x0afunction getOffsets(outerNode) {\x0a  var ownerDocument = outerNode.ownerDocument;\x0a\x0a  var win = ownerDocument && ownerDocument.defaultView || window;\x0a  var selection = win.getSelection && win.getSelection();\x0a\x0a  if (!selection || selection.rangeCount === 0) {\x0a    return null;\x0a  }\x0a\x0a  var anchorNode = selection.anchorNode,\x0a      anchorOffset = selection.anchorOffset,\x0a      focusNode = selection.focusNode,\x0a      focusOffset = selection.focusOffset;\x0a\x0a  // In Firefox, anchorNode and focusNode can be \x22anonymous divs\x22, e.g. the\x0a  // up/down buttons on an \x3cinput type=\x22number\x22\x3e. Anonymous divs do not seem to\x0a  // expose properties, triggering a \x22Permission denied error\x22 if any of its\x0a  // properties are accessed. The only seemingly possible way to avoid erroring\x0a  // is to access a property that typically works for non-anonymous divs and\x0a  // catch any error that may otherwise arise. See\x0a  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\x0a\x0a  try {\x0a    /* eslint-disable no-unused-expressions */\x0a    anchorNode.nodeType;\x0a    focusNode.nodeType;\x0a    /* eslint-enable no-unused-expressions */\x0a  } catch (e) {\x0a    return null;\x0a  }\x0a\x0a  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\x0a}\x0a\x0a/**\x0a * Returns {start, end} where `start` is the character/codepoint index of\x0a * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\x0a * `end` is the index of (focusNode, focusOffset).\x0a *\x0a * Returns null if you pass in garbage input but we should probably just crash.\x0a *\x0a * Exported only for testing.\x0a */\x0afunction getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\x0a  var length = 0;\x0a  var start = -1;\x0a  var end = -1;\x0a  var indexWithinAnchor = 0;\x0a  var indexWithinFocus = 0;\x0a  var node = outerNode;\x0a  var parentNode = null;\x0a\x0a  outer: while (true) {\x0a    var next = null;\x0a\x0a    while (true) {\x0a      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\x0a        start = length + anchorOffset;\x0a      }\x0a      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\x0a        end = length + focusOffset;\x0a      }\x0a\x0a      if (node.nodeType === TEXT_NODE) {\x0a        length += node.nodeValue.length;\x0a      }\x0a\x0a      if ((next = node.firstChild) === null) {\x0a        break;\x0a      }\x0a      // Moving from `node` to its first child `next`.\x0a      parentNode = node;\x0a      node = next;\x0a    }\x0a\x0a    while (true) {\x0a      if (node === outerNode) {\x0a        // If `outerNode` has children, this is always the second time visiting\x0a        // it. If it has no children, this is still the first loop, and the only\x0a        // valid selection is anchorNode and focusNode both equal to this node\x0a        // and both offsets 0, in which case we will have handled above.\x0a        break outer;\x0a      }\x0a      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\x0a        start = length;\x0a      }\x0a      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\x0a        end = length;\x0a      }\x0a      if ((next = node.nextSibling) !== null) {\x0a        break;\x0a      }\x0a      node = parentNode;\x0a      parentNode = node.parentNode;\x0a    }\x0a\x0a    // Moving from `node` to its next sibling `next`.\x0a    node = next;\x0a  }\x0a\x0a  if (start === -1 || end === -1) {\x0a    // This should never happen. (Would happen if the anchor/focus nodes aren\x27t\x0a    // actually inside the passed-in node.)\x0a    return null;\x0a  }\x0a\x0a  return {\x0a    start: start,\x0a    end: end\x0a  };\x0a}\x0a\x0a/**\x0a * In modern non-IE browsers, we can support both forward and backward\x0a * selections.\x0a *\x0a * Note: IE10+ supports the Selection object, but it does not support\x0a * the `extend` method, which means that even in modern IE, it\x27s not possible\x0a * to programmatically create a backward selection. Thus, for all IE\x0a * versions, we use the old IE API to create our selections.\x0a *\x0a * @param {DOMElement|DOMTextNode} node\x0a * @param {object} offsets\x0a */\x0afunction setOffsets(node, offsets) {\x0a  var doc = node.ownerDocument || document;\x0a  var win = doc && doc.defaultView || window;\x0a\x0a  // Edge fails with \x22Object expected\x22 in some scenarios.\x0a  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,\x0a  // fails when pasting 100+ items)\x0a  if (!win.getSelection) {\x0a    return;\x0a  }\x0a\x0a  var selection = win.getSelection();\x0a  var length = node.textContent.length;\x0a  var start = Math.min(offsets.start, length);\x0a  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\x0a\x0a  // IE 11 uses modern selection, but doesn\x27t support the extend method.\x0a  // Flip backward selections, so we can set with a single range.\x0a  if (!selection.extend && start \x3e end) {\x0a    var temp = end;\x0a    end = start;\x0a    start = temp;\x0a  }\x0a\x0a  var startMarker = getNodeForCharacterOffset(node, start);\x0a  var endMarker = getNodeForCharacterOffset(node, end);\x0a\x0a  if (startMarker && endMarker) {\x0a    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\x0a      return;\x0a    }\x0a    var range = doc.createRange();\x0a    range.setStart(startMarker.node, startMarker.offset);\x0a    selection.removeAllRanges();\x0a\x0a    if (start \x3e end) {\x0a      selection.addRange(range);\x0a      selection.extend(endMarker.node, endMarker.offset);\x0a    } else {\x0a      range.setEnd(endMarker.node, endMarker.offset);\x0a      selection.addRange(range);\x0a    }\x0a  }\x0a}\x0a\x0afunction isTextNode(node) {\x0a  return node && node.nodeType === TEXT_NODE;\x0a}\x0a\x0afunction containsNode(outerNode, innerNode) {\x0a  if (!outerNode || !innerNode) {\x0a    return false;\x0a  } else if (outerNode === innerNode) {\x0a    return true;\x0a  } else if (isTextNode(outerNode)) {\x0a    return false;\x0a  } else if (isTextNode(innerNode)) {\x0a    return containsNode(outerNode, innerNode.parentNode);\x0a  } else if (\x27contains\x27 in outerNode) {\x0a    return outerNode.contains(innerNode);\x0a  } else if (outerNode.compareDocumentPosition) {\x0a    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\x0a  } else {\x0a    return false;\x0a  }\x0a}\x0a\x0afunction isInDocument(node) {\x0a  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);\x0a}\x0a\x0afunction getActiveElementDeep() {\x0a  var win = window;\x0a  var element = getActiveElement();\x0a  while (element instanceof win.HTMLIFrameElement) {\x0a    // Accessing the contentDocument of a HTMLIframeElement can cause the browser\x0a    // to throw, e.g. if it has a cross-origin src attribute\x0a    try {\x0a      win = element.contentDocument.defaultView;\x0a    } catch (e) {\x0a      return element;\x0a    }\x0a    element = getActiveElement(win.document);\x0a  }\x0a  return element;\x0a}\x0a\x0a/**\x0a * @ReactInputSelection: React input selection module. Based on Selection.js,\x0a * but modified to be suitable for react and has a couple of bug fixes (doesn\x27t\x0a * assume buttons have range selections allowed).\x0a * Input selection module for React.\x0a */\x0a\x0a/**\x0a * @hasSelectionCapabilities: we get the element types that support selection\x0a * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\x0a * and `selectionEnd` rows.\x0a */\x0afunction hasSelectionCapabilities(elem) {\x0a  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\x0a  return nodeName && (nodeName === \x27input\x27 && (elem.type === \x27text\x27 || elem.type === \x27search\x27 || elem.type === \x27tel\x27 || elem.type === \x27url\x27 || elem.type === \x27password\x27) || nodeName === \x27textarea\x27 || elem.contentEditable === \x27true\x27);\x0a}\x0a\x0afunction getSelectionInformation() {\x0a  var focusedElem = getActiveElementDeep();\x0a  return {\x0a    focusedElem: focusedElem,\x0a    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null\x0a  };\x0a}\x0a\x0a/**\x0a * @restoreSelection: If any selection information was potentially lost,\x0a * restore it. This is useful when performing operations that could remove dom\x0a * nodes and place them back in, resulting in focus being lost.\x0a */\x0afunction restoreSelection(priorSelectionInformation) {\x0a  var curFocusedElem = getActiveElementDeep();\x0a  var priorFocusedElem = priorSelectionInformation.focusedElem;\x0a  var priorSelectionRange = priorSelectionInformation.selectionRange;\x0a  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\x0a    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {\x0a      setSelection(priorFocusedElem, priorSelectionRange);\x0a    }\x0a\x0a    // Focusing a node can change the scroll position, which is undesirable\x0a    var ancestors = [];\x0a    var ancestor = priorFocusedElem;\x0a    while (ancestor = ancestor.parentNode) {\x0a      if (ancestor.nodeType === ELEMENT_NODE) {\x0a        ancestors.push({\x0a          element: ancestor,\x0a          left: ancestor.scrollLeft,\x0a          top: ancestor.scrollTop\x0a        });\x0a      }\x0a    }\x0a\x0a    if (typeof priorFocusedElem.focus === \x27function\x27) {\x0a      priorFocusedElem.focus();\x0a    }\x0a\x0a    for (var i = 0; i \x3c ancestors.length; i++) {\x0a      var info = ancestors[i];\x0a      info.element.scrollLeft = info.left;\x0a      info.element.scrollTop = info.top;\x0a    }\x0a  }\x0a}\x0a\x0a/**\x0a * @getSelection: Gets the selection bounds of a focused textarea, input or\x0a * contentEditable node.\x0a * -@input: Look up selection bounds of this input\x0a * -@return {start: selectionStart, end: selectionEnd}\x0a */\x0afunction getSelection$1(input) {\x0a  var selection = void 0;\x0a\x0a  if (\x27selectionStart\x27 in input) {\x0a    // Modern browser with input or textarea.\x0a    selection = {\x0a      start: input.selectionStart,\x0a      end: input.selectionEnd\x0a    };\x0a  } else {\x0a    // Content editable or old IE textarea.\x0a    selection = getOffsets(input);\x0a  }\x0a\x0a  return selection || { start: 0, end: 0 };\x0a}\x0a\x0a/**\x0a * @setSelection: Sets the selection bounds of a textarea or input and focuses\x0a * the input.\x0a * -@input     Set selection bounds of this input or textarea\x0a * -@offsets   Object of same form that is returned from get*\x0a */\x0afunction setSelection(input, offsets) {\x0a  var start = offsets.start,\x0a      end = offsets.end;\x0a\x0a  if (end === undefined) {\x0a    end = start;\x0a  }\x0a\x0a  if (\x27selectionStart\x27 in input) {\x0a    input.selectionStart = start;\x0a    input.selectionEnd = Math.min(end, input.value.length);\x0a  } else {\x0a    setOffsets(input, offsets);\x0a  }\x0a}\x0a\x0avar skipSelectionChangeEvent = canUseDOM && \x27documentMode\x27 in document && document.documentMode \x3c= 11;\x0a\x0avar eventTypes$3 = {\x0a  select: {\x0a    phasedRegistrationNames: {\x0a      bubbled: \x27onSelect\x27,\x0a      captured: \x27onSelectCapture\x27\x0a    },\x0a    dependencies: [TOP_BLUR, TOP_CONTEXT_MENU, TOP_DRAG_END, TOP_FOCUS, TOP_KEY_DOWN, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_SELECTION_CHANGE]\x0a  }\x0a};\x0a\x0avar activeElement$1 = null;\x0avar activeElementInst$1 = null;\x0avar lastSelection = null;\x0avar mouseDown = false;\x0a\x0a/**\x0a * Get an object which is a unique representation of the current selection.\x0a *\x0a * The return value will not be consistent across nodes or browsers, but\x0a * two identical selections on the same node will return identical objects.\x0a *\x0a * @param {DOMElement} node\x0a * @return {object}\x0a */\x0afunction getSelection(node) {\x0a  if (\x27selectionStart\x27 in node && hasSelectionCapabilities(node)) {\x0a    return {\x0a      start: node.selectionStart,\x0a      end: node.selectionEnd\x0a    };\x0a  } else {\x0a    var win = node.ownerDocument && node.ownerDocument.defaultView || window;\x0a    var selection = win.getSelection();\x0a    return {\x0a      anchorNode: selection.anchorNode,\x0a      anchorOffset: selection.anchorOffset,\x0a      focusNode: selection.focusNode,\x0a      focusOffset: selection.focusOffset\x0a    };\x0a  }\x0a}\x0a\x0a/**\x0a * Get document associated with the event target.\x0a *\x0a * @param {object} nativeEventTarget\x0a * @return {Document}\x0a */\x0afunction getEventTargetDocument(eventTarget) {\x0a  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\x0a}\x0a\x0a/**\x0a * Poll selection to see whether it\x27s changed.\x0a *\x0a * @param {object} nativeEvent\x0a * @param {object} nativeEventTarget\x0a * @return {?SyntheticEvent}\x0a */\x0afunction constructSelectEvent(nativeEvent, nativeEventTarget) {\x0a  // Ensure we have the right element, and that the user is not dragging a\x0a  // selection (this matches native `select` event behavior). In HTML5, select\x0a  // fires only on input and textarea thus if there\x27s no focused element we\x0a  // won\x27t dispatch.\x0a  var doc = getEventTargetDocument(nativeEventTarget);\x0a\x0a  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {\x0a    return null;\x0a  }\x0a\x0a  // Only fire when selection has actually changed.\x0a  var currentSelection = getSelection(activeElement$1);\x0a  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\x0a    lastSelection = currentSelection;\x0a\x0a    var syntheticEvent = SyntheticEvent.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\x0a\x0a    syntheticEvent.type = \x27select\x27;\x0a    syntheticEvent.target = activeElement$1;\x0a\x0a    accumulateTwoPhaseDispatches(syntheticEvent);\x0a\x0a    return syntheticEvent;\x0a  }\x0a\x0a  return null;\x0a}\x0a\x0a/**\x0a * This plugin creates an `onSelect` event that normalizes select events\x0a * across form elements.\x0a *\x0a * Supported elements are:\x0a * - input (see `isTextInputElement`)\x0a * - textarea\x0a * - contentEditable\x0a *\x0a * This differs from native browser implementations in the following ways:\x0a * - Fires on contentEditable fields as well as inputs.\x0a * - Fires for collapsed selection.\x0a * - Fires after user input.\x0a */\x0avar SelectEventPlugin = {\x0a  eventTypes: eventTypes$3,\x0a\x0a  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\x0a    var doc = getEventTargetDocument(nativeEventTarget);\x0a    // Track whether all listeners exists for this plugin. If none exist, we do\x0a    // not extract events. See #3639.\x0a    if (!doc || !isListeningToAllDependencies(\x27onSelect\x27, doc)) {\x0a      return null;\x0a    }\x0a\x0a    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\x0a\x0a    switch (topLevelType) {\x0a      // Track the input node that has focus.\x0a      case TOP_FOCUS:\x0a        if (isTextInputElement(targetNode) || targetNode.contentEditable === \x27true\x27) {\x0a          activeElement$1 = targetNode;\x0a          activeElementInst$1 = targetInst;\x0a          lastSelection = null;\x0a        }\x0a        break;\x0a      case TOP_BLUR:\x0a        activeElement$1 = null;\x0a        activeElementInst$1 = null;\x0a        lastSelection = null;\x0a        break;\x0a      // Don\x27t fire the event while the user is dragging. This matches the\x0a      // semantics of the native select event.\x0a      case TOP_MOUSE_DOWN:\x0a        mouseDown = true;\x0a        break;\x0a      case TOP_CONTEXT_MENU:\x0a      case TOP_MOUSE_UP:\x0a      case TOP_DRAG_END:\x0a        mouseDown = false;\x0a        return constructSelectEvent(nativeEvent, nativeEventTarget);\x0a      // Chrome and IE fire non-standard event when selection is changed (and\x0a      // sometimes when it hasn\x27t). IE\x27s event fires out of order with respect\x0a      // to key and input events on deletion, so we discard it.\x0a      //\x0a      // Firefox doesn\x27t support selectionchange, so check selection status\x0a      // after each key entry. The selection changes after keydown and before\x0a      // keyup, but we check on keydown as well in the case of holding down a\x0a      // key, when multiple keydown events are fired but only one keyup is.\x0a      // This is also our approach for IE handling, for the reason above.\x0a      case TOP_SELECTION_CHANGE:\x0a        if (skipSelectionChangeEvent) {\x0a          break;\x0a        }\x0a      // falls through\x0a      case TOP_KEY_DOWN:\x0a      case TOP_KEY_UP:\x0a        return constructSelectEvent(nativeEvent, nativeEventTarget);\x0a    }\x0a\x0a    return null;\x0a  }\x0a};\x0a\x0a/**\x0a * Inject modules for resolving DOM hierarchy and plugin ordering.\x0a */\x0ainjection.injectEventPluginOrder(DOMEventPluginOrder);\x0asetComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1);\x0a\x0a/**\x0a * Some important event plugins included by default (without having to require\x0a * them).\x0a */\x0ainjection.injectEventPluginsByName({\x0a  SimpleEventPlugin: SimpleEventPlugin,\x0a  EnterLeaveEventPlugin: EnterLeaveEventPlugin,\x0a  ChangeEventPlugin: ChangeEventPlugin,\x0a  SelectEventPlugin: SelectEventPlugin,\x0a  BeforeInputEventPlugin: BeforeInputEventPlugin\x0a});\x0a\x0avar didWarnSelectedSetOnOption = false;\x0avar didWarnInvalidChild = false;\x0a\x0afunction flattenChildren(children) {\x0a  var content = \x27\x27;\x0a\x0a  // Flatten children. We\x27ll warn if they are invalid\x0a  // during validateProps() which runs for hydration too.\x0a  // Note that this would throw on non-element objects.\x0a  // Elements are stringified (which is normally irrelevant\x0a  // but matters for \x3cfbt\x3e).\x0a  React.Children.forEach(children, function (child) {\x0a    if (child == null) {\x0a      return;\x0a    }\x0a    content += child;\x0a    // Note: we don\x27t warn about invalid children here.\x0a    // Instead, this is done separately below so that\x0a    // it happens during the hydration codepath too.\x0a  });\x0a\x0a  return content;\x0a}\x0a\x0a/**\x0a * Implements an \x3coption\x3e host component that warns when `selected` is set.\x0a */\x0a\x0afunction validateProps(element, props) {\x0a  {\x0a    // This mirrors the codepath above, but runs for hydration too.\x0a    // Warn about invalid children here so that client and hydration are consistent.\x0a    // TODO: this seems like it could cause a DEV-only throw for hydration\x0a    // if children contains a non-element object. We should try to avoid that.\x0a    if (typeof props.children === \x27object\x27 && props.children !== null) {\x0a      React.Children.forEach(props.children, function (child) {\x0a        if (child == null) {\x0a          return;\x0a        }\x0a        if (typeof child === \x27string\x27 || typeof child === \x27number\x27) {\x0a          return;\x0a        }\x0a        if (typeof child.type !== \x27string\x27) {\x0a          return;\x0a        }\x0a        if (!didWarnInvalidChild) {\x0a          didWarnInvalidChild = true;\x0a          warning$1(false, \x27Only strings and numbers are supported as \x3coption\x3e children.\x27);\x0a        }\x0a      });\x0a    }\x0a\x0a    // TODO: Remove support for `selected` in \x3coption\x3e.\x0a    if (props.selected != null && !didWarnSelectedSetOnOption) {\x0a      warning$1(false, \x27Use the `defaultValue` or `value` props on \x3cselect\x3e instead of \x27 + \x27setting `selected` on \x3coption\x3e.\x27);\x0a      didWarnSelectedSetOnOption = true;\x0a    }\x0a  }\x0a}\x0a\x0afunction postMountWrapper$1(element, props) {\x0a  // value=\x22\x22 should make a value attribute (#6219)\x0a  if (props.value != null) {\x0a    element.setAttribute(\x27value\x27, toString(getToStringValue(props.value)));\x0a  }\x0a}\x0a\x0afunction getHostProps$1(element, props) {\x0a  var hostProps = _assign({ children: undefined }, props);\x0a  var content = flattenChildren(props.children);\x0a\x0a  if (content) {\x0a    hostProps.children = content;\x0a  }\x0a\x0a  return hostProps;\x0a}\x0a\x0a// TODO: direct imports like some-package/src/* are bad. Fix me.\x0avar didWarnValueDefaultValue$1 = void 0;\x0a\x0a{\x0a  didWarnValueDefaultValue$1 = false;\x0a}\x0a\x0afunction getDeclarationErrorAddendum() {\x0a  var ownerName = getCurrentFiberOwnerNameInDevOrNull();\x0a  if (ownerName) {\x0a    return \x27\x5cn\x5cnCheck the render method of `\x27 + ownerName + \x27`.\x27;\x0a  }\x0a  return \x27\x27;\x0a}\x0a\x0avar valuePropNames = [\x27value\x27, \x27defaultValue\x27];\x0a\x0a/**\x0a * Validation function for `value` and `defaultValue`.\x0a */\x0afunction checkSelectPropTypes(props) {\x0a  ReactControlledValuePropTypes.checkPropTypes(\x27select\x27, props);\x0a\x0a  for (var i = 0; i \x3c valuePropNames.length; i++) {\x0a    var propName = valuePropNames[i];\x0a    if (props[propName] == null) {\x0a      continue;\x0a    }\x0a    var isArray = Array.isArray(props[propName]);\x0a    if (props.multiple && !isArray) {\x0a      warning$1(false, \x27The `%s` prop supplied to \x3cselect\x3e must be an array if \x27 + \x27`multiple` is true.%s\x27, propName, getDeclarationErrorAddendum());\x0a    } else if (!props.multiple && isArray) {\x0a      warning$1(false, \x27The `%s` prop supplied to \x3cselect\x3e must be a scalar \x27 + \x27value if `multiple` is false.%s\x27, propName, getDeclarationErrorAddendum());\x0a    }\x0a  }\x0a}\x0a\x0afunction updateOptions(node, multiple, propValue, setDefaultSelected) {\x0a  var options = node.options;\x0a\x0a  if (multiple) {\x0a    var selectedValues = propValue;\x0a    var selectedValue = {};\x0a    for (var i = 0; i \x3c selectedValues.length; i++) {\x0a      // Prefix to avoid chaos with special keys.\x0a      selectedValue[\x27$\x27 + selectedValues[i]] = true;\x0a    }\x0a    for (var _i = 0; _i \x3c options.length; _i++) {\x0a      var selected = selectedValue.hasOwnProperty(\x27$\x27 + options[_i].value);\x0a      if (options[_i].selected !== selected) {\x0a        options[_i].selected = selected;\x0a      }\x0a      if (selected && setDefaultSelected) {\x0a        options[_i].defaultSelected = true;\x0a      }\x0a    }\x0a  } else {\x0a    // Do not set `select.value` as exact behavior isn\x27t consistent across all\x0a    // browsers for all cases.\x0a    var _selectedValue = toString(getToStringValue(propValue));\x0a    var defaultSelected = null;\x0a    for (var _i2 = 0; _i2 \x3c options.length; _i2++) {\x0a      if (options[_i2].value === _selectedValue) {\x0a        options[_i2].selected = true;\x0a        if (setDefaultSelected) {\x0a          options[_i2].defaultSelected = true;\x0a        }\x0a        return;\x0a      }\x0a      if (defaultSelected === null && !options[_i2].disabled) {\x0a        defaultSelected = options[_i2];\x0a      }\x0a    }\x0a    if (defaultSelected !== null) {\x0a      defaultSelected.selected = true;\x0a    }\x0a  }\x0a}\x0a\x0a/**\x0a * Implements a \x3cselect\x3e host component that allows optionally setting the\x0a * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\x0a * stringable. If `multiple` is true, the prop must be an array of stringables.\x0a *\x0a * If `value` is not supplied (or null/undefined), user actions that change the\x0a * selected option will trigger updates to the rendered options.\x0a *\x0a * If it is supplied (and not null/undefined), the rendered options will not\x0a * update in response to user actions. Instead, the `value` prop must change in\x0a * order for the rendered options to update.\x0a *\x0a * If `defaultValue` is provided, any options with the supplied values will be\x0a * selected.\x0a */\x0a\x0afunction getHostProps$2(element, props) {\x0a  return _assign({}, props, {\x0a    value: undefined\x0a  });\x0a}\x0a\x0afunction initWrapperState$1(element, props) {\x0a  var node = element;\x0a  {\x0a    checkSelectPropTypes(props);\x0a  }\x0a\x0a  node._wrapperState = {\x0a    wasMultiple: !!props.multiple\x0a  };\x0a\x0a  {\x0a    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\x0a      warning$1(false, \x27Select elements must be either controlled or uncontrolled \x27 + \x27(specify either the value prop, or the defaultValue prop, but not \x27 + \x27both). Decide between using a controlled or uncontrolled select \x27 + \x27element and remove one of these props. More info: \x27 + \x27https://fb.me/react-controlled-components\x27);\x0a      didWarnValueDefaultValue$1 = true;\x0a    }\x0a  }\x0a}\x0a\x0afunction postMountWrapper$2(element, props) {\x0a  var node = element;\x0a  node.multiple = !!props.multiple;\x0a  var value = props.value;\x0a  if (value != null) {\x0a    updateOptions(node, !!props.multiple, value, false);\x0a  } else if (props.defaultValue != null) {\x0a    updateOptions(node, !!props.multiple, props.defaultValue, true);\x0a  }\x0a}\x0a\x0afunction postUpdateWrapper(element, props) {\x0a  var node = element;\x0a  var wasMultiple = node._wrapperState.wasMultiple;\x0a  node._wrapperState.wasMultiple = !!props.multiple;\x0a\x0a  var value = props.value;\x0a  if (value != null) {\x0a    updateOptions(node, !!props.multiple, value, false);\x0a  } else if (wasMultiple !== !!props.multiple) {\x0a    // For simplicity, reapply `defaultValue` if `multiple` is toggled.\x0a    if (props.defaultValue != null) {\x0a      updateOptions(node, !!props.multiple, props.defaultValue, true);\x0a    } else {\x0a      // Revert the select back to its default unselected state.\x0a      updateOptions(node, !!props.multiple, props.multiple ? [] : \x27\x27, false);\x0a    }\x0a  }\x0a}\x0a\x0afunction restoreControlledState$2(element, props) {\x0a  var node = element;\x0a  var value = props.value;\x0a\x0a  if (value != null) {\x0a    updateOptions(node, !!props.multiple, value, false);\x0a  }\x0a}\x0a\x0avar didWarnValDefaultVal = false;\x0a\x0a/**\x0a * Implements a \x3ctextarea\x3e host component that allows setting `value`, and\x0a * `defaultValue`. This differs from the traditional DOM API because value is\x0a * usually set as PCDATA children.\x0a *\x0a * If `value` is not supplied (or null/undefined), user actions that affect the\x0a * value will trigger updates to the element.\x0a *\x0a * If `value` is supplied (and not null/undefined), the rendered element will\x0a * not trigger updates to the element. Instead, the `value` prop must change in\x0a * order for the rendered element to be updated.\x0a *\x0a * The rendered element will be initialized with an empty value, the prop\x0a * `defaultValue` if specified, or the children content (deprecated).\x0a */\x0a\x0afunction getHostProps$3(element, props) {\x0a  var node = element;\x0a  !(props.dangerouslySetInnerHTML == null) ? invariant(false, \x27`dangerouslySetInnerHTML` does not make sense on \x3ctextarea\x3e.\x27) : void 0;\x0a\x0a  // Always set children to the same thing. In IE9, the selection range will\x0a  // get reset if `textContent` is mutated.  We could add a check in setTextContent\x0a  // to only set the value if/when the value differs from the node value (which would\x0a  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\x0a  // solution. The value can be a boolean or object so that\x27s why it\x27s forced\x0a  // to be a string.\x0a  var hostProps = _assign({}, props, {\x0a    value: undefined,\x0a    defaultValue: undefined,\x0a    children: toString(node._wrapperState.initialValue)\x0a  });\x0a\x0a  return hostProps;\x0a}\x0a\x0afunction initWrapperState$2(element, props) {\x0a  var node = element;\x0a  {\x0a    ReactControlledValuePropTypes.checkPropTypes(\x27textarea\x27, props);\x0a    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\x0a      warning$1(false, \x27%s contains a textarea with both value and defaultValue props. \x27 + \x27Textarea elements must be either controlled or uncontrolled \x27 + \x27(specify either the value prop, or the defaultValue prop, but not \x27 + \x27both). Decide between using a controlled or uncontrolled textarea \x27 + \x27and remove one of these props. More info: \x27 + \x27https://fb.me/react-controlled-components\x27, getCurrentFiberOwnerNameInDevOrNull() || \x27A component\x27);\x0a      didWarnValDefaultVal = true;\x0a    }\x0a  }\x0a\x0a  var initialValue = props.value;\x0a\x0a  // Only bother fetching default value if we\x27re going to use it\x0a  if (initialValue == null) {\x0a    var defaultValue = props.defaultValue;\x0a    // TODO (yungsters): Remove support for children content in \x3ctextarea\x3e.\x0a    var children = props.children;\x0a    if (children != null) {\x0a      {\x0a        warning$1(false, \x27Use the `defaultValue` or `value` props instead of setting \x27 + \x27children on \x3ctextarea\x3e.\x27);\x0a      }\x0a      !(defaultValue == null) ? invariant(false, \x27If you supply `defaultValue` on a \x3ctextarea\x3e, do not pass children.\x27) : void 0;\x0a      if (Array.isArray(children)) {\x0a        !(children.length \x3c= 1) ? invariant(false, \x27\x3ctextarea\x3e can only have at most one child.\x27) : void 0;\x0a        children = children[0];\x0a      }\x0a\x0a      defaultValue = children;\x0a    }\x0a    if (defaultValue == null) {\x0a      defaultValue = \x27\x27;\x0a    }\x0a    initialValue = defaultValue;\x0a  }\x0a\x0a  node._wrapperState = {\x0a    initialValue: getToStringValue(initialValue)\x0a  };\x0a}\x0a\x0afunction updateWrapper$1(element, props) {\x0a  var node = element;\x0a  var value = getToStringValue(props.value);\x0a  var defaultValue = getToStringValue(props.defaultValue);\x0a  if (value != null) {\x0a    // Cast `value` to a string to ensure the value is set correctly. While\x0a    // browsers typically do this as necessary, jsdom doesn\x27t.\x0a    var newValue = toString(value);\x0a    // To avoid side effects (such as losing text selection), only set value if changed\x0a    if (newValue !== node.value) {\x0a      node.value = newValue;\x0a    }\x0a    if (props.defaultValue == null && node.defaultValue !== newValue) {\x0a      node.defaultValue = newValue;\x0a    }\x0a  }\x0a  if (defaultValue != null) {\x0a    node.defaultValue = toString(defaultValue);\x0a  }\x0a}\x0a\x0afunction postMountWrapper$3(element, props) {\x0a  var node = element;\x0a  // This is in postMount because we need access to the DOM node, which is not\x0a  // available until after the component has mounted.\x0a  var textContent = node.textContent;\x0a\x0a  // Only set node.value if textContent is equal to the expected\x0a  // initial value. In IE10/IE11 there is a bug where the placeholder attribute\x0a  // will populate textContent as well.\x0a  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\x0a  if (textContent === node._wrapperState.initialValue) {\x0a    node.value = textContent;\x0a  }\x0a}\x0a\x0afunction restoreControlledState$3(element, props) {\x0a  // DOM component is still mounted; update\x0a  updateWrapper$1(element, props);\x0a}\x0a\x0avar HTML_NAMESPACE$1 = \x27http://www.w3.org/1999/xhtml\x27;\x0avar MATH_NAMESPACE = \x27http://www.w3.org/1998/Math/MathML\x27;\x0avar SVG_NAMESPACE = \x27http://www.w3.org/2000/svg\x27;\x0a\x0avar Namespaces = {\x0a  html: HTML_NAMESPACE$1,\x0a  mathml: MATH_NAMESPACE,\x0a  svg: SVG_NAMESPACE\x0a};\x0a\x0a// Assumes there is no parent namespace.\x0afunction getIntrinsicNamespace(type) {\x0a  switch (type) {\x0a    case \x27svg\x27:\x0a      return SVG_NAMESPACE;\x0a    case \x27math\x27:\x0a      return MATH_NAMESPACE;\x0a    default:\x0a      return HTML_NAMESPACE$1;\x0a  }\x0a}\x0a\x0afunction getChildNamespace(parentNamespace, type) {\x0a  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {\x0a    // No (or default) parent namespace: potential entry point.\x0a    return getIntrinsicNamespace(type);\x0a  }\x0a  if (parentNamespace === SVG_NAMESPACE && type === \x27foreignObject\x27) {\x0a    // We\x27re leaving SVG.\x0a    return HTML_NAMESPACE$1;\x0a  }\x0a  // By default, pass namespace below.\x0a  return parentNamespace;\x0a}\x0a\x0a/* globals MSApp */\x0a\x0a/**\x0a * Create a function which has \x27unsafe\x27 privileges (required by windows8 apps)\x0a */\x0avar createMicrosoftUnsafeLocalFunction = function (func) {\x0a  if (typeof MSApp !== \x27undefined\x27 && MSApp.execUnsafeLocalFunction) {\x0a    return function (arg0, arg1, arg2, arg3) {\x0a      MSApp.execUnsafeLocalFunction(function () {\x0a        return func(arg0, arg1, arg2, arg3);\x0a      });\x0a    };\x0a  } else {\x0a    return func;\x0a  }\x0a};\x0a\x0a// SVG temp container for IE lacking innerHTML\x0avar reusableSVGContainer = void 0;\x0a\x0a/**\x0a * Set the innerHTML property of a node\x0a *\x0a * @param {DOMElement} node\x0a * @param {string} html\x0a * @internal\x0a */\x0avar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\x0a  // IE does not have innerHTML for SVG nodes, so instead we inject the\x0a  // new markup in a temp node and then move the child nodes across into\x0a  // the target node\x0a\x0a  if (node.namespaceURI === Namespaces.svg && !(\x27innerHTML\x27 in node)) {\x0a    reusableSVGContainer = reusableSVGContainer || document.createElement(\x27div\x27);\x0a    reusableSVGContainer.innerHTML = \x27\x3csvg\x3e\x27 + html + \x27\x3c/svg\x3e\x27;\x0a    var svgNode = reusableSVGContainer.firstChild;\x0a    while (node.firstChild) {\x0a      node.removeChild(node.firstChild);\x0a    }\x0a    while (svgNode.firstChild) {\x0a      node.appendChild(svgNode.firstChild);\x0a    }\x0a  } else {\x0a    node.innerHTML = html;\x0a  }\x0a});\x0a\x0a/**\x0a * Set the textContent property of a node. For text updates, it\x27s faster\x0a * to set the `nodeValue` of the Text node directly instead of using\x0a * `.textContent` which will remove the existing node and create a new one.\x0a *\x0a * @param {DOMElement} node\x0a * @param {string} text\x0a * @internal\x0a */\x0avar setTextContent = function (node, text) {\x0a  if (text) {\x0a    var firstChild = node.firstChild;\x0a\x0a    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\x0a      firstChild.nodeValue = text;\x0a      return;\x0a    }\x0a  }\x0a  node.textContent = text;\x0a};\x0a\x0a// List derived from Gecko source code:\x0a// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js\x0avar shorthandToLonghand = {\x0a  animation: [\x27animationDelay\x27, \x27animationDirection\x27, \x27animationDuration\x27, \x27animationFillMode\x27, \x27animationIterationCount\x27, \x27animationName\x27, \x27animationPlayState\x27, \x27animationTimingFunction\x27],\x0a  background: [\x27backgroundAttachment\x27, \x27backgroundClip\x27, \x27backgroundColor\x27, \x27backgroundImage\x27, \x27backgroundOrigin\x27, \x27backgroundPositionX\x27, \x27backgroundPositionY\x27, \x27backgroundRepeat\x27, \x27backgroundSize\x27],\x0a  backgroundPosition: [\x27backgroundPositionX\x27, \x27backgroundPositionY\x27],\x0a  border: [\x27borderBottomColor\x27, \x27borderBottomStyle\x27, \x27borderBottomWidth\x27, \x27borderImageOutset\x27, \x27borderImageRepeat\x27, \x27borderImageSlice\x27, \x27borderImageSource\x27, \x27borderImageWidth\x27, \x27borderLeftColor\x27, \x27borderLeftStyle\x27, \x27borderLeftWidth\x27, \x27borderRightColor\x27, \x27borderRightStyle\x27, \x27borderRightWidth\x27, \x27borderTopColor\x27, \x27borderTopStyle\x27, \x27borderTopWidth\x27],\x0a  borderBlockEnd: [\x27borderBlockEndColor\x27, \x27borderBlockEndStyle\x27, \x27borderBlockEndWidth\x27],\x0a  borderBlockStart: [\x27borderBlockStartColor\x27, \x27borderBlockStartStyle\x27, \x27borderBlockStartWidth\x27],\x0a  borderBottom: [\x27borderBottomColor\x27, \x27borderBottomStyle\x27, \x27borderBottomWidth\x27],\x0a  borderColor: [\x27borderBottomColor\x27, \x27borderLeftColor\x27, \x27borderRightColor\x27, \x27borderTopColor\x27],\x0a  borderImage: [\x27borderImageOutset\x27, \x27borderImageRepeat\x27, \x27borderImageSlice\x27, \x27borderImageSource\x27, \x27borderImageWidth\x27],\x0a  borderInlineEnd: [\x27borderInlineEndColor\x27, \x27borderInlineEndStyle\x27, \x27borderInlineEndWidth\x27],\x0a  borderInlineStart: [\x27borderInlineStartColor\x27, \x27borderInlineStartStyle\x27, \x27borderInlineStartWidth\x27],\x0a  borderLeft: [\x27borderLeftColor\x27, \x27borderLeftStyle\x27, \x27borderLeftWidth\x27],\x0a  borderRadius: [\x27borderBottomLeftRadius\x27, \x27borderBottomRightRadius\x27, \x27borderTopLeftRadius\x27, \x27borderTopRightRadius\x27],\x0a  borderRight: [\x27borderRightColor\x27, \x27borderRightStyle\x27, \x27borderRightWidth\x27],\x0a  borderStyle: [\x27borderBottomStyle\x27, \x27borderLeftStyle\x27, \x27borderRightStyle\x27, \x27borderTopStyle\x27],\x0a  borderTop: [\x27borderTopColor\x27, \x27borderTopStyle\x27, \x27borderTopWidth\x27],\x0a  borderWidth: [\x27borderBottomWidth\x27, \x27borderLeftWidth\x27, \x27borderRightWidth\x27, \x27borderTopWidth\x27],\x0a  columnRule: [\x27columnRuleColor\x27, \x27columnRuleStyle\x27, \x27columnRuleWidth\x27],\x0a  columns: [\x27columnCount\x27, \x27columnWidth\x27],\x0a  flex: [\x27flexBasis\x27, \x27flexGrow\x27, \x27flexShrink\x27],\x0a  flexFlow: [\x27flexDirection\x27, \x27flexWrap\x27],\x0a  font: [\x27fontFamily\x27, \x27fontFeatureSettings\x27, \x27fontKerning\x27, \x27fontLanguageOverride\x27, \x27fontSize\x27, \x27fontSizeAdjust\x27, \x27fontStretch\x27, \x27fontStyle\x27, \x27fontVariant\x27, \x27fontVariantAlternates\x27, \x27fontVariantCaps\x27, \x27fontVariantEastAsian\x27, \x27fontVariantLigatures\x27, \x27fontVariantNumeric\x27, \x27fontVariantPosition\x27, \x27fontWeight\x27, \x27lineHeight\x27],\x0a  fontVariant: [\x27fontVariantAlternates\x27, \x27fontVariantCaps\x27, \x27fontVariantEastAsian\x27, \x27fontVariantLigatures\x27, \x27fontVariantNumeric\x27, \x27fontVariantPosition\x27],\x0a  gap: [\x27columnGap\x27, \x27rowGap\x27],\x0a  grid: [\x27gridAutoColumns\x27, \x27gridAutoFlow\x27, \x27gridAutoRows\x27, \x27gridTemplateAreas\x27, \x27gridTemplateColumns\x27, \x27gridTemplateRows\x27],\x0a  gridArea: [\x27gridColumnEnd\x27, \x27gridColumnStart\x27, \x27gridRowEnd\x27, \x27gridRowStart\x27],\x0a  gridColumn: [\x27gridColumnEnd\x27, \x27gridColumnStart\x27],\x0a  gridColumnGap: [\x27columnGap\x27],\x0a  gridGap: [\x27columnGap\x27, \x27rowGap\x27],\x0a  gridRow: [\x27gridRowEnd\x27, \x27gridRowStart\x27],\x0a  gridRowGap: [\x27rowGap\x27],\x0a  gridTemplate: [\x27gridTemplateAreas\x27, \x27gridTemplateColumns\x27, \x27gridTemplateRows\x27],\x0a  listStyle: [\x27listStyleImage\x27, \x27listStylePosition\x27, \x27listStyleType\x27],\x0a  margin: [\x27marginBottom\x27, \x27marginLeft\x27, \x27marginRight\x27, \x27marginTop\x27],\x0a  marker: [\x27markerEnd\x27, \x27markerMid\x27, \x27markerStart\x27],\x0a  mask: [\x27maskClip\x27, \x27maskComposite\x27, \x27maskImage\x27, \x27maskMode\x27, \x27maskOrigin\x27, \x27maskPositionX\x27, \x27maskPositionY\x27, \x27maskRepeat\x27, \x27maskSize\x27],\x0a  maskPosition: [\x27maskPositionX\x27, \x27maskPositionY\x27],\x0a  outline: [\x27outlineColor\x27, \x27outlineStyle\x27, \x27outlineWidth\x27],\x0a  overflow: [\x27overflowX\x27, \x27overflowY\x27],\x0a  padding: [\x27paddingBottom\x27, \x27paddingLeft\x27, \x27paddingRight\x27, \x27paddingTop\x27],\x0a  placeContent: [\x27alignContent\x27, \x27justifyContent\x27],\x0a  placeItems: [\x27alignItems\x27, \x27justifyItems\x27],\x0a  placeSelf: [\x27alignSelf\x27, \x27justifySelf\x27],\x0a  textDecoration: [\x27textDecorationColor\x27, \x27textDecorationLine\x27, \x27textDecorationStyle\x27],\x0a  textEmphasis: [\x27textEmphasisColor\x27, \x27textEmphasisStyle\x27],\x0a  transition: [\x27transitionDelay\x27, \x27transitionDuration\x27, \x27transitionProperty\x27, \x27transitionTimingFunction\x27],\x0a  wordWrap: [\x27overflowWrap\x27]\x0a};\x0a\x0a/**\x0a * CSS properties which accept numbers but are not in units of \x22px\x22.\x0a */\x0avar isUnitlessNumber = {\x0a  animationIterationCount: true,\x0a  borderImageOutset: true,\x0a  borderImageSlice: true,\x0a  borderImageWidth: true,\x0a  boxFlex: true,\x0a  boxFlexGroup: true,\x0a  boxOrdinalGroup: true,\x0a  columnCount: true,\x0a  columns: true,\x0a  flex: true,\x0a  flexGrow: true,\x0a  flexPositive: true,\x0a  flexShrink: true,\x0a  flexNegative: true,\x0a  flexOrder: true,\x0a  gridArea: true,\x0a  gridRow: true,\x0a  gridRowEnd: true,\x0a  gridRowSpan: true,\x0a  gridRowStart: true,\x0a  gridColumn: true,\x0a  gridColumnEnd: true,\x0a  gridColumnSpan: true,\x0a  gridColumnStart: true,\x0a  fontWeight: true,\x0a  lineClamp: true,\x0a  lineHeight: true,\x0a  opacity: true,\x0a  order: true,\x0a  orphans: true,\x0a  tabSize: true,\x0a  widows: true,\x0a  zIndex: true,\x0a  zoom: true,\x0a\x0a  // SVG-related properties\x0a  fillOpacity: true,\x0a  floodOpacity: true,\x0a  stopOpacity: true,\x0a  strokeDasharray: true,\x0a  strokeDashoffset: true,\x0a  strokeMiterlimit: true,\x0a  strokeOpacity: true,\x0a  strokeWidth: true\x0a};\x0a\x0a/**\x0a * @param {string} prefix vendor-specific prefix, eg: Webkit\x0a * @param {string} key style name, eg: transitionDuration\x0a * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\x0a * WebkitTransitionDuration\x0a */\x0afunction prefixKey(prefix, key) {\x0a  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\x0a}\x0a\x0a/**\x0a * Support style names that may come passed in prefixed by adding permutations\x0a * of vendor prefixes.\x0a */\x0avar prefixes = [\x27Webkit\x27, \x27ms\x27, \x27Moz\x27, \x27O\x27];\x0a\x0a// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\x0a// infinite loop, because it iterates over the newly added props too.\x0aObject.keys(isUnitlessNumber).forEach(function (prop) {\x0a  prefixes.forEach(function (prefix) {\x0a    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\x0a  });\x0a});\x0a\x0a/**\x0a * Convert a value into the proper css writable value. The style name `name`\x0a * should be logical (no hyphens), as specified\x0a * in `CSSProperty.isUnitlessNumber`.\x0a *\x0a * @param {string} name CSS property name such as `topMargin`.\x0a * @param {*} value CSS property value such as `10px`.\x0a * @return {string} Normalized style value with dimensions applied.\x0a */\x0afunction dangerousStyleValue(name, value, isCustomProperty) {\x0a  // Note that we\x27ve removed escapeTextForBrowser() calls here since the\x0a  // whole string will be escaped when the attribute is injected into\x0a  // the markup. If you provide unsafe user data here they can inject\x0a  // arbitrary CSS which may be problematic (I couldn\x27t repro this):\x0a  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\x0a  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\x0a  // This is not an XSS hole but instead a potential CSS injection issue\x0a  // which has lead to a greater discussion about how we\x27re going to\x0a  // trust URLs moving forward. See #2115901\x0a\x0a  var isEmpty = value == null || typeof value === \x27boolean\x27 || value === \x27\x27;\x0a  if (isEmpty) {\x0a    return \x27\x27;\x0a  }\x0a\x0a  if (!isCustomProperty && typeof value === \x27number\x27 && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\x0a    return value + \x27px\x27; // Presumes implicit \x27px\x27 suffix for unitless numbers\x0a  }\x0a\x0a  return (\x27\x27 + value).trim();\x0a}\x0a\x0avar uppercasePattern = /([A-Z])/g;\x0avar msPattern = /^ms-/;\x0a\x0a/**\x0a * Hyphenates a camelcased CSS property name, for example:\x0a *\x0a *   \x3e hyphenateStyleName(\x27backgroundColor\x27)\x0a *   \x3c \x22background-color\x22\x0a *   \x3e hyphenateStyleName(\x27MozTransition\x27)\x0a *   \x3c \x22-moz-transition\x22\x0a *   \x3e hyphenateStyleName(\x27msTransition\x27)\x0a *   \x3c \x22-ms-transition\x22\x0a *\x0a * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\x0a * is converted to `-ms-`.\x0a */\x0afunction hyphenateStyleName(name) {\x0a  return name.replace(uppercasePattern, \x27-$1\x27).toLowerCase().replace(msPattern, \x27-ms-\x27);\x0a}\x0a\x0avar warnValidStyle = function () {};\x0a\x0a{\x0a  // \x27msTransform\x27 is correct, but the other prefixes should be capitalized\x0a  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\x0a  var msPattern$1 = /^-ms-/;\x0a  var hyphenPattern = /-(.)/g;\x0a\x0a  // style values shouldn\x27t contain a semicolon\x0a  var badStyleValueWithSemicolonPattern = /;\x5cs*$/;\x0a\x0a  var warnedStyleNames = {};\x0a  var warnedStyleValues = {};\x0a  var warnedForNaNValue = false;\x0a  var warnedForInfinityValue = false;\x0a\x0a  var camelize = function (string) {\x0a    return string.replace(hyphenPattern, function (_, character) {\x0a      return character.toUpperCase();\x0a    });\x0a  };\x0a\x0a  var warnHyphenatedStyleName = function (name) {\x0a    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\x0a      return;\x0a    }\x0a\x0a    warnedStyleNames[name] = true;\x0a    warning$1(false, \x27Unsupported style property %s. Did you mean %s?\x27, name,\x0a    // As Andi Smith suggests\x0a    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\x0a    // is converted to lowercase `ms`.\x0a    camelize(name.replace(msPattern$1, \x27ms-\x27)));\x0a  };\x0a\x0a  var warnBadVendoredStyleName = function (name) {\x0a    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\x0a      return;\x0a    }\x0a\x0a    warnedStyleNames[name] = true;\x0a    warning$1(false, \x27Unsupported vendor-prefixed style property %s. Did you mean %s?\x27, name, name.charAt(0).toUpperCase() + name.slice(1));\x0a  };\x0a\x0a  var warnStyleValueWithSemicolon = function (name, value) {\x0a    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\x0a      return;\x0a    }\x0a\x0a    warnedStyleValues[value] = true;\x0a    warning$1(false, \x22Style property values shouldn\x27t contain a semicolon. \x22 + \x27Try \x22%s: %s\x22 instead.\x27, name, value.replace(badStyleValueWithSemicolonPattern, \x27\x27));\x0a  };\x0a\x0a  var warnStyleValueIsNaN = function (name, value) {\x0a    if (warnedForNaNValue) {\x0a      return;\x0a    }\x0a\x0a    warnedForNaNValue = true;\x0a    warning$1(false, \x27`NaN` is an invalid value for the `%s` css style property.\x27, name);\x0a  };\x0a\x0a  var warnStyleValueIsInfinity = function (name, value) {\x0a    if (warnedForInfinityValue) {\x0a      return;\x0a    }\x0a\x0a    warnedForInfinityValue = true;\x0a    warning$1(false, \x27`Infinity` is an invalid value for the `%s` css style property.\x27, name);\x0a  };\x0a\x0a  warnValidStyle = function (name, value) {\x0a    if (name.indexOf(\x27-\x27) \x3e -1) {\x0a      warnHyphenatedStyleName(name);\x0a    } else if (badVendoredStyleNamePattern.test(name)) {\x0a      warnBadVendoredStyleName(name);\x0a    } else if (badStyleValueWithSemicolonPattern.test(value)) {\x0a      warnStyleValueWithSemicolon(name, value);\x0a    }\x0a\x0a    if (typeof value === \x27number\x27) {\x0a      if (isNaN(value)) {\x0a        warnStyleValueIsNaN(name, value);\x0a      } else if (!isFinite(value)) {\x0a        warnStyleValueIsInfinity(name, value);\x0a      }\x0a    }\x0a  };\x0a}\x0a\x0avar warnValidStyle$1 = warnValidStyle;\x0a\x0a/**\x0a * Operations for dealing with CSS properties.\x0a */\x0a\x0a/**\x0a * This creates a string that is expected to be equivalent to the style\x0a * attribute generated by server-side rendering. It by-passes warnings and\x0a * security checks so it\x27s not safe to use this value for anything other than\x0a * comparison. It is only used in DEV for SSR validation.\x0a */\x0afunction createDangerousStringForStyles(styles) {\x0a  {\x0a    var serialized = \x27\x27;\x0a    var delimiter = \x27\x27;\x0a    for (var styleName in styles) {\x0a      if (!styles.hasOwnProperty(styleName)) {\x0a        continue;\x0a      }\x0a      var styleValue = styles[styleName];\x0a      if (styleValue != null) {\x0a        var isCustomProperty = styleName.indexOf(\x27--\x27) === 0;\x0a        serialized += delimiter + hyphenateStyleName(styleName) + \x27:\x27;\x0a        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\x0a\x0a        delimiter = \x27;\x27;\x0a      }\x0a    }\x0a    return serialized || null;\x0a  }\x0a}\x0a\x0a/**\x0a * Sets the value for multiple styles on a node.  If a value is specified as\x0a * \x27\x27 (empty string), the corresponding style property will be unset.\x0a *\x0a * @param {DOMElement} node\x0a * @param {object} styles\x0a */\x0afunction setValueForStyles(node, styles) {\x0a  var style = node.style;\x0a  for (var styleName in styles) {\x0a    if (!styles.hasOwnProperty(styleName)) {\x0a      continue;\x0a    }\x0a    var isCustomProperty = styleName.indexOf(\x27--\x27) === 0;\x0a    {\x0a      if (!isCustomProperty) {\x0a        warnValidStyle$1(styleName, styles[styleName]);\x0a      }\x0a    }\x0a    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\x0a    if (styleName === \x27float\x27) {\x0a      styleName = \x27cssFloat\x27;\x0a    }\x0a    if (isCustomProperty) {\x0a      style.setProperty(styleName, styleValue);\x0a    } else {\x0a      style[styleName] = styleValue;\x0a    }\x0a  }\x0a}\x0a\x0afunction isValueEmpty(value) {\x0a  return value == null || typeof value === \x27boolean\x27 || value === \x27\x27;\x0a}\x0a\x0a/**\x0a * Given {color: \x27red\x27, overflow: \x27hidden\x27} returns {\x0a *   color: \x27color\x27,\x0a *   overflowX: \x27overflow\x27,\x0a *   overflowY: \x27overflow\x27,\x0a * }. This can be read as \x22the overflowY property was set by the overflow\x0a * shorthand\x22. That is, the values are the property that each was derived from.\x0a */\x0afunction expandShorthandMap(styles) {\x0a  var expanded = {};\x0a  for (var key in styles) {\x0a    var longhands = shorthandToLonghand[key] || [key];\x0a    for (var i = 0; i \x3c longhands.length; i++) {\x0a      expanded[longhands[i]] = key;\x0a    }\x0a  }\x0a  return expanded;\x0a}\x0a\x0a/**\x0a * When mixing shorthand and longhand property names, we warn during updates if\x0a * we expect an incorrect result to occur. In particular, we warn for:\x0a *\x0a * Updating a shorthand property (longhand gets overwritten):\x0a *   {font: \x27foo\x27, fontVariant: \x27bar\x27} -\x3e {font: \x27baz\x27, fontVariant: \x27bar\x27}\x0a *   becomes .style.font = \x27baz\x27\x0a * Removing a shorthand property (longhand gets lost too):\x0a *   {font: \x27foo\x27, fontVariant: \x27bar\x27} -\x3e {fontVariant: \x27bar\x27}\x0a *   becomes .style.font = \x27\x27\x0a * Removing a longhand property (should revert to shorthand; doesn\x27t):\x0a *   {font: \x27foo\x27, fontVariant: \x27bar\x27} -\x3e {font: \x27foo\x27}\x0a *   becomes .style.fontVariant = \x27\x27\x0a */\x0afunction validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {\x0a  if (!warnAboutShorthandPropertyCollision) {\x0a    return;\x0a  }\x0a\x0a  if (!nextStyles) {\x0a    return;\x0a  }\x0a\x0a  var expandedUpdates = expandShorthandMap(styleUpdates);\x0a  var expandedStyles = expandShorthandMap(nextStyles);\x0a  var warnedAbout = {};\x0a  for (var key in expandedUpdates) {\x0a    var originalKey = expandedUpdates[key];\x0a    var correctOriginalKey = expandedStyles[key];\x0a    if (correctOriginalKey && originalKey !== correctOriginalKey) {\x0a      var warningKey = originalKey + \x27,\x27 + correctOriginalKey;\x0a      if (warnedAbout[warningKey]) {\x0a        continue;\x0a      }\x0a      warnedAbout[warningKey] = true;\x0a      warning$1(false, \x27%s a style property during rerender (%s) when a \x27 + \x27conflicting property is set (%s) can lead to styling bugs. To \x27 + \x22avoid this, don\x27t mix shorthand and non-shorthand properties \x22 + \x27for the same value; instead, replace the shorthand with \x27 + \x27separate values.\x27, isValueEmpty(styleUpdates[originalKey]) ? \x27Removing\x27 : \x27Updating\x27, originalKey, correctOriginalKey);\x0a    }\x0a  }\x0a}\x0a\x0a// For HTML, certain tags should omit their close tag. We keep a whitelist for\x0a// those special-case tags.\x0a\x0avar omittedCloseTags = {\x0a  area: true,\x0a  base: true,\x0a  br: true,\x0a  col: true,\x0a  embed: true,\x0a  hr: true,\x0a  img: true,\x0a  input: true,\x0a  keygen: true,\x0a  link: true,\x0a  meta: true,\x0a  param: true,\x0a  source: true,\x0a  track: true,\x0a  wbr: true\x0a  // NOTE: menuitem\x27s close tag should be omitted, but that causes problems.\x0a};\x0a\x0a// For HTML, certain tags cannot have children. This has the same purpose as\x0a// `omittedCloseTags` except that `menuitem` should still have its closing tag.\x0a\x0avar voidElementTags = _assign({\x0a  menuitem: true\x0a}, omittedCloseTags);\x0a\x0a// TODO: We can remove this if we add invariantWithStack()\x0a// or add stack by default to invariants where possible.\x0avar HTML$1 = \x27__html\x27;\x0a\x0avar ReactDebugCurrentFrame$2 = null;\x0a{\x0a  ReactDebugCurrentFrame$2 = ReactSharedInternals.ReactDebugCurrentFrame;\x0a}\x0a\x0afunction assertValidProps(tag, props) {\x0a  if (!props) {\x0a    return;\x0a  }\x0a  // Note the use of `==` which checks for null or undefined.\x0a  if (voidElementTags[tag]) {\x0a    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, \x27%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s\x27, tag, ReactDebugCurrentFrame$2.getStackAddendum()) : void 0;\x0a  }\x0a  if (props.dangerouslySetInnerHTML != null) {\x0a    !(props.children == null) ? invariant(false, \x27Can only set one of `children` or `props.dangerouslySetInnerHTML`.\x27) : void 0;\x0a    !(typeof props.dangerouslySetInnerHTML === \x27object\x27 && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, \x27`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.\x27) : void 0;\x0a  }\x0a  {\x0a    !(props.suppressContentEditableWarning || !props.contentEditable || props.children == null) ? warning$1(false, \x27A component is `contentEditable` and contains `children` managed by \x27 + \x27React. It is now your responsibility to guarantee that none of \x27 + \x27those nodes are unexpectedly modified or duplicated. This is \x27 + \x27probably not intentional.\x27) : void 0;\x0a  }\x0a  !(props.style == null || typeof props.style === \x27object\x27) ? invariant(false, \x27The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \x5c\x27em\x5c\x27}} when using JSX.%s\x27, ReactDebugCurrentFrame$2.getStackAddendum()) : void 0;\x0a}\x0a\x0afunction isCustomComponent(tagName, props) {\x0a  if (tagName.indexOf(\x27-\x27) === -1) {\x0a    return typeof props.is === \x27string\x27;\x0a  }\x0a  switch (tagName) {\x0a    // These are reserved SVG and MathML elements.\x0a    // We don\x27t mind this whitelist too much because we expect it to never grow.\x0a    // The alternative is to track the namespace in a few places which is convoluted.\x0a    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\x0a    case \x27annotation-xml\x27:\x0a    case \x27color-profile\x27:\x0a    case \x27font-face\x27:\x0a    case \x27font-face-src\x27:\x0a    case \x27font-face-uri\x27:\x0a    case \x27font-face-format\x27:\x0a    case \x27font-face-name\x27:\x0a    case \x27missing-glyph\x27:\x0a      return false;\x0a    default:\x0a      return true;\x0a  }\x0a}\x0a\x0a// When adding attributes to the HTML or SVG whitelist, be sure to\x0a// also add them to this module to ensure casing and incorrect name\x0a// warnings.\x0avar possibleStandardNames = {\x0a  // HTML\x0a  accept: \x27accept\x27,\x0a  acceptcharset: \x27acceptCharset\x27,\x0a  \x27accept-charset\x27: \x27acceptCharset\x27,\x0a  accesskey: \x27accessKey\x27,\x0a  action: \x27action\x27,\x0a  allowfullscreen: \x27allowFullScreen\x27,\x0a  alt: \x27alt\x27,\x0a  as: \x27as\x27,\x0a  async: \x27async\x27,\x0a  autocapitalize: \x27autoCapitalize\x27,\x0a  autocomplete: \x27autoComplete\x27,\x0a  autocorrect: \x27autoCorrect\x27,\x0a  autofocus: \x27autoFocus\x27,\x0a  autoplay: \x27autoPlay\x27,\x0a  autosave: \x27autoSave\x27,\x0a  capture: \x27capture\x27,\x0a  cellpadding: \x27cellPadding\x27,\x0a  cellspacing: \x27cellSpacing\x27,\x0a  challenge: \x27challenge\x27,\x0a  charset: \x27charSet\x27,\x0a  checked: \x27checked\x27,\x0a  children: \x27children\x27,\x0a  cite: \x27cite\x27,\x0a  class: \x27className\x27,\x0a  classid: \x27classID\x27,\x0a  classname: \x27className\x27,\x0a  cols: \x27cols\x27,\x0a  colspan: \x27colSpan\x27,\x0a  content: \x27content\x27,\x0a  contenteditable: \x27contentEditable\x27,\x0a  contextmenu: \x27contextMenu\x27,\x0a  controls: \x27controls\x27,\x0a  controlslist: \x27controlsList\x27,\x0a  coords: \x27coords\x27,\x0a  crossorigin: \x27crossOrigin\x27,\x0a  dangerouslysetinnerhtml: \x27dangerouslySetInnerHTML\x27,\x0a  data: \x27data\x27,\x0a  datetime: \x27dateTime\x27,\x0a  default: \x27default\x27,\x0a  defaultchecked: \x27defaultChecked\x27,\x0a  defaultvalue: \x27defaultValue\x27,\x0a  defer: \x27defer\x27,\x0a  dir: \x27dir\x27,\x0a  disabled: \x27disabled\x27,\x0a  download: \x27download\x27,\x0a  draggable: \x27draggable\x27,\x0a  enctype: \x27encType\x27,\x0a  for: \x27htmlFor\x27,\x0a  form: \x27form\x27,\x0a  formmethod: \x27formMethod\x27,\x0a  formaction: \x27formAction\x27,\x0a  formenctype: \x27formEncType\x27,\x0a  formnovalidate: \x27formNoValidate\x27,\x0a  formtarget: \x27formTarget\x27,\x0a  frameborder: \x27frameBorder\x27,\x0a  headers: \x27headers\x27,\x0a  height: \x27height\x27,\x0a  hidden: \x27hidden\x27,\x0a  high: \x27high\x27,\x0a  href: \x27href\x27,\x0a  hreflang: \x27hrefLang\x27,\x0a  htmlfor: \x27htmlFor\x27,\x0a  httpequiv: \x27httpEquiv\x27,\x0a  \x27http-equiv\x27: \x27httpEquiv\x27,\x0a  icon: \x27icon\x27,\x0a  id: \x27id\x27,\x0a  innerhtml: \x27innerHTML\x27,\x0a  inputmode: \x27inputMode\x27,\x0a  integrity: \x27integrity\x27,\x0a  is: \x27is\x27,\x0a  itemid: \x27itemID\x27,\x0a  itemprop: \x27itemProp\x27,\x0a  itemref: \x27itemRef\x27,\x0a  itemscope: \x27itemScope\x27,\x0a  itemtype: \x27itemType\x27,\x0a  keyparams: \x27keyParams\x27,\x0a  keytype: \x27keyType\x27,\x0a  kind: \x27kind\x27,\x0a  label: \x27label\x27,\x0a  lang: \x27lang\x27,\x0a  list: \x27list\x27,\x0a  loop: \x27loop\x27,\x0a  low: \x27low\x27,\x0a  manifest: \x27manifest\x27,\x0a  marginwidth: \x27marginWidth\x27,\x0a  marginheight: \x27marginHeight\x27,\x0a  max: \x27max\x27,\x0a  maxlength: \x27maxLength\x27,\x0a  media: \x27media\x27,\x0a  mediagroup: \x27mediaGroup\x27,\x0a  method: \x27method\x27,\x0a  min: \x27min\x27,\x0a  minlength: \x27minLength\x27,\x0a  multiple: \x27multiple\x27,\x0a  muted: \x27muted\x27,\x0a  name: \x27name\x27,\x0a  nomodule: \x27noModule\x27,\x0a  nonce: \x27nonce\x27,\x0a  novalidate: \x27noValidate\x27,\x0a  open: \x27open\x27,\x0a  optimum: \x27optimum\x27,\x0a  pattern: \x27pattern\x27,\x0a  placeholder: \x27placeholder\x27,\x0a  playsinline: \x27playsInline\x27,\x0a  poster: \x27poster\x27,\x0a  preload: \x27preload\x27,\x0a  profile: \x27profile\x27,\x0a  radiogroup: \x27radioGroup\x27,\x0a  readonly: \x27readOnly\x27,\x0a  referrerpolicy: \x27referrerPolicy\x27,\x0a  rel: \x27rel\x27,\x0a  required: \x27required\x27,\x0a  reversed: \x27reversed\x27,\x0a  role: \x27role\x27,\x0a  rows: \x27rows\x27,\x0a  rowspan: \x27rowSpan\x27,\x0a  sandbox: \x27sandbox\x27,\x0a  scope: \x27scope\x27,\x0a  scoped: \x27scoped\x27,\x0a  scrolling: \x27scrolling\x27,\x0a  seamless: \x27seamless\x27,\x0a  selected: \x27selected\x27,\x0a  shape: \x27shape\x27,\x0a  size: \x27size\x27,\x0a  sizes: \x27sizes\x27,\x0a  span: \x27span\x27,\x0a  spellcheck: \x27spellCheck\x27,\x0a  src: \x27src\x27,\x0a  srcdoc: \x27srcDoc\x27,\x0a  srclang: \x27srcLang\x27,\x0a  srcset: \x27srcSet\x27,\x0a  start: \x27start\x27,\x0a  step: \x27step\x27,\x0a  style: \x27style\x27,\x0a  summary: \x27summary\x27,\x0a  tabindex: \x27tabIndex\x27,\x0a  target: \x27target\x27,\x0a  title: \x27title\x27,\x0a  type: \x27type\x27,\x0a  usemap: \x27useMap\x27,\x0a  value: \x27value\x27,\x0a  width: \x27width\x27,\x0a  wmode: \x27wmode\x27,\x0a  wrap: \x27wrap\x27,\x0a\x0a  // SVG\x0a  about: \x27about\x27,\x0a  accentheight: \x27accentHeight\x27,\x0a  \x27accent-height\x27: \x27accentHeight\x27,\x0a  accumulate: \x27accumulate\x27,\x0a  additive: \x27additive\x27,\x0a  alignmentbaseline: \x27alignmentBaseline\x27,\x0a  \x27alignment-baseline\x27: \x27alignmentBaseline\x27,\x0a  allowreorder: \x27allowReorder\x27,\x0a  alphabetic: \x27alphabetic\x27,\x0a  amplitude: \x27amplitude\x27,\x0a  arabicform: \x27arabicForm\x27,\x0a  \x27arabic-form\x27: \x27arabicForm\x27,\x0a  ascent: \x27ascent\x27,\x0a  attributename: \x27attributeName\x27,\x0a  attributetype: \x27attributeType\x27,\x0a  autoreverse: \x27autoReverse\x27,\x0a  azimuth: \x27azimuth\x27,\x0a  basefrequency: \x27baseFrequency\x27,\x0a  baselineshift: \x27baselineShift\x27,\x0a  \x27baseline-shift\x27: \x27baselineShift\x27,\x0a  baseprofile: \x27baseProfile\x27,\x0a  bbox: \x27bbox\x27,\x0a  begin: \x27begin\x27,\x0a  bias: \x27bias\x27,\x0a  by: \x27by\x27,\x0a  calcmode: \x27calcMode\x27,\x0a  capheight: \x27capHeight\x27,\x0a  \x27cap-height\x27: \x27capHeight\x27,\x0a  clip: \x27clip\x27,\x0a  clippath: \x27clipPath\x27,\x0a  \x27clip-path\x27: \x27clipPath\x27,\x0a  clippathunits: \x27clipPathUnits\x27,\x0a  cliprule: \x27clipRule\x27,\x0a  \x27clip-rule\x27: \x27clipRule\x27,\x0a  color: \x27color\x27,\x0a  colorinterpolation: \x27colorInterpolation\x27,\x0a  \x27color-interpolation\x27: \x27colorInterpolation\x27,\x0a  colorinterpolationfilters: \x27colorInterpolationFilters\x27,\x0a  \x27color-interpolation-filters\x27: \x27colorInterpolationFilters\x27,\x0a  colorprofile: \x27colorProfile\x27,\x0a  \x27color-profile\x27: \x27colorProfile\x27,\x0a  colorrendering: \x27colorRendering\x27,\x0a  \x27color-rendering\x27: \x27colorRendering\x27,\x0a  contentscripttype: \x27contentScriptType\x27,\x0a  contentstyletype: \x27contentStyleType\x27,\x0a  cursor: \x27cursor\x27,\x0a  cx: \x27cx\x27,\x0a  cy: \x27cy\x27,\x0a  d: \x27d\x27,\x0a  datatype: \x27datatype\x27,\x0a  decelerate: \x27decelerate\x27,\x0a  descent: \x27descent\x27,\x0a  diffuseconstant: \x27diffuseConstant\x27,\x0a  direction: \x27direction\x27,\x0a  display: \x27display\x27,\x0a  divisor: \x27divisor\x27,\x0a  dominantbaseline: \x27dominantBaseline\x27,\x0a  \x27dominant-baseline\x27: \x27dominantBaseline\x27,\x0a  dur: \x27dur\x27,\x0a  dx: \x27dx\x27,\x0a  dy: \x27dy\x27,\x0a  edgemode: \x27edgeMode\x27,\x0a  elevation: \x27elevation\x27,\x0a  enablebackground: \x27enableBackground\x27,\x0a  \x27enable-background\x27: \x27enableBackground\x27,\x0a  end: \x27end\x27,\x0a  exponent: \x27exponent\x27,\x0a  externalresourcesrequired: \x27externalResourcesRequired\x27,\x0a  fill: \x27fill\x27,\x0a  fillopacity: \x27fillOpacity\x27,\x0a  \x27fill-opacity\x27: \x27fillOpacity\x27,\x0a  fillrule: \x27fillRule\x27,\x0a  \x27fill-rule\x27: \x27fillRule\x27,\x0a  filter: \x27filter\x27,\x0a  filterres: \x27filterRes\x27,\x0a  filterunits: \x27filterUnits\x27,\x0a  floodopacity: \x27floodOpacity\x27,\x0a  \x27flood-opacity\x27: \x27floodOpacity\x27,\x0a  floodcolor: \x27floodColor\x27,\x0a  \x27flood-color\x27: \x27floodColor\x27,\x0a  focusable: \x27focusable\x27,\x0a  fontfamily: \x27fontFamily\x27,\x0a  \x27font-family\x27: \x27fontFamily\x27,\x0a  fontsize: \x27fontSize\x27,\x0a  \x27font-size\x27: \x27fontSize\x27,\x0a  fontsizeadjust: \x27fontSizeAdjust\x27,\x0a  \x27font-size-adjust\x27: \x27fontSizeAdjust\x27,\x0a  fontstretch: \x27fontStretch\x27,\x0a  \x27font-stretch\x27: \x27fontStretch\x27,\x0a  fontstyle: \x27fontStyle\x27,\x0a  \x27font-style\x27: \x27fontStyle\x27,\x0a  fontvariant: \x27fontVariant\x27,\x0a  \x27font-variant\x27: \x27fontVariant\x27,\x0a  fontweight: \x27fontWeight\x27,\x0a  \x27font-weight\x27: \x27fontWeight\x27,\x0a  format: \x27format\x27,\x0a  from: \x27from\x27,\x0a  fx: \x27fx\x27,\x0a  fy: \x27fy\x27,\x0a  g1: \x27g1\x27,\x0a  g2: \x27g2\x27,\x0a  glyphname: \x27glyphName\x27,\x0a  \x27glyph-name\x27: \x27glyphName\x27,\x0a  glyphorientationhorizontal: \x27glyphOrientationHorizontal\x27,\x0a  \x27glyph-orientation-horizontal\x27: \x27glyphOrientationHorizontal\x27,\x0a  glyphorientationvertical: \x27glyphOrientationVertical\x27,\x0a  \x27glyph-orientation-vertical\x27: \x27glyphOrientationVertical\x27,\x0a  glyphref: \x27glyphRef\x27,\x0a  gradienttransform: \x27gradientTransform\x27,\x0a  gradientunits: \x27gradientUnits\x27,\x0a  hanging: \x27hanging\x27,\x0a  horizadvx: \x27horizAdvX\x27,\x0a  \x27horiz-adv-x\x27: \x27horizAdvX\x27,\x0a  horizoriginx: \x27horizOriginX\x27,\x0a  \x27horiz-origin-x\x27: \x27horizOriginX\x27,\x0a  ideographic: \x27ideographic\x27,\x0a  imagerendering: \x27imageRendering\x27,\x0a  \x27image-rendering\x27: \x27imageRendering\x27,\x0a  in2: \x27in2\x27,\x0a  in: \x27in\x27,\x0a  inlist: \x27inlist\x27,\x0a  intercept: \x27intercept\x27,\x0a  k1: \x27k1\x27,\x0a  k2: \x27k2\x27,\x0a  k3: \x27k3\x27,\x0a  k4: \x27k4\x27,\x0a  k: \x27k\x27,\x0a  kernelmatrix: \x27kernelMatrix\x27,\x0a  kernelunitlength: \x27kernelUnitLength\x27,\x0a  kerning: \x27kerning\x27,\x0a  keypoints: \x27keyPoints\x27,\x0a  keysplines: \x27keySplines\x27,\x0a  keytimes: \x27keyTimes\x27,\x0a  lengthadjust: \x27lengthAdjust\x27,\x0a  letterspacing: \x27letterSpacing\x27,\x0a  \x27letter-spacing\x27: \x27letterSpacing\x27,\x0a  lightingcolor: \x27lightingColor\x27,\x0a  \x27lighting-color\x27: \x27lightingColor\x27,\x0a  limitingconeangle: \x27limitingConeAngle\x27,\x0a  local: \x27local\x27,\x0a  markerend: \x27markerEnd\x27,\x0a  \x27marker-end\x27: \x27markerEnd\x27,\x0a  markerheight: \x27markerHeight\x27,\x0a  markermid: \x27markerMid\x27,\x0a  \x27marker-mid\x27: \x27markerMid\x27,\x0a  markerstart: \x27markerStart\x27,\x0a  \x27marker-start\x27: \x27markerStart\x27,\x0a  markerunits: \x27markerUnits\x27,\x0a  markerwidth: \x27markerWidth\x27,\x0a  mask: \x27mask\x27,\x0a  maskcontentunits: \x27maskContentUnits\x27,\x0a  maskunits: \x27maskUnits\x27,\x0a  mathematical: \x27mathematical\x27,\x0a  mode: \x27mode\x27,\x0a  numoctaves: \x27numOctaves\x27,\x0a  offset: \x27offset\x27,\x0a  opacity: \x27opacity\x27,\x0a  operator: \x27operator\x27,\x0a  order: \x27order\x27,\x0a  orient: \x27orient\x27,\x0a  orientation: \x27orientation\x27,\x0a  origin: \x27origin\x27,\x0a  overflow: \x27overflow\x27,\x0a  overlineposition: \x27overlinePosition\x27,\x0a  \x27overline-position\x27: \x27overlinePosition\x27,\x0a  overlinethickness: \x27overlineThickness\x27,\x0a  \x27overline-thickness\x27: \x27overlineThickness\x27,\x0a  paintorder: \x27paintOrder\x27,\x0a  \x27paint-order\x27: \x27paintOrder\x27,\x0a  panose1: \x27panose1\x27,\x0a  \x27panose-1\x27: \x27panose1\x27,\x0a  pathlength: \x27pathLength\x27,\x0a  patterncontentunits: \x27patternContentUnits\x27,\x0a  patterntransform: \x27patternTransform\x27,\x0a  patternunits: \x27patternUnits\x27,\x0a  pointerevents: \x27pointerEvents\x27,\x0a  \x27pointer-events\x27: \x27pointerEvents\x27,\x0a  points: \x27points\x27,\x0a  pointsatx: \x27pointsAtX\x27,\x0a  pointsaty: \x27pointsAtY\x27,\x0a  pointsatz: \x27pointsAtZ\x27,\x0a  prefix: \x27prefix\x27,\x0a  preservealpha: \x27preserveAlpha\x27,\x0a  preserveaspectratio: \x27preserveAspectRatio\x27,\x0a  primitiveunits: \x27primitiveUnits\x27,\x0a  property: \x27property\x27,\x0a  r: \x27r\x27,\x0a  radius: \x27radius\x27,\x0a  refx: \x27refX\x27,\x0a  refy: \x27refY\x27,\x0a  renderingintent: \x27renderingIntent\x27,\x0a  \x27rendering-intent\x27: \x27renderingIntent\x27,\x0a  repeatcount: \x27repeatCount\x27,\x0a  repeatdur: \x27repeatDur\x27,\x0a  requiredextensions: \x27requiredExtensions\x27,\x0a  requiredfeatures: \x27requiredFeatures\x27,\x0a  resource: \x27resource\x27,\x0a  restart: \x27restart\x27,\x0a  result: \x27result\x27,\x0a  results: \x27results\x27,\x0a  rotate: \x27rotate\x27,\x0a  rx: \x27rx\x27,\x0a  ry: \x27ry\x27,\x0a  scale: \x27scale\x27,\x0a  security: \x27security\x27,\x0a  seed: \x27seed\x27,\x0a  shaperendering: \x27shapeRendering\x27,\x0a  \x27shape-rendering\x27: \x27shapeRendering\x27,\x0a  slope: \x27slope\x27,\x0a  spacing: \x27spacing\x27,\x0a  specularconstant: \x27specularConstant\x27,\x0a  specularexponent: \x27specularExponent\x27,\x0a  speed: \x27speed\x27,\x0a  spreadmethod: \x27spreadMethod\x27,\x0a  startoffset: \x27startOffset\x27,\x0a  stddeviation: \x27stdDeviation\x27,\x0a  stemh: \x27stemh\x27,\x0a  stemv: \x27stemv\x27,\x0a  stitchtiles: \x27stitchTiles\x27,\x0a  stopcolor: \x27stopColor\x27,\x0a  \x27stop-color\x27: \x27stopColor\x27,\x0a  stopopacity: \x27stopOpacity\x27,\x0a  \x27stop-opacity\x27: \x27stopOpacity\x27,\x0a  strikethroughposition: \x27strikethroughPosition\x27,\x0a  \x27strikethrough-position\x27: \x27strikethroughPosition\x27,\x0a  strikethroughthickness: \x27strikethroughThickness\x27,\x0a  \x27strikethrough-thickness\x27: \x27strikethroughThickness\x27,\x0a  string: \x27string\x27,\x0a  stroke: \x27stroke\x27,\x0a  strokedasharray: \x27strokeDasharray\x27,\x0a  \x27stroke-dasharray\x27: \x27strokeDasharray\x27,\x0a  strokedashoffset: \x27strokeDashoffset\x27,\x0a  \x27stroke-dashoffset\x27: \x27strokeDashoffset\x27,\x0a  strokelinecap: \x27strokeLinecap\x27,\x0a  \x27stroke-linecap\x27: \x27strokeLinecap\x27,\x0a  strokelinejoin: \x27strokeLinejoin\x27,\x0a  \x27stroke-linejoin\x27: \x27strokeLinejoin\x27,\x0a  strokemiterlimit: \x27strokeMiterlimit\x27,\x0a  \x27stroke-miterlimit\x27: \x27strokeMiterlimit\x27,\x0a  strokewidth: \x27strokeWidth\x27,\x0a  \x27stroke-width\x27: \x27strokeWidth\x27,\x0a  strokeopacity: \x27strokeOpacity\x27,\x0a  \x27stroke-opacity\x27: \x27strokeOpacity\x27,\x0a  suppresscontenteditablewarning: \x27suppressContentEditableWarning\x27,\x0a  suppresshydrationwarning: \x27suppressHydrationWarning\x27,\x0a  surfacescale: \x27surfaceScale\x27,\x0a  systemlanguage: \x27systemLanguage\x27,\x0a  tablevalues: \x27tableValues\x27,\x0a  targetx: \x27targetX\x27,\x0a  targety: \x27targetY\x27,\x0a  textanchor: \x27textAnchor\x27,\x0a  \x27text-anchor\x27: \x27textAnchor\x27,\x0a  textdecoration: \x27textDecoration\x27,\x0a  \x27text-decoration\x27: \x27textDecoration\x27,\x0a  textlength: \x27textLength\x27,\x0a  textrendering: \x27textRendering\x27,\x0a  \x27text-rendering\x27: \x27textRendering\x27,\x0a  to: \x27to\x27,\x0a  transform: \x27transform\x27,\x0a  typeof: \x27typeof\x27,\x0a  u1: \x27u1\x27,\x0a  u2: \x27u2\x27,\x0a  underlineposition: \x27underlinePosition\x27,\x0a  \x27underline-position\x27: \x27underlinePosition\x27,\x0a  underlinethickness: \x27underlineThickness\x27,\x0a  \x27underline-thickness\x27: \x27underlineThickness\x27,\x0a  unicode: \x27unicode\x27,\x0a  unicodebidi: \x27unicodeBidi\x27,\x0a  \x27unicode-bidi\x27: \x27unicodeBidi\x27,\x0a  unicoderange: \x27unicodeRange\x27,\x0a  \x27unicode-range\x27: \x27unicodeRange\x27,\x0a  unitsperem: \x27unitsPerEm\x27,\x0a  \x27units-per-em\x27: \x27unitsPerEm\x27,\x0a  unselectable: \x27unselectable\x27,\x0a  valphabetic: \x27vAlphabetic\x27,\x0a  \x27v-alphabetic\x27: \x27vAlphabetic\x27,\x0a  values: \x27values\x27,\x0a  vectoreffect: \x27vectorEffect\x27,\x0a  \x27vector-effect\x27: \x27vectorEffect\x27,\x0a  version: \x27version\x27,\x0a  vertadvy: \x27vertAdvY\x27,\x0a  \x27vert-adv-y\x27: \x27vertAdvY\x27,\x0a  vertoriginx: \x27vertOriginX\x27,\x0a  \x27vert-origin-x\x27: \x27vertOriginX\x27,\x0a  vertoriginy: \x27vertOriginY\x27,\x0a  \x27vert-origin-y\x27: \x27vertOriginY\x27,\x0a  vhanging: \x27vHanging\x27,\x0a  \x27v-hanging\x27: \x27vHanging\x27,\x0a  videographic: \x27vIdeographic\x27,\x0a  \x27v-ideographic\x27: \x27vIdeographic\x27,\x0a  viewbox: \x27viewBox\x27,\x0a  viewtarget: \x27viewTarget\x27,\x0a  visibility: \x27visibility\x27,\x0a  vmathematical: \x27vMathematical\x27,\x0a  \x27v-mathematical\x27: \x27vMathematical\x27,\x0a  vocab: \x27vocab\x27,\x0a  widths: \x27widths\x27,\x0a  wordspacing: \x27wordSpacing\x27,\x0a  \x27word-spacing\x27: \x27wordSpacing\x27,\x0a  writingmode: \x27writingMode\x27,\x0a  \x27writing-mode\x27: \x27writingMode\x27,\x0a  x1: \x27x1\x27,\x0a  x2: \x27x2\x27,\x0a  x: \x27x\x27,\x0a  xchannelselector: \x27xChannelSelector\x27,\x0a  xheight: \x27xHeight\x27,\x0a  \x27x-height\x27: \x27xHeight\x27,\x0a  xlinkactuate: \x27xlinkActuate\x27,\x0a  \x27xlink:actuate\x27: \x27xlinkActuate\x27,\x0a  xlinkarcrole: \x27xlinkArcrole\x27,\x0a  \x27xlink:arcrole\x27: \x27xlinkArcrole\x27,\x0a  xlinkhref: \x27xlinkHref\x27,\x0a  \x27xlink:href\x27: \x27xlinkHref\x27,\x0a  xlinkrole: \x27xlinkRole\x27,\x0a  \x27xlink:role\x27: \x27xlinkRole\x27,\x0a  xlinkshow: \x27xlinkShow\x27,\x0a  \x27xlink:show\x27: \x27xlinkShow\x27,\x0a  xlinktitle: \x27xlinkTitle\x27,\x0a  \x27xlink:title\x27: \x27xlinkTitle\x27,\x0a  xlinktype: \x27xlinkType\x27,\x0a  \x27xlink:type\x27: \x27xlinkType\x27,\x0a  xmlbase: \x27xmlBase\x27,\x0a  \x27xml:base\x27: \x27xmlBase\x27,\x0a  xmllang: \x27xmlLang\x27,\x0a  \x27xml:lang\x27: \x27xmlLang\x27,\x0a  xmlns: \x27xmlns\x27,\x0a  \x27xml:space\x27: \x27xmlSpace\x27,\x0a  xmlnsxlink: \x27xmlnsXlink\x27,\x0a  \x27xmlns:xlink\x27: \x27xmlnsXlink\x27,\x0a  xmlspace: \x27xmlSpace\x27,\x0a  y1: \x27y1\x27,\x0a  y2: \x27y2\x27,\x0a  y: \x27y\x27,\x0a  ychannelselector: \x27yChannelSelector\x27,\x0a  z: \x27z\x27,\x0a  zoomandpan: \x27zoomAndPan\x27\x0a};\x0a\x0avar ariaProperties = {\x0a  \x27aria-current\x27: 0, // state\x0a  \x27aria-details\x27: 0,\x0a  \x27aria-disabled\x27: 0, // state\x0a  \x27aria-hidden\x27: 0, // state\x0a  \x27aria-invalid\x27: 0, // state\x0a  \x27aria-keyshortcuts\x27: 0,\x0a  \x27aria-label\x27: 0,\x0a  \x27aria-roledescription\x27: 0,\x0a  // Widget Attributes\x0a  \x27aria-autocomplete\x27: 0,\x0a  \x27aria-checked\x27: 0,\x0a  \x27aria-expanded\x27: 0,\x0a  \x27aria-haspopup\x27: 0,\x0a  \x27aria-level\x27: 0,\x0a  \x27aria-modal\x27: 0,\x0a  \x27aria-multiline\x27: 0,\x0a  \x27aria-multiselectable\x27: 0,\x0a  \x27aria-orientation\x27: 0,\x0a  \x27aria-placeholder\x27: 0,\x0a  \x27aria-pressed\x27: 0,\x0a  \x27aria-readonly\x27: 0,\x0a  \x27aria-required\x27: 0,\x0a  \x27aria-selected\x27: 0,\x0a  \x27aria-sort\x27: 0,\x0a  \x27aria-valuemax\x27: 0,\x0a  \x27aria-valuemin\x27: 0,\x0a  \x27aria-valuenow\x27: 0,\x0a  \x27aria-valuetext\x27: 0,\x0a  // Live Region Attributes\x0a  \x27aria-atomic\x27: 0,\x0a  \x27aria-busy\x27: 0,\x0a  \x27aria-live\x27: 0,\x0a  \x27aria-relevant\x27: 0,\x0a  // Drag-and-Drop Attributes\x0a  \x27aria-dropeffect\x27: 0,\x0a  \x27aria-grabbed\x27: 0,\x0a  // Relationship Attributes\x0a  \x27aria-activedescendant\x27: 0,\x0a  \x27aria-colcount\x27: 0,\x0a  \x27aria-colindex\x27: 0,\x0a  \x27aria-colspan\x27: 0,\x0a  \x27aria-controls\x27: 0,\x0a  \x27aria-describedby\x27: 0,\x0a  \x27aria-errormessage\x27: 0,\x0a  \x27aria-flowto\x27: 0,\x0a  \x27aria-labelledby\x27: 0,\x0a  \x27aria-owns\x27: 0,\x0a  \x27aria-posinset\x27: 0,\x0a  \x27aria-rowcount\x27: 0,\x0a  \x27aria-rowindex\x27: 0,\x0a  \x27aria-rowspan\x27: 0,\x0a  \x27aria-setsize\x27: 0\x0a};\x0a\x0avar warnedProperties = {};\x0avar rARIA = new RegExp(\x27^(aria)-[\x27 + ATTRIBUTE_NAME_CHAR + \x27]*$\x27);\x0avar rARIACamel = new RegExp(\x27^(aria)[A-Z][\x27 + ATTRIBUTE_NAME_CHAR + \x27]*$\x27);\x0a\x0avar hasOwnProperty$2 = Object.prototype.hasOwnProperty;\x0a\x0afunction validateProperty(tagName, name) {\x0a  if (hasOwnProperty$2.call(warnedProperties, name) && warnedProperties[name]) {\x0a    return true;\x0a  }\x0a\x0a  if (rARIACamel.test(name)) {\x0a    var ariaName = \x27aria-\x27 + name.slice(4).toLowerCase();\x0a    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\x0a\x0a    // If this is an aria-* attribute, but is not listed in the known DOM\x0a    // DOM properties, then it is an invalid aria-* attribute.\x0a    if (correctName == null) {\x0a      warning$1(false, \x27Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\x27, name);\x0a      warnedProperties[name] = true;\x0a      return true;\x0a    }\x0a    // aria-* attributes should be lowercase; suggest the lowercase version.\x0a    if (name !== correctName) {\x0a      warning$1(false, \x27Invalid ARIA attribute `%s`. Did you mean `%s`?\x27, name, correctName);\x0a      warnedProperties[name] = true;\x0a      return true;\x0a    }\x0a  }\x0a\x0a  if (rARIA.test(name)) {\x0a    var lowerCasedName = name.toLowerCase();\x0a    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\x0a\x0a    // If this is an aria-* attribute, but is not listed in the known DOM\x0a    // DOM properties, then it is an invalid aria-* attribute.\x0a    if (standardName == null) {\x0a      warnedProperties[name] = true;\x0a      return false;\x0a    }\x0a    // aria-* attributes should be lowercase; suggest the lowercase version.\x0a    if (name !== standardName) {\x0a      warning$1(false, \x27Unknown ARIA attribute `%s`. Did you mean `%s`?\x27, name, standardName);\x0a      warnedProperties[name] = true;\x0a      return true;\x0a    }\x0a  }\x0a\x0a  return true;\x0a}\x0a\x0afunction warnInvalidARIAProps(type, props) {\x0a  var invalidProps = [];\x0a\x0a  for (var key in props) {\x0a    var isValid = validateProperty(type, key);\x0a    if (!isValid) {\x0a      invalidProps.push(key);\x0a    }\x0a  }\x0a\x0a  var unknownPropString = invalidProps.map(function (prop) {\x0a    return \x27`\x27 + prop + \x27`\x27;\x0a  }).join(\x27, \x27);\x0a\x0a  if (invalidProps.length === 1) {\x0a    warning$1(false, \x27Invalid aria prop %s on \x3c%s\x3e tag. \x27 + \x27For details, see https://fb.me/invalid-aria-prop\x27, unknownPropString, type);\x0a  } else if (invalidProps.length \x3e 1) {\x0a    warning$1(false, \x27Invalid aria props %s on \x3c%s\x3e tag. \x27 + \x27For details, see https://fb.me/invalid-aria-prop\x27, unknownPropString, type);\x0a  }\x0a}\x0a\x0afunction validateProperties(type, props) {\x0a  if (isCustomComponent(type, props)) {\x0a    return;\x0a  }\x0a  warnInvalidARIAProps(type, props);\x0a}\x0a\x0avar didWarnValueNull = false;\x0a\x0afunction validateProperties$1(type, props) {\x0a  if (type !== \x27input\x27 && type !== \x27textarea\x27 && type !== \x27select\x27) {\x0a    return;\x0a  }\x0a\x0a  if (props != null && props.value === null && !didWarnValueNull) {\x0a    didWarnValueNull = true;\x0a    if (type === \x27select\x27 && props.multiple) {\x0a      warning$1(false, \x27`value` prop on `%s` should not be null. \x27 + \x27Consider using an empty array when `multiple` is set to `true` \x27 + \x27to clear the component or `undefined` for uncontrolled components.\x27, type);\x0a    } else {\x0a      warning$1(false, \x27`value` prop on `%s` should not be null. \x27 + \x27Consider using an empty string to clear the component or `undefined` \x27 + \x27for uncontrolled components.\x27, type);\x0a    }\x0a  }\x0a}\x0a\x0avar validateProperty$1 = function () {};\x0a\x0a{\x0a  var warnedProperties$1 = {};\x0a  var _hasOwnProperty = Object.prototype.hasOwnProperty;\x0a  var EVENT_NAME_REGEX = /^on./;\x0a  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\x0a  var rARIA$1 = new RegExp(\x27^(aria)-[\x27 + ATTRIBUTE_NAME_CHAR + \x27]*$\x27);\x0a  var rARIACamel$1 = new RegExp(\x27^(aria)[A-Z][\x27 + ATTRIBUTE_NAME_CHAR + \x27]*$\x27);\x0a\x0a  validateProperty$1 = function (tagName, name, value, canUseEventSystem) {\x0a    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\x0a      return true;\x0a    }\x0a\x0a    var lowerCasedName = name.toLowerCase();\x0a    if (lowerCasedName === \x27onfocusin\x27 || lowerCasedName === \x27onfocusout\x27) {\x0a      warning$1(false, \x27React uses onFocus and onBlur instead of onFocusIn and onFocusOut. \x27 + \x27All React events are normalized to bubble, so onFocusIn and onFocusOut \x27 + \x27are not needed/supported by React.\x27);\x0a      warnedProperties$1[name] = true;\x0a      return true;\x0a    }\x0a\x0a    // We can\x27t rely on the event system being injected on the server.\x0a    if (canUseEventSystem) {\x0a      if (registrationNameModules.hasOwnProperty(name)) {\x0a        return true;\x0a      }\x0a      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\x0a      if (registrationName != null) {\x0a        warning$1(false, \x27Invalid event handler property `%s`. Did you mean `%s`?\x27, name, registrationName);\x0a        warnedProperties$1[name] = true;\x0a        return true;\x0a      }\x0a      if (EVENT_NAME_REGEX.test(name)) {\x0a        warning$1(false, \x27Unknown event handler property `%s`. It will be ignored.\x27, name);\x0a        warnedProperties$1[name] = true;\x0a        return true;\x0a      }\x0a    } else if (EVENT_NAME_REGEX.test(name)) {\x0a      // If no event plugins have been injected, we are in a server environment.\x0a      // So we can\x27t tell if the event name is correct for sure, but we can filter\x0a      // out known bad ones like `onclick`. We can\x27t suggest a specific replacement though.\x0a      if (INVALID_EVENT_NAME_REGEX.test(name)) {\x0a        warning$1(false, \x27Invalid event handler property `%s`. \x27 + \x27React events use the camelCase naming convention, for example `onClick`.\x27, name);\x0a      }\x0a      warnedProperties$1[name] = true;\x0a      return true;\x0a    }\x0a\x0a    // Let the ARIA attribute hook validate ARIA attributes\x0a    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\x0a      return true;\x0a    }\x0a\x0a    if (lowerCasedName === \x27innerhtml\x27) {\x0a      warning$1(false, \x27Directly setting property `innerHTML` is not permitted. \x27 + \x27For more information, lookup documentation on `dangerouslySetInnerHTML`.\x27);\x0a      warnedProperties$1[name] = true;\x0a      return true;\x0a    }\x0a\x0a    if (lowerCasedName === \x27aria\x27) {\x0a      warning$1(false, \x27The `aria` attribute is reserved for future use in React. \x27 + \x27Pass individual `aria-` attributes instead.\x27);\x0a      warnedProperties$1[name] = true;\x0a      return true;\x0a    }\x0a\x0a    if (lowerCasedName === \x27is\x27 && value !== null && value !== undefined && typeof value !== \x27string\x27) {\x0a      warning$1(false, \x27Received a `%s` for a string attribute `is`. If this is expected, cast \x27 + \x27the value to a string.\x27, typeof value);\x0a      warnedProperties$1[name] = true;\x0a      return true;\x0a    }\x0a\x0a    if (typeof value === \x27number\x27 && isNaN(value)) {\x0a      warning$1(false, \x27Received NaN for the `%s` attribute. If this is expected, cast \x27 + \x27the value to a string.\x27, name);\x0a      warnedProperties$1[name] = true;\x0a      return true;\x0a    }\x0a\x0a    var propertyInfo = getPropertyInfo(name);\x0a    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;\x0a\x0a    // Known attributes should match the casing specified in the property config.\x0a    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\x0a      var standardName = possibleStandardNames[lowerCasedName];\x0a      if (standardName !== name) {\x0a        warning$1(false, \x27Invalid DOM property `%s`. Did you mean `%s`?\x27, name, standardName);\x0a        warnedProperties$1[name] = true;\x0a        return true;\x0a      }\x0a    } else if (!isReserved && name !== lowerCasedName) {\x0a      // Unknown attributes should have lowercase casing since that\x27s how they\x0a      // will be cased anyway with server rendering.\x0a      warning$1(false, \x27React does not recognize the `%s` prop on a DOM element. If you \x27 + \x27intentionally want it to appear in the DOM as a custom \x27 + \x27attribute, spell it as lowercase `%s` instead. \x27 + \x27If you accidentally passed it from a parent component, remove \x27 + \x27it from the DOM element.\x27, name, lowerCasedName);\x0a      warnedProperties$1[name] = true;\x0a      return true;\x0a    }\x0a\x0a    if (typeof value === \x27boolean\x27 && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\x0a      if (value) {\x0a        warning$1(false, \x27Received `%s` for a non-boolean attribute `%s`.\x5cn\x5cn\x27 + \x27If you want to write it to the DOM, pass a string instead: \x27 + \x27%s=\x22%s\x22 or %s={value.toString()}.\x27, value, name, name, value, name);\x0a      } else {\x0a        warning$1(false, \x27Received `%s` for a non-boolean attribute `%s`.\x5cn\x5cn\x27 + \x27If you want to write it to the DOM, pass a string instead: \x27 + \x27%s=\x22%s\x22 or %s={value.toString()}.\x5cn\x5cn\x27 + \x27If you used to conditionally omit it with %s={condition && value}, \x27 + \x27pass %s={condition ? value : undefined} instead.\x27, value, name, name, value, name, name, name);\x0a      }\x0a      warnedProperties$1[name] = true;\x0a      return true;\x0a    }\x0a\x0a    // Now that we\x27ve validated casing, do not validate\x0a    // data types for reserved props\x0a    if (isReserved) {\x0a      return true;\x0a    }\x0a\x0a    // Warn when a known attribute is a bad type\x0a    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\x0a      warnedProperties$1[name] = true;\x0a      return false;\x0a    }\x0a\x0a    // Warn when passing the strings \x27false\x27 or \x27true\x27 into a boolean prop\x0a    if ((value === \x27false\x27 || value === \x27true\x27) && propertyInfo !== null && propertyInfo.type === BOOLEAN) {\x0a      warning$1(false, \x27Received the string `%s` for the boolean attribute `%s`. \x27 + \x27%s \x27 + \x27Did you mean %s={%s}?\x27, value, name, value === \x27false\x27 ? \x27The browser will interpret it as a truthy value.\x27 : \x27Although this works, it will not work as expected if you pass the string \x22false\x22.\x27, name, value);\x0a      warnedProperties$1[name] = true;\x0a      return true;\x0a    }\x0a\x0a    return true;\x0a  };\x0a}\x0a\x0avar warnUnknownProperties = function (type, props, canUseEventSystem) {\x0a  var unknownProps = [];\x0a  for (var key in props) {\x0a    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);\x0a    if (!isValid) {\x0a      unknownProps.push(key);\x0a    }\x0a  }\x0a\x0a  var unknownPropString = unknownProps.map(function (prop) {\x0a    return \x27`\x27 + prop + \x27`\x27;\x0a  }).join(\x27, \x27);\x0a  if (unknownProps.length === 1) {\x0a    warning$1(false, \x27Invalid value for prop %s on \x3c%s\x3e tag. Either remove it from the element, \x27 + \x27or pass a string or number value to keep it in the DOM. \x27 + \x27For details, see https://fb.me/react-attribute-behavior\x27, unknownPropString, type);\x0a  } else if (unknownProps.length \x3e 1) {\x0a    warning$1(false, \x27Invalid values for props %s on \x3c%s\x3e tag. Either remove them from the element, \x27 + \x27or pass a string or number value to keep them in the DOM. \x27 + \x27For details, see https://fb.me/react-attribute-behavior\x27, unknownPropString, type);\x0a  }\x0a};\x0a\x0afunction validateProperties$2(type, props, canUseEventSystem) {\x0a  if (isCustomComponent(type, props)) {\x0a    return;\x0a  }\x0a  warnUnknownProperties(type, props, canUseEventSystem);\x0a}\x0a\x0a// TODO: direct imports like some-package/src/* are bad. Fix me.\x0avar didWarnInvalidHydration = false;\x0avar didWarnShadyDOM = false;\x0a\x0avar DANGEROUSLY_SET_INNER_HTML = \x27dangerouslySetInnerHTML\x27;\x0avar SUPPRESS_CONTENT_EDITABLE_WARNING = \x27suppressContentEditableWarning\x27;\x0avar SUPPRESS_HYDRATION_WARNING$1 = \x27suppressHydrationWarning\x27;\x0avar AUTOFOCUS = \x27autoFocus\x27;\x0avar CHILDREN = \x27children\x27;\x0avar STYLE$1 = \x27style\x27;\x0avar HTML = \x27__html\x27;\x0a\x0avar HTML_NAMESPACE = Namespaces.html;\x0a\x0a\x0avar warnedUnknownTags = void 0;\x0avar suppressHydrationWarning = void 0;\x0a\x0avar validatePropertiesInDevelopment = void 0;\x0avar warnForTextDifference = void 0;\x0avar warnForPropDifference = void 0;\x0avar warnForExtraAttributes = void 0;\x0avar warnForInvalidEventListener = void 0;\x0avar canDiffStyleForHydrationWarning = void 0;\x0a\x0avar normalizeMarkupForTextOrAttribute = void 0;\x0avar normalizeHTML = void 0;\x0a\x0a{\x0a  warnedUnknownTags = {\x0a    // Chrome is the only major browser not shipping \x3ctime\x3e. But as of July\x0a    // 2017 it intends to ship it due to widespread usage. We intentionally\x0a    // *don\x27t* warn for \x3ctime\x3e even if it\x27s unrecognized by Chrome because\x0a    // it soon will be, and many apps have been using it anyway.\x0a    time: true,\x0a    // There are working polyfills for \x3cdialog\x3e. Let people use it.\x0a    dialog: true,\x0a    // Electron ships a custom \x3cwebview\x3e tag to display external web content in\x0a    // an isolated frame and process.\x0a    // This tag is not present in non Electron environments such as JSDom which\x0a    // is often used for testing purposes.\x0a    // @see https://electronjs.org/docs/api/webview-tag\x0a    webview: true\x0a  };\x0a\x0a  validatePropertiesInDevelopment = function (type, props) {\x0a    validateProperties(type, props);\x0a    validateProperties$1(type, props);\x0a    validateProperties$2(type, props, /* canUseEventSystem */true);\x0a  };\x0a\x0a  // IE 11 parses & normalizes the style attribute as opposed to other\x0a  // browsers. It adds spaces and sorts the properties in some\x0a  // non-alphabetical order. Handling that would require sorting CSS\x0a  // properties in the client & server versions or applying\x0a  // `expectedStyle` to a temporary DOM node to read its `style` attribute\x0a  // normalized. Since it only affects IE, we\x27re skipping style warnings\x0a  // in that browser completely in favor of doing all that work.\x0a  // See https://github.com/facebook/react/issues/11807\x0a  canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;\x0a\x0a  // HTML parsing normalizes CR and CRLF to LF.\x0a  // It also can turn \x5cu0000 into \x5cuFFFD inside attributes.\x0a  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\x0a  // If we have a mismatch, it might be caused by that.\x0a  // We will still patch up in this case but not fire the warning.\x0a  var NORMALIZE_NEWLINES_REGEX = /\x5cr\x5cn?/g;\x0a  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\x5cu0000|\x5cuFFFD/g;\x0a\x0a  normalizeMarkupForTextOrAttribute = function (markup) {\x0a    var markupString = typeof markup === \x27string\x27 ? markup : \x27\x27 + markup;\x0a    return markupString.replace(NORMALIZE_NEWLINES_REGEX, \x27\x5cn\x27).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, \x27\x27);\x0a  };\x0a\x0a  warnForTextDifference = function (serverText, clientText) {\x0a    if (didWarnInvalidHydration) {\x0a      return;\x0a    }\x0a    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\x0a    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\x0a    if (normalizedServerText === normalizedClientText) {\x0a      return;\x0a    }\x0a    didWarnInvalidHydration = true;\x0a    warningWithoutStack$1(false, \x27Text content did not match. Server: \x22%s\x22 Client: \x22%s\x22\x27, normalizedServerText, normalizedClientText);\x0a  };\x0a\x0a  warnForPropDifference = function (propName, serverValue, clientValue) {\x0a    if (didWarnInvalidHydration) {\x0a      return;\x0a    }\x0a    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\x0a    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\x0a    if (normalizedServerValue === normalizedClientValue) {\x0a      return;\x0a    }\x0a    didWarnInvalidHydration = true;\x0a    warningWithoutStack$1(false, \x27Prop `%s` did not match. Server: %s Client: %s\x27, propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\x0a  };\x0a\x0a  warnForExtraAttributes = function (attributeNames) {\x0a    if (didWarnInvalidHydration) {\x0a      return;\x0a    }\x0a    didWarnInvalidHydration = true;\x0a    var names = [];\x0a    attributeNames.forEach(function (name) {\x0a      names.push(name);\x0a    });\x0a    warningWithoutStack$1(false, \x27Extra attributes from the server: %s\x27, names);\x0a  };\x0a\x0a  warnForInvalidEventListener = function (registrationName, listener) {\x0a    if (listener === false) {\x0a      warning$1(false, \x27Expected `%s` listener to be a function, instead got `false`.\x5cn\x5cn\x27 + \x27If you used to conditionally omit it with %s={condition && value}, \x27 + \x27pass %s={condition ? value : undefined} instead.\x27, registrationName, registrationName, registrationName);\x0a    } else {\x0a      warning$1(false, \x27Expected `%s` listener to be a function, instead got a value of `%s` type.\x27, registrationName, typeof listener);\x0a    }\x0a  };\x0a\x0a  // Parse the HTML and read it back to normalize the HTML string so that it\x0a  // can be used for comparison.\x0a  normalizeHTML = function (parent, html) {\x0a    // We could have created a separate document here to avoid\x0a    // re-initializing custom elements if they exist. But this breaks\x0a    // how \x3cnoscript\x3e is being handled. So we use the same document.\x0a    // See the discussion in https://github.com/facebook/react/pull/11157.\x0a    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\x0a    testElement.innerHTML = html;\x0a    return testElement.innerHTML;\x0a  };\x0a}\x0a\x0afunction ensureListeningTo(rootContainerElement, registrationName) {\x0a  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;\x0a  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\x0a  listenTo(registrationName, doc);\x0a}\x0a\x0afunction getOwnerDocumentFromRootContainer(rootContainerElement) {\x0a  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\x0a}\x0a\x0afunction noop() {}\x0a\x0afunction trapClickOnNonInteractiveElement(node) {\x0a  // Mobile Safari does not fire properly bubble click events on\x0a  // non-interactive elements, which means delegated click listeners do not\x0a  // fire. The workaround for this bug involves attaching an empty click\x0a  // listener on the target node.\x0a  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\x0a  // Just set it using the onclick property so that we don\x27t have to manage any\x0a  // bookkeeping for it. Not sure if we need to clear it when the listener is\x0a  // removed.\x0a  // TODO: Only do this for the relevant Safaris maybe?\x0a  node.onclick = noop;\x0a}\x0a\x0afunction setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\x0a  for (var propKey in nextProps) {\x0a    if (!nextProps.hasOwnProperty(propKey)) {\x0a      continue;\x0a    }\x0a    var nextProp = nextProps[propKey];\x0a    if (propKey === STYLE$1) {\x0a      {\x0a        if (nextProp) {\x0a          // Freeze the next style object so that we can assume it won\x27t be\x0a          // mutated. We have already warned for this in the past.\x0a          Object.freeze(nextProp);\x0a        }\x0a      }\x0a      // Relies on `updateStylesByID` not mutating `styleUpdates`.\x0a      setValueForStyles(domElement, nextProp);\x0a    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\x0a      var nextHtml = nextProp ? nextProp[HTML] : undefined;\x0a      if (nextHtml != null) {\x0a        setInnerHTML(domElement, nextHtml);\x0a      }\x0a    } else if (propKey === CHILDREN) {\x0a      if (typeof nextProp === \x27string\x27) {\x0a        // Avoid setting initial textContent when the text is empty. In IE11 setting\x0a        // textContent on a \x3ctextarea\x3e will cause the placeholder to not\x0a        // show within the \x3ctextarea\x3e until it has been focused and blurred again.\x0a        // https://github.com/facebook/react/issues/6731#issuecomment-254874553\x0a        var canSetTextContent = tag !== \x27textarea\x27 || nextProp !== \x27\x27;\x0a        if (canSetTextContent) {\x0a          setTextContent(domElement, nextProp);\x0a        }\x0a      } else if (typeof nextProp === \x27number\x27) {\x0a        setTextContent(domElement, \x27\x27 + nextProp);\x0a      }\x0a    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\x0a      // Noop\x0a    } else if (propKey === AUTOFOCUS) {\x0a      // We polyfill it separately on the client during commit.\x0a      // We could have excluded it in the property list instead of\x0a      // adding a special case here, but then it wouldn\x27t be emitted\x0a      // on server rendering (but we *do* want to emit it in SSR).\x0a    } else if (registrationNameModules.hasOwnProperty(propKey)) {\x0a      if (nextProp != null) {\x0a        if (true && typeof nextProp !== \x27function\x27) {\x0a          warnForInvalidEventListener(propKey, nextProp);\x0a        }\x0a        ensureListeningTo(rootContainerElement, propKey);\x0a      }\x0a    } else if (nextProp != null) {\x0a      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);\x0a    }\x0a  }\x0a}\x0a\x0afunction updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\x0a  // TODO: Handle wasCustomComponentTag\x0a  for (var i = 0; i \x3c updatePayload.length; i += 2) {\x0a    var propKey = updatePayload[i];\x0a    var propValue = updatePayload[i + 1];\x0a    if (propKey === STYLE$1) {\x0a      setValueForStyles(domElement, propValue);\x0a    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\x0a      setInnerHTML(domElement, propValue);\x0a    } else if (propKey === CHILDREN) {\x0a      setTextContent(domElement, propValue);\x0a    } else {\x0a      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\x0a    }\x0a  }\x0a}\x0a\x0afunction createElement(type, props, rootContainerElement, parentNamespace) {\x0a  var isCustomComponentTag = void 0;\x0a\x0a  // We create tags in the namespace of their parent container, except HTML\x0a  // tags get no namespace.\x0a  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\x0a  var domElement = void 0;\x0a  var namespaceURI = parentNamespace;\x0a  if (namespaceURI === HTML_NAMESPACE) {\x0a    namespaceURI = getIntrinsicNamespace(type);\x0a  }\x0a  if (namespaceURI === HTML_NAMESPACE) {\x0a    {\x0a      isCustomComponentTag = isCustomComponent(type, props);\x0a      // Should this check be gated by parent namespace? Not sure we want to\x0a      // allow \x3cSVG\x3e or \x3cmATH\x3e.\x0a      !(isCustomComponentTag || type === type.toLowerCase()) ? warning$1(false, \x27\x3c%s /\x3e is using incorrect casing. \x27 + \x27Use PascalCase for React components, \x27 + \x27or lowercase for HTML elements.\x27, type) : void 0;\x0a    }\x0a\x0a    if (type === \x27script\x27) {\x0a      // Create the script via .innerHTML so its \x22parser-inserted\x22 flag is\x0a      // set to true and it does not execute\x0a      var div = ownerDocument.createElement(\x27div\x27);\x0a      div.innerHTML = \x27\x3cscript\x3e\x3c\x27 + \x27/script\x3e\x27; // eslint-disable-line\x0a      // This is guaranteed to yield a script element.\x0a      var firstChild = div.firstChild;\x0a      domElement = div.removeChild(firstChild);\x0a    } else if (typeof props.is === \x27string\x27) {\x0a      // $FlowIssue `createElement` should be updated for Web Components\x0a      domElement = ownerDocument.createElement(type, { is: props.is });\x0a    } else {\x0a      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\x0a      // See discussion in https://github.com/facebook/react/pull/6896\x0a      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\x0a      domElement = ownerDocument.createElement(type);\x0a      // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple`\x0a      // attribute on `select`s needs to be added before `option`s are inserted. This prevents\x0a      // a bug where the `select` does not scroll to the correct option because singular\x0a      // `select` elements automatically pick the first item.\x0a      // See https://github.com/facebook/react/issues/13222\x0a      if (type === \x27select\x27 && props.multiple) {\x0a        var node = domElement;\x0a        node.multiple = true;\x0a      }\x0a    }\x0a  } else {\x0a    domElement = ownerDocument.createElementNS(namespaceURI, type);\x0a  }\x0a\x0a  {\x0a    if (namespaceURI === HTML_NAMESPACE) {\x0a      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === \x27[object HTMLUnknownElement]\x27 && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\x0a        warnedUnknownTags[type] = true;\x0a        warning$1(false, \x27The tag \x3c%s\x3e is unrecognized in this browser. \x27 + \x27If you meant to render a React component, start its name with \x27 + \x27an uppercase letter.\x27, type);\x0a      }\x0a    }\x0a  }\x0a\x0a  return domElement;\x0a}\x0a\x0afunction createTextNode(text, rootContainerElement) {\x0a  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\x0a}\x0a\x0afunction setInitialProperties(domElement, tag, rawProps, rootContainerElement) {\x0a  var isCustomComponentTag = isCustomComponent(tag, rawProps);\x0a  {\x0a    validatePropertiesInDevelopment(tag, rawProps);\x0a    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\x0a      warning$1(false, \x27%s is using shady DOM. Using shady DOM with React can \x27 + \x27cause things to break subtly.\x27, getCurrentFiberOwnerNameInDevOrNull() || \x27A component\x27);\x0a      didWarnShadyDOM = true;\x0a    }\x0a  }\x0a\x0a  // TODO: Make sure that we check isMounted before firing any of these events.\x0a  var props = void 0;\x0a  switch (tag) {\x0a    case \x27iframe\x27:\x0a    case \x27object\x27:\x0a      trapBubbledEvent(TOP_LOAD, domElement);\x0a      props = rawProps;\x0a      break;\x0a    case \x27video\x27:\x0a    case \x27audio\x27:\x0a      // Create listener for each media event\x0a      for (var i = 0; i \x3c mediaEventTypes.length; i++) {\x0a        trapBubbledEvent(mediaEventTypes[i], domElement);\x0a      }\x0a      props = rawProps;\x0a      break;\x0a    case \x27source\x27:\x0a      trapBubbledEvent(TOP_ERROR, domElement);\x0a      props = rawProps;\x0a      break;\x0a    case \x27img\x27:\x0a    case \x27image\x27:\x0a    case \x27link\x27:\x0a      trapBubbledEvent(TOP_ERROR, domElement);\x0a      trapBubbledEvent(TOP_LOAD, domElement);\x0a      props = rawProps;\x0a      break;\x0a    case \x27form\x27:\x0a      trapBubbledEvent(TOP_RESET, domElement);\x0a      trapBubbledEvent(TOP_SUBMIT, domElement);\x0a      props = rawProps;\x0a      break;\x0a    case \x27details\x27:\x0a      trapBubbledEvent(TOP_TOGGLE, domElement);\x0a      props = rawProps;\x0a      break;\x0a    case \x27input\x27:\x0a      initWrapperState(domElement, rawProps);\x0a      props = getHostProps(domElement, rawProps);\x0a      trapBubbledEvent(TOP_INVALID, domElement);\x0a      // For controlled components we always need to ensure we\x27re listening\x0a      // to onChange. Even if there is no listener.\x0a      ensureListeningTo(rootContainerElement, \x27onChange\x27);\x0a      break;\x0a    case \x27option\x27:\x0a      validateProps(domElement, rawProps);\x0a      props = getHostProps$1(domElement, rawProps);\x0a      break;\x0a    case \x27select\x27:\x0a      initWrapperState$1(domElement, rawProps);\x0a      props = getHostProps$2(domElement, rawProps);\x0a      trapBubbledEvent(TOP_INVALID, domElement);\x0a      // For controlled components we always need to ensure we\x27re listening\x0a      // to onChange. Even if there is no listener.\x0a      ensureListeningTo(rootContainerElement, \x27onChange\x27);\x0a      break;\x0a    case \x27textarea\x27:\x0a      initWrapperState$2(domElement, rawProps);\x0a      props = getHostProps$3(domElement, rawProps);\x0a      trapBubbledEvent(TOP_INVALID, domElement);\x0a      // For controlled components we always need to ensure we\x27re listening\x0a      // to onChange. Even if there is no listener.\x0a      ensureListeningTo(rootContainerElement, \x27onChange\x27);\x0a      break;\x0a    default:\x0a      props = rawProps;\x0a  }\x0a\x0a  assertValidProps(tag, props);\x0a\x0a  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\x0a\x0a  switch (tag) {\x0a    case \x27input\x27:\x0a      // TODO: Make sure we check if this is still unmounted or do any clean\x0a      // up necessary since we never stop tracking anymore.\x0a      track(domElement);\x0a      postMountWrapper(domElement, rawProps, false);\x0a      break;\x0a    case \x27textarea\x27:\x0a      // TODO: Make sure we check if this is still unmounted or do any clean\x0a      // up necessary since we never stop tracking anymore.\x0a      track(domElement);\x0a      postMountWrapper$3(domElement, rawProps);\x0a      break;\x0a    case \x27option\x27:\x0a      postMountWrapper$1(domElement, rawProps);\x0a      break;\x0a    case \x27select\x27:\x0a      postMountWrapper$2(domElement, rawProps);\x0a      break;\x0a    default:\x0a      if (typeof props.onClick === \x27function\x27) {\x0a        // TODO: This cast may not be sound for SVG, MathML or custom elements.\x0a        trapClickOnNonInteractiveElement(domElement);\x0a      }\x0a      break;\x0a  }\x0a}\x0a\x0a// Calculate the diff between the two objects.\x0afunction diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\x0a  {\x0a    validatePropertiesInDevelopment(tag, nextRawProps);\x0a  }\x0a\x0a  var updatePayload = null;\x0a\x0a  var lastProps = void 0;\x0a  var nextProps = void 0;\x0a  switch (tag) {\x0a    case \x27input\x27:\x0a      lastProps = getHostProps(domElement, lastRawProps);\x0a      nextProps = getHostProps(domElement, nextRawProps);\x0a      updatePayload = [];\x0a      break;\x0a    case \x27option\x27:\x0a      lastProps = getHostProps$1(domElement, lastRawProps);\x0a      nextProps = getHostProps$1(domElement, nextRawProps);\x0a      updatePayload = [];\x0a      break;\x0a    case \x27select\x27:\x0a      lastProps = getHostProps$2(domElement, lastRawProps);\x0a      nextProps = getHostProps$2(domElement, nextRawProps);\x0a      updatePayload = [];\x0a      break;\x0a    case \x27textarea\x27:\x0a      lastProps = getHostProps$3(domElement, lastRawProps);\x0a      nextProps = getHostProps$3(domElement, nextRawProps);\x0a      updatePayload = [];\x0a      break;\x0a    default:\x0a      lastProps = lastRawProps;\x0a      nextProps = nextRawProps;\x0a      if (typeof lastProps.onClick !== \x27function\x27 && typeof nextProps.onClick === \x27function\x27) {\x0a        // TODO: This cast may not be sound for SVG, MathML or custom elements.\x0a        trapClickOnNonInteractiveElement(domElement);\x0a      }\x0a      break;\x0a  }\x0a\x0a  assertValidProps(tag, nextProps);\x0a\x0a  var propKey = void 0;\x0a  var styleName = void 0;\x0a  var styleUpdates = null;\x0a  for (propKey in lastProps) {\x0a    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\x0a      continue;\x0a    }\x0a    if (propKey === STYLE$1) {\x0a      var lastStyle = lastProps[propKey];\x0a      for (styleName in lastStyle) {\x0a        if (lastStyle.hasOwnProperty(styleName)) {\x0a          if (!styleUpdates) {\x0a            styleUpdates = {};\x0a          }\x0a          styleUpdates[styleName] = \x27\x27;\x0a        }\x0a      }\x0a    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {\x0a      // Noop. This is handled by the clear text mechanism.\x0a    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\x0a      // Noop\x0a    } else if (propKey === AUTOFOCUS) {\x0a      // Noop. It doesn\x27t work on updates anyway.\x0a    } else if (registrationNameModules.hasOwnProperty(propKey)) {\x0a      // This is a special case. If any listener updates we need to ensure\x0a      // that the \x22current\x22 fiber pointer gets updated so we need a commit\x0a      // to update this element.\x0a      if (!updatePayload) {\x0a        updatePayload = [];\x0a      }\x0a    } else {\x0a      // For all other deleted properties we add it to the queue. We use\x0a      // the whitelist in the commit phase instead.\x0a      (updatePayload = updatePayload || []).push(propKey, null);\x0a    }\x0a  }\x0a  for (propKey in nextProps) {\x0a    var nextProp = nextProps[propKey];\x0a    var lastProp = lastProps != null ? lastProps[propKey] : undefined;\x0a    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\x0a      continue;\x0a    }\x0a    if (propKey === STYLE$1) {\x0a      {\x0a        if (nextProp) {\x0a          // Freeze the next style object so that we can assume it won\x27t be\x0a          // mutated. We have already warned for this in the past.\x0a          Object.freeze(nextProp);\x0a        }\x0a      }\x0a      if (lastProp) {\x0a        // Unset styles on `lastProp` but not on `nextProp`.\x0a        for (styleName in lastProp) {\x0a          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\x0a            if (!styleUpdates) {\x0a              styleUpdates = {};\x0a            }\x0a            styleUpdates[styleName] = \x27\x27;\x0a          }\x0a        }\x0a        // Update styles that changed since `lastProp`.\x0a        for (styleName in nextProp) {\x0a          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\x0a            if (!styleUpdates) {\x0a              styleUpdates = {};\x0a            }\x0a            styleUpdates[styleName] = nextProp[styleName];\x0a          }\x0a        }\x0a      } else {\x0a        // Relies on `updateStylesByID` not mutating `styleUpdates`.\x0a        if (!styleUpdates) {\x0a          if (!updatePayload) {\x0a            updatePayload = [];\x0a          }\x0a          updatePayload.push(propKey, styleUpdates);\x0a        }\x0a        styleUpdates = nextProp;\x0a      }\x0a    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\x0a      var nextHtml = nextProp ? nextProp[HTML] : undefined;\x0a      var lastHtml = lastProp ? lastProp[HTML] : undefined;\x0a      if (nextHtml != null) {\x0a        if (lastHtml !== nextHtml) {\x0a          (updatePayload = updatePayload || []).push(propKey, \x27\x27 + nextHtml);\x0a        }\x0a      } else {\x0a        // TODO: It might be too late to clear this if we have children\x0a        // inserted already.\x0a      }\x0a    } else if (propKey === CHILDREN) {\x0a      if (lastProp !== nextProp && (typeof nextProp === \x27string\x27 || typeof nextProp === \x27number\x27)) {\x0a        (updatePayload = updatePayload || []).push(propKey, \x27\x27 + nextProp);\x0a      }\x0a    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\x0a      // Noop\x0a    } else if (registrationNameModules.hasOwnProperty(propKey)) {\x0a      if (nextProp != null) {\x0a        // We eagerly listen to this even though we haven\x27t committed yet.\x0a        if (true && typeof nextProp !== \x27function\x27) {\x0a          warnForInvalidEventListener(propKey, nextProp);\x0a        }\x0a        ensureListeningTo(rootContainerElement, propKey);\x0a      }\x0a      if (!updatePayload && lastProp !== nextProp) {\x0a        // This is a special case. If any listener updates we need to ensure\x0a        // that the \x22current\x22 props pointer gets updated so we need a commit\x0a        // to update this element.\x0a        updatePayload = [];\x0a      }\x0a    } else {\x0a      // For any other property we always add it to the queue and then we\x0a      // filter it out using the whitelist during the commit.\x0a      (updatePayload = updatePayload || []).push(propKey, nextProp);\x0a    }\x0a  }\x0a  if (styleUpdates) {\x0a    {\x0a      validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE$1]);\x0a    }\x0a    (updatePayload = updatePayload || []).push(STYLE$1, styleUpdates);\x0a  }\x0a  return updatePayload;\x0a}\x0a\x0a// Apply the diff.\x0afunction updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\x0a  // Update checked *before* name.\x0a  // In the middle of an update, it is possible to have multiple checked.\x0a  // When a checked radio tries to change name, browser makes another radio\x27s checked false.\x0a  if (tag === \x27input\x27 && nextRawProps.type === \x27radio\x27 && nextRawProps.name != null) {\x0a    updateChecked(domElement, nextRawProps);\x0a  }\x0a\x0a  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\x0a  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\x0a  // Apply the diff.\x0a  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\x0a\x0a  // TODO: Ensure that an update gets scheduled if any of the special props\x0a  // changed.\x0a  switch (tag) {\x0a    case \x27input\x27:\x0a      // Update the wrapper around inputs *after* updating props. This has to\x0a      // happen after `updateDOMProperties`. Otherwise HTML5 input validations\x0a      // raise warnings and prevent the new value from being assigned.\x0a      updateWrapper(domElement, nextRawProps);\x0a      break;\x0a    case \x27textarea\x27:\x0a      updateWrapper$1(domElement, nextRawProps);\x0a      break;\x0a    case \x27select\x27:\x0a      // \x3cselect\x3e value update needs to occur after \x3coption\x3e children\x0a      // reconciliation\x0a      postUpdateWrapper(domElement, nextRawProps);\x0a      break;\x0a  }\x0a}\x0a\x0afunction getPossibleStandardName(propName) {\x0a  {\x0a    var lowerCasedName = propName.toLowerCase();\x0a    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {\x0a      return null;\x0a    }\x0a    return possibleStandardNames[lowerCasedName] || null;\x0a  }\x0a  return null;\x0a}\x0a\x0afunction diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\x0a  var isCustomComponentTag = void 0;\x0a  var extraAttributeNames = void 0;\x0a\x0a  {\x0a    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;\x0a    isCustomComponentTag = isCustomComponent(tag, rawProps);\x0a    validatePropertiesInDevelopment(tag, rawProps);\x0a    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\x0a      warning$1(false, \x27%s is using shady DOM. Using shady DOM with React can \x27 + \x27cause things to break subtly.\x27, getCurrentFiberOwnerNameInDevOrNull() || \x27A component\x27);\x0a      didWarnShadyDOM = true;\x0a    }\x0a  }\x0a\x0a  // TODO: Make sure that we check isMounted before firing any of these events.\x0a  switch (tag) {\x0a    case \x27iframe\x27:\x0a    case \x27object\x27:\x0a      trapBubbledEvent(TOP_LOAD, domElement);\x0a      break;\x0a    case \x27video\x27:\x0a    case \x27audio\x27:\x0a      // Create listener for each media event\x0a      for (var i = 0; i \x3c mediaEventTypes.length; i++) {\x0a        trapBubbledEvent(mediaEventTypes[i], domElement);\x0a      }\x0a      break;\x0a    case \x27source\x27:\x0a      trapBubbledEvent(TOP_ERROR, domElement);\x0a      break;\x0a    case \x27img\x27:\x0a    case \x27image\x27:\x0a    case \x27link\x27:\x0a      trapBubbledEvent(TOP_ERROR, domElement);\x0a      trapBubbledEvent(TOP_LOAD, domElement);\x0a      break;\x0a    case \x27form\x27:\x0a      trapBubbledEvent(TOP_RESET, domElement);\x0a      trapBubbledEvent(TOP_SUBMIT, domElement);\x0a      break;\x0a    case \x27details\x27:\x0a      trapBubbledEvent(TOP_TOGGLE, domElement);\x0a      break;\x0a    case \x27input\x27:\x0a      initWrapperState(domElement, rawProps);\x0a      trapBubbledEvent(TOP_INVALID, domElement);\x0a      // For controlled components we always need to ensure we\x27re listening\x0a      // to onChange. Even if there is no listener.\x0a      ensureListeningTo(rootContainerElement, \x27onChange\x27);\x0a      break;\x0a    case \x27option\x27:\x0a      validateProps(domElement, rawProps);\x0a      break;\x0a    case \x27select\x27:\x0a      initWrapperState$1(domElement, rawProps);\x0a      trapBubbledEvent(TOP_INVALID, domElement);\x0a      // For controlled components we always need to ensure we\x27re listening\x0a      // to onChange. Even if there is no listener.\x0a      ensureListeningTo(rootContainerElement, \x27onChange\x27);\x0a      break;\x0a    case \x27textarea\x27:\x0a      initWrapperState$2(domElement, rawProps);\x0a      trapBubbledEvent(TOP_INVALID, domElement);\x0a      // For controlled components we always need to ensure we\x27re listening\x0a      // to onChange. Even if there is no listener.\x0a      ensureListeningTo(rootContainerElement, \x27onChange\x27);\x0a      break;\x0a  }\x0a\x0a  assertValidProps(tag, rawProps);\x0a\x0a  {\x0a    extraAttributeNames = new Set();\x0a    var attributes = domElement.attributes;\x0a    for (var _i = 0; _i \x3c attributes.length; _i++) {\x0a      var name = attributes[_i].name.toLowerCase();\x0a      switch (name) {\x0a        // Built-in SSR attribute is whitelisted\x0a        case \x27data-reactroot\x27:\x0a          break;\x0a        // Controlled attributes are not validated\x0a        // TODO: Only ignore them on controlled tags.\x0a        case \x27value\x27:\x0a          break;\x0a        case \x27checked\x27:\x0a          break;\x0a        case \x27selected\x27:\x0a          break;\x0a        default:\x0a          // Intentionally use the original name.\x0a          // See discussion in https://github.com/facebook/react/pull/10676.\x0a          extraAttributeNames.add(attributes[_i].name);\x0a      }\x0a    }\x0a  }\x0a\x0a  var updatePayload = null;\x0a  for (var propKey in rawProps) {\x0a    if (!rawProps.hasOwnProperty(propKey)) {\x0a      continue;\x0a    }\x0a    var nextProp = rawProps[propKey];\x0a    if (propKey === CHILDREN) {\x0a      // For text content children we compare against textContent. This\x0a      // might match additional HTML that is hidden when we read it using\x0a      // textContent. E.g. \x22foo\x22 will match \x22f\x3cspan\x3eoo\x3c/span\x3e\x22 but that still\x0a      // satisfies our requirement. Our requirement is not to produce perfect\x0a      // HTML and attributes. Ideally we should preserve structure but it\x27s\x0a      // ok not to if the visible content is still enough to indicate what\x0a      // even listeners these nodes might be wired up to.\x0a      // TODO: Warn if there is more than a single textNode as a child.\x0a      // TODO: Should we use domElement.firstChild.nodeValue to compare?\x0a      if (typeof nextProp === \x27string\x27) {\x0a        if (domElement.textContent !== nextProp) {\x0a          if (true && !suppressHydrationWarning) {\x0a            warnForTextDifference(domElement.textContent, nextProp);\x0a          }\x0a          updatePayload = [CHILDREN, nextProp];\x0a        }\x0a      } else if (typeof nextProp === \x27number\x27) {\x0a        if (domElement.textContent !== \x27\x27 + nextProp) {\x0a          if (true && !suppressHydrationWarning) {\x0a            warnForTextDifference(domElement.textContent, nextProp);\x0a          }\x0a          updatePayload = [CHILDREN, \x27\x27 + nextProp];\x0a        }\x0a      }\x0a    } else if (registrationNameModules.hasOwnProperty(propKey)) {\x0a      if (nextProp != null) {\x0a        if (true && typeof nextProp !== \x27function\x27) {\x0a          warnForInvalidEventListener(propKey, nextProp);\x0a        }\x0a        ensureListeningTo(rootContainerElement, propKey);\x0a      }\x0a    } else if (true &&\x0a    // Convince Flow we\x27ve calculated it (it\x27s DEV-only in this method.)\x0a    typeof isCustomComponentTag === \x27boolean\x27) {\x0a      // Validate that the properties correspond to their expected values.\x0a      var serverValue = void 0;\x0a      var propertyInfo = getPropertyInfo(propKey);\x0a      if (suppressHydrationWarning) {\x0a        // Don\x27t bother comparing. We\x27re ignoring all these warnings.\x0a      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||\x0a      // Controlled attributes are not validated\x0a      // TODO: Only ignore them on controlled tags.\x0a      propKey === \x27value\x27 || propKey === \x27checked\x27 || propKey === \x27selected\x27) {\x0a        // Noop\x0a      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\x0a        var serverHTML = domElement.innerHTML;\x0a        var nextHtml = nextProp ? nextProp[HTML] : undefined;\x0a        var expectedHTML = normalizeHTML(domElement, nextHtml != null ? nextHtml : \x27\x27);\x0a        if (expectedHTML !== serverHTML) {\x0a          warnForPropDifference(propKey, serverHTML, expectedHTML);\x0a        }\x0a      } else if (propKey === STYLE$1) {\x0a        // $FlowFixMe - Should be inferred as not undefined.\x0a        extraAttributeNames.delete(propKey);\x0a\x0a        if (canDiffStyleForHydrationWarning) {\x0a          var expectedStyle = createDangerousStringForStyles(nextProp);\x0a          serverValue = domElement.getAttribute(\x27style\x27);\x0a          if (expectedStyle !== serverValue) {\x0a            warnForPropDifference(propKey, serverValue, expectedStyle);\x0a          }\x0a        }\x0a      } else if (isCustomComponentTag) {\x0a        // $FlowFixMe - Should be inferred as not undefined.\x0a        extraAttributeNames.delete(propKey.toLowerCase());\x0a        serverValue = getValueForAttribute(domElement, propKey, nextProp);\x0a\x0a        if (nextProp !== serverValue) {\x0a          warnForPropDifference(propKey, serverValue, nextProp);\x0a        }\x0a      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {\x0a        var isMismatchDueToBadCasing = false;\x0a        if (propertyInfo !== null) {\x0a          // $FlowFixMe - Should be inferred as not undefined.\x0a          extraAttributeNames.delete(propertyInfo.attributeName);\x0a          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);\x0a        } else {\x0a          var ownNamespace = parentNamespace;\x0a          if (ownNamespace === HTML_NAMESPACE) {\x0a            ownNamespace = getIntrinsicNamespace(tag);\x0a          }\x0a          if (ownNamespace === HTML_NAMESPACE) {\x0a            // $FlowFixMe - Should be inferred as not undefined.\x0a            extraAttributeNames.delete(propKey.toLowerCase());\x0a          } else {\x0a            var standardName = getPossibleStandardName(propKey);\x0a            if (standardName !== null && standardName !== propKey) {\x0a              // If an SVG prop is supplied with bad casing, it will\x0a              // be successfully parsed from HTML, but will produce a mismatch\x0a              // (and would be incorrectly rendered on the client).\x0a              // However, we already warn about bad casing elsewhere.\x0a              // So we\x27ll skip the misleading extra mismatch warning in this case.\x0a              isMismatchDueToBadCasing = true;\x0a              // $FlowFixMe - Should be inferred as not undefined.\x0a              extraAttributeNames.delete(standardName);\x0a            }\x0a            // $FlowFixMe - Should be inferred as not undefined.\x0a            extraAttributeNames.delete(propKey);\x0a          }\x0a          serverValue = getValueForAttribute(domElement, propKey, nextProp);\x0a        }\x0a\x0a        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {\x0a          warnForPropDifference(propKey, serverValue, nextProp);\x0a        }\x0a      }\x0a    }\x0a  }\x0a\x0a  {\x0a    // $FlowFixMe - Should be inferred as not undefined.\x0a    if (extraAttributeNames.size \x3e 0 && !suppressHydrationWarning) {\x0a      // $FlowFixMe - Should be inferred as not undefined.\x0a      warnForExtraAttributes(extraAttributeNames);\x0a    }\x0a  }\x0a\x0a  switch (tag) {\x0a    case \x27input\x27:\x0a      // TODO: Make sure we check if this is still unmounted or do any clean\x0a      // up necessary since we never stop tracking anymore.\x0a      track(domElement);\x0a      postMountWrapper(domElement, rawProps, true);\x0a      break;\x0a    case \x27textarea\x27:\x0a      // TODO: Make sure we check if this is still unmounted or do any clean\x0a      // up necessary since we never stop tracking anymore.\x0a      track(domElement);\x0a      postMountWrapper$3(domElement, rawProps);\x0a      break;\x0a    case \x27select\x27:\x0a    case \x27option\x27:\x0a      // For input and textarea we current always set the value property at\x0a      // post mount to force it to diverge from attributes. However, for\x0a      // option and select we don\x27t quite do the same thing and select\x0a      // is not resilient to the DOM state changing so we don\x27t do that here.\x0a      // TODO: Consider not doing this for input and textarea.\x0a      break;\x0a    default:\x0a      if (typeof rawProps.onClick === \x27function\x27) {\x0a        // TODO: This cast may not be sound for SVG, MathML or custom elements.\x0a        trapClickOnNonInteractiveElement(domElement);\x0a      }\x0a      break;\x0a  }\x0a\x0a  return updatePayload;\x0a}\x0a\x0afunction diffHydratedText(textNode, text) {\x0a  var isDifferent = textNode.nodeValue !== text;\x0a  return isDifferent;\x0a}\x0a\x0afunction warnForUnmatchedText(textNode, text) {\x0a  {\x0a    warnForTextDifference(textNode.nodeValue, text);\x0a  }\x0a}\x0a\x0afunction warnForDeletedHydratableElement(parentNode, child) {\x0a  {\x0a    if (didWarnInvalidHydration) {\x0a      return;\x0a    }\x0a    didWarnInvalidHydration = true;\x0a    warningWithoutStack$1(false, \x27Did not expect server HTML to contain a \x3c%s\x3e in \x3c%s\x3e.\x27, child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\x0a  }\x0a}\x0a\x0afunction warnForDeletedHydratableText(parentNode, child) {\x0a  {\x0a    if (didWarnInvalidHydration) {\x0a      return;\x0a    }\x0a    didWarnInvalidHydration = true;\x0a    warningWithoutStack$1(false, \x27Did not expect server HTML to contain the text node \x22%s\x22 in \x3c%s\x3e.\x27, child.nodeValue, parentNode.nodeName.toLowerCase());\x0a  }\x0a}\x0a\x0afunction warnForInsertedHydratedElement(parentNode, tag, props) {\x0a  {\x0a    if (didWarnInvalidHydration) {\x0a      return;\x0a    }\x0a    didWarnInvalidHydration = true;\x0a    warningWithoutStack$1(false, \x27Expected server HTML to contain a matching \x3c%s\x3e in \x3c%s\x3e.\x27, tag, parentNode.nodeName.toLowerCase());\x0a  }\x0a}\x0a\x0afunction warnForInsertedHydratedText(parentNode, text) {\x0a  {\x0a    if (text === \x27\x27) {\x0a      // We expect to insert empty text nodes since they\x27re not represented in\x0a      // the HTML.\x0a      // TODO: Remove this special case if we can just avoid inserting empty\x0a      // text nodes.\x0a      return;\x0a    }\x0a    if (didWarnInvalidHydration) {\x0a      return;\x0a    }\x0a    didWarnInvalidHydration = true;\x0a    warningWithoutStack$1(false, \x27Expected server HTML to contain a matching text node for \x22%s\x22 in \x3c%s\x3e.\x27, text, parentNode.nodeName.toLowerCase());\x0a  }\x0a}\x0a\x0afunction restoreControlledState$1(domElement, tag, props) {\x0a  switch (tag) {\x0a    case \x27input\x27:\x0a      restoreControlledState(domElement, props);\x0a      return;\x0a    case \x27textarea\x27:\x0a      restoreControlledState$3(domElement, props);\x0a      return;\x0a    case \x27select\x27:\x0a      restoreControlledState$2(domElement, props);\x0a      return;\x0a  }\x0a}\x0a\x0a// TODO: direct imports like some-package/src/* are bad. Fix me.\x0avar validateDOMNesting = function () {};\x0avar updatedAncestorInfo = function () {};\x0a\x0a{\x0a  // This validation code was written based on the HTML5 parsing spec:\x0a  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\x0a  //\x0a  // Note: this does not catch all invalid nesting, nor does it try to (as it\x27s\x0a  // not clear what practical benefit doing so provides); instead, we warn only\x0a  // for cases where the parser will give a parse tree differing from what React\x0a  // intended. For example, \x3cb\x3e\x3cdiv\x3e\x3c/div\x3e\x3c/b\x3e is invalid but we don\x27t warn\x0a  // because it still parses correctly; we do warn for other cases like nested\x0a  // \x3cp\x3e tags where the beginning of the second element implicitly closes the\x0a  // first, causing a confusing mess.\x0a\x0a  // https://html.spec.whatwg.org/multipage/syntax.html#special\x0a  var specialTags = [\x27address\x27, \x27applet\x27, \x27area\x27, \x27article\x27, \x27aside\x27, \x27base\x27, \x27basefont\x27, \x27bgsound\x27, \x27blockquote\x27, \x27body\x27, \x27br\x27, \x27button\x27, \x27caption\x27, \x27center\x27, \x27col\x27, \x27colgroup\x27, \x27dd\x27, \x27details\x27, \x27dir\x27, \x27div\x27, \x27dl\x27, \x27dt\x27, \x27embed\x27, \x27fieldset\x27, \x27figcaption\x27, \x27figure\x27, \x27footer\x27, \x27form\x27, \x27frame\x27, \x27frameset\x27, \x27h1\x27, \x27h2\x27, \x27h3\x27, \x27h4\x27, \x27h5\x27, \x27h6\x27, \x27head\x27, \x27header\x27, \x27hgroup\x27, \x27hr\x27, \x27html\x27, \x27iframe\x27, \x27img\x27, \x27input\x27, \x27isindex\x27, \x27li\x27, \x27link\x27, \x27listing\x27, \x27main\x27, \x27marquee\x27, \x27menu\x27, \x27menuitem\x27, \x27meta\x27, \x27nav\x27, \x27noembed\x27, \x27noframes\x27, \x27noscript\x27, \x27object\x27, \x27ol\x27, \x27p\x27, \x27param\x27, \x27plaintext\x27, \x27pre\x27, \x27script\x27, \x27section\x27, \x27select\x27, \x27source\x27, \x27style\x27, \x27summary\x27, \x27table\x27, \x27tbody\x27, \x27td\x27, \x27template\x27, \x27textarea\x27, \x27tfoot\x27, \x27th\x27, \x27thead\x27, \x27title\x27, \x27tr\x27, \x27track\x27, \x27ul\x27, \x27wbr\x27, \x27xmp\x27];\x0a\x0a  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\x0a  var inScopeTags = [\x27applet\x27, \x27caption\x27, \x27html\x27, \x27table\x27, \x27td\x27, \x27th\x27, \x27marquee\x27, \x27object\x27, \x27template\x27,\x0a\x0a  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\x0a  // TODO: Distinguish by namespace here -- for \x3ctitle\x3e, including it here\x0a  // errs on the side of fewer warnings\x0a  \x27foreignObject\x27, \x27desc\x27, \x27title\x27];\x0a\x0a  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\x0a  var buttonScopeTags = inScopeTags.concat([\x27button\x27]);\x0a\x0a  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\x0a  var impliedEndTags = [\x27dd\x27, \x27dt\x27, \x27li\x27, \x27option\x27, \x27optgroup\x27, \x27p\x27, \x27rp\x27, \x27rt\x27];\x0a\x0a  var emptyAncestorInfo = {\x0a    current: null,\x0a\x0a    formTag: null,\x0a    aTagInScope: null,\x0a    buttonTagInScope: null,\x0a    nobrTagInScope: null,\x0a    pTagInButtonScope: null,\x0a\x0a    listItemTagAutoclosing: null,\x0a    dlItemTagAutoclosing: null\x0a  };\x0a\x0a  updatedAncestorInfo = function (oldInfo, tag) {\x0a    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\x0a    var info = { tag: tag };\x0a\x0a    if (inScopeTags.indexOf(tag) !== -1) {\x0a      ancestorInfo.aTagInScope = null;\x0a      ancestorInfo.buttonTagInScope = null;\x0a      ancestorInfo.nobrTagInScope = null;\x0a    }\x0a    if (buttonScopeTags.indexOf(tag) !== -1) {\x0a      ancestorInfo.pTagInButtonScope = null;\x0a    }\x0a\x0a    // See rules for \x27li\x27, \x27dd\x27, \x27dt\x27 start tags in\x0a    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\x0a    if (specialTags.indexOf(tag) !== -1 && tag !== \x27address\x27 && tag !== \x27div\x27 && tag !== \x27p\x27) {\x0a      ancestorInfo.listItemTagAutoclosing = null;\x0a      ancestorInfo.dlItemTagAutoclosing = null;\x0a    }\x0a\x0a    ancestorInfo.current = info;\x0a\x0a    if (tag === \x27form\x27) {\x0a      ancestorInfo.formTag = info;\x0a    }\x0a    if (tag === \x27a\x27) {\x0a      ancestorInfo.aTagInScope = info;\x0a    }\x0a    if (tag === \x27button\x27) {\x0a      ancestorInfo.buttonTagInScope = info;\x0a    }\x0a    if (tag === \x27nobr\x27) {\x0a      ancestorInfo.nobrTagInScope = info;\x0a    }\x0a    if (tag === \x27p\x27) {\x0a      ancestorInfo.pTagInButtonScope = info;\x0a    }\x0a    if (tag === \x27li\x27) {\x0a      ancestorInfo.listItemTagAutoclosing = info;\x0a    }\x0a    if (tag === \x27dd\x27 || tag === \x27dt\x27) {\x0a      ancestorInfo.dlItemTagAutoclosing = info;\x0a    }\x0a\x0a    return ancestorInfo;\x0a  };\x0a\x0a  /**\x0a   * Returns whether\x0a   */\x0a  var isTagValidWithParent = function (tag, parentTag) {\x0a    // First, let\x27s check if we\x27re in an unusual parsing mode...\x0a    switch (parentTag) {\x0a      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\x0a      case \x27select\x27:\x0a        return tag === \x27option\x27 || tag === \x27optgroup\x27 || tag === \x27#text\x27;\x0a      case \x27optgroup\x27:\x0a        return tag === \x27option\x27 || tag === \x27#text\x27;\x0a      // Strictly speaking, seeing an \x3coption\x3e doesn\x27t mean we\x27re in a \x3cselect\x3e\x0a      // but\x0a      case \x27option\x27:\x0a        return tag === \x27#text\x27;\x0a      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\x0a      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\x0a      // No special behavior since these rules fall back to \x22in body\x22 mode for\x0a      // all except special table nodes which cause bad parsing behavior anyway.\x0a\x0a      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\x0a      case \x27tr\x27:\x0a        return tag === \x27th\x27 || tag === \x27td\x27 || tag === \x27style\x27 || tag === \x27script\x27 || tag === \x27template\x27;\x0a      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\x0a      case \x27tbody\x27:\x0a      case \x27thead\x27:\x0a      case \x27tfoot\x27:\x0a        return tag === \x27tr\x27 || tag === \x27style\x27 || tag === \x27script\x27 || tag === \x27template\x27;\x0a      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\x0a      case \x27colgroup\x27:\x0a        return tag === \x27col\x27 || tag === \x27template\x27;\x0a      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\x0a      case \x27table\x27:\x0a        return tag === \x27caption\x27 || tag === \x27colgroup\x27 || tag === \x27tbody\x27 || tag === \x27tfoot\x27 || tag === \x27thead\x27 || tag === \x27style\x27 || tag === \x27script\x27 || tag === \x27template\x27;\x0a      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\x0a      case \x27head\x27:\x0a        return tag === \x27base\x27 || tag === \x27basefont\x27 || tag === \x27bgsound\x27 || tag === \x27link\x27 || tag === \x27meta\x27 || tag === \x27title\x27 || tag === \x27noscript\x27 || tag === \x27noframes\x27 || tag === \x27style\x27 || tag === \x27script\x27 || tag === \x27template\x27;\x0a      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\x0a      case \x27html\x27:\x0a        return tag === \x27head\x27 || tag === \x27body\x27;\x0a      case \x27#document\x27:\x0a        return tag === \x27html\x27;\x0a    }\x0a\x0a    // Probably in the \x22in body\x22 parsing mode, so we outlaw only tag combos\x0a    // where the parsing rules cause implicit opens or closes to be added.\x0a    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\x0a    switch (tag) {\x0a      case \x27h1\x27:\x0a      case \x27h2\x27:\x0a      case \x27h3\x27:\x0a      case \x27h4\x27:\x0a      case \x27h5\x27:\x0a      case \x27h6\x27:\x0a        return parentTag !== \x27h1\x27 && parentTag !== \x27h2\x27 && parentTag !== \x27h3\x27 && parentTag !== \x27h4\x27 && parentTag !== \x27h5\x27 && parentTag !== \x27h6\x27;\x0a\x0a      case \x27rp\x27:\x0a      case \x27rt\x27:\x0a        return impliedEndTags.indexOf(parentTag) === -1;\x0a\x0a      case \x27body\x27:\x0a      case \x27caption\x27:\x0a      case \x27col\x27:\x0a      case \x27colgroup\x27:\x0a      case \x27frame\x27:\x0a      case \x27head\x27:\x0a      case \x27html\x27:\x0a      case \x27tbody\x27:\x0a      case \x27td\x27:\x0a      case \x27tfoot\x27:\x0a      case \x27th\x27:\x0a      case \x27thead\x27:\x0a      case \x27tr\x27:\x0a        // These tags are only valid with a few parents that have special child\x0a        // parsing rules -- if we\x27re down here, then none of those matched and\x0a        // so we allow it only if we don\x27t know what the parent is, as all other\x0a        // cases are invalid.\x0a        return parentTag == null;\x0a    }\x0a\x0a    return true;\x0a  };\x0a\x0a  /**\x0a   * Returns whether\x0a   */\x0a  var findInvalidAncestorForTag = function (tag, ancestorInfo) {\x0a    switch (tag) {\x0a      case \x27address\x27:\x0a      case \x27article\x27:\x0a      case \x27aside\x27:\x0a      case \x27blockquote\x27:\x0a      case \x27center\x27:\x0a      case \x27details\x27:\x0a      case \x27dialog\x27:\x0a      case \x27dir\x27:\x0a      case \x27div\x27:\x0a      case \x27dl\x27:\x0a      case \x27fieldset\x27:\x0a      case \x27figcaption\x27:\x0a      case \x27figure\x27:\x0a      case \x27footer\x27:\x0a      case \x27header\x27:\x0a      case \x27hgroup\x27:\x0a      case \x27main\x27:\x0a      case \x27menu\x27:\x0a      case \x27nav\x27:\x0a      case \x27ol\x27:\x0a      case \x27p\x27:\x0a      case \x27section\x27:\x0a      case \x27summary\x27:\x0a      case \x27ul\x27:\x0a      case \x27pre\x27:\x0a      case \x27listing\x27:\x0a      case \x27table\x27:\x0a      case \x27hr\x27:\x0a      case \x27xmp\x27:\x0a      case \x27h1\x27:\x0a      case \x27h2\x27:\x0a      case \x27h3\x27:\x0a      case \x27h4\x27:\x0a      case \x27h5\x27:\x0a      case \x27h6\x27:\x0a        return ancestorInfo.pTagInButtonScope;\x0a\x0a      case \x27form\x27:\x0a        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\x0a\x0a      case \x27li\x27:\x0a        return ancestorInfo.listItemTagAutoclosing;\x0a\x0a      case \x27dd\x27:\x0a      case \x27dt\x27:\x0a        return ancestorInfo.dlItemTagAutoclosing;\x0a\x0a      case \x27button\x27:\x0a        return ancestorInfo.buttonTagInScope;\x0a\x0a      case \x27a\x27:\x0a        // Spec says something about storing a list of markers, but it sounds\x0a        // equivalent to this check.\x0a        return ancestorInfo.aTagInScope;\x0a\x0a      case \x27nobr\x27:\x0a        return ancestorInfo.nobrTagInScope;\x0a    }\x0a\x0a    return null;\x0a  };\x0a\x0a  var didWarn = {};\x0a\x0a  validateDOMNesting = function (childTag, childText, ancestorInfo) {\x0a    ancestorInfo = ancestorInfo || emptyAncestorInfo;\x0a    var parentInfo = ancestorInfo.current;\x0a    var parentTag = parentInfo && parentInfo.tag;\x0a\x0a    if (childText != null) {\x0a      !(childTag == null) ? warningWithoutStack$1(false, \x27validateDOMNesting: when childText is passed, childTag should be null\x27) : void 0;\x0a      childTag = \x27#text\x27;\x0a    }\x0a\x0a    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\x0a    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\x0a    var invalidParentOrAncestor = invalidParent || invalidAncestor;\x0a    if (!invalidParentOrAncestor) {\x0a      return;\x0a    }\x0a\x0a    var ancestorTag = invalidParentOrAncestor.tag;\x0a    var addendum = getCurrentFiberStackInDev();\x0a\x0a    var warnKey = !!invalidParent + \x27|\x27 + childTag + \x27|\x27 + ancestorTag + \x27|\x27 + addendum;\x0a    if (didWarn[warnKey]) {\x0a      return;\x0a    }\x0a    didWarn[warnKey] = true;\x0a\x0a    var tagDisplayName = childTag;\x0a    var whitespaceInfo = \x27\x27;\x0a    if (childTag === \x27#text\x27) {\x0a      if (/\x5cS/.test(childText)) {\x0a        tagDisplayName = \x27Text nodes\x27;\x0a      } else {\x0a        tagDisplayName = \x27Whitespace text nodes\x27;\x0a        whitespaceInfo = \x22 Make sure you don\x27t have any extra whitespace between tags on \x22 + \x27each line of your source code.\x27;\x0a      }\x0a    } else {\x0a      tagDisplayName = \x27\x3c\x27 + childTag + \x27\x3e\x27;\x0a    }\x0a\x0a    if (invalidParent) {\x0a      var info = \x27\x27;\x0a      if (ancestorTag === \x27table\x27 && childTag === \x27tr\x27) {\x0a        info += \x27 Add a \x3ctbody\x3e to your code to match the DOM tree generated by \x27 + \x27the browser.\x27;\x0a      }\x0a      warningWithoutStack$1(false, \x27validateDOMNesting(...): %s cannot appear as a child of \x3c%s\x3e.%s%s%s\x27, tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\x0a    } else {\x0a      warningWithoutStack$1(false, \x27validateDOMNesting(...): %s cannot appear as a descendant of \x27 + \x27\x3c%s\x3e.%s\x27, tagDisplayName, ancestorTag, addendum);\x0a    }\x0a  };\x0a}\x0a\x0avar ReactInternals$1 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\x0a\x0avar _ReactInternals$Sched = ReactInternals$1.Scheduler;\x0avar unstable_cancelCallback = _ReactInternals$Sched.unstable_cancelCallback;\x0avar unstable_now = _ReactInternals$Sched.unstable_now;\x0avar unstable_scheduleCallback = _ReactInternals$Sched.unstable_scheduleCallback;\x0avar unstable_shouldYield = _ReactInternals$Sched.unstable_shouldYield;\x0avar unstable_getFirstCallbackNode = _ReactInternals$Sched.unstable_getFirstCallbackNode;\x0avar unstable_runWithPriority = _ReactInternals$Sched.unstable_runWithPriority;\x0avar unstable_next = _ReactInternals$Sched.unstable_next;\x0avar unstable_continueExecution = _ReactInternals$Sched.unstable_continueExecution;\x0avar unstable_pauseExecution = _ReactInternals$Sched.unstable_pauseExecution;\x0avar unstable_getCurrentPriorityLevel = _ReactInternals$Sched.unstable_getCurrentPriorityLevel;\x0avar unstable_ImmediatePriority = _ReactInternals$Sched.unstable_ImmediatePriority;\x0avar unstable_UserBlockingPriority = _ReactInternals$Sched.unstable_UserBlockingPriority;\x0avar unstable_NormalPriority = _ReactInternals$Sched.unstable_NormalPriority;\x0avar unstable_LowPriority = _ReactInternals$Sched.unstable_LowPriority;\x0avar unstable_IdlePriority = _ReactInternals$Sched.unstable_IdlePriority;\x0a\x0a// Renderers that don\x27t support persistence\x0a// can re-export everything from this module.\x0a\x0afunction shim() {\x0a  invariant(false, \x27The current renderer does not support persistence. This error is likely caused by a bug in React. Please file an issue.\x27);\x0a}\x0a\x0a// Persistence (when unsupported)\x0avar supportsPersistence = false;\x0avar cloneInstance = shim;\x0avar createContainerChildSet = shim;\x0avar appendChildToContainerChildSet = shim;\x0avar finalizeContainerChildren = shim;\x0avar replaceContainerChildren = shim;\x0avar cloneHiddenInstance = shim;\x0avar cloneUnhiddenInstance = shim;\x0avar createHiddenTextInstance = shim;\x0a\x0avar SUPPRESS_HYDRATION_WARNING = void 0;\x0a{\x0a  SUPPRESS_HYDRATION_WARNING = \x27suppressHydrationWarning\x27;\x0a}\x0a\x0avar SUSPENSE_START_DATA = \x27$\x27;\x0avar SUSPENSE_END_DATA = \x27/$\x27;\x0a\x0avar STYLE = \x27style\x27;\x0a\x0avar eventsEnabled = null;\x0avar selectionInformation = null;\x0a\x0afunction shouldAutoFocusHostComponent(type, props) {\x0a  switch (type) {\x0a    case \x27button\x27:\x0a    case \x27input\x27:\x0a    case \x27select\x27:\x0a    case \x27textarea\x27:\x0a      return !!props.autoFocus;\x0a  }\x0a  return false;\x0a}\x0a\x0afunction getRootHostContext(rootContainerInstance) {\x0a  var type = void 0;\x0a  var namespace = void 0;\x0a  var nodeType = rootContainerInstance.nodeType;\x0a  switch (nodeType) {\x0a    case DOCUMENT_NODE:\x0a    case DOCUMENT_FRAGMENT_NODE:\x0a      {\x0a        type = nodeType === DOCUMENT_NODE ? \x27#document\x27 : \x27#fragment\x27;\x0a        var root = rootContainerInstance.documentElement;\x0a        namespace = root ? root.namespaceURI : getChildNamespace(null, \x27\x27);\x0a        break;\x0a      }\x0a    default:\x0a      {\x0a        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\x0a        var ownNamespace = container.namespaceURI || null;\x0a        type = container.tagName;\x0a        namespace = getChildNamespace(ownNamespace, type);\x0a        break;\x0a      }\x0a  }\x0a  {\x0a    var validatedTag = type.toLowerCase();\x0a    var _ancestorInfo = updatedAncestorInfo(null, validatedTag);\x0a    return { namespace: namespace, ancestorInfo: _ancestorInfo };\x0a  }\x0a  return namespace;\x0a}\x0a\x0afunction getChildHostContext(parentHostContext, type, rootContainerInstance) {\x0a  {\x0a    var parentHostContextDev = parentHostContext;\x0a    var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\x0a    var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);\x0a    return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };\x0a  }\x0a  var parentNamespace = parentHostContext;\x0a  return getChildNamespace(parentNamespace, type);\x0a}\x0a\x0afunction getPublicInstance(instance) {\x0a  return instance;\x0a}\x0a\x0afunction prepareForCommit(containerInfo) {\x0a  eventsEnabled = isEnabled();\x0a  selectionInformation = getSelectionInformation();\x0a  setEnabled(false);\x0a}\x0a\x0afunction resetAfterCommit(containerInfo) {\x0a  restoreSelection(selectionInformation);\x0a  selectionInformation = null;\x0a  setEnabled(eventsEnabled);\x0a  eventsEnabled = null;\x0a}\x0a\x0afunction createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\x0a  var parentNamespace = void 0;\x0a  {\x0a    // TODO: take namespace into account when validating.\x0a    var hostContextDev = hostContext;\x0a    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\x0a    if (typeof props.children === \x27string\x27 || typeof props.children === \x27number\x27) {\x0a      var string = \x27\x27 + props.children;\x0a      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\x0a      validateDOMNesting(null, string, ownAncestorInfo);\x0a    }\x0a    parentNamespace = hostContextDev.namespace;\x0a  }\x0a  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\x0a  precacheFiberNode(internalInstanceHandle, domElement);\x0a  updateFiberProps(domElement, props);\x0a  return domElement;\x0a}\x0a\x0afunction appendInitialChild(parentInstance, child) {\x0a  parentInstance.appendChild(child);\x0a}\x0a\x0afunction finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\x0a  setInitialProperties(domElement, type, props, rootContainerInstance);\x0a  return shouldAutoFocusHostComponent(type, props);\x0a}\x0a\x0afunction prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\x0a  {\x0a    var hostContextDev = hostContext;\x0a    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === \x27string\x27 || typeof newProps.children === \x27number\x27)) {\x0a      var string = \x27\x27 + newProps.children;\x0a      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\x0a      validateDOMNesting(null, string, ownAncestorInfo);\x0a    }\x0a  }\x0a  return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\x0a}\x0a\x0afunction shouldSetTextContent(type, props) {\x0a  return type === \x27textarea\x27 || type === \x27option\x27 || type === \x27noscript\x27 || typeof props.children === \x27string\x27 || typeof props.children === \x27number\x27 || typeof props.dangerouslySetInnerHTML === \x27object\x27 && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\x0a}\x0a\x0afunction shouldDeprioritizeSubtree(type, props) {\x0a  return !!props.hidden;\x0a}\x0a\x0afunction createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\x0a  {\x0a    var hostContextDev = hostContext;\x0a    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\x0a  }\x0a  var textNode = createTextNode(text, rootContainerInstance);\x0a  precacheFiberNode(internalInstanceHandle, textNode);\x0a  return textNode;\x0a}\x0a\x0avar isPrimaryRenderer = true;\x0a// This initialization code may run even on server environments\x0a// if a component just imports ReactDOM (e.g. for findDOMNode).\x0a// Some environments might not have setTimeout or clearTimeout.\x0avar scheduleTimeout = typeof setTimeout === \x27function\x27 ? setTimeout : undefined;\x0avar cancelTimeout = typeof clearTimeout === \x27function\x27 ? clearTimeout : undefined;\x0avar noTimeout = -1;\x0avar schedulePassiveEffects = unstable_scheduleCallback;\x0avar cancelPassiveEffects = unstable_cancelCallback;\x0a\x0a// -------------------\x0a//     Mutation\x0a// -------------------\x0a\x0avar supportsMutation = true;\x0a\x0afunction commitMount(domElement, type, newProps, internalInstanceHandle) {\x0a  // Despite the naming that might imply otherwise, this method only\x0a  // fires if there is an `Update` effect scheduled during mounting.\x0a  // This happens if `finalizeInitialChildren` returns `true` (which it\x0a  // does to implement the `autoFocus` attribute on the client). But\x0a  // there are also other cases when this might happen (such as patching\x0a  // up text content during hydration mismatch). So we\x27ll check this again.\x0a  if (shouldAutoFocusHostComponent(type, newProps)) {\x0a    domElement.focus();\x0a  }\x0a}\x0a\x0afunction commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\x0a  // Update the props handle so that we know which props are the ones with\x0a  // with current event handlers.\x0a  updateFiberProps(domElement, newProps);\x0a  // Apply the diff to the DOM node.\x0a  updateProperties(domElement, updatePayload, type, oldProps, newProps);\x0a}\x0a\x0afunction resetTextContent(domElement) {\x0a  setTextContent(domElement, \x27\x27);\x0a}\x0a\x0afunction commitTextUpdate(textInstance, oldText, newText) {\x0a  textInstance.nodeValue = newText;\x0a}\x0a\x0afunction appendChild(parentInstance, child) {\x0a  parentInstance.appendChild(child);\x0a}\x0a\x0afunction appendChildToContainer(container, child) {\x0a  var parentNode = void 0;\x0a  if (container.nodeType === COMMENT_NODE) {\x0a    parentNode = container.parentNode;\x0a    parentNode.insertBefore(child, container);\x0a  } else {\x0a    parentNode = container;\x0a    parentNode.appendChild(child);\x0a  }\x0a  // This container might be used for a portal.\x0a  // If something inside a portal is clicked, that click should bubble\x0a  // through the React tree. However, on Mobile Safari the click would\x0a  // never bubble through the *DOM* tree unless an ancestor with onclick\x0a  // event exists. So we wouldn\x27t see it and dispatch it.\x0a  // This is why we ensure that non React root containers have inline onclick\x0a  // defined.\x0a  // https://github.com/facebook/react/issues/11918\x0a  var reactRootContainer = container._reactRootContainer;\x0a  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {\x0a    // TODO: This cast may not be sound for SVG, MathML or custom elements.\x0a    trapClickOnNonInteractiveElement(parentNode);\x0a  }\x0a}\x0a\x0afunction insertBefore(parentInstance, child, beforeChild) {\x0a  parentInstance.insertBefore(child, beforeChild);\x0a}\x0a\x0afunction insertInContainerBefore(container, child, beforeChild) {\x0a  if (container.nodeType === COMMENT_NODE) {\x0a    container.parentNode.insertBefore(child, beforeChild);\x0a  } else {\x0a    container.insertBefore(child, beforeChild);\x0a  }\x0a}\x0a\x0afunction removeChild(parentInstance, child) {\x0a  parentInstance.removeChild(child);\x0a}\x0a\x0afunction removeChildFromContainer(container, child) {\x0a  if (container.nodeType === COMMENT_NODE) {\x0a    container.parentNode.removeChild(child);\x0a  } else {\x0a    container.removeChild(child);\x0a  }\x0a}\x0a\x0afunction clearSuspenseBoundary(parentInstance, suspenseInstance) {\x0a  var node = suspenseInstance;\x0a  // Delete all nodes within this suspense boundary.\x0a  // There might be nested nodes so we need to keep track of how\x0a  // deep we are and only break out when we\x27re back on top.\x0a  var depth = 0;\x0a  do {\x0a    var nextNode = node.nextSibling;\x0a    parentInstance.removeChild(node);\x0a    if (nextNode && nextNode.nodeType === COMMENT_NODE) {\x0a      var data = nextNode.data;\x0a      if (data === SUSPENSE_END_DATA) {\x0a        if (depth === 0) {\x0a          parentInstance.removeChild(nextNode);\x0a          return;\x0a        } else {\x0a          depth--;\x0a        }\x0a      } else if (data === SUSPENSE_START_DATA) {\x0a        depth++;\x0a      }\x0a    }\x0a    node = nextNode;\x0a  } while (node);\x0a  // TODO: Warn, we didn\x27t find the end comment boundary.\x0a}\x0a\x0afunction clearSuspenseBoundaryFromContainer(container, suspenseInstance) {\x0a  if (container.nodeType === COMMENT_NODE) {\x0a    clearSuspenseBoundary(container.parentNode, suspenseInstance);\x0a  } else if (container.nodeType === ELEMENT_NODE) {\x0a    clearSuspenseBoundary(container, suspenseInstance);\x0a  } else {\x0a    // Document nodes should never contain suspense boundaries.\x0a  }\x0a}\x0a\x0afunction hideInstance(instance) {\x0a  // TODO: Does this work for all element types? What about MathML? Should we\x0a  // pass host context to this method?\x0a  instance = instance;\x0a  instance.style.display = \x27none\x27;\x0a}\x0a\x0afunction hideTextInstance(textInstance) {\x0a  textInstance.nodeValue = \x27\x27;\x0a}\x0a\x0afunction unhideInstance(instance, props) {\x0a  instance = instance;\x0a  var styleProp = props[STYLE];\x0a  var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty(\x27display\x27) ? styleProp.display : null;\x0a  instance.style.display = dangerousStyleValue(\x27display\x27, display);\x0a}\x0a\x0afunction unhideTextInstance(textInstance, text) {\x0a  textInstance.nodeValue = text;\x0a}\x0a\x0a// -------------------\x0a//     Hydration\x0a// -------------------\x0a\x0avar supportsHydration = true;\x0a\x0afunction canHydrateInstance(instance, type, props) {\x0a  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\x0a    return null;\x0a  }\x0a  // This has now been refined to an element node.\x0a  return instance;\x0a}\x0a\x0afunction canHydrateTextInstance(instance, text) {\x0a  if (text === \x27\x27 || instance.nodeType !== TEXT_NODE) {\x0a    // Empty strings are not parsed by HTML so there won\x27t be a correct match here.\x0a    return null;\x0a  }\x0a  // This has now been refined to a text node.\x0a  return instance;\x0a}\x0a\x0afunction canHydrateSuspenseInstance(instance) {\x0a  if (instance.nodeType !== COMMENT_NODE) {\x0a    // Empty strings are not parsed by HTML so there won\x27t be a correct match here.\x0a    return null;\x0a  }\x0a  // This has now been refined to a suspense node.\x0a  return instance;\x0a}\x0a\x0afunction getNextHydratableSibling(instance) {\x0a  var node = instance.nextSibling;\x0a  // Skip non-hydratable nodes.\x0a  while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE && (!enableSuspenseServerRenderer || node.nodeType !== COMMENT_NODE || node.data !== SUSPENSE_START_DATA)) {\x0a    node = node.nextSibling;\x0a  }\x0a  return node;\x0a}\x0a\x0afunction getFirstHydratableChild(parentInstance) {\x0a  var next = parentInstance.firstChild;\x0a  // Skip non-hydratable nodes.\x0a  while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE && (!enableSuspenseServerRenderer || next.nodeType !== COMMENT_NODE || next.data !== SUSPENSE_START_DATA)) {\x0a    next = next.nextSibling;\x0a  }\x0a  return next;\x0a}\x0a\x0afunction hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\x0a  precacheFiberNode(internalInstanceHandle, instance);\x0a  // TODO: Possibly defer this until the commit phase where all the events\x0a  // get attached.\x0a  updateFiberProps(instance, props);\x0a  var parentNamespace = void 0;\x0a  {\x0a    var hostContextDev = hostContext;\x0a    parentNamespace = hostContextDev.namespace;\x0a  }\x0a  return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\x0a}\x0a\x0afunction hydrateTextInstance(textInstance, text, internalInstanceHandle) {\x0a  precacheFiberNode(internalInstanceHandle, textInstance);\x0a  return diffHydratedText(textInstance, text);\x0a}\x0a\x0afunction getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {\x0a  var node = suspenseInstance.nextSibling;\x0a  // Skip past all nodes within this suspense boundary.\x0a  // There might be nested nodes so we need to keep track of how\x0a  // deep we are and only break out when we\x27re back on top.\x0a  var depth = 0;\x0a  while (node) {\x0a    if (node.nodeType === COMMENT_NODE) {\x0a      var data = node.data;\x0a      if (data === SUSPENSE_END_DATA) {\x0a        if (depth === 0) {\x0a          return getNextHydratableSibling(node);\x0a        } else {\x0a          depth--;\x0a        }\x0a      } else if (data === SUSPENSE_START_DATA) {\x0a        depth++;\x0a      }\x0a    }\x0a    node = node.nextSibling;\x0a  }\x0a  // TODO: Warn, we didn\x27t find the end comment boundary.\x0a  return null;\x0a}\x0a\x0afunction didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {\x0a  {\x0a    warnForUnmatchedText(textInstance, text);\x0a  }\x0a}\x0a\x0afunction didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {\x0a  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\x0a    warnForUnmatchedText(textInstance, text);\x0a  }\x0a}\x0a\x0afunction didNotHydrateContainerInstance(parentContainer, instance) {\x0a  {\x0a    if (instance.nodeType === ELEMENT_NODE) {\x0a      warnForDeletedHydratableElement(parentContainer, instance);\x0a    } else if (instance.nodeType === COMMENT_NODE) {\x0a      // TODO: warnForDeletedHydratableSuspenseBoundary\x0a    } else {\x0a      warnForDeletedHydratableText(parentContainer, instance);\x0a    }\x0a  }\x0a}\x0a\x0afunction didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {\x0a  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\x0a    if (instance.nodeType === ELEMENT_NODE) {\x0a      warnForDeletedHydratableElement(parentInstance, instance);\x0a    } else if (instance.nodeType === COMMENT_NODE) {\x0a      // TODO: warnForDeletedHydratableSuspenseBoundary\x0a    } else {\x0a      warnForDeletedHydratableText(parentInstance, instance);\x0a    }\x0a  }\x0a}\x0a\x0afunction didNotFindHydratableContainerInstance(parentContainer, type, props) {\x0a  {\x0a    warnForInsertedHydratedElement(parentContainer, type, props);\x0a  }\x0a}\x0a\x0afunction didNotFindHydratableContainerTextInstance(parentContainer, text) {\x0a  {\x0a    warnForInsertedHydratedText(parentContainer, text);\x0a  }\x0a}\x0a\x0a\x0a\x0afunction didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {\x0a  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\x0a    warnForInsertedHydratedElement(parentInstance, type, props);\x0a  }\x0a}\x0a\x0afunction didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {\x0a  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\x0a    warnForInsertedHydratedText(parentInstance, text);\x0a  }\x0a}\x0a\x0afunction didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {\x0a  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\x0a    // TODO: warnForInsertedHydratedSuspense(parentInstance);\x0a  }\x0a}\x0a\x0a// Prefix measurements so that it\x27s possible to filter them.\x0a// Longer prefixes are hard to read in DevTools.\x0avar reactEmoji = \x27\x5cu269B\x27;\x0avar warningEmoji = \x27\x5cu26D4\x27;\x0avar supportsUserTiming = typeof performance !== \x27undefined\x27 && typeof performance.mark === \x27function\x27 && typeof performance.clearMarks === \x27function\x27 && typeof performance.measure === \x27function\x27 && typeof performance.clearMeasures === \x27function\x27;\x0a\x0a// Keep track of current fiber so that we know the path to unwind on pause.\x0a// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\x0avar currentFiber = null;\x0a// If we\x27re in the middle of user code, which fiber and method is it?\x0a// Reusing `currentFiber` would be confusing for this because user code fiber\x0a// can change during commit phase too, but we don\x27t need to unwind it (since\x0a// lifecycles in the commit phase don\x27t resemble a tree).\x0avar currentPhase = null;\x0avar currentPhaseFiber = null;\x0a// Did lifecycle hook schedule an update? This is often a performance problem,\x0a// so we will keep track of it, and include it in the report.\x0a// Track commits caused by cascading updates.\x0avar isCommitting = false;\x0avar hasScheduledUpdateInCurrentCommit = false;\x0avar hasScheduledUpdateInCurrentPhase = false;\x0avar commitCountInCurrentWorkLoop = 0;\x0avar effectCountInCurrentCommit = 0;\x0avar isWaitingForCallback = false;\x0a// During commits, we only show a measurement once per method name\x0a// to avoid stretch the commit phase with measurement overhead.\x0avar labelsInCurrentCommit = new Set();\x0a\x0avar formatMarkName = function (markName) {\x0a  return reactEmoji + \x27 \x27 + markName;\x0a};\x0a\x0avar formatLabel = function (label, warning) {\x0a  var prefix = warning ? warningEmoji + \x27 \x27 : reactEmoji + \x27 \x27;\x0a  var suffix = warning ? \x27 Warning: \x27 + warning : \x27\x27;\x0a  return \x27\x27 + prefix + label + suffix;\x0a};\x0a\x0avar beginMark = function (markName) {\x0a  performance.mark(formatMarkName(markName));\x0a};\x0a\x0avar clearMark = function (markName) {\x0a  performance.clearMarks(formatMarkName(markName));\x0a};\x0a\x0avar endMark = function (label, markName, warning) {\x0a  var formattedMarkName = formatMarkName(markName);\x0a  var formattedLabel = formatLabel(label, warning);\x0a  try {\x0a    performance.measure(formattedLabel, formattedMarkName);\x0a  } catch (err) {}\x0a  // If previous mark was missing for some reason, this will throw.\x0a  // This could only happen if React crashed in an unexpected place earlier.\x0a  // Don\x27t pile on with more errors.\x0a\x0a  // Clear marks immediately to avoid growing buffer.\x0a  performance.clearMarks(formattedMarkName);\x0a  performance.clearMeasures(formattedLabel);\x0a};\x0a\x0avar getFiberMarkName = function (label, debugID) {\x0a  return label + \x27 (#\x27 + debugID + \x27)\x27;\x0a};\x0a\x0avar getFiberLabel = function (componentName, isMounted, phase) {\x0a  if (phase === null) {\x0a    // These are composite component total time measurements.\x0a    return componentName + \x27 [\x27 + (isMounted ? \x27update\x27 : \x27mount\x27) + \x27]\x27;\x0a  } else {\x0a    // Composite component methods.\x0a    return componentName + \x27.\x27 + phase;\x0a  }\x0a};\x0a\x0avar beginFiberMark = function (fiber, phase) {\x0a  var componentName = getComponentName(fiber.type) || \x27Unknown\x27;\x0a  var debugID = fiber._debugID;\x0a  var isMounted = fiber.alternate !== null;\x0a  var label = getFiberLabel(componentName, isMounted, phase);\x0a\x0a  if (isCommitting && labelsInCurrentCommit.has(label)) {\x0a    // During the commit phase, we don\x27t show duplicate labels because\x0a    // there is a fixed overhead for every measurement, and we don\x27t\x0a    // want to stretch the commit phase beyond necessary.\x0a    return false;\x0a  }\x0a  labelsInCurrentCommit.add(label);\x0a\x0a  var markName = getFiberMarkName(label, debugID);\x0a  beginMark(markName);\x0a  return true;\x0a};\x0a\x0avar clearFiberMark = function (fiber, phase) {\x0a  var componentName = getComponentName(fiber.type) || \x27Unknown\x27;\x0a  var debugID = fiber._debugID;\x0a  var isMounted = fiber.alternate !== null;\x0a  var label = getFiberLabel(componentName, isMounted, phase);\x0a  var markName = getFiberMarkName(label, debugID);\x0a  clearMark(markName);\x0a};\x0a\x0avar endFiberMark = function (fiber, phase, warning) {\x0a  var componentName = getComponentName(fiber.type) || \x27Unknown\x27;\x0a  var debugID = fiber._debugID;\x0a  var isMounted = fiber.alternate !== null;\x0a  var label = getFiberLabel(componentName, isMounted, phase);\x0a  var markName = getFiberMarkName(label, debugID);\x0a  endMark(label, markName, warning);\x0a};\x0a\x0avar shouldIgnoreFiber = function (fiber) {\x0a  // Host components should be skipped in the timeline.\x0a  // We could check typeof fiber.type, but does this work with RN?\x0a  switch (fiber.tag) {\x0a    case HostRoot:\x0a    case HostComponent:\x0a    case HostText:\x0a    case HostPortal:\x0a    case Fragment:\x0a    case ContextProvider:\x0a    case ContextConsumer:\x0a    case Mode:\x0a      return true;\x0a    default:\x0a      return false;\x0a  }\x0a};\x0a\x0avar clearPendingPhaseMeasurement = function () {\x0a  if (currentPhase !== null && currentPhaseFiber !== null) {\x0a    clearFiberMark(currentPhaseFiber, currentPhase);\x0a  }\x0a  currentPhaseFiber = null;\x0a  currentPhase = null;\x0a  hasScheduledUpdateInCurrentPhase = false;\x0a};\x0a\x0avar pauseTimers = function () {\x0a  // Stops all currently active measurements so that they can be resumed\x0a  // if we continue in a later deferred loop from the same unit of work.\x0a  var fiber = currentFiber;\x0a  while (fiber) {\x0a    if (fiber._debugIsCurrentlyTiming) {\x0a      endFiberMark(fiber, null, null);\x0a    }\x0a    fiber = fiber.return;\x0a  }\x0a};\x0a\x0avar resumeTimersRecursively = function (fiber) {\x0a  if (fiber.return !== null) {\x0a    resumeTimersRecursively(fiber.return);\x0a  }\x0a  if (fiber._debugIsCurrentlyTiming) {\x0a    beginFiberMark(fiber, null);\x0a  }\x0a};\x0a\x0avar resumeTimers = function () {\x0a  // Resumes all measurements that were active during the last deferred loop.\x0a  if (currentFiber !== null) {\x0a    resumeTimersRecursively(currentFiber);\x0a  }\x0a};\x0a\x0afunction recordEffect() {\x0a  if (enableUserTimingAPI) {\x0a    effectCountInCurrentCommit++;\x0a  }\x0a}\x0a\x0afunction recordScheduleUpdate() {\x0a  if (enableUserTimingAPI) {\x0a    if (isCommitting) {\x0a      hasScheduledUpdateInCurrentCommit = true;\x0a    }\x0a    if (currentPhase !== null && currentPhase !== \x27componentWillMount\x27 && currentPhase !== \x27componentWillReceiveProps\x27) {\x0a      hasScheduledUpdateInCurrentPhase = true;\x0a    }\x0a  }\x0a}\x0a\x0afunction startRequestCallbackTimer() {\x0a  if (enableUserTimingAPI) {\x0a    if (supportsUserTiming && !isWaitingForCallback) {\x0a      isWaitingForCallback = true;\x0a      beginMark(\x27(Waiting for async callback...)\x27);\x0a    }\x0a  }\x0a}\x0a\x0afunction stopRequestCallbackTimer(didExpire, expirationTime) {\x0a  if (enableUserTimingAPI) {\x0a    if (supportsUserTiming) {\x0a      isWaitingForCallback = false;\x0a      var warning = didExpire ? \x27React was blocked by main thread\x27 : null;\x0a      endMark(\x27(Waiting for async callback... will force flush in \x27 + expirationTime + \x27 ms)\x27, \x27(Waiting for async callback...)\x27, warning);\x0a    }\x0a  }\x0a}\x0a\x0afunction startWorkTimer(fiber) {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\x0a      return;\x0a    }\x0a    // If we pause, this is the fiber to unwind from.\x0a    currentFiber = fiber;\x0a    if (!beginFiberMark(fiber, null)) {\x0a      return;\x0a    }\x0a    fiber._debugIsCurrentlyTiming = true;\x0a  }\x0a}\x0a\x0afunction cancelWorkTimer(fiber) {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\x0a      return;\x0a    }\x0a    // Remember we shouldn\x27t complete measurement for this fiber.\x0a    // Otherwise flamechart will be deep even for small updates.\x0a    fiber._debugIsCurrentlyTiming = false;\x0a    clearFiberMark(fiber, null);\x0a  }\x0a}\x0a\x0afunction stopWorkTimer(fiber) {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\x0a      return;\x0a    }\x0a    // If we pause, its parent is the fiber to unwind from.\x0a    currentFiber = fiber.return;\x0a    if (!fiber._debugIsCurrentlyTiming) {\x0a      return;\x0a    }\x0a    fiber._debugIsCurrentlyTiming = false;\x0a    endFiberMark(fiber, null, null);\x0a  }\x0a}\x0a\x0afunction stopFailedWorkTimer(fiber) {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\x0a      return;\x0a    }\x0a    // If we pause, its parent is the fiber to unwind from.\x0a    currentFiber = fiber.return;\x0a    if (!fiber._debugIsCurrentlyTiming) {\x0a      return;\x0a    }\x0a    fiber._debugIsCurrentlyTiming = false;\x0a    var warning = fiber.tag === SuspenseComponent || fiber.tag === DehydratedSuspenseComponent ? \x27Rendering was suspended\x27 : \x27An error was thrown inside this error boundary\x27;\x0a    endFiberMark(fiber, null, warning);\x0a  }\x0a}\x0a\x0afunction startPhaseTimer(fiber, phase) {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a    clearPendingPhaseMeasurement();\x0a    if (!beginFiberMark(fiber, phase)) {\x0a      return;\x0a    }\x0a    currentPhaseFiber = fiber;\x0a    currentPhase = phase;\x0a  }\x0a}\x0a\x0afunction stopPhaseTimer() {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a    if (currentPhase !== null && currentPhaseFiber !== null) {\x0a      var warning = hasScheduledUpdateInCurrentPhase ? \x27Scheduled a cascading update\x27 : null;\x0a      endFiberMark(currentPhaseFiber, currentPhase, warning);\x0a    }\x0a    currentPhase = null;\x0a    currentPhaseFiber = null;\x0a  }\x0a}\x0a\x0afunction startWorkLoopTimer(nextUnitOfWork) {\x0a  if (enableUserTimingAPI) {\x0a    currentFiber = nextUnitOfWork;\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a    commitCountInCurrentWorkLoop = 0;\x0a    // This is top level call.\x0a    // Any other measurements are performed within.\x0a    beginMark(\x27(React Tree Reconciliation)\x27);\x0a    // Resume any measurements that were in progress during the last loop.\x0a    resumeTimers();\x0a  }\x0a}\x0a\x0afunction stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a    var warning = null;\x0a    if (interruptedBy !== null) {\x0a      if (interruptedBy.tag === HostRoot) {\x0a        warning = \x27A top-level update interrupted the previous render\x27;\x0a      } else {\x0a        var componentName = getComponentName(interruptedBy.type) || \x27Unknown\x27;\x0a        warning = \x27An update to \x27 + componentName + \x27 interrupted the previous render\x27;\x0a      }\x0a    } else if (commitCountInCurrentWorkLoop \x3e 1) {\x0a      warning = \x27There were cascading updates\x27;\x0a    }\x0a    commitCountInCurrentWorkLoop = 0;\x0a    var label = didCompleteRoot ? \x27(React Tree Reconciliation: Completed Root)\x27 : \x27(React Tree Reconciliation: Yielded)\x27;\x0a    // Pause any measurements until the next loop.\x0a    pauseTimers();\x0a    endMark(label, \x27(React Tree Reconciliation)\x27, warning);\x0a  }\x0a}\x0a\x0afunction startCommitTimer() {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a    isCommitting = true;\x0a    hasScheduledUpdateInCurrentCommit = false;\x0a    labelsInCurrentCommit.clear();\x0a    beginMark(\x27(Committing Changes)\x27);\x0a  }\x0a}\x0a\x0afunction stopCommitTimer() {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a\x0a    var warning = null;\x0a    if (hasScheduledUpdateInCurrentCommit) {\x0a      warning = \x27Lifecycle hook scheduled a cascading update\x27;\x0a    } else if (commitCountInCurrentWorkLoop \x3e 0) {\x0a      warning = \x27Caused by a cascading update in earlier commit\x27;\x0a    }\x0a    hasScheduledUpdateInCurrentCommit = false;\x0a    commitCountInCurrentWorkLoop++;\x0a    isCommitting = false;\x0a    labelsInCurrentCommit.clear();\x0a\x0a    endMark(\x27(Committing Changes)\x27, \x27(Committing Changes)\x27, warning);\x0a  }\x0a}\x0a\x0afunction startCommitSnapshotEffectsTimer() {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a    effectCountInCurrentCommit = 0;\x0a    beginMark(\x27(Committing Snapshot Effects)\x27);\x0a  }\x0a}\x0a\x0afunction stopCommitSnapshotEffectsTimer() {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a    var count = effectCountInCurrentCommit;\x0a    effectCountInCurrentCommit = 0;\x0a    endMark(\x27(Committing Snapshot Effects: \x27 + count + \x27 Total)\x27, \x27(Committing Snapshot Effects)\x27, null);\x0a  }\x0a}\x0a\x0afunction startCommitHostEffectsTimer() {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a    effectCountInCurrentCommit = 0;\x0a    beginMark(\x27(Committing Host Effects)\x27);\x0a  }\x0a}\x0a\x0afunction stopCommitHostEffectsTimer() {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a    var count = effectCountInCurrentCommit;\x0a    effectCountInCurrentCommit = 0;\x0a    endMark(\x27(Committing Host Effects: \x27 + count + \x27 Total)\x27, \x27(Committing Host Effects)\x27, null);\x0a  }\x0a}\x0a\x0afunction startCommitLifeCyclesTimer() {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a    effectCountInCurrentCommit = 0;\x0a    beginMark(\x27(Calling Lifecycle Methods)\x27);\x0a  }\x0a}\x0a\x0afunction stopCommitLifeCyclesTimer() {\x0a  if (enableUserTimingAPI) {\x0a    if (!supportsUserTiming) {\x0a      return;\x0a    }\x0a    var count = effectCountInCurrentCommit;\x0a    effectCountInCurrentCommit = 0;\x0a    endMark(\x27(Calling Lifecycle Methods: \x27 + count + \x27 Total)\x27, \x27(Calling Lifecycle Methods)\x27, null);\x0a  }\x0a}\x0a\x0avar valueStack = [];\x0a\x0avar fiberStack = void 0;\x0a\x0a{\x0a  fiberStack = [];\x0a}\x0a\x0avar index = -1;\x0a\x0afunction createCursor(defaultValue) {\x0a  return {\x0a    current: defaultValue\x0a  };\x0a}\x0a\x0afunction pop(cursor, fiber) {\x0a  if (index \x3c 0) {\x0a    {\x0a      warningWithoutStack$1(false, \x27Unexpected pop.\x27);\x0a    }\x0a    return;\x0a  }\x0a\x0a  {\x0a    if (fiber !== fiberStack[index]) {\x0a      warningWithoutStack$1(false, \x27Unexpected Fiber popped.\x27);\x0a    }\x0a  }\x0a\x0a  cursor.current = valueStack[index];\x0a\x0a  valueStack[index] = null;\x0a\x0a  {\x0a    fiberStack[index] = null;\x0a  }\x0a\x0a  index--;\x0a}\x0a\x0afunction push(cursor, value, fiber) {\x0a  index++;\x0a\x0a  valueStack[index] = cursor.current;\x0a\x0a  {\x0a    fiberStack[index] = fiber;\x0a  }\x0a\x0a  cursor.current = value;\x0a}\x0a\x0afunction checkThatStackIsEmpty() {\x0a  {\x0a    if (index !== -1) {\x0a      warningWithoutStack$1(false, \x27Expected an empty stack. Something was not reset properly.\x27);\x0a    }\x0a  }\x0a}\x0a\x0afunction resetStackAfterFatalErrorInDev() {\x0a  {\x0a    index = -1;\x0a    valueStack.length = 0;\x0a    fiberStack.length = 0;\x0a  }\x0a}\x0a\x0avar warnedAboutMissingGetChildContext = void 0;\x0a\x0a{\x0a  warnedAboutMissingGetChildContext = {};\x0a}\x0a\x0avar emptyContextObject = {};\x0a{\x0a  Object.freeze(emptyContextObject);\x0a}\x0a\x0a// A cursor to the current merged context object on the stack.\x0avar contextStackCursor = createCursor(emptyContextObject);\x0a// A cursor to a boolean indicating whether the context has changed.\x0avar didPerformWorkStackCursor = createCursor(false);\x0a// Keep track of the previous context object that was on the stack.\x0a// We use this to get access to the parent context after we have already\x0a// pushed the next context provider, and now need to merge their contexts.\x0avar previousContext = emptyContextObject;\x0a\x0afunction getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\x0a  if (didPushOwnContextIfProvider && isContextProvider(Component)) {\x0a    // If the fiber is a context provider itself, when we read its context\x0a    // we may have already pushed its own child context on the stack. A context\x0a    // provider should not \x22see\x22 its own child context. Therefore we read the\x0a    // previous (parent) context instead for a context provider.\x0a    return previousContext;\x0a  }\x0a  return contextStackCursor.current;\x0a}\x0a\x0afunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\x0a  var instance = workInProgress.stateNode;\x0a  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\x0a  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\x0a}\x0a\x0afunction getMaskedContext(workInProgress, unmaskedContext) {\x0a  var type = workInProgress.type;\x0a  var contextTypes = type.contextTypes;\x0a  if (!contextTypes) {\x0a    return emptyContextObject;\x0a  }\x0a\x0a  // Avoid recreating masked context unless unmasked context has changed.\x0a  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\x0a  // This may trigger infinite loops if componentWillReceiveProps calls setState.\x0a  var instance = workInProgress.stateNode;\x0a  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\x0a    return instance.__reactInternalMemoizedMaskedChildContext;\x0a  }\x0a\x0a  var context = {};\x0a  for (var key in contextTypes) {\x0a    context[key] = unmaskedContext[key];\x0a  }\x0a\x0a  {\x0a    var name = getComponentName(type) || \x27Unknown\x27;\x0a    checkPropTypes_1(contextTypes, context, \x27context\x27, name, getCurrentFiberStackInDev);\x0a  }\x0a\x0a  // Cache unmasked context so we can avoid recreating masked context unless necessary.\x0a  // Context is created before the class component is instantiated so check for instance.\x0a  if (instance) {\x0a    cacheContext(workInProgress, unmaskedContext, context);\x0a  }\x0a\x0a  return context;\x0a}\x0a\x0afunction hasContextChanged() {\x0a  return didPerformWorkStackCursor.current;\x0a}\x0a\x0afunction isContextProvider(type) {\x0a  var childContextTypes = type.childContextTypes;\x0a  return childContextTypes !== null && childContextTypes !== undefined;\x0a}\x0a\x0afunction popContext(fiber) {\x0a  pop(didPerformWorkStackCursor, fiber);\x0a  pop(contextStackCursor, fiber);\x0a}\x0a\x0afunction popTopLevelContextObject(fiber) {\x0a  pop(didPerformWorkStackCursor, fiber);\x0a  pop(contextStackCursor, fiber);\x0a}\x0a\x0afunction pushTopLevelContextObject(fiber, context, didChange) {\x0a  !(contextStackCursor.current === emptyContextObject) ? invariant(false, \x27Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.\x27) : void 0;\x0a\x0a  push(contextStackCursor, context, fiber);\x0a  push(didPerformWorkStackCursor, didChange, fiber);\x0a}\x0a\x0afunction processChildContext(fiber, type, parentContext) {\x0a  var instance = fiber.stateNode;\x0a  var childContextTypes = type.childContextTypes;\x0a\x0a  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\x0a  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\x0a  if (typeof instance.getChildContext !== \x27function\x27) {\x0a    {\x0a      var componentName = getComponentName(type) || \x27Unknown\x27;\x0a\x0a      if (!warnedAboutMissingGetChildContext[componentName]) {\x0a        warnedAboutMissingGetChildContext[componentName] = true;\x0a        warningWithoutStack$1(false, \x27%s.childContextTypes is specified but there is no getChildContext() method \x27 + \x27on the instance. You can either define getChildContext() on %s or remove \x27 + \x27childContextTypes from it.\x27, componentName, componentName);\x0a      }\x0a    }\x0a    return parentContext;\x0a  }\x0a\x0a  var childContext = void 0;\x0a  {\x0a    setCurrentPhase(\x27getChildContext\x27);\x0a  }\x0a  startPhaseTimer(fiber, \x27getChildContext\x27);\x0a  childContext = instance.getChildContext();\x0a  stopPhaseTimer();\x0a  {\x0a    setCurrentPhase(null);\x0a  }\x0a  for (var contextKey in childContext) {\x0a    !(contextKey in childContextTypes) ? invariant(false, \x27%s.getChildContext(): key \x22%s\x22 is not defined in childContextTypes.\x27, getComponentName(type) || \x27Unknown\x27, contextKey) : void 0;\x0a  }\x0a  {\x0a    var name = getComponentName(type) || \x27Unknown\x27;\x0a    checkPropTypes_1(childContextTypes, childContext, \x27child context\x27, name,\x0a    // In practice, there is one case in which we won\x27t get a stack. It\x27s when\x0a    // somebody calls unstable_renderSubtreeIntoContainer() and we process\x0a    // context from the parent component instance. The stack will be missing\x0a    // because it\x27s outside of the reconciliation, and so the pointer has not\x0a    // been set. This is rare and doesn\x27t matter. We\x27ll also remove that API.\x0a    getCurrentFiberStackInDev);\x0a  }\x0a\x0a  return _assign({}, parentContext, childContext);\x0a}\x0a\x0afunction pushContextProvider(workInProgress) {\x0a  var instance = workInProgress.stateNode;\x0a  // We push the context as early as possible to ensure stack integrity.\x0a  // If the instance does not exist yet, we will push null at first,\x0a  // and replace it on the stack later when invalidating the context.\x0a  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;\x0a\x0a  // Remember the parent context so we can merge with it later.\x0a  // Inherit the parent\x27s did-perform-work value to avoid inadvertently blocking updates.\x0a  previousContext = contextStackCursor.current;\x0a  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\x0a  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\x0a\x0a  return true;\x0a}\x0a\x0afunction invalidateContextProvider(workInProgress, type, didChange) {\x0a  var instance = workInProgress.stateNode;\x0a  !instance ? invariant(false, \x27Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.\x27) : void 0;\x0a\x0a  if (didChange) {\x0a    // Merge parent and own context.\x0a    // Skip this if we\x27re not updating due to sCU.\x0a    // This avoids unnecessarily recomputing memoized values.\x0a    var mergedContext = processChildContext(workInProgress, type, previousContext);\x0a    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\x0a\x0a    // Replace the old (or empty) context with the new one.\x0a    // It is important to unwind the context in the reverse order.\x0a    pop(didPerformWorkStackCursor, workInProgress);\x0a    pop(contextStackCursor, workInProgress);\x0a    // Now push the new context and mark that it has changed.\x0a    push(contextStackCursor, mergedContext, workInProgress);\x0a    push(didPerformWorkStackCursor, didChange, workInProgress);\x0a  } else {\x0a    pop(didPerformWorkStackCursor, workInProgress);\x0a    push(didPerformWorkStackCursor, didChange, workInProgress);\x0a  }\x0a}\x0a\x0afunction findCurrentUnmaskedContext(fiber) {\x0a  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\x0a  // makes sense elsewhere\x0a  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, \x27Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.\x27) : void 0;\x0a\x0a  var node = fiber;\x0a  do {\x0a    switch (node.tag) {\x0a      case HostRoot:\x0a        return node.stateNode.context;\x0a      case ClassComponent:\x0a        {\x0a          var Component = node.type;\x0a          if (isContextProvider(Component)) {\x0a            return node.stateNode.__reactInternalMemoizedMergedChildContext;\x0a          }\x0a          break;\x0a        }\x0a    }\x0a    node = node.return;\x0a  } while (node !== null);\x0a  invariant(false, \x27Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.\x27);\x0a}\x0a\x0avar onCommitFiberRoot = null;\x0avar onCommitFiberUnmount = null;\x0avar hasLoggedError = false;\x0a\x0afunction catchErrors(fn) {\x0a  return function (arg) {\x0a    try {\x0a      return fn(arg);\x0a    } catch (err) {\x0a      if (true && !hasLoggedError) {\x0a        hasLoggedError = true;\x0a        warningWithoutStack$1(false, \x27React DevTools encountered an error: %s\x27, err);\x0a      }\x0a    }\x0a  };\x0a}\x0a\x0avar isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \x27undefined\x27;\x0a\x0afunction injectInternals(internals) {\x0a  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \x27undefined\x27) {\x0a    // No DevTools\x0a    return false;\x0a  }\x0a  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\x0a  if (hook.isDisabled) {\x0a    // This isn\x27t a real property on the hook, but it can be set to opt out\x0a    // of DevTools integration and associated warnings and logs.\x0a    // https://github.com/facebook/react/issues/3877\x0a    return true;\x0a  }\x0a  if (!hook.supportsFiber) {\x0a    {\x0a      warningWithoutStack$1(false, \x27The installed version of React DevTools is too old and will not work \x27 + \x27with the current version of React. Please update React DevTools. \x27 + \x27https://fb.me/react-devtools\x27);\x0a    }\x0a    // DevTools exists, even though it doesn\x27t support Fiber.\x0a    return true;\x0a  }\x0a  try {\x0a    var rendererID = hook.inject(internals);\x0a    // We have successfully injected, so now it is safe to set up hooks.\x0a    onCommitFiberRoot = catchErrors(function (root) {\x0a      return hook.onCommitFiberRoot(rendererID, root);\x0a    });\x0a    onCommitFiberUnmount = catchErrors(function (fiber) {\x0a      return hook.onCommitFiberUnmount(rendererID, fiber);\x0a    });\x0a  } catch (err) {\x0a    // Catch all errors because it is unsafe to throw during initialization.\x0a    {\x0a      warningWithoutStack$1(false, \x27React DevTools encountered an error: %s.\x27, err);\x0a    }\x0a  }\x0a  // DevTools exists\x0a  return true;\x0a}\x0a\x0afunction onCommitRoot(root) {\x0a  if (typeof onCommitFiberRoot === \x27function\x27) {\x0a    onCommitFiberRoot(root);\x0a  }\x0a}\x0a\x0afunction onCommitUnmount(fiber) {\x0a  if (typeof onCommitFiberUnmount === \x27function\x27) {\x0a    onCommitFiberUnmount(fiber);\x0a  }\x0a}\x0a\x0a// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\x0a// Math.pow(2, 30) - 1\x0a// 0b111111111111111111111111111111\x0avar maxSigned31BitInt = 1073741823;\x0a\x0avar NoWork = 0;\x0avar Never = 1;\x0avar Sync = maxSigned31BitInt;\x0a\x0avar UNIT_SIZE = 10;\x0avar MAGIC_NUMBER_OFFSET = maxSigned31BitInt - 1;\x0a\x0a// 1 unit of expiration time represents 10ms.\x0afunction msToExpirationTime(ms) {\x0a  // Always add an offset so that we don\x27t clash with the magic number for NoWork.\x0a  return MAGIC_NUMBER_OFFSET - (ms / UNIT_SIZE | 0);\x0a}\x0a\x0afunction expirationTimeToMs(expirationTime) {\x0a  return (MAGIC_NUMBER_OFFSET - expirationTime) * UNIT_SIZE;\x0a}\x0a\x0afunction ceiling(num, precision) {\x0a  return ((num / precision | 0) + 1) * precision;\x0a}\x0a\x0afunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\x0a  return MAGIC_NUMBER_OFFSET - ceiling(MAGIC_NUMBER_OFFSET - currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\x0a}\x0a\x0avar LOW_PRIORITY_EXPIRATION = 5000;\x0avar LOW_PRIORITY_BATCH_SIZE = 250;\x0a\x0afunction computeAsyncExpiration(currentTime) {\x0a  return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);\x0a}\x0a\x0a// We intentionally set a higher expiration time for interactive updates in\x0a// dev than in production.\x0a//\x0a// If the main thread is being blocked so long that you hit the expiration,\x0a// it\x27s a problem that could be solved with better scheduling.\x0a//\x0a// People will be more likely to notice this and fix it with the long\x0a// expiration time in development.\x0a//\x0a// In production we opt for better UX at the risk of masking scheduling\x0a// problems, by expiring fast.\x0avar HIGH_PRIORITY_EXPIRATION = 500;\x0avar HIGH_PRIORITY_BATCH_SIZE = 100;\x0a\x0afunction computeInteractiveExpiration(currentTime) {\x0a  return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);\x0a}\x0a\x0avar NoContext = 0;\x0avar ConcurrentMode = 1;\x0avar StrictMode = 2;\x0avar ProfileMode = 4;\x0a\x0avar hasBadMapPolyfill = void 0;\x0a\x0a{\x0a  hasBadMapPolyfill = false;\x0a  try {\x0a    var nonExtensibleObject = Object.preventExtensions({});\x0a    var testMap = new Map([[nonExtensibleObject, null]]);\x0a    var testSet = new Set([nonExtensibleObject]);\x0a    // This is necessary for Rollup to not consider these unused.\x0a    // https://github.com/rollup/rollup/issues/1771\x0a    // TODO: we can remove these if Rollup fixes the bug.\x0a    testMap.set(0, 0);\x0a    testSet.add(0);\x0a  } catch (e) {\x0a    // TODO: Consider warning about bad polyfills\x0a    hasBadMapPolyfill = true;\x0a  }\x0a}\x0a\x0a// A Fiber is work on a Component that needs to be done or was done. There can\x0a// be more than one per component.\x0a\x0a\x0avar debugCounter = void 0;\x0a\x0a{\x0a  debugCounter = 1;\x0a}\x0a\x0afunction FiberNode(tag, pendingProps, key, mode) {\x0a  // Instance\x0a  this.tag = tag;\x0a  this.key = key;\x0a  this.elementType = null;\x0a  this.type = null;\x0a  this.stateNode = null;\x0a\x0a  // Fiber\x0a  this.return = null;\x0a  this.child = null;\x0a  this.sibling = null;\x0a  this.index = 0;\x0a\x0a  this.ref = null;\x0a\x0a  this.pendingProps = pendingProps;\x0a  this.memoizedProps = null;\x0a  this.updateQueue = null;\x0a  this.memoizedState = null;\x0a  this.contextDependencies = null;\x0a\x0a  this.mode = mode;\x0a\x0a  // Effects\x0a  this.effectTag = NoEffect;\x0a  this.nextEffect = null;\x0a\x0a  this.firstEffect = null;\x0a  this.lastEffect = null;\x0a\x0a  this.expirationTime = NoWork;\x0a  this.childExpirationTime = NoWork;\x0a\x0a  this.alternate = null;\x0a\x0a  if (enableProfilerTimer) {\x0a    // Note: The following is done to avoid a v8 performance cliff.\x0a    //\x0a    // Initializing the fields below to smis and later updating them with\x0a    // double values will cause Fibers to end up having separate shapes.\x0a    // This behavior/bug has something to do with Object.preventExtension().\x0a    // Fortunately this only impacts DEV builds.\x0a    // Unfortunately it makes React unusably slow for some applications.\x0a    // To work around this, initialize the fields below with doubles.\x0a    //\x0a    // Learn more about this here:\x0a    // https://github.com/facebook/react/issues/14365\x0a    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\x0a    this.actualDuration = Number.NaN;\x0a    this.actualStartTime = Number.NaN;\x0a    this.selfBaseDuration = Number.NaN;\x0a    this.treeBaseDuration = Number.NaN;\x0a\x0a    // It\x27s okay to replace the initial doubles with smis after initialization.\x0a    // This won\x27t trigger the performance cliff mentioned above,\x0a    // and it simplifies other profiler code (including DevTools).\x0a    this.actualDuration = 0;\x0a    this.actualStartTime = -1;\x0a    this.selfBaseDuration = 0;\x0a    this.treeBaseDuration = 0;\x0a  }\x0a\x0a  {\x0a    this._debugID = debugCounter++;\x0a    this._debugSource = null;\x0a    this._debugOwner = null;\x0a    this._debugIsCurrentlyTiming = false;\x0a    this._debugHookTypes = null;\x0a    if (!hasBadMapPolyfill && typeof Object.preventExtensions === \x27function\x27) {\x0a      Object.preventExtensions(this);\x0a    }\x0a  }\x0a}\x0a\x0a// This is a constructor function, rather than a POJO constructor, still\x0a// please ensure we do the following:\x0a// 1) Nobody should add any instance methods on this. Instance methods can be\x0a//    more difficult to predict when they get optimized and they are almost\x0a//    never inlined properly in static compilers.\x0a// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\x0a//    always know when it is a fiber.\x0a// 3) We might want to experiment with using numeric keys since they are easier\x0a//    to optimize in a non-JIT environment.\x0a// 4) We can easily go from a constructor to a createFiber object literal if that\x0a//    is faster.\x0a// 5) It should be easy to port this to a C struct and keep a C implementation\x0a//    compatible.\x0avar createFiber = function (tag, pendingProps, key, mode) {\x0a  // $FlowFixMe: the shapes are exact here but Flow doesn\x27t like constructors\x0a  return new FiberNode(tag, pendingProps, key, mode);\x0a};\x0a\x0afunction shouldConstruct(Component) {\x0a  var prototype = Component.prototype;\x0a  return !!(prototype && prototype.isReactComponent);\x0a}\x0a\x0afunction isSimpleFunctionComponent(type) {\x0a  return typeof type === \x27function\x27 && !shouldConstruct(type) && type.defaultProps === undefined;\x0a}\x0a\x0afunction resolveLazyComponentTag(Component) {\x0a  if (typeof Component === \x27function\x27) {\x0a    return shouldConstruct(Component) ? ClassComponent : FunctionComponent;\x0a  } else if (Component !== undefined && Component !== null) {\x0a    var $$typeof = Component.$$typeof;\x0a    if ($$typeof === REACT_FORWARD_REF_TYPE) {\x0a      return ForwardRef;\x0a    }\x0a    if ($$typeof === REACT_MEMO_TYPE) {\x0a      return MemoComponent;\x0a    }\x0a  }\x0a  return IndeterminateComponent;\x0a}\x0a\x0a// This is used to create an alternate fiber to do work on.\x0afunction createWorkInProgress(current, pendingProps, expirationTime) {\x0a  var workInProgress = current.alternate;\x0a  if (workInProgress === null) {\x0a    // We use a double buffering pooling technique because we know that we\x27ll\x0a    // only ever need at most two versions of a tree. We pool the \x22other\x22 unused\x0a    // node that we\x27re free to reuse. This is lazily created to avoid allocating\x0a    // extra objects for things that are never updated. It also allow us to\x0a    // reclaim the extra memory if needed.\x0a    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\x0a    workInProgress.elementType = current.elementType;\x0a    workInProgress.type = current.type;\x0a    workInProgress.stateNode = current.stateNode;\x0a\x0a    {\x0a      // DEV-only fields\x0a      workInProgress._debugID = current._debugID;\x0a      workInProgress._debugSource = current._debugSource;\x0a      workInProgress._debugOwner = current._debugOwner;\x0a      workInProgress._debugHookTypes = current._debugHookTypes;\x0a    }\x0a\x0a    workInProgress.alternate = current;\x0a    current.alternate = workInProgress;\x0a  } else {\x0a    workInProgress.pendingProps = pendingProps;\x0a\x0a    // We already have an alternate.\x0a    // Reset the effect tag.\x0a    workInProgress.effectTag = NoEffect;\x0a\x0a    // The effect list is no longer valid.\x0a    workInProgress.nextEffect = null;\x0a    workInProgress.firstEffect = null;\x0a    workInProgress.lastEffect = null;\x0a\x0a    if (enableProfilerTimer) {\x0a      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\x0a      // This prevents time from endlessly accumulating in new commits.\x0a      // This has the downside of resetting values for different priority renders,\x0a      // But works for yielding (the common case) and should support resuming.\x0a      workInProgress.actualDuration = 0;\x0a      workInProgress.actualStartTime = -1;\x0a    }\x0a  }\x0a\x0a  workInProgress.childExpirationTime = current.childExpirationTime;\x0a  workInProgress.expirationTime = current.expirationTime;\x0a\x0a  workInProgress.child = current.child;\x0a  workInProgress.memoizedProps = current.memoizedProps;\x0a  workInProgress.memoizedState = current.memoizedState;\x0a  workInProgress.updateQueue = current.updateQueue;\x0a  workInProgress.contextDependencies = current.contextDependencies;\x0a\x0a  // These will be overridden during the parent\x27s reconciliation\x0a  workInProgress.sibling = current.sibling;\x0a  workInProgress.index = current.index;\x0a  workInProgress.ref = current.ref;\x0a\x0a  if (enableProfilerTimer) {\x0a    workInProgress.selfBaseDuration = current.selfBaseDuration;\x0a    workInProgress.treeBaseDuration = current.treeBaseDuration;\x0a  }\x0a\x0a  return workInProgress;\x0a}\x0a\x0afunction createHostRootFiber(isConcurrent) {\x0a  var mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext;\x0a\x0a  if (enableProfilerTimer && isDevToolsPresent) {\x0a    // Always collect profile timings when DevTools are present.\x0a    // This enables DevTools to start capturing timing at any point\xe2\x80\x93\x0a    // Without some nodes in the tree having empty base times.\x0a    mode |= ProfileMode;\x0a  }\x0a\x0a  return createFiber(HostRoot, null, null, mode);\x0a}\x0a\x0afunction createFiberFromTypeAndProps(type, // React$ElementType\x0akey, pendingProps, owner, mode, expirationTime) {\x0a  var fiber = void 0;\x0a\x0a  var fiberTag = IndeterminateComponent;\x0a  // The resolved type is set if we know what the final type will be. I.e. it\x27s not lazy.\x0a  var resolvedType = type;\x0a  if (typeof type === \x27function\x27) {\x0a    if (shouldConstruct(type)) {\x0a      fiberTag = ClassComponent;\x0a    }\x0a  } else if (typeof type === \x27string\x27) {\x0a    fiberTag = HostComponent;\x0a  } else {\x0a    getTag: switch (type) {\x0a      case REACT_FRAGMENT_TYPE:\x0a        return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);\x0a      case REACT_CONCURRENT_MODE_TYPE:\x0a        return createFiberFromMode(pendingProps, mode | ConcurrentMode | StrictMode, expirationTime, key);\x0a      case REACT_STRICT_MODE_TYPE:\x0a        return createFiberFromMode(pendingProps, mode | StrictMode, expirationTime, key);\x0a      case REACT_PROFILER_TYPE:\x0a        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);\x0a      case REACT_SUSPENSE_TYPE:\x0a        return createFiberFromSuspense(pendingProps, mode, expirationTime, key);\x0a      default:\x0a        {\x0a          if (typeof type === \x27object\x27 && type !== null) {\x0a            switch (type.$$typeof) {\x0a              case REACT_PROVIDER_TYPE:\x0a                fiberTag = ContextProvider;\x0a                break getTag;\x0a              case REACT_CONTEXT_TYPE:\x0a                // This is a consumer\x0a                fiberTag = ContextConsumer;\x0a                break getTag;\x0a              case REACT_FORWARD_REF_TYPE:\x0a                fiberTag = ForwardRef;\x0a                break getTag;\x0a              case REACT_MEMO_TYPE:\x0a                fiberTag = MemoComponent;\x0a                break getTag;\x0a              case REACT_LAZY_TYPE:\x0a                fiberTag = LazyComponent;\x0a                resolvedType = null;\x0a                break getTag;\x0a            }\x0a          }\x0a          var info = \x27\x27;\x0a          {\x0a            if (type === undefined || typeof type === \x27object\x27 && type !== null && Object.keys(type).length === 0) {\x0a              info += \x27 You likely forgot to export your component from the file \x27 + \x22it\x27s defined in, or you might have mixed up default and \x22 + \x27named imports.\x27;\x0a            }\x0a            var ownerName = owner ? getComponentName(owner.type) : null;\x0a            if (ownerName) {\x0a              info += \x27\x5cn\x5cnCheck the render method of `\x27 + ownerName + \x27`.\x27;\x0a            }\x0a          }\x0a          invariant(false, \x27Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\x27, type == null ? type : typeof type, info);\x0a        }\x0a    }\x0a  }\x0a\x0a  fiber = createFiber(fiberTag, pendingProps, key, mode);\x0a  fiber.elementType = type;\x0a  fiber.type = resolvedType;\x0a  fiber.expirationTime = expirationTime;\x0a\x0a  return fiber;\x0a}\x0a\x0afunction createFiberFromElement(element, mode, expirationTime) {\x0a  var owner = null;\x0a  {\x0a    owner = element._owner;\x0a  }\x0a  var type = element.type;\x0a  var key = element.key;\x0a  var pendingProps = element.props;\x0a  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, expirationTime);\x0a  {\x0a    fiber._debugSource = element._source;\x0a    fiber._debugOwner = element._owner;\x0a  }\x0a  return fiber;\x0a}\x0a\x0afunction createFiberFromFragment(elements, mode, expirationTime, key) {\x0a  var fiber = createFiber(Fragment, elements, key, mode);\x0a  fiber.expirationTime = expirationTime;\x0a  return fiber;\x0a}\x0a\x0afunction createFiberFromProfiler(pendingProps, mode, expirationTime, key) {\x0a  {\x0a    if (typeof pendingProps.id !== \x27string\x27 || typeof pendingProps.onRender !== \x27function\x27) {\x0a      warningWithoutStack$1(false, \x27Profiler must specify an \x22id\x22 string and \x22onRender\x22 function as props\x27);\x0a    }\x0a  }\x0a\x0a  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\x0a  // TODO: The Profiler fiber shouldn\x27t have a type. It has a tag.\x0a  fiber.elementType = REACT_PROFILER_TYPE;\x0a  fiber.type = REACT_PROFILER_TYPE;\x0a  fiber.expirationTime = expirationTime;\x0a\x0a  return fiber;\x0a}\x0a\x0afunction createFiberFromMode(pendingProps, mode, expirationTime, key) {\x0a  var fiber = createFiber(Mode, pendingProps, key, mode);\x0a\x0a  // TODO: The Mode fiber shouldn\x27t have a type. It has a tag.\x0a  var type = (mode & ConcurrentMode) === NoContext ? REACT_STRICT_MODE_TYPE : REACT_CONCURRENT_MODE_TYPE;\x0a  fiber.elementType = type;\x0a  fiber.type = type;\x0a\x0a  fiber.expirationTime = expirationTime;\x0a  return fiber;\x0a}\x0a\x0afunction createFiberFromSuspense(pendingProps, mode, expirationTime, key) {\x0a  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\x0a\x0a  // TODO: The SuspenseComponent fiber shouldn\x27t have a type. It has a tag.\x0a  var type = REACT_SUSPENSE_TYPE;\x0a  fiber.elementType = type;\x0a  fiber.type = type;\x0a\x0a  fiber.expirationTime = expirationTime;\x0a  return fiber;\x0a}\x0a\x0afunction createFiberFromText(content, mode, expirationTime) {\x0a  var fiber = createFiber(HostText, content, null, mode);\x0a  fiber.expirationTime = expirationTime;\x0a  return fiber;\x0a}\x0a\x0afunction createFiberFromHostInstanceForDeletion() {\x0a  var fiber = createFiber(HostComponent, null, null, NoContext);\x0a  // TODO: These should not need a type.\x0a  fiber.elementType = \x27DELETED\x27;\x0a  fiber.type = \x27DELETED\x27;\x0a  return fiber;\x0a}\x0a\x0afunction createFiberFromPortal(portal, mode, expirationTime) {\x0a  var pendingProps = portal.children !== null ? portal.children : [];\x0a  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\x0a  fiber.expirationTime = expirationTime;\x0a  fiber.stateNode = {\x0a    containerInfo: portal.containerInfo,\x0a    pendingChildren: null, // Used by persistent updates\x0a    implementation: portal.implementation\x0a  };\x0a  return fiber;\x0a}\x0a\x0a// Used for stashing WIP properties to replay failed work in DEV.\x0afunction assignFiberPropertiesInDEV(target, source) {\x0a  if (target === null) {\x0a    // This Fiber\x27s initial properties will always be overwritten.\x0a    // We only use a Fiber to ensure the same hidden class so DEV isn\x27t slow.\x0a    target = createFiber(IndeterminateComponent, null, null, NoContext);\x0a  }\x0a\x0a  // This is intentionally written as a list of all properties.\x0a  // We tried to use Object.assign() instead but this is called in\x0a  // the hottest path, and Object.assign() was too slow:\x0a  // https://github.com/facebook/react/issues/12502\x0a  // This code is DEV-only so size is not a concern.\x0a\x0a  target.tag = source.tag;\x0a  target.key = source.key;\x0a  target.elementType = source.elementType;\x0a  target.type = source.type;\x0a  target.stateNode = source.stateNode;\x0a  target.return = source.return;\x0a  target.child = source.child;\x0a  target.sibling = source.sibling;\x0a  target.index = source.index;\x0a  target.ref = source.ref;\x0a  target.pendingProps = source.pendingProps;\x0a  target.memoizedProps = source.memoizedProps;\x0a  target.updateQueue = source.updateQueue;\x0a  target.memoizedState = source.memoizedState;\x0a  target.contextDependencies = source.contextDependencies;\x0a  target.mode = source.mode;\x0a  target.effectTag = source.effectTag;\x0a  target.nextEffect = source.nextEffect;\x0a  target.firstEffect = source.firstEffect;\x0a  target.lastEffect = source.lastEffect;\x0a  target.expirationTime = source.expirationTime;\x0a  target.childExpirationTime = source.childExpirationTime;\x0a  target.alternate = source.alternate;\x0a  if (enableProfilerTimer) {\x0a    target.actualDuration = source.actualDuration;\x0a    target.actualStartTime = source.actualStartTime;\x0a    target.selfBaseDuration = source.selfBaseDuration;\x0a    target.treeBaseDuration = source.treeBaseDuration;\x0a  }\x0a  target._debugID = source._debugID;\x0a  target._debugSource = source._debugSource;\x0a  target._debugOwner = source._debugOwner;\x0a  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\x0a  target._debugHookTypes = source._debugHookTypes;\x0a  return target;\x0a}\x0a\x0avar ReactInternals$2 = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\x0a\x0avar _ReactInternals$Sched$1 = ReactInternals$2.SchedulerTracing;\x0avar __interactionsRef = _ReactInternals$Sched$1.__interactionsRef;\x0avar __subscriberRef = _ReactInternals$Sched$1.__subscriberRef;\x0avar unstable_clear = _ReactInternals$Sched$1.unstable_clear;\x0avar unstable_getCurrent = _ReactInternals$Sched$1.unstable_getCurrent;\x0avar unstable_getThreadID = _ReactInternals$Sched$1.unstable_getThreadID;\x0avar unstable_subscribe = _ReactInternals$Sched$1.unstable_subscribe;\x0avar unstable_trace = _ReactInternals$Sched$1.unstable_trace;\x0avar unstable_unsubscribe = _ReactInternals$Sched$1.unstable_unsubscribe;\x0avar unstable_wrap = _ReactInternals$Sched$1.unstable_wrap;\x0a\x0a// TODO: This should be lifted into the renderer.\x0a\x0a\x0a// The following attributes are only used by interaction tracing builds.\x0a// They enable interactions to be associated with their async work,\x0a// And expose interaction metadata to the React DevTools Profiler plugin.\x0a// Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.\x0a\x0a\x0a// Exported FiberRoot type includes all properties,\x0a// To avoid requiring potentially error-prone :any casts throughout the project.\x0a// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracing is true).\x0a// The types are defined separately within this file to ensure they stay in sync.\x0a// (We don\x27t have to use an inline :any cast when enableSchedulerTracing is disabled.)\x0a\x0a\x0afunction createFiberRoot(containerInfo, isConcurrent, hydrate) {\x0a  // Cyclic construction. This cheats the type system right now because\x0a  // stateNode is any.\x0a  var uninitializedFiber = createHostRootFiber(isConcurrent);\x0a\x0a  var root = void 0;\x0a  if (enableSchedulerTracing) {\x0a    root = {\x0a      current: uninitializedFiber,\x0a      containerInfo: containerInfo,\x0a      pendingChildren: null,\x0a\x0a      earliestPendingTime: NoWork,\x0a      latestPendingTime: NoWork,\x0a      earliestSuspendedTime: NoWork,\x0a      latestSuspendedTime: NoWork,\x0a      latestPingedTime: NoWork,\x0a\x0a      pingCache: null,\x0a\x0a      didError: false,\x0a\x0a      pendingCommitExpirationTime: NoWork,\x0a      finishedWork: null,\x0a      timeoutHandle: noTimeout,\x0a      context: null,\x0a      pendingContext: null,\x0a      hydrate: hydrate,\x0a      nextExpirationTimeToWorkOn: NoWork,\x0a      expirationTime: NoWork,\x0a      firstBatch: null,\x0a      nextScheduledRoot: null,\x0a\x0a      interactionThreadID: unstable_getThreadID(),\x0a      memoizedInteractions: new Set(),\x0a      pendingInteractionMap: new Map()\x0a    };\x0a  } else {\x0a    root = {\x0a      current: uninitializedFiber,\x0a      containerInfo: containerInfo,\x0a      pendingChildren: null,\x0a\x0a      pingCache: null,\x0a\x0a      earliestPendingTime: NoWork,\x0a      latestPendingTime: NoWork,\x0a      earliestSuspendedTime: NoWork,\x0a      latestSuspendedTime: NoWork,\x0a      latestPingedTime: NoWork,\x0a\x0a      didError: false,\x0a\x0a      pendingCommitExpirationTime: NoWork,\x0a      finishedWork: null,\x0a      timeoutHandle: noTimeout,\x0a      context: null,\x0a      pendingContext: null,\x0a      hydrate: hydrate,\x0a      nextExpirationTimeToWorkOn: NoWork,\x0a      expirationTime: NoWork,\x0a      firstBatch: null,\x0a      nextScheduledRoot: null\x0a    };\x0a  }\x0a\x0a  uninitializedFiber.stateNode = root;\x0a\x0a  // The reason for the way the Flow types are structured in this file,\x0a  // Is to avoid needing :any casts everywhere interaction tracing fields are used.\x0a  // Unfortunately that requires an :any cast for non-interaction tracing capable builds.\x0a  // $FlowFixMe Remove this :any cast and replace it with something better.\x0a  return root;\x0a}\x0a\x0a/**\x0a * Forked from fbjs/warning:\x0a * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\x0a *\x0a * Only change is we use console.warn instead of console.error,\x0a * and do nothing when \x27console\x27 is not supported.\x0a * This really simplifies the code.\x0a * ---\x0a * Similar to invariant but only logs a warning if the condition is not met.\x0a * This can be used to log issues in development environments in critical\x0a * paths. Removing the logging code for production environments will keep the\x0a * same logic and follow the same code paths.\x0a */\x0a\x0avar lowPriorityWarning = function () {};\x0a\x0a{\x0a  var printWarning$1 = function (format) {\x0a    for (var _len = arguments.length, args = Array(_len \x3e 1 ? _len - 1 : 0), _key = 1; _key \x3c _len; _key++) {\x0a      args[_key - 1] = arguments[_key];\x0a    }\x0a\x0a    var argIndex = 0;\x0a    var message = \x27Warning: \x27 + format.replace(/%s/g, function () {\x0a      return args[argIndex++];\x0a    });\x0a    if (typeof console !== \x27undefined\x27) {\x0a      console.warn(message);\x0a    }\x0a    try {\x0a      // --- Welcome to debugging React ---\x0a      // This error was thrown as a convenience so that you can use this stack\x0a      // to find the callsite that caused this warning to fire.\x0a      throw new Error(message);\x0a    } catch (x) {}\x0a  };\x0a\x0a  lowPriorityWarning = function (condition, format) {\x0a    if (format === undefined) {\x0a      throw new Error(\x27`lowPriorityWarning(condition, format, ...args)` requires a warning \x27 + \x27message argument\x27);\x0a    }\x0a    if (!condition) {\x0a      for (var _len2 = arguments.length, args = Array(_len2 \x3e 2 ? _len2 - 2 : 0), _key2 = 2; _key2 \x3c _len2; _key2++) {\x0a        args[_key2 - 2] = arguments[_key2];\x0a      }\x0a\x0a      printWarning$1.apply(undefined, [format].concat(args));\x0a    }\x0a  };\x0a}\x0a\x0avar lowPriorityWarning$1 = lowPriorityWarning;\x0a\x0avar ReactStrictModeWarnings = {\x0a  discardPendingWarnings: function () {},\x0a  flushPendingDeprecationWarnings: function () {},\x0a  flushPendingUnsafeLifecycleWarnings: function () {},\x0a  recordDeprecationWarnings: function (fiber, instance) {},\x0a  recordUnsafeLifecycleWarnings: function (fiber, instance) {},\x0a  recordLegacyContextWarning: function (fiber, instance) {},\x0a  flushLegacyContextWarning: function () {}\x0a};\x0a\x0a{\x0a  var LIFECYCLE_SUGGESTIONS = {\x0a    UNSAFE_componentWillMount: \x27componentDidMount\x27,\x0a    UNSAFE_componentWillReceiveProps: \x27static getDerivedStateFromProps\x27,\x0a    UNSAFE_componentWillUpdate: \x27componentDidUpdate\x27\x0a  };\x0a\x0a  var pendingComponentWillMountWarnings = [];\x0a  var pendingComponentWillReceivePropsWarnings = [];\x0a  var pendingComponentWillUpdateWarnings = [];\x0a  var pendingUnsafeLifecycleWarnings = new Map();\x0a  var pendingLegacyContextWarning = new Map();\x0a\x0a  // Tracks components we have already warned about.\x0a  var didWarnAboutDeprecatedLifecycles = new Set();\x0a  var didWarnAboutUnsafeLifecycles = new Set();\x0a  var didWarnAboutLegacyContext = new Set();\x0a\x0a  var setToSortedString = function (set) {\x0a    var array = [];\x0a    set.forEach(function (value) {\x0a      array.push(value);\x0a    });\x0a    return array.sort().join(\x27, \x27);\x0a  };\x0a\x0a  ReactStrictModeWarnings.discardPendingWarnings = function () {\x0a    pendingComponentWillMountWarnings = [];\x0a    pendingComponentWillReceivePropsWarnings = [];\x0a    pendingComponentWillUpdateWarnings = [];\x0a    pendingUnsafeLifecycleWarnings = new Map();\x0a    pendingLegacyContextWarning = new Map();\x0a  };\x0a\x0a  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\x0a    pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {\x0a      var lifecyclesWarningMessages = [];\x0a\x0a      Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {\x0a        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\x0a        if (lifecycleWarnings.length \x3e 0) {\x0a          var componentNames = new Set();\x0a          lifecycleWarnings.forEach(function (fiber) {\x0a            componentNames.add(getComponentName(fiber.type) || \x27Component\x27);\x0a            didWarnAboutUnsafeLifecycles.add(fiber.type);\x0a          });\x0a\x0a          var formatted = lifecycle.replace(\x27UNSAFE_\x27, \x27\x27);\x0a          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\x0a          var sortedComponentNames = setToSortedString(componentNames);\x0a\x0a          lifecyclesWarningMessages.push(formatted + \x27: Please update the following components to use \x27 + (suggestion + \x27 instead: \x27 + sortedComponentNames));\x0a        }\x0a      });\x0a\x0a      if (lifecyclesWarningMessages.length \x3e 0) {\x0a        var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\x0a\x0a        warningWithoutStack$1(false, \x27Unsafe lifecycle methods were found within a strict-mode tree:%s\x27 + \x27\x5cn\x5cn%s\x27 + \x27\x5cn\x5cnLearn more about this warning here:\x27 + \x27\x5cnhttps://fb.me/react-strict-mode-warnings\x27, strictRootComponentStack, lifecyclesWarningMessages.join(\x27\x5cn\x5cn\x27));\x0a      }\x0a    });\x0a\x0a    pendingUnsafeLifecycleWarnings = new Map();\x0a  };\x0a\x0a  var findStrictRoot = function (fiber) {\x0a    var maybeStrictRoot = null;\x0a\x0a    var node = fiber;\x0a    while (node !== null) {\x0a      if (node.mode & StrictMode) {\x0a        maybeStrictRoot = node;\x0a      }\x0a      node = node.return;\x0a    }\x0a\x0a    return maybeStrictRoot;\x0a  };\x0a\x0a  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {\x0a    if (pendingComponentWillMountWarnings.length \x3e 0) {\x0a      var uniqueNames = new Set();\x0a      pendingComponentWillMountWarnings.forEach(function (fiber) {\x0a        uniqueNames.add(getComponentName(fiber.type) || \x27Component\x27);\x0a        didWarnAboutDeprecatedLifecycles.add(fiber.type);\x0a      });\x0a\x0a      var sortedNames = setToSortedString(uniqueNames);\x0a\x0a      lowPriorityWarning$1(false, \x27componentWillMount is deprecated and will be removed in the next major version. \x27 + \x27Use componentDidMount instead. As a temporary workaround, \x27 + \x27you can rename to UNSAFE_componentWillMount.\x27 + \x27\x5cn\x5cnPlease update the following components: %s\x27 + \x27\x5cn\x5cnLearn more about this warning here:\x27 + \x27\x5cnhttps://fb.me/react-async-component-lifecycle-hooks\x27, sortedNames);\x0a\x0a      pendingComponentWillMountWarnings = [];\x0a    }\x0a\x0a    if (pendingComponentWillReceivePropsWarnings.length \x3e 0) {\x0a      var _uniqueNames = new Set();\x0a      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\x0a        _uniqueNames.add(getComponentName(fiber.type) || \x27Component\x27);\x0a        didWarnAboutDeprecatedLifecycles.add(fiber.type);\x0a      });\x0a\x0a      var _sortedNames = setToSortedString(_uniqueNames);\x0a\x0a      lowPriorityWarning$1(false, \x27componentWillReceiveProps is deprecated and will be removed in the next major version. \x27 + \x27Use static getDerivedStateFromProps instead.\x27 + \x27\x5cn\x5cnPlease update the following components: %s\x27 + \x27\x5cn\x5cnLearn more about this warning here:\x27 + \x27\x5cnhttps://fb.me/react-async-component-lifecycle-hooks\x27, _sortedNames);\x0a\x0a      pendingComponentWillReceivePropsWarnings = [];\x0a    }\x0a\x0a    if (pendingComponentWillUpdateWarnings.length \x3e 0) {\x0a      var _uniqueNames2 = new Set();\x0a      pendingComponentWillUpdateWarnings.forEach(function (fiber) {\x0a        _uniqueNames2.add(getComponentName(fiber.type) || \x27Component\x27);\x0a        didWarnAboutDeprecatedLifecycles.add(fiber.type);\x0a      });\x0a\x0a      var _sortedNames2 = setToSortedString(_uniqueNames2);\x0a\x0a      lowPriorityWarning$1(false, \x27componentWillUpdate is deprecated and will be removed in the next major version. \x27 + \x27Use componentDidUpdate instead. As a temporary workaround, \x27 + \x27you can rename to UNSAFE_componentWillUpdate.\x27 + \x27\x5cn\x5cnPlease update the following components: %s\x27 + \x27\x5cn\x5cnLearn more about this warning here:\x27 + \x27\x5cnhttps://fb.me/react-async-component-lifecycle-hooks\x27, _sortedNames2);\x0a\x0a      pendingComponentWillUpdateWarnings = [];\x0a    }\x0a  };\x0a\x0a  ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {\x0a    // Dedup strategy: Warn once per component.\x0a    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\x0a      return;\x0a    }\x0a\x0a    // Don\x27t warn about react-lifecycles-compat polyfilled components.\x0a    if (typeof instance.componentWillMount === \x27function\x27 && instance.componentWillMount.__suppressDeprecationWarning !== true) {\x0a      pendingComponentWillMountWarnings.push(fiber);\x0a    }\x0a    if (typeof instance.componentWillReceiveProps === \x27function\x27 && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\x0a      pendingComponentWillReceivePropsWarnings.push(fiber);\x0a    }\x0a    if (typeof instance.componentWillUpdate === \x27function\x27 && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\x0a      pendingComponentWillUpdateWarnings.push(fiber);\x0a    }\x0a  };\x0a\x0a  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\x0a    var strictRoot = findStrictRoot(fiber);\x0a    if (strictRoot === null) {\x0a      warningWithoutStack$1(false, \x27Expected to find a StrictMode component in a strict mode tree. \x27 + \x27This error is likely caused by a bug in React. Please file an issue.\x27);\x0a      return;\x0a    }\x0a\x0a    // Dedup strategy: Warn once per component.\x0a    // This is difficult to track any other way since component names\x0a    // are often vague and are likely to collide between 3rd party libraries.\x0a    // An expand property is probably okay to use here since it\x27s DEV-only,\x0a    // and will only be set in the event of serious warnings.\x0a    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\x0a      return;\x0a    }\x0a\x0a    var warningsForRoot = void 0;\x0a    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\x0a      warningsForRoot = {\x0a        UNSAFE_componentWillMount: [],\x0a        UNSAFE_componentWillReceiveProps: [],\x0a        UNSAFE_componentWillUpdate: []\x0a      };\x0a\x0a      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\x0a    } else {\x0a      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\x0a    }\x0a\x0a    var unsafeLifecycles = [];\x0a    if (typeof instance.componentWillMount === \x27function\x27 && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === \x27function\x27) {\x0a      unsafeLifecycles.push(\x27UNSAFE_componentWillMount\x27);\x0a    }\x0a    if (typeof instance.componentWillReceiveProps === \x27function\x27 && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === \x27function\x27) {\x0a      unsafeLifecycles.push(\x27UNSAFE_componentWillReceiveProps\x27);\x0a    }\x0a    if (typeof instance.componentWillUpdate === \x27function\x27 && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === \x27function\x27) {\x0a      unsafeLifecycles.push(\x27UNSAFE_componentWillUpdate\x27);\x0a    }\x0a\x0a    if (unsafeLifecycles.length \x3e 0) {\x0a      unsafeLifecycles.forEach(function (lifecycle) {\x0a        warningsForRoot[lifecycle].push(fiber);\x0a      });\x0a    }\x0a  };\x0a\x0a  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {\x0a    var strictRoot = findStrictRoot(fiber);\x0a    if (strictRoot === null) {\x0a      warningWithoutStack$1(false, \x27Expected to find a StrictMode component in a strict mode tree. \x27 + \x27This error is likely caused by a bug in React. Please file an issue.\x27);\x0a      return;\x0a    }\x0a\x0a    // Dedup strategy: Warn once per component.\x0a    if (didWarnAboutLegacyContext.has(fiber.type)) {\x0a      return;\x0a    }\x0a\x0a    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\x0a\x0a    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === \x27function\x27) {\x0a      if (warningsForRoot === undefined) {\x0a        warningsForRoot = [];\x0a        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\x0a      }\x0a      warningsForRoot.push(fiber);\x0a    }\x0a  };\x0a\x0a  ReactStrictModeWarnings.flushLegacyContextWarning = function () {\x0a    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {\x0a      var uniqueNames = new Set();\x0a      fiberArray.forEach(function (fiber) {\x0a        uniqueNames.add(getComponentName(fiber.type) || \x27Component\x27);\x0a        didWarnAboutLegacyContext.add(fiber.type);\x0a      });\x0a\x0a      var sortedNames = setToSortedString(uniqueNames);\x0a      var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\x0a\x0a      warningWithoutStack$1(false, \x27Legacy context API has been detected within a strict-mode tree: %s\x27 + \x27\x5cn\x5cnPlease update the following components: %s\x27 + \x27\x5cn\x5cnLearn more about this warning here:\x27 + \x27\x5cnhttps://fb.me/react-strict-mode-warnings\x27, strictRootComponentStack, sortedNames);\x0a    });\x0a  };\x0a}\x0a\x0a// This lets us hook into Fiber to debug what it\x27s doing.\x0a// See https://github.com/facebook/react/pull/8033.\x0a// This is not part of the public API, not even for React DevTools.\x0a// You may only inject a debugTool if you work on React Fiber itself.\x0avar ReactFiberInstrumentation = {\x0a  debugTool: null\x0a};\x0a\x0avar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\x0a\x0a// TODO: Offscreen updates should never suspend. However, a promise that\x0a// suspended inside an offscreen subtree should be able to ping at the priority\x0a// of the outer render.\x0a\x0afunction markPendingPriorityLevel(root, expirationTime) {\x0a  // If there\x27s a gap between completing a failed root and retrying it,\x0a  // additional updates may be scheduled. Clear `didError`, in case the update\x0a  // is sufficient to fix the error.\x0a  root.didError = false;\x0a\x0a  // Update the latest and earliest pending times\x0a  var earliestPendingTime = root.earliestPendingTime;\x0a  if (earliestPendingTime === NoWork) {\x0a    // No other pending updates.\x0a    root.earliestPendingTime = root.latestPendingTime = expirationTime;\x0a  } else {\x0a    if (earliestPendingTime \x3c expirationTime) {\x0a      // This is the earliest pending update.\x0a      root.earliestPendingTime = expirationTime;\x0a    } else {\x0a      var latestPendingTime = root.latestPendingTime;\x0a      if (latestPendingTime \x3e expirationTime) {\x0a        // This is the latest pending update\x0a        root.latestPendingTime = expirationTime;\x0a      }\x0a    }\x0a  }\x0a  findNextExpirationTimeToWorkOn(expirationTime, root);\x0a}\x0a\x0afunction markCommittedPriorityLevels(root, earliestRemainingTime) {\x0a  root.didError = false;\x0a\x0a  if (earliestRemainingTime === NoWork) {\x0a    // Fast path. There\x27s no remaining work. Clear everything.\x0a    root.earliestPendingTime = NoWork;\x0a    root.latestPendingTime = NoWork;\x0a    root.earliestSuspendedTime = NoWork;\x0a    root.latestSuspendedTime = NoWork;\x0a    root.latestPingedTime = NoWork;\x0a    findNextExpirationTimeToWorkOn(NoWork, root);\x0a    return;\x0a  }\x0a\x0a  if (earliestRemainingTime \x3c root.latestPingedTime) {\x0a    root.latestPingedTime = NoWork;\x0a  }\x0a\x0a  // Let\x27s see if the previous latest known pending level was just flushed.\x0a  var latestPendingTime = root.latestPendingTime;\x0a  if (latestPendingTime !== NoWork) {\x0a    if (latestPendingTime \x3e earliestRemainingTime) {\x0a      // We\x27ve flushed all the known pending levels.\x0a      root.earliestPendingTime = root.latestPendingTime = NoWork;\x0a    } else {\x0a      var earliestPendingTime = root.earliestPendingTime;\x0a      if (earliestPendingTime \x3e earliestRemainingTime) {\x0a        // We\x27ve flushed the earliest known pending level. Set this to the\x0a        // latest pending time.\x0a        root.earliestPendingTime = root.latestPendingTime;\x0a      }\x0a    }\x0a  }\x0a\x0a  // Now let\x27s handle the earliest remaining level in the whole tree. We need to\x0a  // decide whether to treat it as a pending level or as suspended. Check\x0a  // it falls within the range of known suspended levels.\x0a\x0a  var earliestSuspendedTime = root.earliestSuspendedTime;\x0a  if (earliestSuspendedTime === NoWork) {\x0a    // There\x27s no suspended work. Treat the earliest remaining level as a\x0a    // pending level.\x0a    markPendingPriorityLevel(root, earliestRemainingTime);\x0a    findNextExpirationTimeToWorkOn(NoWork, root);\x0a    return;\x0a  }\x0a\x0a  var latestSuspendedTime = root.latestSuspendedTime;\x0a  if (earliestRemainingTime \x3c latestSuspendedTime) {\x0a    // The earliest remaining level is later than all the suspended work. That\x0a    // means we\x27ve flushed all the suspended work.\x0a    root.earliestSuspendedTime = NoWork;\x0a    root.latestSuspendedTime = NoWork;\x0a    root.latestPingedTime = NoWork;\x0a\x0a    // There\x27s no suspended work. Treat the earliest remaining level as a\x0a    // pending level.\x0a    markPendingPriorityLevel(root, earliestRemainingTime);\x0a    findNextExpirationTimeToWorkOn(NoWork, root);\x0a    return;\x0a  }\x0a\x0a  if (earliestRemainingTime \x3e earliestSuspendedTime) {\x0a    // The earliest remaining time is earlier than all the suspended work.\x0a    // Treat it as a pending update.\x0a    markPendingPriorityLevel(root, earliestRemainingTime);\x0a    findNextExpirationTimeToWorkOn(NoWork, root);\x0a    return;\x0a  }\x0a\x0a  // The earliest remaining time falls within the range of known suspended\x0a  // levels. We should treat this as suspended work.\x0a  findNextExpirationTimeToWorkOn(NoWork, root);\x0a}\x0a\x0afunction hasLowerPriorityWork(root, erroredExpirationTime) {\x0a  var latestPendingTime = root.latestPendingTime;\x0a  var latestSuspendedTime = root.latestSuspendedTime;\x0a  var latestPingedTime = root.latestPingedTime;\x0a  return latestPendingTime !== NoWork && latestPendingTime \x3c erroredExpirationTime || latestSuspendedTime !== NoWork && latestSuspendedTime \x3c erroredExpirationTime || latestPingedTime !== NoWork && latestPingedTime \x3c erroredExpirationTime;\x0a}\x0a\x0afunction isPriorityLevelSuspended(root, expirationTime) {\x0a  var earliestSuspendedTime = root.earliestSuspendedTime;\x0a  var latestSuspendedTime = root.latestSuspendedTime;\x0a  return earliestSuspendedTime !== NoWork && expirationTime \x3c= earliestSuspendedTime && expirationTime \x3e= latestSuspendedTime;\x0a}\x0a\x0afunction markSuspendedPriorityLevel(root, suspendedTime) {\x0a  root.didError = false;\x0a  clearPing(root, suspendedTime);\x0a\x0a  // First, check the known pending levels and update them if needed.\x0a  var earliestPendingTime = root.earliestPendingTime;\x0a  var latestPendingTime = root.latestPendingTime;\x0a  if (earliestPendingTime === suspendedTime) {\x0a    if (latestPendingTime === suspendedTime) {\x0a      // Both known pending levels were suspended. Clear them.\x0a      root.earliestPendingTime = root.latestPendingTime = NoWork;\x0a    } else {\x0a      // The earliest pending level was suspended. Clear by setting it to the\x0a      // latest pending level.\x0a      root.earliestPendingTime = latestPendingTime;\x0a    }\x0a  } else if (latestPendingTime === suspendedTime) {\x0a    // The latest pending level was suspended. Clear by setting it to the\x0a    // latest pending level.\x0a    root.latestPendingTime = earliestPendingTime;\x0a  }\x0a\x0a  // Finally, update the known suspended levels.\x0a  var earliestSuspendedTime = root.earliestSuspendedTime;\x0a  var latestSuspendedTime = root.latestSuspendedTime;\x0a  if (earliestSuspendedTime === NoWork) {\x0a    // No other suspended levels.\x0a    root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;\x0a  } else {\x0a    if (earliestSuspendedTime \x3c suspendedTime) {\x0a      // This is the earliest suspended level.\x0a      root.earliestSuspendedTime = suspendedTime;\x0a    } else if (latestSuspendedTime \x3e suspendedTime) {\x0a      // This is the latest suspended level\x0a      root.latestSuspendedTime = suspendedTime;\x0a    }\x0a  }\x0a\x0a  findNextExpirationTimeToWorkOn(suspendedTime, root);\x0a}\x0a\x0afunction markPingedPriorityLevel(root, pingedTime) {\x0a  root.didError = false;\x0a\x0a  // TODO: When we add back resuming, we need to ensure the progressed work\x0a  // is thrown out and not reused during the restarted render. One way to\x0a  // invalidate the progressed work is to restart at expirationTime + 1.\x0a  var latestPingedTime = root.latestPingedTime;\x0a  if (latestPingedTime === NoWork || latestPingedTime \x3e pingedTime) {\x0a    root.latestPingedTime = pingedTime;\x0a  }\x0a  findNextExpirationTimeToWorkOn(pingedTime, root);\x0a}\x0a\x0afunction clearPing(root, completedTime) {\x0a  var latestPingedTime = root.latestPingedTime;\x0a  if (latestPingedTime \x3e= completedTime) {\x0a    root.latestPingedTime = NoWork;\x0a  }\x0a}\x0a\x0afunction findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {\x0a  var earliestExpirationTime = renderExpirationTime;\x0a\x0a  var earliestPendingTime = root.earliestPendingTime;\x0a  var earliestSuspendedTime = root.earliestSuspendedTime;\x0a  if (earliestPendingTime \x3e earliestExpirationTime) {\x0a    earliestExpirationTime = earliestPendingTime;\x0a  }\x0a  if (earliestSuspendedTime \x3e earliestExpirationTime) {\x0a    earliestExpirationTime = earliestSuspendedTime;\x0a  }\x0a  return earliestExpirationTime;\x0a}\x0a\x0afunction didExpireAtExpirationTime(root, currentTime) {\x0a  var expirationTime = root.expirationTime;\x0a  if (expirationTime !== NoWork && currentTime \x3c= expirationTime) {\x0a    // The root has expired. Flush all work up to the current time.\x0a    root.nextExpirationTimeToWorkOn = currentTime;\x0a  }\x0a}\x0a\x0afunction findNextExpirationTimeToWorkOn(completedExpirationTime, root) {\x0a  var earliestSuspendedTime = root.earliestSuspendedTime;\x0a  var latestSuspendedTime = root.latestSuspendedTime;\x0a  var earliestPendingTime = root.earliestPendingTime;\x0a  var latestPingedTime = root.latestPingedTime;\x0a\x0a  // Work on the earliest pending time. Failing that, work on the latest\x0a  // pinged time.\x0a  var nextExpirationTimeToWorkOn = earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;\x0a\x0a  // If there is no pending or pinged work, check if there\x27s suspended work\x0a  // that\x27s lower priority than what we just completed.\x0a  if (nextExpirationTimeToWorkOn === NoWork && (completedExpirationTime === NoWork || latestSuspendedTime \x3c completedExpirationTime)) {\x0a    // The lowest priority suspended work is the work most likely to be\x0a    // committed next. Let\x27s start rendering it again, so that if it times out,\x0a    // it\x27s ready to commit.\x0a    nextExpirationTimeToWorkOn = latestSuspendedTime;\x0a  }\x0a\x0a  var expirationTime = nextExpirationTimeToWorkOn;\x0a  if (expirationTime !== NoWork && earliestSuspendedTime \x3e expirationTime) {\x0a    // Expire using the earliest known expiration time.\x0a    expirationTime = earliestSuspendedTime;\x0a  }\x0a\x0a  root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;\x0a  root.expirationTime = expirationTime;\x0a}\x0a\x0afunction resolveDefaultProps(Component, baseProps) {\x0a  if (Component && Component.defaultProps) {\x0a    // Resolve default props. Taken from ReactElement\x0a    var props = _assign({}, baseProps);\x0a    var defaultProps = Component.defaultProps;\x0a    for (var propName in defaultProps) {\x0a      if (props[propName] === undefined) {\x0a        props[propName] = defaultProps[propName];\x0a      }\x0a    }\x0a    return props;\x0a  }\x0a  return baseProps;\x0a}\x0a\x0afunction readLazyComponentType(lazyComponent) {\x0a  var status = lazyComponent._status;\x0a  var result = lazyComponent._result;\x0a  switch (status) {\x0a    case Resolved:\x0a      {\x0a        var Component = result;\x0a        return Component;\x0a      }\x0a    case Rejected:\x0a      {\x0a        var error = result;\x0a        throw error;\x0a      }\x0a    case Pending:\x0a      {\x0a        var thenable = result;\x0a        throw thenable;\x0a      }\x0a    default:\x0a      {\x0a        lazyComponent._status = Pending;\x0a        var ctor = lazyComponent._ctor;\x0a        var _thenable = ctor();\x0a        _thenable.then(function (moduleObject) {\x0a          if (lazyComponent._status === Pending) {\x0a            var defaultExport = moduleObject.default;\x0a            {\x0a              if (defaultExport === undefined) {\x0a                warning$1(false, \x27lazy: Expected the result of a dynamic import() call. \x27 + \x27Instead received: %s\x5cn\x5cnYour code should look like: \x5cn  \x27 + \x22const MyComponent = lazy(() =\x3e import(\x27./MyComponent\x27))\x22, moduleObject);\x0a              }\x0a            }\x0a            lazyComponent._status = Resolved;\x0a            lazyComponent._result = defaultExport;\x0a          }\x0a        }, function (error) {\x0a          if (lazyComponent._status === Pending) {\x0a            lazyComponent._status = Rejected;\x0a            lazyComponent._result = error;\x0a          }\x0a        });\x0a        // Handle synchronous thenables.\x0a        switch (lazyComponent._status) {\x0a          case Resolved:\x0a            return lazyComponent._result;\x0a          case Rejected:\x0a            throw lazyComponent._result;\x0a        }\x0a        lazyComponent._result = _thenable;\x0a        throw _thenable;\x0a      }\x0a  }\x0a}\x0a\x0avar fakeInternalInstance = {};\x0avar isArray$1 = Array.isArray;\x0a\x0a// React.Component uses a shared frozen object by default.\x0a// We\x27ll use it to determine whether we need to initialize legacy refs.\x0avar emptyRefsObject = new React.Component().refs;\x0a\x0avar didWarnAboutStateAssignmentForComponent = void 0;\x0avar didWarnAboutUninitializedState = void 0;\x0avar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;\x0avar didWarnAboutLegacyLifecyclesAndDerivedState = void 0;\x0avar didWarnAboutUndefinedDerivedState = void 0;\x0avar warnOnUndefinedDerivedState = void 0;\x0avar warnOnInvalidCallback$1 = void 0;\x0avar didWarnAboutDirectlyAssigningPropsToState = void 0;\x0avar didWarnAboutContextTypeAndContextTypes = void 0;\x0avar didWarnAboutInvalidateContextType = void 0;\x0a\x0a{\x0a  didWarnAboutStateAssignmentForComponent = new Set();\x0a  didWarnAboutUninitializedState = new Set();\x0a  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\x0a  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\x0a  didWarnAboutDirectlyAssigningPropsToState = new Set();\x0a  didWarnAboutUndefinedDerivedState = new Set();\x0a  didWarnAboutContextTypeAndContextTypes = new Set();\x0a  didWarnAboutInvalidateContextType = new Set();\x0a\x0a  var didWarnOnInvalidCallback = new Set();\x0a\x0a  warnOnInvalidCallback$1 = function (callback, callerName) {\x0a    if (callback === null || typeof callback === \x27function\x27) {\x0a      return;\x0a    }\x0a    var key = callerName + \x27_\x27 + callback;\x0a    if (!didWarnOnInvalidCallback.has(key)) {\x0a      didWarnOnInvalidCallback.add(key);\x0a      warningWithoutStack$1(false, \x27%s(...): Expected the last optional `callback` argument to be a \x27 + \x27function. Instead received: %s.\x27, callerName, callback);\x0a    }\x0a  };\x0a\x0a  warnOnUndefinedDerivedState = function (type, partialState) {\x0a    if (partialState === undefined) {\x0a      var componentName = getComponentName(type) || \x27Component\x27;\x0a      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\x0a        didWarnAboutUndefinedDerivedState.add(componentName);\x0a        warningWithoutStack$1(false, \x27%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \x27 + \x27You have returned undefined.\x27, componentName);\x0a      }\x0a    }\x0a  };\x0a\x0a  // This is so gross but it\x27s at least non-critical and can be removed if\x0a  // it causes problems. This is meant to give a nicer error message for\x0a  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\x0a  // ...)) which otherwise throws a \x22_processChildContext is not a function\x22\x0a  // exception.\x0a  Object.defineProperty(fakeInternalInstance, \x27_processChildContext\x27, {\x0a    enumerable: false,\x0a    value: function () {\x0a      invariant(false, \x27_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\x5c\x27t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).\x27);\x0a    }\x0a  });\x0a  Object.freeze(fakeInternalInstance);\x0a}\x0a\x0afunction applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\x0a  var prevState = workInProgress.memoizedState;\x0a\x0a  {\x0a    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\x0a      // Invoke the function an extra time to help detect side-effects.\x0a      getDerivedStateFromProps(nextProps, prevState);\x0a    }\x0a  }\x0a\x0a  var partialState = getDerivedStateFromProps(nextProps, prevState);\x0a\x0a  {\x0a    warnOnUndefinedDerivedState(ctor, partialState);\x0a  }\x0a  // Merge the partial state and the previous state.\x0a  var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({}, prevState, partialState);\x0a  workInProgress.memoizedState = memoizedState;\x0a\x0a  // Once the update queue is empty, persist the derived state onto the\x0a  // base state.\x0a  var updateQueue = workInProgress.updateQueue;\x0a  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {\x0a    updateQueue.baseState = memoizedState;\x0a  }\x0a}\x0a\x0avar classComponentUpdater = {\x0a  isMounted: isMounted,\x0a  enqueueSetState: function (inst, payload, callback) {\x0a    var fiber = get(inst);\x0a    var currentTime = requestCurrentTime();\x0a    var expirationTime = computeExpirationForFiber(currentTime, fiber);\x0a\x0a    var update = createUpdate(expirationTime);\x0a    update.payload = payload;\x0a    if (callback !== undefined && callback !== null) {\x0a      {\x0a        warnOnInvalidCallback$1(callback, \x27setState\x27);\x0a      }\x0a      update.callback = callback;\x0a    }\x0a\x0a    flushPassiveEffects();\x0a    enqueueUpdate(fiber, update);\x0a    scheduleWork(fiber, expirationTime);\x0a  },\x0a  enqueueReplaceState: function (inst, payload, callback) {\x0a    var fiber = get(inst);\x0a    var currentTime = requestCurrentTime();\x0a    var expirationTime = computeExpirationForFiber(currentTime, fiber);\x0a\x0a    var update = createUpdate(expirationTime);\x0a    update.tag = ReplaceState;\x0a    update.payload = payload;\x0a\x0a    if (callback !== undefined && callback !== null) {\x0a      {\x0a        warnOnInvalidCallback$1(callback, \x27replaceState\x27);\x0a      }\x0a      update.callback = callback;\x0a    }\x0a\x0a    flushPassiveEffects();\x0a    enqueueUpdate(fiber, update);\x0a    scheduleWork(fiber, expirationTime);\x0a  },\x0a  enqueueForceUpdate: function (inst, callback) {\x0a    var fiber = get(inst);\x0a    var currentTime = requestCurrentTime();\x0a    var expirationTime = computeExpirationForFiber(currentTime, fiber);\x0a\x0a    var update = createUpdate(expirationTime);\x0a    update.tag = ForceUpdate;\x0a\x0a    if (callback !== undefined && callback !== null) {\x0a      {\x0a        warnOnInvalidCallback$1(callback, \x27forceUpdate\x27);\x0a      }\x0a      update.callback = callback;\x0a    }\x0a\x0a    flushPassiveEffects();\x0a    enqueueUpdate(fiber, update);\x0a    scheduleWork(fiber, expirationTime);\x0a  }\x0a};\x0a\x0afunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\x0a  var instance = workInProgress.stateNode;\x0a  if (typeof instance.shouldComponentUpdate === \x27function\x27) {\x0a    startPhaseTimer(workInProgress, \x27shouldComponentUpdate\x27);\x0a    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\x0a    stopPhaseTimer();\x0a\x0a    {\x0a      !(shouldUpdate !== undefined) ? warningWithoutStack$1(false, \x27%s.shouldComponentUpdate(): Returned undefined instead of a \x27 + \x27boolean value. Make sure to return true or false.\x27, getComponentName(ctor) || \x27Component\x27) : void 0;\x0a    }\x0a\x0a    return shouldUpdate;\x0a  }\x0a\x0a  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\x0a    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\x0a  }\x0a\x0a  return true;\x0a}\x0a\x0afunction checkClassInstance(workInProgress, ctor, newProps) {\x0a  var instance = workInProgress.stateNode;\x0a  {\x0a    var name = getComponentName(ctor) || \x27Component\x27;\x0a    var renderPresent = instance.render;\x0a\x0a    if (!renderPresent) {\x0a      if (ctor.prototype && typeof ctor.prototype.render === \x27function\x27) {\x0a        warningWithoutStack$1(false, \x27%s(...): No `render` method found on the returned component \x27 + \x27instance: did you accidentally return an object from the constructor?\x27, name);\x0a      } else {\x0a        warningWithoutStack$1(false, \x27%s(...): No `render` method found on the returned component \x27 + \x27instance: you may have forgotten to define `render`.\x27, name);\x0a      }\x0a    }\x0a\x0a    var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\x0a    !noGetInitialStateOnES6 ? warningWithoutStack$1(false, \x27getInitialState was defined on %s, a plain JavaScript class. \x27 + \x27This is only supported for classes created using React.createClass. \x27 + \x27Did you mean to define a state property instead?\x27, name) : void 0;\x0a    var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\x0a    !noGetDefaultPropsOnES6 ? warningWithoutStack$1(false, \x27getDefaultProps was defined on %s, a plain JavaScript class. \x27 + \x27This is only supported for classes created using React.createClass. \x27 + \x27Use a static property to define defaultProps instead.\x27, name) : void 0;\x0a    var noInstancePropTypes = !instance.propTypes;\x0a    !noInstancePropTypes ? warningWithoutStack$1(false, \x27propTypes was defined as an instance property on %s. Use a static \x27 + \x27property to define propTypes instead.\x27, name) : void 0;\x0a    var noInstanceContextType = !instance.contextType;\x0a    !noInstanceContextType ? warningWithoutStack$1(false, \x27contextType was defined as an instance property on %s. Use a static \x27 + \x27property to define contextType instead.\x27, name) : void 0;\x0a    var noInstanceContextTypes = !instance.contextTypes;\x0a    !noInstanceContextTypes ? warningWithoutStack$1(false, \x27contextTypes was defined as an instance property on %s. Use a static \x27 + \x27property to define contextTypes instead.\x27, name) : void 0;\x0a\x0a    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\x0a      didWarnAboutContextTypeAndContextTypes.add(ctor);\x0a      warningWithoutStack$1(false, \x27%s declares both contextTypes and contextType static properties. \x27 + \x27The legacy contextTypes property will be ignored.\x27, name);\x0a    }\x0a\x0a    var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== \x27function\x27;\x0a    !noComponentShouldUpdate ? warningWithoutStack$1(false, \x27%s has a method called \x27 + \x27componentShouldUpdate(). Did you mean shouldComponentUpdate()? \x27 + \x27The name is phrased as a question because the function is \x27 + \x27expected to return a value.\x27, name) : void 0;\x0a    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \x27undefined\x27) {\x0a      warningWithoutStack$1(false, \x27%s has a method called shouldComponentUpdate(). \x27 + \x27shouldComponentUpdate should not be used when extending React.PureComponent. \x27 + \x27Please extend React.Component if shouldComponentUpdate is used.\x27, getComponentName(ctor) || \x27A pure component\x27);\x0a    }\x0a    var noComponentDidUnmount = typeof instance.componentDidUnmount !== \x27function\x27;\x0a    !noComponentDidUnmount ? warningWithoutStack$1(false, \x27%s has a method called \x27 + \x27componentDidUnmount(). But there is no such lifecycle method. \x27 + \x27Did you mean componentWillUnmount()?\x27, name) : void 0;\x0a    var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== \x27function\x27;\x0a    !noComponentDidReceiveProps ? warningWithoutStack$1(false, \x27%s has a method called \x27 + \x27componentDidReceiveProps(). But there is no such lifecycle method. \x27 + \x27If you meant to update the state '}