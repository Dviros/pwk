var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:05:14 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Fri, 14 Dec 2018 04:41:57 GMT\x0aETag: \x2223dac-57cf40d168f40-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-32629/32630\x0aContent-Length: 32630\x0aKeep-Alive: timeout=5, max=69\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a//! moment.js\x0a\x0a;(function (global, factory) {\x0a    typeof exports === \x27object\x27 && typeof module !== \x27undefined\x27 ? module.exports = factory() :\x0a    typeof define === \x27function\x27 && define.amd ? define(factory) :\x0a    global.moment = factory()\x0a}(this, (function () { \x27use strict\x27;\x0a\x0a    var hookCallback;\x0a\x0a    function hooks () {\x0a        return hookCallback.apply(null, arguments);\x0a    }\x0a\x0a    // This is done to register the method called with moment()\x0a    // without creating circular dependencies.\x0a    function setHookCallback (callback) {\x0a        hookCallback = callback;\x0a    }\x0a\x0a    function isArray(input) {\x0a        return input instanceof Array || Object.prototype.toString.call(input) === \x27[object Array]\x27;\x0a    }\x0a\x0a    function isObject(input) {\x0a        // IE8 will treat undefined and null as object if it wasn\x27t for\x0a        // input != null\x0a        return input != null && Object.prototype.toString.call(input) === \x27[object Object]\x27;\x0a    }\x0a\x0a    function isObjectEmpty(obj) {\x0a        if (Object.getOwnPropertyNames) {\x0a            return (Object.getOwnPropertyNames(obj).length === 0);\x0a        } else {\x0a            var k;\x0a            for (k in obj) {\x0a                if (obj.hasOwnProperty(k)) {\x0a                    return false;\x0a                }\x0a            }\x0a            return true;\x0a        }\x0a    }\x0a\x0a    function isUndefined(input) {\x0a        return input === void 0;\x0a    }\x0a\x0a    function isNumber(input) {\x0a        return typeof input === \x27number\x27 || Object.prototype.toString.call(input) === \x27[object Number]\x27;\x0a    }\x0a\x0a    function isDate(input) {\x0a        return input instanceof Date || Object.prototype.toString.call(input) === \x27[object Date]\x27;\x0a    }\x0a\x0a    function map(arr, fn) {\x0a        var res = [], i;\x0a        for (i = 0; i \x3c arr.length; ++i) {\x0a            res.push(fn(arr[i], i));\x0a        }\x0a        return res;\x0a    }\x0a\x0a    function hasOwnProp(a, b) {\x0a        return Object.prototype.hasOwnProperty.call(a, b);\x0a    }\x0a\x0a    function extend(a, b) {\x0a        for (var i in b) {\x0a            if (hasOwnProp(b, i)) {\x0a                a[i] = b[i];\x0a            }\x0a        }\x0a\x0a        if (hasOwnProp(b, \x27toString\x27)) {\x0a            a.toString = b.toString;\x0a        }\x0a\x0a        if (hasOwnProp(b, \x27valueOf\x27)) {\x0a            a.valueOf = b.valueOf;\x0a        }\x0a\x0a        return a;\x0a    }\x0a\x0a    function createUTC (input, format, locale, strict) {\x0a        return createLocalOrUTC(input, format, locale, strict, true).utc();\x0a    }\x0a\x0a    function defaultParsingFlags() {\x0a        // We need to deep clone this object.\x0a        return {\x0a            empty           : false,\x0a            unusedTokens    : [],\x0a            unusedInput     : [],\x0a            overflow        : -2,\x0a            charsLeftOver   : 0,\x0a            nullInput       : false,\x0a            invalidMonth    : null,\x0a            invalidFormat   : false,\x0a            userInvalidated : false,\x0a            iso             : false,\x0a            parsedDateParts : [],\x0a            meridiem        : null,\x0a            rfc2822         : false,\x0a            weekdayMismatch : false\x0a        };\x0a    }\x0a\x0a    function getParsingFlags(m) {\x0a        if (m._pf == null) {\x0a            m._pf = defaultParsingFlags();\x0a        }\x0a        return m._pf;\x0a    }\x0a\x0a    var some;\x0a    if (Array.prototype.some) {\x0a        some = Array.prototype.some;\x0a    } else {\x0a        some = function (fun) {\x0a            var t = Object(this);\x0a            var len = t.length \x3e\x3e\x3e 0;\x0a\x0a            for (var i = 0; i \x3c len; i++) {\x0a                if (i in t && fun.call(this, t[i], i, t)) {\x0a                    return true;\x0a                }\x0a            }\x0a\x0a            return false;\x0a        };\x0a    }\x0a\x0a    function isValid(m) {\x0a        if (m._isValid == null) {\x0a            var flags = getParsingFlags(m);\x0a            var parsedParts = some.call(flags.parsedDateParts, function (i) {\x0a                return i != null;\x0a            });\x0a            var isNowValid = !isNaN(m._d.getTime()) &&\x0a                flags.overflow \x3c 0 &&\x0a                !flags.empty &&\x0a                !flags.invalidMonth &&\x0a                !flags.invalidWeekday &&\x0a                !flags.weekdayMismatch &&\x0a                !flags.nullInput &&\x0a                !flags.invalidFormat &&\x0a                !flags.userInvalidated &&\x0a                (!flags.meridiem || (flags.meridiem && parsedParts));\x0a\x0a            if (m._strict) {\x0a                isNowValid = isNowValid &&\x0a                    flags.charsLeftOver === 0 &&\x0a                    flags.unusedTokens.length === 0 &&\x0a                    flags.bigHour === undefined;\x0a            }\x0a\x0a            if (Object.isFrozen == null || !Object.isFrozen(m)) {\x0a                m._isValid = isNowValid;\x0a            }\x0a            else {\x0a                return isNowValid;\x0a            }\x0a        }\x0a        return m._isValid;\x0a    }\x0a\x0a    function createInvalid (flags) {\x0a        var m = createUTC(NaN);\x0a        if (flags != null) {\x0a            extend(getParsingFlags(m), flags);\x0a        }\x0a        else {\x0a            getParsingFlags(m).userInvalidated = true;\x0a        }\x0a\x0a        return m;\x0a    }\x0a\x0a    // Plugins that add properties should also add the key here (null value),\x0a    // so we can properly clone ourselves.\x0a    var momentProperties = hooks.momentProperties = [];\x0a\x0a    function copyConfig(to, from) {\x0a        var i, prop, val;\x0a\x0a        if (!isUndefined(from._isAMomentObject)) {\x0a            to._isAMomentObject = from._isAMomentObject;\x0a        }\x0a        if (!isUndefined(from._i)) {\x0a            to._i = from._i;\x0a        }\x0a        if (!isUndefined(from._f)) {\x0a            to._f = from._f;\x0a        }\x0a        if (!isUndefined(from._l)) {\x0a            to._l = from._l;\x0a        }\x0a        if (!isUndefined(from._strict)) {\x0a            to._strict = from._strict;\x0a        }\x0a        if (!isUndefined(from._tzm)) {\x0a            to._tzm = from._tzm;\x0a        }\x0a        if (!isUndefined(from._isUTC)) {\x0a            to._isUTC = from._isUTC;\x0a        }\x0a        if (!isUndefined(from._offset)) {\x0a            to._offset = from._offset;\x0a        }\x0a        if (!isUndefined(from._pf)) {\x0a            to._pf = getParsingFlags(from);\x0a        }\x0a        if (!isUndefined(from._locale)) {\x0a            to._locale = from._locale;\x0a        }\x0a\x0a        if (momentProperties.length \x3e 0) {\x0a            for (i = 0; i \x3c momentProperties.length; i++) {\x0a                prop = momentProperties[i];\x0a                val = from[prop];\x0a                if (!isUndefined(val)) {\x0a                    to[prop] = val;\x0a                }\x0a            }\x0a        }\x0a\x0a        return to;\x0a    }\x0a\x0a    var updateInProgress = false;\x0a\x0a    // Moment prototype object\x0a    function Moment(config) {\x0a        copyConfig(this, config);\x0a        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\x0a        if (!this.isValid()) {\x0a            this._d = new Date(NaN);\x0a        }\x0a        // Prevent infinite loop in case updateOffset creates new moment\x0a        // objects.\x0a        if (updateInProgress === false) {\x0a            updateInProgress = true;\x0a            hooks.updateOffset(this);\x0a            updateInProgress = false;\x0a        }\x0a    }\x0a\x0a    function isMoment (obj) {\x0a        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\x0a    }\x0a\x0a    function absFloor (number) {\x0a        if (number \x3c 0) {\x0a            // -0 -\x3e 0\x0a            return Math.ceil(number) || 0;\x0a        } else {\x0a            return Math.floor(number);\x0a        }\x0a    }\x0a\x0a    function toInt(argumentForCoercion) {\x0a        var coercedNumber = +argumentForCoercion,\x0a            value = 0;\x0a\x0a        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\x0a            value = absFloor(coercedNumber);\x0a        }\x0a\x0a        return value;\x0a    }\x0a\x0a    // compare two arrays, return the number of differences\x0a    function compareArrays(array1, array2, dontConvert) {\x0a        var len = Math.min(array1.length, array2.length),\x0a            lengthDiff = Math.abs(array1.length - array2.length),\x0a            diffs = 0,\x0a            i;\x0a        for (i = 0; i \x3c len; i++) {\x0a            if ((dontConvert && array1[i] !== array2[i]) ||\x0a                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\x0a                diffs++;\x0a            }\x0a        }\x0a        return diffs + lengthDiff;\x0a    }\x0a\x0a    function warn(msg) {\x0a        if (hooks.suppressDeprecationWarnings === false &&\x0a                (typeof console !==  \x27undefined\x27) && console.warn) {\x0a            console.warn(\x27Deprecation warning: \x27 + msg);\x0a        }\x0a    }\x0a\x0a    function deprecate(msg, fn) {\x0a        var firstTime = true;\x0a\x0a        return extend(function () {\x0a            if (hooks.deprecationHandler != null) {\x0a                hooks.deprecationHandler(null, msg);\x0a            }\x0a            if (firstTime) {\x0a                var args = [];\x0a                var arg;\x0a                for (var i = 0; i \x3c arguments.length; i++) {\x0a                    arg = \x27\x27;\x0a                    if (typeof arguments[i] === \x27object\x27) {\x0a                        arg += \x27\x5cn[\x27 + i + \x27] \x27;\x0a                        for (var key in arguments[0]) {\x0a                            arg += key + \x27: \x27 + arguments[0][key] + \x27, \x27;\x0a                        }\x0a                        arg = arg.slice(0, -2); // Remove trailing comma and space\x0a                    } else {\x0a                        arg = arguments[i];\x0a                    }\x0a                    args.push(arg);\x0a                }\x0a                warn(msg + \x27\x5cnArguments: \x27 + Array.prototype.slice.call(args).join(\x27\x27) + \x27\x5cn\x27 + (new Error()).stack);\x0a                firstTime = false;\x0a            }\x0a            return fn.apply(this, arguments);\x0a        }, fn);\x0a    }\x0a\x0a    var deprecations = {};\x0a\x0a    function deprecateSimple(name, msg) {\x0a        if (hooks.deprecationHandler != null) {\x0a            hooks.deprecationHandler(name, msg);\x0a        }\x0a        if (!deprecations[name]) {\x0a            warn(msg);\x0a            deprecations[name] = true;\x0a        }\x0a    }\x0a\x0a    hooks.suppressDeprecationWarnings = false;\x0a    hooks.deprecationHandler = null;\x0a\x0a    function isFunction(input) {\x0a        return input instanceof Function || Object.prototype.toString.call(input) === \x27[object Function]\x27;\x0a    }\x0a\x0a    function set (config) {\x0a        var prop, i;\x0a        for (i in config) {\x0a            prop = config[i];\x0a            if (isFunction(prop)) {\x0a                this[i] = prop;\x0a            } else {\x0a                this[\x27_\x27 + i] = prop;\x0a            }\x0a        }\x0a        this._config = config;\x0a        // Lenient ordinal parsing accepts just a number in addition to\x0a        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\x0a        // TODO: Remove \x22ordinalParse\x22 fallback in next major release.\x0a        this._dayOfMonthOrdinalParseLenient = new RegExp(\x0a            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\x0a                \x27|\x27 + (/\x5cd{1,2}/).source);\x0a    }\x0a\x0a    function mergeConfigs(parentConfig, childConfig) {\x0a        var res = extend({}, parentConfig), prop;\x0a        for (prop in childConfig) {\x0a            if (hasOwnProp(childConfig, prop)) {\x0a                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\x0a                    res[prop] = {};\x0a                    extend(res[prop], parentConfig[prop]);\x0a                    extend(res[prop], childConfig[prop]);\x0a                } else if (childConfig[prop] != null) {\x0a                    res[prop] = childConfig[prop];\x0a                } else {\x0a                    delete res[prop];\x0a                }\x0a            }\x0a        }\x0a        for (prop in parentConfig) {\x0a            if (hasOwnProp(parentConfig, prop) &&\x0a                    !hasOwnProp(childConfig, prop) &&\x0a                    isObject(parentConfig[prop])) {\x0a                // make sure changes to properties don\x27t modify parent config\x0a                res[prop] = extend({}, res[prop]);\x0a            }\x0a        }\x0a        return res;\x0a    }\x0a\x0a    function Locale(config) {\x0a        if (config != null) {\x0a            this.set(config);\x0a        }\x0a    }\x0a\x0a    var keys;\x0a\x0a    if (Object.keys) {\x0a        keys = Object.keys;\x0a    } else {\x0a        keys = function (obj) {\x0a            var i, res = [];\x0a            for (i in obj) {\x0a                if (hasOwnProp(obj, i)) {\x0a                    res.push(i);\x0a                }\x0a            }\x0a            return res;\x0a        };\x0a    }\x0a\x0a    var defaultCalendar = {\x0a        sameDay : \x27[Today at] LT\x27,\x0a        nextDay : \x27[Tomorrow at] LT\x27,\x0a        nextWeek : \x27dddd [at] LT\x27,\x0a        lastDay : \x27[Yesterday at] LT\x27,\x0a        lastWeek : \x27[Last] dddd [at] LT\x27,\x0a        sameElse : \x27L\x27\x0a    };\x0a\x0a    function calendar (key, mom, now) {\x0a        var output = this._calendar[key] || this._calendar[\x27sameElse\x27];\x0a        return isFunction(output) ? output.call(mom, now) : output;\x0a    }\x0a\x0a    var defaultLongDateFormat = {\x0a        LTS  : \x27h:mm:ss A\x27,\x0a        LT   : \x27h:mm A\x27,\x0a        L    : \x27MM/DD/YYYY\x27,\x0a        LL   : \x27MMMM D, YYYY\x27,\x0a        LLL  : \x27MMMM D, YYYY h:mm A\x27,\x0a        LLLL : \x27dddd, MMMM D, YYYY h:mm A\x27\x0a    };\x0a\x0a    function longDateFormat (key) {\x0a        var format = this._longDateFormat[key],\x0a            formatUpper = this._longDateFormat[key.toUpperCase()];\x0a\x0a        if (format || !formatUpper) {\x0a            return format;\x0a        }\x0a\x0a        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\x0a            return val.slice(1);\x0a        });\x0a\x0a        return this._longDateFormat[key];\x0a    }\x0a\x0a    var defaultInvalidDate = \x27Invalid date\x27;\x0a\x0a    function invalidDate () {\x0a        return this._invalidDate;\x0a    }\x0a\x0a    var defaultOrdinal = \x27%d\x27;\x0a    var defaultDayOfMonthOrdinalParse = /\x5cd{1,2}/;\x0a\x0a    function ordinal (number) {\x0a        return this._ordinal.replace(\x27%d\x27, number);\x0a    }\x0a\x0a    var defaultRelativeTime = {\x0a        future : \x27in %s\x27,\x0a        past   : \x27%s ago\x27,\x0a        s  : \x27a few seconds\x27,\x0a        ss : \x27%d seconds\x27,\x0a        m  : \x27a minute\x27,\x0a        mm : \x27%d minutes\x27,\x0a        h  : \x27an hour\x27,\x0a        hh : \x27%d hours\x27,\x0a        d  : \x27a day\x27,\x0a        dd : \x27%d days\x27,\x0a        M  : \x27a month\x27,\x0a        MM : \x27%d months\x27,\x0a        y  : \x27a year\x27,\x0a        yy : \x27%d years\x27\x0a    };\x0a\x0a    function relativeTime (number, withoutSuffix, string, isFuture) {\x0a        var output = this._relativeTime[string];\x0a        return (isFunction(output)) ?\x0a            output(number, withoutSuffix, string, isFuture) :\x0a            output.replace(/%d/i, number);\x0a    }\x0a\x0a    function pastFuture (diff, output) {\x0a        var format = this._relativeTime[diff \x3e 0 ? \x27future\x27 : \x27past\x27];\x0a        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\x0a    }\x0a\x0a    var aliases = {};\x0a\x0a    function addUnitAlias (unit, shorthand) {\x0a        var lowerCase = unit.toLowerCase();\x0a        aliases[lowerCase] = aliases[lowerCase + \x27s\x27] = aliases[shorthand] = unit;\x0a    }\x0a\x0a    function normalizeUnits(units) {\x0a        return typeof units === \x27string\x27 ? aliases[units] || aliases[units.toLowerCase()] : undefined;\x0a    }\x0a\x0a    function normalizeObjectUnits(inputObject) {\x0a        var normalizedInput = {},\x0a            normalizedProp,\x0a            prop;\x0a\x0a        for (prop in inputObject) {\x0a            if (hasOwnProp(inputObject, prop)) {\x0a                normalizedProp = normalizeUnits(prop);\x0a                if (normalizedProp) {\x0a                    normalizedInput[normalizedProp] = inputObject[prop];\x0a                }\x0a            }\x0a        }\x0a\x0a        return normalizedInput;\x0a    }\x0a\x0a    var priorities = {};\x0a\x0a    function addUnitPriority(unit, priority) {\x0a        priorities[unit] = priority;\x0a    }\x0a\x0a    function getPrioritizedUnits(unitsObj) {\x0a        var units = [];\x0a        for (var u in unitsObj) {\x0a            units.push({unit: u, priority: priorities[u]});\x0a        }\x0a        units.sort(function (a, b) {\x0a            return a.priority - b.priority;\x0a        });\x0a        return units;\x0a    }\x0a\x0a    function zeroFill(number, targetLength, forceSign) {\x0a        var absNumber = \x27\x27 + Math.abs(number),\x0a            zerosToFill = targetLength - absNumber.length,\x0a            sign = number \x3e= 0;\x0a        return (sign ? (forceSign ? \x27+\x27 : \x27\x27) : \x27-\x27) +\x0a            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\x0a    }\x0a\x0a    var formattingTokens = /(\x5c[[^\x5c[]*\x5c])|(\x5c\x5c)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\x0a\x0a    var localFormattingTokens = /(\x5c[[^\x5c[]*\x5c])|(\x5c\x5c)?(LTS|LT|LL?L?L?|l{1,4})/g;\x0a\x0a    var formatFunctions = {};\x0a\x0a    var formatTokenFunctions = {};\x0a\x0a    // token:    \x27M\x27\x0a    // padded:   [\x27MM\x27, 2]\x0a    // ordinal:  \x27Mo\x27\x0a    // callback: function () { this.month() + 1 }\x0a    function addFormatToken (token, padded, ordinal, callback) {\x0a        var func = callback;\x0a        if (typeof callback === \x27string\x27) {\x0a            func = function () {\x0a                return this[callback]();\x0a            };\x0a        }\x0a        if (token) {\x0a            formatTokenFunctions[token] = func;\x0a        }\x0a        if (padded) {\x0a            formatTokenFunctions[padded[0]] = function () {\x0a                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\x0a            };\x0a        }\x0a        if (ordinal) {\x0a            formatTokenFunctions[ordinal] = function () {\x0a                return this.localeData().ordinal(func.apply(this, arguments), token);\x0a            };\x0a        }\x0a    }\x0a\x0a    function removeFormattingTokens(input) {\x0a        if (input.match(/\x5c[[\x5cs\x5cS]/)) {\x0a            return input.replace(/^\x5c[|\x5c]$/g, \x27\x27);\x0a        }\x0a        return input.replace(/\x5c\x5c/g, \x27\x27);\x0a    }\x0a\x0a    function makeFormatFunction(format) {\x0a        var array = format.match(formattingTokens), i, length;\x0a\x0a        for (i = 0, length = array.length; i \x3c length; i++) {\x0a            if (formatTokenFunctions[array[i]]) {\x0a                array[i] = formatTokenFunctions[array[i]];\x0a            } else {\x0a                array[i] = removeFormattingTokens(array[i]);\x0a            }\x0a        }\x0a\x0a        return function (mom) {\x0a            var output = \x27\x27, i;\x0a            for (i = 0; i \x3c length; i++) {\x0a                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\x0a            }\x0a            return output;\x0a        };\x0a    }\x0a\x0a    // format date using native date object\x0a    function formatMoment(m, format) {\x0a        if (!m.isValid()) {\x0a            return m.localeData().invalidDate();\x0a        }\x0a\x0a        format = expandFormat(format, m.localeData());\x0a        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\x0a\x0a        return formatFunctions[format](m);\x0a    }\x0a\x0a    function expandFormat(format, locale) {\x0a        var i = 5;\x0a\x0a        function replaceLongDateFormatTokens(input) {\x0a            return locale.longDateFormat(input) || input;\x0a        }\x0a\x0a        localFormattingTokens.lastIndex = 0;\x0a        while (i \x3e= 0 && localFormattingTokens.test(format)) {\x0a            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\x0a            localFormattingTokens.lastIndex = 0;\x0a            i -= 1;\x0a        }\x0a\x0a        return format;\x0a    }\x0a\x0a    var match1         = /\x5cd/;            //       0 - 9\x0a    var match2         = /\x5cd\x5cd/;          //      00 - 99\x0a    var match3         = /\x5cd{3}/;         //     000 - 999\x0a    var match4         = /\x5cd{4}/;         //    0000 - 9999\x0a    var match6         = /[+-]?\x5cd{6}/;    // -999999 - 999999\x0a    var match1to2      = /\x5cd\x5cd?/;         //       0 - 99\x0a    var match3to4      = /\x5cd\x5cd\x5cd\x5cd?/;     //     999 - 9999\x0a    var match5to6      = /\x5cd\x5cd\x5cd\x5cd\x5cd\x5cd?/; //   99999 - 999999\x0a    var match1to3      = /\x5cd{1,3}/;       //       0 - 999\x0a    var match1to4      = /\x5cd{1,4}/;       //       0 - 9999\x0a    var match1to6      = /[+-]?\x5cd{1,6}/;  // -999999 - 999999\x0a\x0a    var matchUnsigned  = /\x5cd+/;           //       0 - inf\x0a    var matchSigned    = /[+-]?\x5cd+/;      //    -inf - inf\x0a\x0a    var matchOffset    = /Z|[+-]\x5cd\x5cd:?\x5cd\x5cd/gi; // +00:00 -00:00 +0000 -0000 or Z\x0a    var matchShortOffset = /Z|[+-]\x5cd\x5cd(?::?\x5cd\x5cd)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\x0a\x0a    var matchTimestamp = /[+-]?\x5cd+(\x5c.\x5cd{1,3})?/; // 123456789 123456789.123\x0a\x0a    // any word (or two) characters or numbers including two/three word month in arabic.\x0a    // includes scottish gaelic two word and hyphenated months\x0a    var matchWord = /[0-9]{0,256}[\x27a-z\x5cu00A0-\x5cu05FF\x5cu0700-\x5cuD7FF\x5cuF900-\x5cuFDCF\x5cuFDF0-\x5cuFF07\x5cuFF10-\x5cuFFEF]{1,256}|[\x5cu0600-\x5cu06FF\x5c/]{1,256}(\x5cs*?[\x5cu0600-\x5cu06FF]{1,256}){1,2}/i;\x0a\x0a    var regexes = {};\x0a\x0a    function addRegexToken (token, regex, strictRegex) {\x0a        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\x0a            return (isStrict && strictRegex) ? strictRegex : regex;\x0a        };\x0a    }\x0a\x0a    function getParseRegexForToken (token, config) {\x0a        if (!hasOwnProp(regexes, token)) {\x0a            return new RegExp(unescapeFormat(token));\x0a        }\x0a\x0a        return regexes[token](config._strict, config._locale);\x0a    }\x0a\x0a    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\x0a    function unescapeFormat(s) {\x0a        return regexEscape(s.replace(\x27\x5c\x5c\x27, \x27\x27).replace(/\x5c\x5c(\x5c[)|\x5c\x5c(\x5c])|\x5c[([^\x5c]\x5c[]*)\x5c]|\x5c\x5c(.)/g, function (matched, p1, p2, p3, p4) {\x0a            return p1 || p2 || p3 || p4;\x0a        }));\x0a    }\x0a\x0a    function regexEscape(s) {\x0a        return s.replace(/[-\x5c/\x5c\x5c^$*+?.()|[\x5c]{}]/g, \x27\x5c\x5c$&\x27);\x0a    }\x0a\x0a    var tokens = {};\x0a\x0a    function addParseToken (token, callback) {\x0a        var i, func = callback;\x0a        if (typeof token === \x27string\x27) {\x0a            token = [token];\x0a        }\x0a        if (isNumber(callback)) {\x0a            func = function (input, array) {\x0a                array[callback] = toInt(input);\x0a            };\x0a        }\x0a        for (i = 0; i \x3c token.length; i++) {\x0a            tokens[token[i]] = func;\x0a        }\x0a    }\x0a\x0a    function addWeekParseToken (token, callback) {\x0a        addParseToken(token, function (input, array, config, token) {\x0a            config._w = config._w || {};\x0a            callback(input, config._w, config, token);\x0a        });\x0a    }\x0a\x0a    function addTimeToArrayFromToken(token, input, config) {\x0a        if (input != null && hasOwnProp(tokens, token)) {\x0a            tokens[token](input, config._a, config, token);\x0a        }\x0a    }\x0a\x0a    var YEAR = 0;\x0a    var MONTH = 1;\x0a    var DATE = 2;\x0a    var HOUR = 3;\x0a    var MINUTE = 4;\x0a    var SECOND = 5;\x0a    var MILLISECOND = 6;\x0a    var WEEK = 7;\x0a    var WEEKDAY = 8;\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27Y\x27, 0, 0, function () {\x0a        var y = this.year();\x0a        return y \x3c= 9999 ? \x27\x27 + y : \x27+\x27 + y;\x0a    });\x0a\x0a    addFormatToken(0, [\x27YY\x27, 2], 0, function () {\x0a        return this.year() % 100;\x0a    });\x0a\x0a    addFormatToken(0, [\x27YYYY\x27,   4],       0, \x27year\x27);\x0a    addFormatToken(0, [\x27YYYYY\x27,  5],       0, \x27year\x27);\x0a    addFormatToken(0, [\x27YYYYYY\x27, 6, true], 0, \x27year\x27);\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27year\x27, \x27y\x27);\x0a\x0a    // PRIORITIES\x0a\x0a    addUnitPriority(\x27year\x27, 1);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27Y\x27,      matchSigned);\x0a    addRegexToken(\x27YY\x27,     match1to2, match2);\x0a    addRegexToken(\x27YYYY\x27,   match1to4, match4);\x0a    addRegexToken(\x27YYYYY\x27,  match1to6, match6);\x0a    addRegexToken(\x27YYYYYY\x27, match1to6, match6);\x0a\x0a    addParseToken([\x27YYYYY\x27, \x27YYYYYY\x27], YEAR);\x0a    addParseToken(\x27YYYY\x27, function (input, array) {\x0a        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\x0a    });\x0a    addParseToken(\x27YY\x27, function (input, array) {\x0a        array[YEAR] = hooks.parseTwoDigitYear(input);\x0a    });\x0a    addParseToken(\x27Y\x27, function (input, array) {\x0a        array[YEAR] = parseInt(input, 10);\x0a    });\x0a\x0a    // HELPERS\x0a\x0a    function daysInYear(year) {\x0a        return isLeapYear(year) ? 366 : 365;\x0a    }\x0a\x0a    function isLeapYear(year) {\x0a        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\x0a    }\x0a\x0a    // HOOKS\x0a\x0a    hooks.parseTwoDigitYear = function (input) {\x0a        return toInt(input) + (toInt(input) \x3e 68 ? 1900 : 2000);\x0a    };\x0a\x0a    // MOMENTS\x0a\x0a    var getSetYear = makeGetSet(\x27FullYear\x27, true);\x0a\x0a    function getIsLeapYear () {\x0a        return isLeapYear(this.year());\x0a    }\x0a\x0a    function makeGetSet (unit, keepTime) {\x0a        return function (value) {\x0a            if (value != null) {\x0a                set$1(this, unit, value);\x0a                hooks.updateOffset(this, keepTime);\x0a                return this;\x0a            } else {\x0a                return get(this, unit);\x0a            }\x0a        };\x0a    }\x0a\x0a    function get (mom, unit) {\x0a        return mom.isValid() ?\x0a            mom._d[\x27get\x27 + (mom._isUTC ? \x27UTC\x27 : \x27\x27) + unit]() : NaN;\x0a    }\x0a\x0a    function set$1 (mom, unit, value) {\x0a        if (mom.isValid() && !isNaN(value)) {\x0a            if (unit === \x27FullYear\x27 && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\x0a                mom._d[\x27set\x27 + (mom._isUTC ? \x27UTC\x27 : \x27\x27) + unit](value, mom.month(), daysInMonth(value, mom.month()));\x0a            }\x0a            else {\x0a                mom._d[\x27set\x27 + (mom._isUTC ? \x27UTC\x27 : \x27\x27) + unit](value);\x0a            }\x0a        }\x0a    }\x0a\x0a    // MOMENTS\x0a\x0a    function stringGet (units) {\x0a        units = normalizeUnits(units);\x0a        if (isFunction(this[units])) {\x0a            return this[units]();\x0a        }\x0a        return this;\x0a    }\x0a\x0a\x0a    function stringSet (units, value) {\x0a        if (typeof units === \x27object\x27) {\x0a            units = normalizeObjectUnits(units);\x0a            var prioritized = getPrioritizedUnits(units);\x0a            for (var i = 0; i \x3c prioritized.length; i++) {\x0a                this[prioritized[i].unit](units[prioritized[i].unit]);\x0a            }\x0a        } else {\x0a            units = normalizeUnits(units);\x0a            if (isFunction(this[units])) {\x0a                return this[units](value);\x0a            }\x0a        }\x0a        return this;\x0a    }\x0a\x0a    function mod(n, x) {\x0a        return ((n % x) + x) % x;\x0a    }\x0a\x0a    var indexOf;\x0a\x0a    if (Array.prototype.indexOf) {\x0a        indexOf = Array.prototype.indexOf;\x0a    } else {\x0a        indexOf = function (o) {\x0a            // I know\x0a            var i;\x0a            for (i = 0; i \x3c this.length; ++i) {\x0a                if (this[i] === o) {\x0a                    return i;\x0a                }\x0a            }\x0a            return -1;\x0a        };\x0a    }\x0a\x0a    function daysInMonth(year, month) {\x0a        if (isNaN(year) || isNaN(month)) {\x0a            return NaN;\x0a        }\x0a        var modMonth = mod(month, 12);\x0a        year += (month - modMonth) / 12;\x0a        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\x0a    }\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27M\x27, [\x27MM\x27, 2], \x27Mo\x27, function () {\x0a        return this.month() + 1;\x0a    });\x0a\x0a    addFormatToken(\x27MMM\x27, 0, 0, function (format) {\x0a        return this.localeData().monthsShort(this, format);\x0a    });\x0a\x0a    addFormatToken(\x27MMMM\x27, 0, 0, function (format) {\x0a        return this.localeData().months(this, format);\x0a    });\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27month\x27, \x27M\x27);\x0a\x0a    // PRIORITY\x0a\x0a    addUnitPriority(\x27month\x27, 8);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27M\x27,    match1to2);\x0a    addRegexToken(\x27MM\x27,   match1to2, match2);\x0a    addRegexToken(\x27MMM\x27,  function (isStrict, locale) {\x0a        return locale.monthsShortRegex(isStrict);\x0a    });\x0a    addRegexToken(\x27MMMM\x27, function (isStrict, locale) {\x0a        return locale.monthsRegex(isStrict);\x0a    });\x0a\x0a    addParseToken([\x27M\x27, \x27MM\x27], function (input, array) {\x0a        array[MONTH] = toInt(input) - 1;\x0a    });\x0a\x0a    addParseToken([\x27MMM\x27, \x27MMMM\x27], function (input, array, config, token) {\x0a        var month = config._locale.monthsParse(input, token, config._strict);\x0a        // if we didn\x27t find a month name, mark the date as invalid.\x0a        if (month != null) {\x0a            array[MONTH] = month;\x0a        } else {\x0a            getParsingFlags(config).invalidMonth = input;\x0a        }\x0a    });\x0a\x0a    // LOCALES\x0a\x0a    var MONTHS_IN_FORMAT = /D[oD]?(\x5c[[^\x5c[\x5c]]*\x5c]|\x5cs)+MMMM?/;\x0a    var defaultLocaleMonths = \x27January_February_March_April_May_June_July_August_September_October_November_December\x27.split(\x27_\x27);\x0a    function localeMonths (m, format) {\x0a        if (!m) {\x0a            return isArray(this._months) ? this._months :\x0a                this._months[\x27standalone\x27];\x0a        }\x0a        return isArray(this._months) ? this._months[m.month()] :\x0a            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? \x27format\x27 : \x27standalone\x27][m.month()];\x0a    }\x0a\x0a    var defaultLocaleMonthsShort = \x27Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec\x27.split(\x27_\x27);\x0a    function localeMonthsShort (m, format) {\x0a        if (!m) {\x0a            return isArray(this._monthsShort) ? this._monthsShort :\x0a                this._monthsShort[\x27standalone\x27];\x0a        }\x0a        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\x0a            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? \x27format\x27 : \x27standalone\x27][m.month()];\x0a    }\x0a\x0a    function handleStrictParse(monthName, format, strict) {\x0a        var i, ii, mom, llc = monthName.toLocaleLowerCase();\x0a        if (!this._monthsParse) {\x0a            // this is not used\x0a            this._monthsParse = [];\x0a            this._longMonthsParse = [];\x0a            this._shortMonthsParse = [];\x0a            for (i = 0; i \x3c 12; ++i) {\x0a                mom = createUTC([2000, i]);\x0a                this._shortMonthsParse[i] = this.monthsShort(mom, \x27\x27).toLocaleLowerCase();\x0a                this._longMonthsParse[i] = this.months(mom, \x27\x27).toLocaleLowerCase();\x0a            }\x0a        }\x0a\x0a        if (strict) {\x0a            if (format === \x27MMM\x27) {\x0a                ii = indexOf.call(this._shortMonthsParse, llc);\x0a                return ii !== -1 ? ii : null;\x0a            } else {\x0a                ii = indexOf.call(this._longMonthsParse, llc);\x0a                return ii !== -1 ? ii : null;\x0a            }\x0a        } else {\x0a            if (format === \x27MMM\x27) {\x0a                ii = indexOf.call(this._shortMonthsParse, llc);\x0a                if (ii !== -1) {\x0a                    return ii;\x0a                }\x0a                ii = indexOf.call(this._longMonthsParse, llc);\x0a                return ii !== -1 ? ii : null;\x0a            } else {\x0a                ii = indexOf.call(this._longMonthsParse, llc);\x0a                if (ii !== -1) {\x0a                    return ii;\x0a                }\x0a                ii = indexOf.call(this._shortMonthsParse, llc);\x0a                return ii !== -1 ? ii : null;\x0a            }\x0a        }\x0a    }\x0a\x0a    function localeMonthsParse (monthName, format, strict) {\x0a        var i, mom, regex;\x0a\x0a        if (this._monthsParseExact) {\x0a            return handleStrictParse.call(this, monthName, format, strict);\x0a        }\x0a\x0a        if (!this._monthsParse) {\x0a            this._monthsParse = [];\x0a            this._longMonthsParse = [];\x0a            this._shortMonthsParse = [];\x0a        }\x0a\x0a        // TODO: add sorting\x0a        // Sorting makes sure if one month (or abbr) is a prefix of another\x0a        // see sorting in computeMonthsParse\x0a        for (i = 0; i \x3c 12; i++) {\x0a            // make the regex if we don\x27t have it already\x0a            mom = createUTC([2000, i]);\x0a            if (strict && !this._longMonthsParse[i]) {\x0a                this._longMonthsParse[i] = new RegExp(\x27^\x27 + this.months(mom, \x27\x27).replace(\x27.\x27, \x27\x27) + \x27$\x27, \x27i\x27);\x0a                this._shortMonthsParse[i] = new RegExp(\x27^\x27 + this.monthsShort(mom, \x27\x27).replace(\x27.\x27, \x27\x27) + \x27$\x27, \x27i\x27);\x0a            }\x0a            if (!strict && !this._monthsParse[i]) {\x0a                regex = \x27^\x27 + this.months(mom, \x27\x27) + \x27|^\x27 + this.monthsShort(mom, \x27\x27);\x0a                this._monthsParse[i] = new RegExp(regex.replace(\x27.\x27, \x27\x27), \x27i\x27);\x0a            }\x0a            // test the regex\x0a            if (strict && format === \x27MMMM\x27 && this._longMonthsParse[i].test(monthName)) {\x0a                return i;\x0a            } else if (strict && format === \x27MMM\x27 && this._shortMonthsParse[i].test(monthName)) {\x0a                return i;\x0a            } else if (!strict && this._monthsParse[i].test(monthName)) {\x0a                return i;\x0a            }\x0a        }\x0a    }\x0a\x0a    // MOMENTS\x0a\x0a    function setMonth (mom, value) {\x0a        var dayOfMonth;\x0a\x0a        if (!mom.isValid()) {\x0a            // No op\x0a            return mom;\x0a        }\x0a\x0a        if (typeof value === \x27string\x27) {\x0a            if (/^\x5cd+$/.test(value)) {\x0a                value = toInt(value);\x0a            } else {\x0a                value = mom.localeData().monthsParse(value);\x0a                // TODO: Another silent failure?\x0a                if (!isNumber(value)) {\x0a                    return mom;\x0a                }\x0a            }\x0a        }\x0a\x0a        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\x0a        mom._d[\x27set\x27 + (mom._isUTC ? \x27UTC\x27 : \x27\x27) + \x27Month\x27](value, dayOfMonth);\x0a        return mom;\x0a    }\x0a\x0a    function getSetMonth (value) {\x0a        if (value != null) {\x0a            setMonth(this, value);\x0a            hooks.updateOffset(this, true);\x0a            return this;\x0a        } else {\x0a            return get(this, \x27Month\x27);\x0a        }\x0a    }\x0a\x0a    function getDaysInMonth () {\x0a        return daysInMonth(this.year(), this.month());\x0a    }\x0a\x0a    var defaultMonthsShortRegex = matchWord;\x0a    function monthsShortRegex (isStrict) {\x0a        if (this._monthsParseExact) {\x0a            if (!hasOwnProp(this, \x27_monthsRegex\x27)) {\x0a                computeMonthsParse.call(this);\x0a            }\x0a            if (isStrict) {\x0a                return this._monthsShortStrictRegex;\x0a            } else {\x0a                return this._monthsShortRegex;\x0a            }\x0a        } else {\x0a            if (!hasOwnProp(this, \x27_monthsShortRegex\x27)) {\x0a                this._monthsShortRegex = defaultMonthsShortRegex;\x0a            }\x0a            return this._monthsShortStrictRegex && isStrict ?\x0a                this._monthsShortStrictRegex : this._monthsShortRegex;\x0a        }\x0a    }\x0a\x0a    var defaultMonthsRegex = matchWord;\x0a    function monthsRegex (isStrict) {\x0a        if (this._monthsParseExact) {\x0a            if (!hasOwnProp(this, \x27_monthsRegex\x27)) {\x0a                computeMonthsParse.call(this);\x0a            }\x0a            if (isStrict) {\x0a                return this._monthsStrictRegex;\x0a            } else {\x0a                return this._monthsRegex;\x0a            }\x0a        } else {\x0a            if (!hasOwnProp(this, \x27_monthsRegex\x27)) {\x0a                this._monthsRegex = defaultMonthsRegex;\x0a            }\x0a            return this._monthsStrictRegex && isStrict ?\x0a                this._monthsStrictRegex : this._monthsRegex;\x0a        }\x0a    }\x0a\x0a    function computeMonthsParse () {\x0a        function cmpLenRev(a, b) {\x0a            return b.length - a.length;\x0a        }\x0a\x0a        var shortPieces = [], longPieces = [], mixedPieces = [],\x0a            i, mom;\x0a        for (i = 0; i \x3c 12; i++) {\x0a            // make the regex if we don\x27t have it already\x0a            mom = createUTC([2000, i]);\x0a            shortPieces.push(this.monthsShort(mom, \x27\x27));\x0a            longPieces.push(this.months(mom, \x27\x27));\x0a            mixedPieces.push(this.months(mom, \x27\x27));\x0a            mixedPieces.push(this.monthsShort(mom, \x27\x27));\x0a        }\x0a        // Sorting makes sure if one month (or abbr) is a prefix of another it\x0a        // will match the longer piece.\x0a        shortPieces.sort(cmpLenRev);\x0a        longPieces.sort(cmpLenRev);\x0a        mixedPieces.sort(cmpLenRev);\x0a        for (i = 0; i \x3c 12; i++) {\x0a            shortPieces[i] = regexEscape(shortPieces[i]);\x0a            longPieces[i] = regexEscape(longPieces[i]);\x0a        }\x0a        for (i = 0; i \x3c 24; i++) {\x0a            mixedPieces[i] = regexEscape(mixedPieces[i]);\x0a        }\x0a\x0a        this._monthsRegex = new RegExp(\x27^(\x27 + mixedPieces.join(\x27|\x27) + \x27)\x27, \x27i\x27);\x0a        this._monthsShortRegex = this._monthsRegex;\x0a        this._monthsStrictRegex = new RegExp(\x27^(\x27 + longPieces.join(\x27|\x27) + \x27)\x27, \x27i\x27);\x0a        this._monthsShortStrictRegex = new RegExp(\x27^(\x27 + shortPieces.join(\x27|\x27) + \x27)\x27, \x27i\x27);\x0a    }\x0a\x0a    function createDate (y, m, d, h, M, s, ms) {\x0a        // can\x27t just apply() to create a date:\x0a        // https://stackoverflow.com/q/181348\x0a        var date = new Date(y, m, d, h, M, s, ms);\x0a\x0a        // the date constructor remaps years 0-99 to 1900-1999\x0a        if (y \x3c 100 && y \x3e= 0 && isFinite(date.getFullYear())) {\x0a            date.setFullYear(y);\x0a        }\x0a        return date;\x0a    }\x0a\x0a    function createUTCDate (y) {\x0a        var date = new Date(Date.UTC.apply(null, arguments));\x0a\x0a        // the Date.UTC function remaps years 0-99 to 1900-1999\x0a        if (y \x3c 100 && y \x3e= 0 && isFinite(date.getUTCFullYear())) {\x0a            date.setUTCFullYear(y);\x0a        }\x0a        return date;\x0a    }\x0a\x0a    // start-of-first-week - start-of-year\x0a    function firstWeekOffset(year, dow, doy) {\x0a        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\x0a            fwd = 7 + dow - doy,\x0a            // first-week day local weekday -- which local weekday is fwd\x0a            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\x0a\x0a        return -fwdlw + fwd - 1;\x0a    }\x0a\x0a    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\x0a    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\x0a        var localWeekday = (7 + weekday - dow) % 7,\x0a            weekOffset = firstWeekOffset(year, dow, doy),\x0a            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\x0a            resYear, resDayOfYear;\x0a\x0a        if (dayOfYear \x3c= 0) {\x0a            resYear = year - 1;\x0a            resDayOfYear = daysInYear(resYear) + dayOfYear;\x0a        } else if (dayOfYear \x3e daysInYear(year)) {\x0a            resYear = year + 1;\x0a            resDayOfYear = dayOfYear - daysInYear(year);\x0a        } else {\x0a            resYear = year;\x0a            resDayOfYear = dayOfYear;\x0a        }\x0a\x0a        return {\x0a            year: resYear,\x0a            dayOfYear: resDayOfYear\x0a        };\x0a    }\x0a\x0a    function weekOfYear(mom, dow, doy) {\x0a        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\x0a            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\x0a            resWeek, resYear;\x0a\x0a        if (week \x3c 1) {\x0a            resYear = mom.year() - 1;\x0a            resWeek = week + weeksInYear(resYear, dow, doy);\x0a        } else if (week \x3e weeksInYear(mom.year(), dow, doy)) {\x0a            resWeek = week - weeksInYear(mom.year(), dow, doy);\x0a            resYear = mom.year() + 1;\x0a        } else {\x0a            resYear = mom.year();\x0a            resWeek = week;\x0a        }\x0a\x0a        return {\x0a            week: resWeek,\x0a            year: resYear\x0a        };\x0a    }\x0a\x0a    function weeksInYear(year, dow, doy) {\x0a        var weekOffset = firstWeekOffset(year, dow, doy),\x0a            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\x0a        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\x0a    }\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27w\x27, [\x27ww\x27, 2], \x27wo\x27, \x27week\x27);\x0a    addFormatToken(\x27W\x27, [\x27WW\x27, 2], \x27Wo\x27, \x27isoWeek\x27);\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27week\x27, \x27w\x27);\x0a    addUnitAlias(\x27isoWeek\x27, \x27W\x27);\x0a\x0a    // PRIORITIES\x0a\x0a    addUnitPriority(\x27week\x27, 5);\x0a    addUnitPriority(\x27isoWeek\x27, 5);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27w\x27,  match1to2);\x0a    addRegexToken(\x27ww\x27, match1to2, match2);\x0a    addRegexToken(\x27W\x27,  match1to2);\x0a    addRegexToken(\x27WW\x27, match1to2, match2);\x0a\x0a    addWeekParseToken([\x27w\x27, \x27ww\x27, \x27W\x27, \x27WW\x27], function (input, week, config, token) {\x0a        week[token.substr(0, 1)] = toInt(input);\x0a    });\x0a\x0a    // HELPERS\x0a\x0a    // LOCALES\x0a\x0a    function localeWeek (mom) {\x0a        return weekOfYear(mom, this._week.dow, this._week.doy).week;\x0a    }\x0a\x0a    var defaultLocaleWeek = {\x0a        dow : 0, // Sunday is the first day of the week.\x0a        doy : 6  // The week that contains Jan 1st is the first week of the year.\x0a    };\x0a\x0a    function localeFirstDayOfWeek () {\x0a        return this._week.dow;\x0a    }\x0a\x0a    function localeFirstDayOfYear () {\x0a        return this._week.doy;\x0a    }\x0a\x0a    // MOMENTS\x0a\x0a    function getSetWeek (input) {\x0a        var week = this.localeData().week(this);\x0a        return input == null ? week : this.add((input - week) * 7, \x27d\x27);\x0a    }\x0a\x0a    function getSetISOWeek (input) {\x0a        var week = weekOfYear(this, 1, 4).week;\x0a        return input == null ? week : this.add((input - week) * 7, \x27d\x27);\x0a    }\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27d\x27, 0, \x27do\x27, \x27day\x27);\x0a\x0a    addFormatToken(\x27dd\x27, 0, 0, function (format) {\x0a        return this.localeData().weekdaysMin(this, format);\x0a    });\x0a\x0a    addFormatToken(\x27ddd\x27, 0, 0, function (format) {\x0a        return this.localeData().weekdaysShort(this, format);\x0a    });\x0a\x0a    addFormatToken(\x27dddd\x27, 0, 0, function (format) {\x0a        return this.localeData().weekdays(this, format);\x0a    });\x0a\x0a    addFormatToken(\x27e\x27, 0, 0, \x27weekday\x27);\x0a    addFormatToken(\x27E\x27, 0, 0, \x27isoWeekday\x27);\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27day\x27, \x27d\x27);\x0a    addUnitAlias(\x27weekday\x27, \x27e\x27);\x0a    addUnitAlias(\x27isoWeekday\x27, \x27E\x27);\x0a\x0a    // PRIORITY\x0a    addUnitPriority(\x27day\x27, 11);\x0a    addUnitPriority(\x27weekday\x27, 11);\x0a    addUnitPriority(\x27isoWeekday\x27, 11);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27d\x27,    match1to2);\x0a    addRegexToken(\x27e\x27,    match1to2);\x0a    addRegexToken(\x27E\x27,    match1to2);\x0a    addRegexToken(\x27dd\x27,   function (isStrict, locale) {\x0a        return locale.weekdaysMinRegex(isStrict);\x0a    });\x0a    addRegexToken(\x27ddd\x27,   function (isStrict, locale) {\x0a        return locale.weekdaysShortRegex(isStrict);\x0a    });\x0a    addRegexToken(\x27dddd\x27,   function (isStrict, locale) {\x0a        return locale.weekdaysRegex(isStrict);\x0a    });\x0a\x0a    addWeekParseToken([\x27dd\x27, \x27ddd\x27, \x27dddd\x27], function (input, week, config, token) {\x0a        var weekday = config._locale.weekdaysParse(input, token, config._strict);\x0a        // if we didn\x27t get a weekday name, mark the date as invalid\x0a        if (weekday != null) {\x0a            week.d = weekday;\x0a        } else {\x0a            getParsingFlags(config).invalidWeekday = input;\x0a        }\x0a    });\x0a\x0a    addWeekParseToken([\x27d\x27, \x27e\x27, \x27E\x27], function (input, week, config, token) {\x0a        week[token] = toInt(input);\x0a    });\x0a\x0a    // HELPERS\x0a\x0a    function parseWeekday(input, locale) {\x0a        if (typeof input !== \x27string\x27) {\x0a            return input;\x0a        }\x0a\x0a        if (!isNaN(input)) {\x0a            return parseInt(input, 10);\x0a        }\x0a\x0a        input = locale.weekdaysParse(input);\x0a        if (typeof input === \x27number\x27) {\x0a            return input;\x0a        }\x0a\x0a        return null;\x0a    }\x0a\x0a    function parseIsoWeekday(input, locale) {\x0a        if (typeof input === \x27string\x27) {\x0a            return locale.weekdaysParse(input) % 7 || 7;\x0a        }\x0a        return isNaN(input) ? null : input;\x0a    }\x0a\x0a    // LOCALES\x0a\x0a    var defaultLocaleWeekdays = \x27Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\x27.split(\x27_\x27);\x0a    function localeWeekdays (m, format) {\x0a        if (!m) {\x0a            return isArray(this._weekdays) ? this._weekdays :\x0a                this._weekdays[\x27standalone\x27];\x0a        }\x0a        return isArray(this._weekdays) ? this._weekdays[m.day()] :\x0a            this._weekdays[this._weekdays.isFormat.test(format) ? \x27format\x27 : \x27standalone\x27][m.day()];\x0a    }\x0a\x0a    var defaultLocaleWeekdaysShort = \x27Sun_Mon_Tue_Wed_Thu_Fri_Sat\x27.split(\x27_\x27);\x0a    function localeWeekdaysShort (m) {\x0a        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\x0a    }\x0a\x0a    var defaultLocaleWeekdaysMin = \x27Su_Mo_Tu_We_Th_Fr_Sa\x27.split(\x27_\x27);\x0a    function localeWeekdaysMin (m) {\x0a        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\x0a    }\x0a\x0a    function handleStrictParse$1(weekdayName, format, strict) {\x0a        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\x0a        if (!this._weekdaysParse) {\x0a            this._weekdaysParse = [];\x0a            this._shortWeekdaysParse = [];\x0a            this._minWeekdaysParse = [];\x0a\x0a            for (i = 0; i \x3c 7; ++i) {\x0a                mom = createUTC([2000, 1]).day(i);\x0a                this._minWeekdaysParse[i] = this.weekdaysMin(mom, \x27\x27).toLocaleLowerCase();\x0a                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, \x27\x27).toLocaleLowerCase();\x0a                this._weekdaysParse[i] = this.weekdays(mom, \x27\x27).toLocaleLowerCase();\x0a            }\x0a        }\x0a\x0a        if (strict) {\x0a            if (format === \x27dddd\x27) {\x0a                ii = indexOf.call(this._weekdaysParse, llc);\x0a                return ii !== -1 ? ii : null;\x0a            } else if (format === \x27ddd\x27) {\x0a                ii = indexOf.call(this._shortWeekdaysParse, llc);\x0a                return ii !== -1 ? ii : null;\x0a            } else {\x0a                ii = indexOf.call(this._minWeekdaysParse, llc);\x0a                return ii !== -1 ? ii : null;\x0a            }\x0a        } else {\x0a            if (format === \x27dddd\x27) {\x0a                ii = indexOf.call(this._weekdaysParse, llc);\x0a                if (ii !== -1) {\x0a                    return ii;\x0a                }\x0a                ii = indexOf.call(this._shortWeekdaysParse, llc);\x0a                if (ii !== -1) {\x0a                    return ii;\x0a                }\x0a                ii = indexOf.call(this._minWeekdaysParse, llc);\x0a                return ii !== -1 ? ii : null;\x0a            } else if (format === \x27ddd\x27) {\x0a                ii = indexOf.call(this._shortWeekdaysParse, llc);\x0a                if (ii !== -1) {\x0a                    return ii;\x0a                }\x0a                ii = indexOf.call(this._weekdaysParse, llc);\x0a                if (ii !== -1) {\x0a                    return ii;\x0a                }\x0a                ii = indexOf.call(this._minWeekdaysParse, llc);\x0a                return ii !== -1 ? ii : null;\x0a            } else {\x0a                ii = indexOf.call(this._minWeekdaysParse, llc);\x0a                if (ii !== -1) {\x0a                    return ii;\x0a                }\x0a                ii = indexOf.call(this._weekdaysParse, llc);\x0a                if (ii !== -1) {\x0a                    return ii;\x0a                }\x0a                ii = indexOf.call(this._shortWeekdaysParse, llc);\x0a                return ii !== -1 ? ii : null;\x0a            }\x0a        }\x0a    }\x0a\x0a    function localeWeekdaysParse (weekdayName, format, strict) {\x0a        var i, mom, regex;\x0a\x0a        if (this._weekdaysParseExact) {\x0a            return handleStrictParse$1.call(this, weekdayName, format, strict);\x0a        }\x0a\x0a        if (!this._weekdaysParse) {\x0a            this._weekdaysParse = [];\x0a            this._minWeekdaysParse = [];\x0a            this._shortWeekdaysParse = [];\x0a            this._fullWeekdaysParse = [];\x0a        }\x0a\x0a        for (i = 0; i \x3c 7; i++) {\x0a            // make the regex if we don\x27t have it already\x0a\x0a            mom = createUTC([2000, 1]).day(i);\x0a            if (strict && !this._fullWeekdaysParse[i]) {\x0a                this._fullWeekdaysParse[i] = new RegExp(\x27^\x27 + this.weekdays(mom, \x27\x27).replace(\x27.\x27, \x27\x5c\x5c.?\x27) + \x27$\x27, \x27i\x27);\x0a                this._shortWeekdaysParse[i] = new RegExp(\x27^\x27 + this.weekdaysShort(mom, \x27\x27).replace(\x27.\x27, \x27\x5c\x5c.?\x27) + \x27$\x27, \x27i\x27);\x0a                this._minWeekdaysParse[i] = new RegExp(\x27^\x27 + this.weekdaysMin(mom, \x27\x27).replace(\x27.\x27, \x27\x5c\x5c.?\x27) + \x27$\x27, \x27i\x27);\x0a            }\x0a            if (!this._weekdaysParse[i]) {\x0a                regex = \x27^\x27 + this.weekdays(mom, \x27\x27) + \x27|^\x27 + this.weekdaysShort(mom, \x27\x27) + \x27|^\x27 + this.weekdaysMin(mom, \x27\x27);\x0a                this._weekdaysParse[i] = new RegExp(regex.replace(\x27.\x27, \x27\x27), \x27i\x27);\x0a            }\x0a            // test the regex\x0a            if (strict && format === \x27dddd\x27 && this._fullWeekdaysParse[i].test(weekdayName)) {\x0a                return i;\x0a            } else if (strict && format === \x27ddd\x27 && this._shortWeekdaysParse[i].test(weekdayName)) {\x0a                return i;\x0a            } else if (strict && format === \x27dd\x27 && this._minWeekdaysParse[i].test(weekdayName)) {\x0a                return i;\x0a            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\x0a                return i;\x0a            }\x0a        }\x0a    }\x0a\x0a    // MOMENTS\x0a\x0a    function getSetDayOfWeek (input) {\x0a        if (!this.isValid()) {\x0a            return input != null ? this : NaN;\x0a        }\x0a        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\x0a        if (input != null) {\x0a            input = parseWeekday(input, this.localeData());\x0a            return this.add(input - day, \x27d\x27);\x0a        } else {\x0a            return day;\x0a        }\x0a    }\x0a\x0a    function getSetLocaleDayOfWeek (input) {\x0a        if (!this.isValid()) {\x0a            return input != null ? this : NaN;\x0a        }\x0a        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\x0a        return input == null ? weekday : this.add(input - weekday, \x27d\x27);\x0a    }\x0a\x0a    function getSetISODayOfWeek (input) {\x0a        if (!this.isValid()) {\x0a            return input != null ? this : NaN;\x0a        }\x0a\x0a        // behaves the same as moment#day except\x0a        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\x0a        // as a setter, sunday should belong to the previous week.\x0a\x0a        if (input != null) {\x0a            var weekday = parseIsoWeekday(input, this.localeData());\x0a            return this.day(this.day() % 7 ? weekday : weekday - 7);\x0a        } else {\x0a            return this.day() || 7;\x0a        }\x0a    }\x0a\x0a    var defaultWeekdaysRegex = matchWord;\x0a    function weekdaysRegex (isStrict) {\x0a        if (this._weekdaysParseExact) {\x0a            if (!hasOwnProp(this, \x27_weekdaysRegex\x27)) {\x0a                computeWeekdaysParse.call(this);\x0a            }\x0a            if (isStrict) {\x0a                return this._weekdaysStrictRegex;\x0a            } else {\x0a                return this._weekdaysRegex;\x0a            }\x0a        } else {\x0a            if (!hasOwnProp(this, \x27_weekdaysRegex\x27)) {\x0a                this._weekdaysRegex = defaultWeekdaysRegex;\x0a            }\x0a            return this._weekdaysStrictRegex && isStrict ?\x0a                this._weekdaysStrictRegex : this._weekdaysRegex;\x0a        }\x0a    }\x0a\x0a    var defaultWeekdaysShortRegex = matchWord;\x0a    function weekdaysShortRegex (isStrict) {\x0a        if (this._weekdaysParseExact) {\x0a            if (!hasOwnProp(this, \x27_weekdaysRegex\x27)) {\x0a                computeWeekdaysParse.call(this);\x0a            }\x0a            if (isStrict) {\x0a                return this._weekdaysShortStrictRegex;\x0a            } else {\x0a                return this._weekdaysShortRegex;\x0a            }\x0a        } else {\x0a            if (!hasOwnProp(this, \x27_weekdaysShortRegex\x27)) {\x0a                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\x0a            }\x0a            return this._weekdaysShortStrictRegex && isStrict ?\x0a                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\x0a        }\x0a    }\x0a\x0a    var defaultWeekdaysMinRegex = matchWord;\x0a    function weekdaysMinRegex (isStrict) {\x0a        if (this._weekdaysParseExact) {\x0a            if (!hasOwnProp(this, \x27_weekdaysRegex\x27)) {\x0a                computeWeekdaysParse.call(this);\x0a            }\x0a            if (isStrict) {\x0a                return this._weekdaysMinStrictRegex;\x0a            } else {\x0a                return this._weekdaysMinRegex;\x0a            }\x0a        } else {\x0a            if (!hasOwnProp(this, \x27_weekdaysMinRegex\x27)) {\x0a                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\x0a            }\x0a            return this._weekdaysMinStrictRegex && isStrict ?\x0a                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\x0a        }\x0a    }\x0a\x0a\x0a    function computeWeekdaysParse () {\x0a        function cmpLenRev(a, b) {\x0a            return b.length - a.length;\x0a        }\x0a\x0a        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\x0a            i, mom, minp, shortp, longp;\x0a        for (i = 0; i \x3c 7; i++) {\x0a            // make the regex if we don\x27t have it already\x0a            mom = createUTC([2000, 1]).day(i);\x0a            minp = this.weekdaysMin(mom, \x27\x27);\x0a            shortp = this.weekdaysShort(mom, \x27\x27);\x0a            longp = this.weekdays(mom, \x27\x27);\x0a            minPieces.push(minp);\x0a            shortPieces.push(shortp);\x0a            longPieces.push(longp);\x0a            mixedPieces.push(minp);\x0a            mixedPieces.push(shortp);\x0a            mixedPieces.push(longp);\x0a        }\x0a        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\x0a        // will match the longer piece.\x0a        minPieces.sort(cmpLenRev);\x0a        shortPieces.sort(cmpLenRev);\x0a        longPieces.sort(cmpLenRev);\x0a        mixedPieces.sort(cmpLenRev);\x0a        for (i = 0; i \x3c 7; i++) {\x0a            shortPieces[i] = regexEscape(shortPieces[i]);\x0a            longPieces[i] = regexEscape(longPieces[i]);\x0a            mixedPieces[i] = regexEscape(mixedPieces[i]);\x0a        }\x0a\x0a        this._weekdaysRegex = new RegExp(\x27^(\x27 + mixedPieces.join(\x27|\x27) + \x27)\x27, \x27i\x27);\x0a        this._weekdaysShortRegex = this._weekdaysRegex;\x0a        this._weekdaysMinRegex = this._weekdaysRegex;\x0a\x0a        this._weekdaysStrictRegex = new RegExp(\x27^(\x27 + longPieces.join(\x27|\x27) + \x27)\x27, \x27i\x27);\x0a        this._weekdaysShortStrictRegex = new RegExp(\x27^(\x27 + shortPieces.join(\x27|\x27) + \x27)\x27, \x27i\x27);\x0a        this._weekdaysMinStrictRegex = new RegExp(\x27^(\x27 + minPieces.join(\x27|\x27) + \x27)\x27, \x27i\x27);\x0a    }\x0a\x0a    // FORMATTING\x0a\x0a    function hFormat() {\x0a        return this.hours() % 12 || 12;\x0a    }\x0a\x0a    function kFormat() {\x0a        return this.hours() || 24;\x0a    }\x0a\x0a    addFormatToken(\x27H\x27, [\x27HH\x27, 2], 0, \x27hour\x27);\x0a    addFormatToken(\x27h\x27, [\x27hh\x27, 2], 0, hFormat);\x0a    addFormatToken(\x27k\x27, [\x27kk\x27, 2], 0, kFormat);\x0a\x0a    addFormatToken(\x27hmm\x27, 0, 0, function () {\x0a        return \x27\x27 + hFormat.apply(this) + zeroFill(this.minutes(), 2);\x0a    });\x0a\x0a    addFormatToken(\x27hmmss\x27, 0, 0, function () {\x0a        return \x27\x27 + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\x0a            zeroFill(this.seconds(), 2);\x0a    });\x0a\x0a    addFormatToken(\x27Hmm\x27, 0, 0, function () {\x0a        return \x27\x27 + this.hours() + zeroFill(this.minutes(), 2);\x0a    });\x0a\x0a    addFormatToken(\x27Hmmss\x27, 0, 0, function () {\x0a        return \x27\x27 + this.hours() + zeroFill(this.minutes(), 2) +\x0a            zeroFill(this.seconds(), 2);\x0a    });\x0a\x0a    function meridiem (token, lowercase) {\x0a        addFormatToken(token, 0, 0, function () {\x0a            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\x0a        });\x0a    }\x0a\x0a    meridiem(\x27a\x27, true);\x0a    meridiem(\x27A\x27, false);\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27hour\x27, \x27h\x27);\x0a\x0a    // PRIORITY\x0a    addUnitPriority(\x27hour\x27, 13);\x0a\x0a    // PARSING\x0a\x0a    function matchMeridiem (isStrict, locale) {\x0a        return locale._meridiemParse;\x0a    }\x0a\x0a    addRegexToken(\x27a\x27,  matchMeridiem);\x0a    addRegexToken(\x27A\x27,  matchMeridiem);\x0a    addRegexToken(\x27H\x27,  match1to2);\x0a    addRegexToken(\x27h\x27,  match1to2);\x0a    addRegexToken(\x27k\x27,  match1to2);\x0a    addRegexToken(\x27HH\x27, match1to2, match2);\x0a    addRegexToken(\x27hh\x27, match1to2, match2);\x0a    addRegexToken(\x27kk\x27, match1to2, match2);\x0a\x0a    addRegexToken(\x27hmm\x27, match3to4);\x0a    addRegexToken(\x27hmmss\x27, match5to6);\x0a    addRegexToken(\x27Hmm\x27, match3to4);\x0a    addRegexToken(\x27Hmmss\x27, match5to6);\x0a\x0a    addParseToken([\x27H\x27, \x27HH\x27], HOUR);\x0a    addParseToken([\x27k\x27, \x27kk\x27], function (input, array, config) {\x0a        var kInput = toInt(input);\x0a        array[HOUR] = kInput === 24 ? 0 : kInput;\x0a    });\x0a    addParseToken([\x27a\x27, \x27A\x27], function (input, array, config) {\x0a        config._isPm = config._locale.isPM(input);\x0a        config._meridiem = input;\x0a    });\x0a    addParseToken([\x27h\x27, \x27hh\x27], function (input, array, config) {\x0a        array[HOUR] = toInt(input);\x0a        getParsingFlags(config).bigHour = true;\x0a    });\x0a    addParseToken(\x27hmm\x27, function (input, array, config) {\x0a        var pos = input.length - 2;\x0a        array[HOUR] = toInt(input.substr(0, pos));\x0a        array[MINUTE] = toInt(input.substr(pos));\x0a        getParsingFlags(config).bigHour = true;\x0a    });\x0a    addParseToken(\x27hmmss\x27, function (input, array, config) {\x0a        var pos1 = input.length - 4;\x0a        var pos2 = input.length - 2;\x0a        array[HOUR] = toInt(input.substr(0, pos1));\x0a        array[MINUTE] = toInt(input.substr(pos1, 2));\x0a        array[SECOND] = toInt(input.substr(pos2));\x0a        getParsingFlags(config).bigHour = true;\x0a    });\x0a    addParseToken(\x27Hmm\x27, function (input, array, config) {\x0a        var pos = input.length - 2;\x0a        array[HOUR] = toInt(input.substr(0, pos));\x0a        array[MINUTE] = toInt(input.substr(pos));\x0a    });\x0a    addParseToken(\x27Hmmss\x27, function (input, array, config) {\x0a        var pos1 = input.length - 4;\x0a        var pos2 = input.length - 2;\x0a        array[HOUR] = toInt(input.substr(0, pos1));\x0a        array[MINUTE] = toInt(input.substr(pos1, 2));\x0a        array[SECOND] = toInt(input.substr(pos2));\x0a    });\x0a\x0a    // LOCALES\x0a\x0a    function localeIsPM (input) {\x0a        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\x0a        // Using charAt should be more compatible.\x0a        return ((input + \x27\x27).toLowerCase().charAt(0) === \x27p\x27);\x0a    }\x0a\x0a    var defaultLocaleMeridiemParse = /[ap]\x5c.?m?\x5c.?/i;\x0a    function localeMeridiem (hours, minutes, isLower) {\x0a        if (hours \x3e 11) {\x0a            return isLower ? \x27pm\x27 : \x27PM\x27;\x0a        } else {\x0a            return isLower ? \x27am\x27 : \x27AM\x27;\x0a        }\x0a    }\x0a\x0a\x0a    // MOMENTS\x0a\x0a    // Setting the hour should keep the time, because the user explicitly\x0a    // specified which hour they want. So trying to maintain the same hour (in\x0a    // a new timezone) makes sense. Adding/subtracting hours does not follow\x0a    // this rule.\x0a    var getSetHour = makeGetSet(\x27Hours\x27, true);\x0a\x0a    var baseConfig = {\x0a        calendar: defaultCalendar,\x0a        longDateFormat: defaultLongDateFormat,\x0a        invalidDate: defaultInvalidDate,\x0a        ordinal: defaultOrdinal,\x0a        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\x0a        relativeTime: defaultRelativeTime,\x0a\x0a        months: defaultLocaleMonths,\x0a        monthsShort: defaultLocaleMonthsShort,\x0a\x0a        week: defaultLocaleWeek,\x0a\x0a        weekdays: defaultLocaleWeekdays,\x0a        weekdaysMin: defaultLocaleWeekdaysMin,\x0a        weekdaysShort: defaultLocaleWeekdaysShort,\x0a\x0a        meridiemParse: defaultLocaleMeridiemParse\x0a    };\x0a\x0a    // internal storage for locale config files\x0a    var locales = {};\x0a    var localeFamilies = {};\x0a    var globalLocale;\x0a\x0a    function normalizeLocale(key) {\x0a        return key ? key.toLowerCase().replace(\x27_\x27, \x27-\x27) : key;\x0a    }\x0a\x0a    // pick the locale from the array\x0a    // try [\x27en-au\x27, \x27en-gb\x27] as \x27en-au\x27, \x27en-gb\x27, \x27en\x27, as in move through the list trying each\x0a    // substring from most specific to least, but move to the next array item if it\x27s a more specific variant than the current root\x0a    function chooseLocale(names) {\x0a        var i = 0, j, next, locale, split;\x0a\x0a        while (i \x3c names.length) {\x0a            split = normalizeLocale(names[i]).split(\x27-\x27);\x0a            j = split.length;\x0a            next = normalizeLocale(names[i + 1]);\x0a            next = next ? next.split(\x27-\x27) : null;\x0a            while (j \x3e 0) {\x0a                locale = loadLocale(split.slice(0, j).join(\x27-\x27));\x0a                if (locale) {\x0a                    return locale;\x0a                }\x0a                if (next && next.length \x3e= j && compareArrays(split, next, true) \x3e= j - 1) {\x0a                    //the next array item is better than a shallower substring of this one\x0a                    break;\x0a                }\x0a                j--;\x0a            }\x0a            i++;\x0a        }\x0a        return globalLocale;\x0a    }\x0a\x0a    function loadLocale(name) {\x0a        var oldLocale = null;\x0a        // TODO: Find a better way to register and load all the locales in Node\x0a        if (!locales[name] && (typeof module !== \x27undefined\x27) &&\x0a                module && module.exports) {\x0a            try {\x0a                oldLocale = globalLocale._abbr;\x0a                var aliasedRequire = require;\x0a                aliasedRequire(\x27./locale/\x27 + name);\x0a                getSetGlobalLocale(oldLocale);\x0a            } catch (e) {}\x0a        }\x0a        return locales[name];\x0a    }\x0a\x0a    // This function will load locale and then set the global locale.  If\x0a    // no arguments are passed in, it will simply return the current global\x0a    // locale key.\x0a    function getSetGlobalLocale (key, values) {\x0a        var data;\x0a        if (key) {\x0a            if (isUndefined(values)) {\x0a                data = getLocale(key);\x0a            }\x0a            else {\x0a                data = defineLocale(key, values);\x0a            }\x0a\x0a            if (data) {\x0a                // moment.duration._locale = moment._locale = data;\x0a                globalLocale = data;\x0a            }\x0a            else {\x0a                if ((typeof console !==  \x27undefined\x27) && console.warn) {\x0a                    //warn user if arguments are passed but the locale could not be set\x0a                    console.warn(\x27Locale \x27 + key +  \x27 not found. Did you forget to load it?\x27);\x0a                }\x0a            }\x0a        }\x0a\x0a        return globalLocale._abbr;\x0a    }\x0a\x0a    function defineLocale (name, config) {\x0a        if (config !== null) {\x0a            var locale, parentConfig = baseConfig;\x0a            config.abbr = name;\x0a            if (locales[name] != null) {\x0a                deprecateSimple(\x27defineLocaleOverride\x27,\x0a                        \x27use moment.updateLocale(localeName, config) to change \x27 +\x0a                        \x27an existing locale. moment.defineLocale(localeName, \x27 +\x0a                        \x27config) should only be used for creating a new locale \x27 +\x0a                        \x27See http://momentjs.com/guides/#/warnings/define-locale/ for more info.\x27);\x0a                parentConfig = locales[name]._config;\x0a            } else if (config.parentLocale != null) {\x0a                if (locales[config.parentLocale] != null) {\x0a                    parentConfig = locales[config.parentLocale]._config;\x0a                } else {\x0a                    locale = loadLocale(config.parentLocale);\x0a                    if (locale != null) {\x0a                        parentConfig = locale._config;\x0a                    } else {\x0a                        if (!localeFamilies[config.parentLocale]) {\x0a                            localeFamilies[config.parentLocale] = [];\x0a                        }\x0a                        localeFamilies[config.parentLocale].push({\x0a                            name: name,\x0a                            config: config\x0a                        });\x0a                        return null;\x0a                    }\x0a                }\x0a            }\x0a            locales[name] = new Locale(mergeConfigs(parentConfig, config));\x0a\x0a            if (localeFamilies[name]) {\x0a                localeFamilies[name].forEach(function (x) {\x0a                    defineLocale(x.name, x.config);\x0a                });\x0a            }\x0a\x0a            // backwards compat for now: also set the locale\x0a            // make sure we set the locale AFTER all child locales have been\x0a            // created, so we won\x27t end up with the child locale set.\x0a            getSetGlobalLocale(name);\x0a\x0a\x0a            return locales[name];\x0a        } else {\x0a            // useful for testing\x0a            delete locales[name];\x0a            return null;\x0a        }\x0a    }\x0a\x0a    function updateLocale(name, config) {\x0a        if (config != null) {\x0a            var locale, tmpLocale, parentConfig = baseConfig;\x0a            // MERGE\x0a            tmpLocale = loadLocale(name);\x0a            if (tmpLocale != null) {\x0a                parentConfig = tmpLocale._config;\x0a            }\x0a            config = mergeConfigs(parentConfig, config);\x0a            locale = new Locale(config);\x0a            locale.parentLocale = locales[name];\x0a            locales[name] = locale;\x0a\x0a            // backwards compat for now: also set the locale\x0a            getSetGlobalLocale(name);\x0a        } else {\x0a            // pass null for config to unupdate, useful for tests\x0a            if (locales[name] != null) {\x0a                if (locales[name].parentLocale != null) {\x0a                    locales[name] = locales[name].parentLocale;\x0a                } else if (locales[name] != null) {\x0a                    delete locales[name];\x0a                }\x0a            }\x0a        }\x0a        return locales[name];\x0a    }\x0a\x0a    // returns locale data\x0a    function getLocale (key) {\x0a        var locale;\x0a\x0a        if (key && key._locale && key._locale._abbr) {\x0a            key = key._locale._abbr;\x0a        }\x0a\x0a        if (!key) {\x0a            return globalLocale;\x0a        }\x0a\x0a        if (!isArray(key)) {\x0a            //short-circuit everything else\x0a            locale = loadLocale(key);\x0a            if (locale) {\x0a                return locale;\x0a            }\x0a            key = [key];\x0a        }\x0a\x0a        return chooseLocale(key);\x0a    }\x0a\x0a    function listLocales() {\x0a        return keys(locales);\x0a    }\x0a\x0a    function checkOverflow (m) {\x0a        var overflow;\x0a        var a = m._a;\x0a\x0a        if (a && getParsingFlags(m).overflow === -2) {\x0a            overflow =\x0a                a[MONTH]       \x3c 0 || a[MONTH]       \x3e 11  ? MONTH :\x0a                a[DATE]        \x3c 1 || a[DATE]        \x3e daysInMonth(a[YEAR], a[MONTH]) ? DATE :\x0a                a[HOUR]        \x3c 0 || a[HOUR]        \x3e 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\x0a                a[MINUTE]      \x3c 0 || a[MINUTE]      \x3e 59  ? MINUTE :\x0a                a[SECOND]      \x3c 0 || a[SECOND]      \x3e 59  ? SECOND :\x0a                a[MILLISECOND] \x3c 0 || a[MILLISECOND] \x3e 999 ? MILLISECOND :\x0a                -1;\x0a\x0a            if (getParsingFlags(m)._overflowDayOfYear && (overflow \x3c YEAR || overflow \x3e DATE)) {\x0a                overflow = DATE;\x0a            }\x0a            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\x0a                overflow = WEEK;\x0a            }\x0a            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\x0a                overflow = WEEKDAY;\x0a            }\x0a\x0a            getParsingFlags(m).overflow = overflow;\x0a        }\x0a\x0a        return m;\x0a    }\x0a\x0a    // Pick the first defined of two or three arguments.\x0a    function defaults(a, b, c) {\x0a        if (a != null) {\x0a            return a;\x0a        }\x0a        if (b != null) {\x0a            return b;\x0a        }\x0a        return c;\x0a    }\x0a\x0a    function currentDateArray(config) {\x0a        // hooks is actually the exported moment object\x0a        var nowValue = new Date(hooks.now());\x0a        if (config._useUTC) {\x0a            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\x0a        }\x0a        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\x0a    }\x0a\x0a    // convert an array to a date.\x0a    // the array should mirror the parameters below\x0a    // note: all values past the year are optional and will default to the lowest possible value.\x0a    // [year, month, day , hour, minute, second, millisecond]\x0a    function configFromArray (config) {\x0a        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\x0a\x0a        if (config._d) {\x0a            return;\x0a        }\x0a\x0a        currentDate = currentDateArray(config);\x0a\x0a        //compute day of the year from weeks and weekdays\x0a        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\x0a            dayOfYearFromWeekInfo(config);\x0a        }\x0a\x0a        //if the day of the year is set, figure out what it is\x0a        if (config._dayOfYear != null) {\x0a            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\x0a\x0a            if (config._dayOfYear \x3e daysInYear(yearToUse) || config._dayOfYear === 0) {\x0a                getParsingFlags(config)._overflowDayOfYear = true;\x0a            }\x0a\x0a            date = createUTCDate(yearToUse, 0, config._dayOfYear);\x0a            config._a[MONTH] = date.getUTCMonth();\x0a            config._a[DATE] = date.getUTCDate();\x0a        }\x0a\x0a        // Default to current date.\x0a        // * if no year, month, day of month are given, default to today\x0a        // * if day of month is given, default month and year\x0a        // * if month is given, default only year\x0a        // * if year is given, don\x27t default anything\x0a        for (i = 0; i \x3c 3 && config._a[i] == null; ++i) {\x0a            config._a[i] = input[i] = currentDate[i];\x0a        }\x0a\x0a        // Zero out whatever was not defaulted, including time\x0a        for (; i \x3c 7; i++) {\x0a            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\x0a        }\x0a\x0a        // Check for 24:00:00.000\x0a        if (config._a[HOUR] === 24 &&\x0a                config._a[MINUTE] === 0 &&\x0a                config._a[SECOND] === 0 &&\x0a                config._a[MILLISECOND] === 0) {\x0a            config._nextDay = true;\x0a            config._a[HOUR] = 0;\x0a        }\x0a\x0a        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\x0a        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\x0a\x0a        // Apply timezone offset from input. The actual utcOffset can be changed\x0a        // with parseZone.\x0a        if (config._tzm != null) {\x0a            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\x0a        }\x0a\x0a        if (config._nextDay) {\x0a            config._a[HOUR] = 24;\x0a        }\x0a\x0a        // check for mismatching day of week\x0a        if (config._w && typeof config._w.d !== \x27undefined\x27 && config._w.d !== expectedWeekday) {\x0a            getParsingFlags(config).weekdayMismatch = true;\x0a        }\x0a    }\x0a\x0a    function dayOfYearFromWeekInfo(config) {\x0a        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\x0a\x0a        w = config._w;\x0a        if (w.GG != null || w.W != null || w.E != null) {\x0a            dow = 1;\x0a            doy = 4;\x0a\x0a            // TODO: We need to take the current isoWeekYear, but that depends on\x0a            // how we interpret now (local, utc, fixed offset). So create\x0a            // a now version of current config (take local/utc/offset flags, and\x0a            // create now).\x0a            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\x0a            week = defaults(w.W, 1);\x0a            weekday = defaults(w.E, 1);\x0a            if (weekday \x3c 1 || weekday \x3e 7) {\x0a                weekdayOverflow = true;\x0a            }\x0a        } else {\x0a            dow = config._locale._week.dow;\x0a            doy = config._locale._week.doy;\x0a\x0a            var curWeek = weekOfYear(createLocal(), dow, doy);\x0a\x0a            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\x0a\x0a            // Default to current week.\x0a            week = defaults(w.w, curWeek.week);\x0a\x0a            if (w.d != null) {\x0a                // weekday -- low day numbers are considered next week\x0a                weekday = w.d;\x0a                if (weekday \x3c 0 || weekday \x3e 6) {\x0a                    weekdayOverflow = true;\x0a                }\x0a            } else if (w.e != null) {\x0a                // local weekday -- counting starts from begining of week\x0a                weekday = w.e + dow;\x0a                if (w.e \x3c 0 || w.e \x3e 6) {\x0a                    weekdayOverflow = true;\x0a                }\x0a            } else {\x0a                // default to begining of week\x0a                weekday = dow;\x0a            }\x0a        }\x0a        if (week \x3c 1 || week \x3e weeksInYear(weekYear, dow, doy)) {\x0a            getParsingFlags(config)._overflowWeeks = true;\x0a        } else if (weekdayOverflow != null) {\x0a            getParsingFlags(config)._overflowWeekday = true;\x0a        } else {\x0a            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\x0a            config._a[YEAR] = temp.year;\x0a            config._dayOfYear = temp.dayOfYear;\x0a        }\x0a    }\x0a\x0a    // iso 8601 regex\x0a    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\x0a    var extendedIsoRegex = /^\x5cs*((?:[+-]\x5cd{6}|\x5cd{4})-(?:\x5cd\x5cd-\x5cd\x5cd|W\x5cd\x5cd-\x5cd|W\x5cd\x5cd|\x5cd\x5cd\x5cd|\x5cd\x5cd))(?:(T| )(\x5cd\x5cd(?::\x5cd\x5cd(?::\x5cd\x5cd(?:[.,]\x5cd+)?)?)?)([\x5c+\x5c-]\x5cd\x5cd(?::?\x5cd\x5cd)?|\x5cs*Z)?)?$/;\x0a    var basicIsoRegex = /^\x5cs*((?:[+-]\x5cd{6}|\x5cd{4})(?:\x5cd\x5cd\x5cd\x5cd|W\x5cd\x5cd\x5cd|W\x5cd\x5cd|\x5cd\x5cd\x5cd|\x5cd\x5cd))(?:(T| )(\x5cd\x5cd(?:\x5cd\x5cd(?:\x5cd\x5cd(?:[.,]\x5cd+)?)?)?)([\x5c+\x5c-]\x5cd\x5cd(?::?\x5cd\x5cd)?|\x5cs*Z)?)?$/;\x0a\x0a    var tzRegex = /Z|[+-]\x5cd\x5cd(?::?\x5cd\x5cd)?/;\x0a\x0a    var isoDates = [\x0a        [\x27YYYYYY-MM-DD\x27, /[+-]\x5cd{6}-\x5cd\x5cd-\x5cd\x5cd/],\x0a        [\x27YYYY-MM-DD\x27, /\x5cd{4}-\x5cd\x5cd-\x5cd\x5cd/],\x0a        [\x27GGGG-[W]WW-E\x27, /\x5cd{4}-W\x5cd\x5cd-\x5cd/],\x0a        [\x27GGGG-[W]WW\x27, /\x5cd{4}-W\x5cd\x5cd/, false],\x0a        [\x27YYYY-DDD\x27, /\x5cd{4}-\x5cd{3}/],\x0a        [\x27YYYY-MM\x27, /\x5cd{4}-\x5cd\x5cd/, false],\x0a        [\x27YYYYYYMMDD\x27, /[+-]\x5cd{10}/],\x0a        [\x27YYYYMMDD\x27, /\x5cd{8}/],\x0a        // YYYYMM is NOT allowed by the standard\x0a        [\x27GGGG[W]WWE\x27, /\x5cd{4}W\x5cd{3}/],\x0a        [\x27GGGG[W]WW\x27, /\x5cd{4}W\x5cd{2}/, false],\x0a        [\x27YYYYDDD\x27, /\x5cd{7}/]\x0a    ];\x0a\x0a    // iso time formats and regexes\x0a    var isoTimes = [\x0a        [\x27HH:mm:ss.SSSS\x27, /\x5cd\x5cd:\x5cd\x5cd:\x5cd\x5cd\x5c.\x5cd+/],\x0a        [\x27HH:mm:ss,SSSS\x27, /\x5cd\x5cd:\x5cd\x5cd:\x5cd\x5cd,\x5cd+/],\x0a        [\x27HH:mm:ss\x27, /\x5cd\x5cd:\x5cd\x5cd:\x5cd\x5cd/],\x0a        [\x27HH:mm\x27, /\x5cd\x5cd:\x5cd\x5cd/],\x0a        [\x27HHmmss.SSSS\x27, /\x5cd\x5cd\x5cd\x5cd\x5cd\x5cd\x5c.\x5cd+/],\x0a        [\x27HHmmss,SSSS\x27, /\x5cd\x5cd\x5cd\x5cd\x5cd\x5cd,\x5cd+/],\x0a        [\x27HHmmss\x27, /\x5cd\x5cd\x5cd\x5cd\x5cd\x5cd/],\x0a        [\x27HHmm\x27, /\x5cd\x5cd\x5cd\x5cd/],\x0a        [\x27HH\x27, /\x5cd\x5cd/]\x0a    ];\x0a\x0a    var aspNetJsonRegex = /^\x5c/?Date\x5c((\x5c-?\x5cd+)/i;\x0a\x0a    // date from iso format\x0a    function configFromISO(config) {\x0a        var i, l,\x0a            string = config._i,\x0a            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\x0a            allowTime, dateFormat, timeFormat, tzFormat;\x0a\x0a        if (match) {\x0a            getParsingFlags(config).iso = true;\x0a\x0a            for (i = 0, l = isoDates.length; i \x3c l; i++) {\x0a                if (isoDates[i][1].exec(match[1])) {\x0a                    dateFormat = isoDates[i][0];\x0a                    allowTime = isoDates[i][2] !== false;\x0a                    break;\x0a                }\x0a            }\x0a            if (dateFormat == null) {\x0a                config._isValid = false;\x0a                return;\x0a            }\x0a            if (match[3]) {\x0a                for (i = 0, l = isoTimes.length; i \x3c l; i++) {\x0a                    if (isoTimes[i][1].exec(match[3])) {\x0a                        // match[2] should be \x27T\x27 or space\x0a                        timeFormat = (match[2] || \x27 \x27) + isoTimes[i][0];\x0a                        break;\x0a                    }\x0a                }\x0a                if (timeFormat == null) {\x0a                    config._isValid = false;\x0a                    return;\x0a                }\x0a            }\x0a            if (!allowTime && timeFormat != null) {\x0a                config._isValid = false;\x0a                return;\x0a            }\x0a            if (match[4]) {\x0a                if (tzRegex.exec(match[4])) {\x0a                    tzFormat = \x27Z\x27;\x0a                } else {\x0a                    config._isValid = false;\x0a                    return;\x0a                }\x0a            }\x0a            config._f = dateFormat + (timeFormat || \x27\x27) + (tzFormat || \x27\x27);\x0a            configFromStringAndFormat(config);\x0a        } else {\x0a            config._isValid = false;\x0a        }\x0a    }\x0a\x0a    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\x0a    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\x5cs)?(\x5cd{1,2})\x5cs(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\x5cs(\x5cd{2,4})\x5cs(\x5cd\x5cd):(\x5cd\x5cd)(?::(\x5cd\x5cd))?\x5cs(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\x5cd{4}))$/;\x0a\x0a    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\x0a        var result = [\x0a            untruncateYear(yearStr),\x0a            defaultLocaleMonthsShort.indexOf(monthStr),\x0a            parseInt(dayStr, 10),\x0a            parseInt(hourStr, 10),\x0a            parseInt(minuteStr, 10)\x0a        ];\x0a\x0a        if (secondStr) {\x0a            result.push(parseInt(secondStr, 10));\x0a        }\x0a\x0a        return result;\x0a    }\x0a\x0a    function untruncateYear(yearStr) {\x0a        var year = parseInt(yearStr, 10);\x0a        if (year \x3c= 49) {\x0a            return 2000 + year;\x0a        } else if (year \x3c= 999) {\x0a            return 1900 + year;\x0a        }\x0a        return year;\x0a    }\x0a\x0a    function preprocessRFC2822(s) {\x0a        // Remove comments and folding whitespace and replace multiple-spaces with a single space\x0a        return s.replace(/\x5c([^)]*\x5c)|[\x5cn\x5ct]/g, \x27 \x27).replace(/(\x5cs\x5cs+)/g, \x27 \x27).replace(/^\x5cs\x5cs*/, \x27\x27).replace(/\x5cs\x5cs*$/, \x27\x27);\x0a    }\x0a\x0a    function checkWeekday(weekdayStr, parsedInput, config) {\x0a        if (weekdayStr) {\x0a            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\x0a            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\x0a                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\x0a            if (weekdayProvided !== weekdayActual) {\x0a                getParsingFlags(config).weekdayMismatch = true;\x0a                config._isValid = false;\x0a                return false;\x0a            }\x0a        }\x0a        return true;\x0a    }\x0a\x0a    var obsOffsets = {\x0a        UT: 0,\x0a        GMT: 0,\x0a        EDT: -4 * 60,\x0a        EST: -5 * 60,\x0a        CDT: -5 * 60,\x0a        CST: -6 * 60,\x0a        MDT: -6 * 60,\x0a        MST: -7 * 60,\x0a        PDT: -7 * 60,\x0a        PST: -8 * 60\x0a    };\x0a\x0a    function calculateOffset(obsOffset, militaryOffset, numOffset) {\x0a        if (obsOffset) {\x0a            return obsOffsets[obsOffset];\x0a        } else if (militaryOffset) {\x0a            // the only allowed military tz is Z\x0a            return 0;\x0a        } else {\x0a            var hm = parseInt(numOffset, 10);\x0a            var m = hm % 100, h = (hm - m) / 100;\x0a            return h * 60 + m;\x0a        }\x0a    }\x0a\x0a    // date and time from ref 2822 format\x0a    function configFromRFC2822(config) {\x0a        var match = rfc2822.exec(preprocessRFC2822(config._i));\x0a        if (match) {\x0a            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\x0a            if (!checkWeekday(match[1], parsedArray, config)) {\x0a                return;\x0a            }\x0a\x0a            config._a = parsedArray;\x0a            config._tzm = calculateOffset(match[8], match[9], match[10]);\x0a\x0a            config._d = createUTCDate.apply(null, config._a);\x0a            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\x0a\x0a            getParsingFlags(config).rfc2822 = true;\x0a        } else {\x0a            config._isValid = false;\x0a        }\x0a    }\x0a\x0a    // date from iso format or fallback\x0a    function configFromString(config) {\x0a        var matched = aspNetJsonRegex.exec(config._i);\x0a\x0a        if (matched !== null) {\x0a            config._d = new Date(+matched[1]);\x0a            return;\x0a        }\x0a\x0a        configFromISO(config);\x0a        if (config._isValid === false) {\x0a            delete config._isValid;\x0a        } else {\x0a            return;\x0a        }\x0a\x0a        configFromRFC2822(config);\x0a        if (config._isValid === false) {\x0a            delete config._isValid;\x0a        } else {\x0a            return;\x0a        }\x0a\x0a        // Final attempt, use Input Fallback\x0a        hooks.createFromInputFallback(config);\x0a    }\x0a\x0a    hooks.createFromInputFallback = deprecate(\x0a        \x27value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), \x27 +\x0a        \x27which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are \x27 +\x0a        \x27discouraged and will be removed in an upcoming major release. Please refer to \x27 +\x0a        \x27http://momentjs.com/guides/#/warnings/js-date/ for more info.\x27,\x0a        function (config) {\x0a            config._d = new Date(config._i + (config._useUTC ? \x27 UTC\x27 : \x27\x27));\x0a        }\x0a    );\x0a\x0a    // constant that refers to the ISO standard\x0a    hooks.ISO_8601 = function () {};\x0a\x0a    // constant that refers to the RFC 2822 form\x0a    hooks.RFC_2822 = function () {};\x0a\x0a    // date from string and format string\x0a    function configFromStringAndFormat(config) {\x0a        // TODO: Move this to another part of the creation flow to prevent circular deps\x0a        if (config._f === hooks.ISO_8601) {\x0a            configFromISO(config);\x0a            return;\x0a        }\x0a        if (config._f === hooks.RFC_2822) {\x0a            configFromRFC2822(config);\x0a            return;\x0a        }\x0a        config._a = [];\x0a        getParsingFlags(config).empty = true;\x0a\x0a        // This array is used to make a Date, either with `new Date` or `Date.UTC`\x0a        var string = \x27\x27 + config._i,\x0a            i, parsedInput, tokens, token, skipped,\x0a            stringLength = string.length,\x0a            totalParsedInputLength = 0;\x0a\x0a        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\x0a\x0a        for (i = 0; i \x3c tokens.length; i++) {\x0a            token = tokens[i];\x0a            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\x0a            // console.log(\x27token\x27, token, \x27parsedInput\x27, parsedInput,\x0a            //         \x27regex\x27, getParseRegexForToken(token, config));\x0a            if (parsedInput) {\x0a                skipped = string.substr(0, string.indexOf(parsedInput));\x0a                if (skipped.length \x3e 0) {\x0a                    getParsingFlags(config).unusedInput.push(skipped);\x0a                }\x0a                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\x0a                totalParsedInputLength += parsedInput.length;\x0a            }\x0a            // don\x27t parse if it\x27s not a known token\x0a            if (formatTokenFunctions[token]) {\x0a                if (parsedInput) {\x0a                    getParsingFlags(config).empty = false;\x0a                }\x0a                else {\x0a                    getParsingFlags(config).unusedTokens.push(token);\x0a                }\x0a                addTimeToArrayFromToken(token, parsedInput, config);\x0a            }\x0a            else if (config._strict && !parsedInput) {\x0a                getParsingFlags(config).unusedTokens.push(token);\x0a            }\x0a        }\x0a\x0a        // add remaining unparsed input length to the string\x0a        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\x0a        if (string.length \x3e 0) {\x0a            getParsingFlags(config).unusedInput.push(string);\x0a        }\x0a\x0a        // clear _12h flag if hour is \x3c= 12\x0a        if (config._a[HOUR] \x3c= 12 &&\x0a            getParsingFlags(config).bigHour === true &&\x0a            config._a[HOUR] \x3e 0) {\x0a            getParsingFlags(config).bigHour = undefined;\x0a        }\x0a\x0a        getParsingFlags(config).parsedDateParts = config._a.slice(0);\x0a        getParsingFlags(config).meridiem = config._meridiem;\x0a        // handle meridiem\x0a        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\x0a\x0a        configFromArray(config);\x0a        checkOverflow(config);\x0a    }\x0a\x0a\x0a    function meridiemFixWrap (locale, hour, meridiem) {\x0a        var isPm;\x0a\x0a        if (meridiem == null) {\x0a            // nothing to do\x0a            return hour;\x0a        }\x0a        if (locale.meridiemHour != null) {\x0a            return locale.meridiemHour(hour, meridiem);\x0a        } else if (locale.isPM != null) {\x0a            // Fallback\x0a            isPm = locale.isPM(meridiem);\x0a            if (isPm && hour \x3c 12) {\x0a                hour += 12;\x0a            }\x0a            if (!isPm && hour === 12) {\x0a                hour = 0;\x0a            }\x0a            return hour;\x0a        } else {\x0a            // this is not supposed to happen\x0a            return hour;\x0a        }\x0a    }\x0a\x0a    // date from string and array of format strings\x0a    function configFromStringAndArray(config) {\x0a        var tempConfig,\x0a            bestMoment,\x0a\x0a            scoreToBeat,\x0a            i,\x0a            currentScore;\x0a\x0a        if (config._f.length === 0) {\x0a            getParsingFlags(config).invalidFormat = true;\x0a            config._d = new Date(NaN);\x0a            return;\x0a        }\x0a\x0a        for (i = 0; i \x3c config._f.length; i++) {\x0a            currentScore = 0;\x0a            tempConfig = copyConfig({}, config);\x0a            if (config._useUTC != null) {\x0a                tempConfig._useUTC = config._useUTC;\x0a            }\x0a            tempConfig._f = config._f[i];\x0a            configFromStringAndFormat(tempConfig);\x0a\x0a            if (!isValid(tempConfig)) {\x0a                continue;\x0a            }\x0a\x0a            // if there is any input that was not parsed add a penalty for that format\x0a            currentScore += getParsingFlags(tempConfig).charsLeftOver;\x0a\x0a            //or tokens\x0a            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\x0a\x0a            getParsingFlags(tempConfig).score = currentScore;\x0a\x0a            if (scoreToBeat == null || currentScore \x3c scoreToBeat) {\x0a                scoreToBeat = currentScore;\x0a                bestMoment = tempConfig;\x0a            }\x0a        }\x0a\x0a        extend(config, bestMoment || tempConfig);\x0a    }\x0a\x0a    function configFromObject(config) {\x0a        if (config._d) {\x0a            return;\x0a        }\x0a\x0a        var i = normalizeObjectUnits(config._i);\x0a        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\x0a            return obj && parseInt(obj, 10);\x0a        });\x0a\x0a        configFromArray(config);\x0a    }\x0a\x0a    function createFromConfig (config) {\x0a        var res = new Moment(checkOverflow(prepareConfig(config)));\x0a        if (res._nextDay) {\x0a            // Adding is smart enough around DST\x0a            res.add(1, \x27d\x27);\x0a            res._nextDay = undefined;\x0a        }\x0a\x0a        return res;\x0a    }\x0a\x0a    function prepareConfig (config) {\x0a        var input = config._i,\x0a            format = config._f;\x0a\x0a        config._locale = config._locale || getLocale(config._l);\x0a\x0a        if (input === null || (format === undefined && input === \x27\x27)) {\x0a            return createInvalid({nullInput: true});\x0a        }\x0a\x0a        if (typeof input === \x27string\x27) {\x0a            config._i = input = config._locale.preparse(input);\x0a        }\x0a\x0a        if (isMoment(input)) {\x0a            return new Moment(checkOverflow(input));\x0a        } else if (isDate(input)) {\x0a            config._d = input;\x0a        } else if (isArray(format)) {\x0a            configFromStringAndArray(config);\x0a        } else if (format) {\x0a            configFromStringAndFormat(config);\x0a        }  else {\x0a            configFromInput(config);\x0a        }\x0a\x0a        if (!isValid(config)) {\x0a            config._d = null;\x0a        }\x0a\x0a        return config;\x0a    }\x0a\x0a    function configFromInput(config) {\x0a        var input = config._i;\x0a        if (isUndefined(input)) {\x0a            config._d = new Date(hooks.now());\x0a        } else if (isDate(input)) {\x0a            config._d = new Date(input.valueOf());\x0a        } else if (typeof input === \x27string\x27) {\x0a            configFromString(config);\x0a        } else if (isArray(input)) {\x0a            config._a = map(input.slice(0), function (obj) {\x0a                return parseInt(obj, 10);\x0a            });\x0a            configFromArray(config);\x0a        } else if (isObject(input)) {\x0a            configFromObject(config);\x0a        } else if (isNumber(input)) {\x0a            // from milliseconds\x0a            config._d = new Date(input);\x0a        } else {\x0a            hooks.createFromInputFallback(config);\x0a        }\x0a    }\x0a\x0a    function createLocalOrUTC (input, format, locale, strict, isUTC) {\x0a        var c = {};\x0a\x0a        if (locale === true || locale === false) {\x0a            strict = locale;\x0a            locale = undefined;\x0a        }\x0a\x0a        if ((isObject(input) && isObjectEmpty(input)) ||\x0a                (isArray(input) && input.length === 0)) {\x0a            input = undefined;\x0a        }\x0a        // object construction must be done this way.\x0a        // https://github.com/moment/moment/issues/1423\x0a        c._isAMomentObject = true;\x0a        c._useUTC = c._isUTC = isUTC;\x0a        c._l = locale;\x0a        c._i = input;\x0a        c._f = format;\x0a        c._strict = strict;\x0a\x0a        return createFromConfig(c);\x0a    }\x0a\x0a    function createLocal (input, format, locale, strict) {\x0a        return createLocalOrUTC(input, format, locale, strict, false);\x0a    }\x0a\x0a    var prototypeMin = deprecate(\x0a        \x27moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/\x27,\x0a        function () {\x0a            var other = createLocal.apply(null, arguments);\x0a            if (this.isValid() && other.isValid()) {\x0a                return other \x3c this ? this : other;\x0a            } else {\x0a                return createInvalid();\x0a            }\x0a        }\x0a    );\x0a\x0a    var prototypeMax = deprecate(\x0a        \x27moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/\x27,\x0a        function () {\x0a            var other = createLocal.apply(null, arguments);\x0a            if (this.isValid() && other.isValid()) {\x0a                return other \x3e this ? this : other;\x0a            } else {\x0a                return createInvalid();\x0a            }\x0a        }\x0a    );\x0a\x0a    // Pick a moment m from moments so that m[fn](other) is true for all\x0a    // other. This relies on the function fn to be transitive.\x0a    //\x0a    // moments should either be an array of moment objects or an array, whose\x0a    // first element is an array of moment objects.\x0a    function pickBy(fn, moments) {\x0a        var res, i;\x0a        if (moments.length === 1 && isArray(moments[0])) {\x0a            moments = moments[0];\x0a        }\x0a        if (!moments.length) {\x0a            return createLocal();\x0a        }\x0a        res = moments[0];\x0a        for (i = 1; i \x3c moments.length; ++i) {\x0a            if (!moments[i].isValid() || moments[i][fn](res)) {\x0a                res = moments[i];\x0a            }\x0a        }\x0a        return res;\x0a    }\x0a\x0a    // TODO: Use [].sort instead?\x0a    function min () {\x0a        var args = [].slice.call(arguments, 0);\x0a\x0a        return pickBy(\x27isBefore\x27, args);\x0a    }\x0a\x0a    function max () {\x0a        var args = [].slice.call(arguments, 0);\x0a\x0a        return pickBy(\x27isAfter\x27, args);\x0a    }\x0a\x0a    var now = function () {\x0a        return Date.now ? Date.now() : +(new Date());\x0a    };\x0a\x0a    var ordering = [\x27year\x27, \x27quarter\x27, \x27month\x27, \x27week\x27, \x27day\x27, \x27hour\x27, \x27minute\x27, \x27second\x27, \x27millisecond\x27];\x0a\x0a    function isDurationValid(m) {\x0a        for (var key in m) {\x0a            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\x0a                return false;\x0a            }\x0a        }\x0a\x0a        var unitHasDecimal = false;\x0a        for (var i = 0; i \x3c ordering.length; ++i) {\x0a            if (m[ordering[i]]) {\x0a                if (unitHasDecimal) {\x0a                    return false; // only allow non-integers for smallest unit\x0a                }\x0a                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\x0a                    unitHasDecimal = true;\x0a                }\x0a            }\x0a        }\x0a\x0a        return true;\x0a    }\x0a\x0a    function isValid$1() {\x0a        return this._isValid;\x0a    }\x0a\x0a    function createInvalid$1() {\x0a        return createDuration(NaN);\x0a    }\x0a\x0a    function Duration (duration) {\x0a        var normalizedInput = normalizeObjectUnits(duration),\x0a            years = normalizedInput.year || 0,\x0a            quarters = normalizedInput.quarter || 0,\x0a            months = normalizedInput.month || 0,\x0a            weeks = normalizedInput.week || 0,\x0a            days = normalizedInput.day || 0,\x0a            hours = normalizedInput.hour || 0,\x0a            minutes = normalizedInput.minute || 0,\x0a            seconds = normalizedInput.second || 0,\x0a            milliseconds = normalizedInput.millisecond || 0;\x0a\x0a        this._isValid = isDurationValid(normalizedInput);\x0a\x0a        // representation for dateAddRemove\x0a        this._milliseconds = +milliseconds +\x0a            seconds * 1e3 + // 1000\x0a            minutes * 6e4 + // 1000 * 60\x0a            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\x0a        // Because of dateAddRemove treats 24 hours as different from a\x0a        // day when working around DST, we need to store them separately\x0a        this._days = +days +\x0a            weeks * 7;\x0a        // It is impossible to translate months into days without knowing\x0a        // which months you are are talking about, so we have to store\x0a        // it separately.\x0a        this._months = +months +\x0a            quarters * 3 +\x0a            years * 12;\x0a\x0a        this._data = {};\x0a\x0a        this._locale = getLocale();\x0a\x0a        this._bubble();\x0a    }\x0a\x0a    function isDuration (obj) {\x0a        return obj instanceof Duration;\x0a    }\x0a\x0a    function absRound (number) {\x0a        if (number \x3c 0) {\x0a            return Math.round(-1 * number) * -1;\x0a        } else {\x0a            return Math.round(number);\x0a        }\x0a    }\x0a\x0a    // FORMATTING\x0a\x0a    function offset (token, separator) {\x0a        addFormatToken(token, 0, 0, function () {\x0a            var offset = this.utcOffset();\x0a            var sign = \x27+\x27;\x0a            if (offset \x3c 0) {\x0a                offset = -offset;\x0a                sign = \x27-\x27;\x0a            }\x0a            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\x0a        });\x0a    }\x0a\x0a    offset(\x27Z\x27, \x27:\x27);\x0a    offset(\x27ZZ\x27, \x27\x27);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27Z\x27,  matchShortOffset);\x0a    addRegexToken(\x27ZZ\x27, matchShortOffset);\x0a    addParseToken([\x27Z\x27, \x27ZZ\x27], function (input, array, config) {\x0a        config._useUTC = true;\x0a        config._tzm = offsetFromString(matchShortOffset, input);\x0a    });\x0a\x0a    // HELPERS\x0a\x0a    // timezone chunker\x0a    // \x27+10:00\x27 \x3e [\x2710\x27,  \x2700\x27]\x0a    // \x27-1530\x27  \x3e [\x27-15\x27, \x2730\x27]\x0a    var chunkOffset = /([\x5c+\x5c-]|\x5cd\x5cd)/gi;\x0a\x0a    function offsetFromString(matcher, string) {\x0a        var matches = (string || \x27\x27).match(matcher);\x0a\x0a        if (matches === null) {\x0a            return null;\x0a        }\x0a\x0a        var chunk   = matches[matches.length - 1] || [];\x0a        var parts   = (chunk + \x27\x27).match(chunkOffset) || [\x27-\x27, 0, 0];\x0a        var minutes = +(parts[1] * 60) + toInt(parts[2]);\x0a\x0a        return minutes === 0 ?\x0a          0 :\x0a          parts[0] === \x27+\x27 ? minutes : -minutes;\x0a    }\x0a\x0a    // Return a moment from input, that is local/utc/zone equivalent to model.\x0a    function cloneWithOffset(input, model) {\x0a        var res, diff;\x0a        if (model._isUTC) {\x0a            res = model.clone();\x0a            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\x0a            // Use low-level api, because this fn is low-level api.\x0a            res._d.setTime(res._d.valueOf() + diff);\x0a            hooks.updateOffset(res, false);\x0a            return res;\x0a        } else {\x0a            return createLocal(input).local();\x0a        }\x0a    }\x0a\x0a    function getDateOffset (m) {\x0a        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\x0a        // https://github.com/moment/moment/pull/1871\x0a        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\x0a    }\x0a\x0a    // HOOKS\x0a\x0a    // This function will be called whenever a moment is mutated.\x0a    // It is intended to keep the offset in sync with the timezone.\x0a    hooks.updateOffset = function () {};\x0a\x0a    // MOMENTS\x0a\x0a    // keepLocalTime = true means only change the timezone, without\x0a    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]--\x3e\x0a    // 5:31:26 +0200 It is possible that 5:31:26 doesn\x27t exist with offset\x0a    // +0200, so we adjust the time as needed, to be valid.\x0a    //\x0a    // Keeping the time actually adds/subtracts (one hour)\x0a    // from the actual represented time. That is why we call updateOffset\x0a    // a second time. In case it wants us to change the offset again\x0a    // _changeInProgress == true case, then we have to adjust, because\x0a    // there is no such time in the given timezone.\x0a    function getSetOffset (input, keepLocalTime, keepMinutes) {\x0a        var offset = this._offset || 0,\x0a            localAdjust;\x0a        if (!this.isValid()) {\x0a            return input != null ? this : NaN;\x0a        }\x0a        if (input != null) {\x0a            if (typeof input === \x27string\x27) {\x0a                input = offsetFromString(matchShortOffset, input);\x0a                if (input === null) {\x0a                    return this;\x0a                }\x0a            } else if (Math.abs(input) \x3c 16 && !keepMinutes) {\x0a                input = input * 60;\x0a            }\x0a            if (!this._isUTC && keepLocalTime) {\x0a                localAdjust = getDateOffset(this);\x0a            }\x0a            this._offset = input;\x0a            this._isUTC = true;\x0a            if (localAdjust != null) {\x0a                this.add(localAdjust, \x27m\x27);\x0a            }\x0a            if (offset !== input) {\x0a                if (!keepLocalTime || this._changeInProgress) {\x0a                    addSubtract(this, createDuration(input - offset, \x27m\x27), 1, false);\x0a                } else if (!this._changeInProgress) {\x0a                    this._changeInProgress = true;\x0a                    hooks.updateOffset(this, true);\x0a                    this._changeInProgress = null;\x0a                }\x0a            }\x0a            return this;\x0a        } else {\x0a            return this._isUTC ? offset : getDateOffset(this);\x0a        }\x0a    }\x0a\x0a    function getSetZone (input, keepLocalTime) {\x0a        if (input != null) {\x0a            if (typeof input !== \x27string\x27) {\x0a                input = -input;\x0a            }\x0a\x0a            this.utcOffset(input, keepLocalTime);\x0a\x0a            return this;\x0a        } else {\x0a            return -this.utcOffset();\x0a        }\x0a    }\x0a\x0a    function setOffsetToUTC (keepLocalTime) {\x0a        return this.utcOffset(0, keepLocalTime);\x0a    }\x0a\x0a    function setOffsetToLocal (keepLocalTime) {\x0a        if (this._isUTC) {\x0a            this.utcOffset(0, keepLocalTime);\x0a            this._isUTC = false;\x0a\x0a            if (keepLocalTime) {\x0a                this.subtract(getDateOffset(this), \x27m\x27);\x0a            }\x0a        }\x0a        return this;\x0a    }\x0a\x0a    function setOffsetToParsedOffset () {\x0a        if (this._tzm != null) {\x0a            this.utcOffset(this._tzm, false, true);\x0a        } else if (typeof this._i === \x27string\x27) {\x0a            var tZone = offsetFromString(matchOffset, this._i);\x0a            if (tZone != null) {\x0a                this.utcOffset(tZone);\x0a            }\x0a            else {\x0a                this.utcOffset(0, true);\x0a            }\x0a        }\x0a        return this;\x0a    }\x0a\x0a    function hasAlignedHourOffset (input) {\x0a        if (!this.isValid()) {\x0a            return false;\x0a        }\x0a        input = input ? createLocal(input).utcOffset() : 0;\x0a\x0a        return (this.utcOffset() - input) % 60 === 0;\x0a    }\x0a\x0a    function isDaylightSavingTime () {\x0a        return (\x0a            this.utcOffset() \x3e this.clone().month(0).utcOffset() ||\x0a            this.utcOffset() \x3e this.clone().month(5).utcOffset()\x0a        );\x0a    }\x0a\x0a    function isDaylightSavingTimeShifted () {\x0a        if (!isUndefined(this._isDSTShifted)) {\x0a            return this._isDSTShifted;\x0a        }\x0a\x0a        var c = {};\x0a\x0a        copyConfig(c, this);\x0a        c = prepareConfig(c);\x0a\x0a        if (c._a) {\x0a            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\x0a            this._isDSTShifted = this.isValid() &&\x0a                compareArrays(c._a, other.toArray()) \x3e 0;\x0a        } else {\x0a            this._isDSTShifted = false;\x0a        }\x0a\x0a        return this._isDSTShifted;\x0a    }\x0a\x0a    function isLocal () {\x0a        return this.isValid() ? !this._isUTC : false;\x0a    }\x0a\x0a    function isUtcOffset () {\x0a        return this.isValid() ? this._isUTC : false;\x0a    }\x0a\x0a    function isUtc () {\x0a        return this.isValid() ? this._isUTC && this._offset === 0 : false;\x0a    }\x0a\x0a    // ASP.NET json date format regex\x0a    var aspNetRegex = /^(\x5c-|\x5c+)?(?:(\x5cd*)[. ])?(\x5cd+)\x5c:(\x5cd+)(?:\x5c:(\x5cd+)(\x5c.\x5cd*)?)?$/;\x0a\x0a    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\x0a    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\x0a    // and further modified to allow for strings containing both week and day\x0a    var isoRegex = /^(-|\x5c+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\x0a\x0a    function createDuration (input, key) {\x0a        var duration = input,\x0a            // matching against regexp is expensive, do it on demand\x0a            match = null,\x0a            sign,\x0a            ret,\x0a            diffRes;\x0a\x0a        if (isDuration(input)) {\x0a            duration = {\x0a                ms : input._milliseconds,\x0a                d  : input._days,\x0a                M  : input._months\x0a            };\x0a        } else if (isNumber(input)) {\x0a            duration = {};\x0a            if (key) {\x0a                duration[key] = input;\x0a            } else {\x0a                duration.milliseconds = input;\x0a            }\x0a        } else if (!!(match = aspNetRegex.exec(input))) {\x0a            sign = (match[1] === \x27-\x27) ? -1 : 1;\x0a            duration = {\x0a                y  : 0,\x0a                d  : toInt(match[DATE])                         * sign,\x0a                h  : toInt(match[HOUR])                         * sign,\x0a                m  : toInt(match[MINUTE])                       * sign,\x0a                s  : toInt(match[SECOND])                       * sign,\x0a                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\x0a            };\x0a        } else if (!!(match = isoRegex.exec(input))) {\x0a            sign = (match[1] === \x27-\x27) ? -1 : (match[1] === \x27+\x27) ? 1 : 1;\x0a            duration = {\x0a                y : parseIso(match[2], sign),\x0a                M : parseIso(match[3], sign),\x0a                w : parseIso(match[4], sign),\x0a                d : parseIso(match[5], sign),\x0a                h : parseIso(match[6], sign),\x0a                m : parseIso(match[7], sign),\x0a                s : parseIso(match[8], sign)\x0a            };\x0a        } else if (duration == null) {// checks for null or undefined\x0a            duration = {};\x0a        } else if (typeof duration === \x27object\x27 && (\x27from\x27 in duration || \x27to\x27 in duration)) {\x0a            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\x0a\x0a            duration = {};\x0a            duration.ms = diffRes.milliseconds;\x0a            duration.M = diffRes.months;\x0a        }\x0a\x0a        ret = new Duration(duration);\x0a\x0a        if (isDuration(input) && hasOwnProp(input, \x27_locale\x27)) {\x0a            ret._locale = input._locale;\x0a        }\x0a\x0a        return ret;\x0a    }\x0a\x0a    createDuration.fn = Duration.prototype;\x0a    createDuration.invalid = createInvalid$1;\x0a\x0a    function parseIso (inp, sign) {\x0a        // We\x27d normally use ~~inp for this, but unfortunately it also\x0a        // converts floats to ints.\x0a        // inp may be undefined, so careful calling replace on it.\x0a        var res = inp && parseFloat(inp.replace(\x27,\x27, \x27.\x27));\x0a        // apply sign while we\x27re at it\x0a        return (isNaN(res) ? 0 : res) * sign;\x0a    }\x0a\x0a    function positiveMomentsDifference(base, other) {\x0a        var res = {milliseconds: 0, months: 0};\x0a\x0a        res.months = other.month() - base.month() +\x0a            (other.year() - base.year()) * 12;\x0a        if (base.clone().add(res.months, \x27M\x27).isAfter(other)) {\x0a            --res.months;\x0a        }\x0a\x0a        res.milliseconds = +other - +(base.clone().add(res.months, \x27M\x27));\x0a\x0a        return res;\x0a    }\x0a\x0a    function momentsDifference(base, other) {\x0a        var res;\x0a        if (!(base.isValid() && other.isValid())) {\x0a            return {milliseconds: 0, months: 0};\x0a        }\x0a\x0a        other = cloneWithOffset(other, base);\x0a        if (base.isBefore(other)) {\x0a            res = positiveMomentsDifference(base, other);\x0a        } else {\x0a            res = positiveMomentsDifference(other, base);\x0a            res.milliseconds = -res.milliseconds;\x0a            res.months = -res.months;\x0a        }\x0a\x0a        return res;\x0a    }\x0a\x0a    // TODO: remove \x27name\x27 arg after deprecation is removed\x0a    function createAdder(direction, name) {\x0a        return function (val, period) {\x0a            var dur, tmp;\x0a            //invert the arguments, but complain about it\x0a            if (period !== null && !isNaN(+period)) {\x0a                deprecateSimple(name, \x27moment().\x27 + name  + \x27(period, number) is deprecated. Please use moment().\x27 + name + \x27(number, period). \x27 +\x0a                \x27See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.\x27);\x0a                tmp = val; val = period; period = tmp;\x0a            }\x0a\x0a            val = typeof val === \x27string\x27 ? +val : val;\x0a            dur = createDuration(val, period);\x0a            addSubtract(this, dur, direction);\x0a            return this;\x0a        };\x0a    }\x0a\x0a    function addSubtract (mom, duration, isAdding, updateOffset) {\x0a        var milliseconds = duration._milliseconds,\x0a            days = absRound(duration._days),\x0a            months = absRound(duration._months);\x0a\x0a        if (!mom.isValid()) {\x0a            // No op\x0a            return;\x0a        }\x0a\x0a        updateOffset = updateOffset == null ? true : updateOffset;\x0a\x0a        if (months) {\x0a            setMonth(mom, get(mom, \x27Month\x27) + months * isAdding);\x0a        }\x0a        if (days) {\x0a            set$1(mom, \x27Date\x27, get(mom, \x27Date\x27) + days * isAdding);\x0a        }\x0a        if (milliseconds) {\x0a            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\x0a        }\x0a        if (updateOffset) {\x0a            hooks.updateOffset(mom, days || months);\x0a        }\x0a    }\x0a\x0a    var add      = createAdder(1, \x27add\x27);\x0a    var subtract = createAdder(-1, \x27subtract\x27);\x0a\x0a    function getCalendarFormat(myMoment, now) {\x0a        var diff = myMoment.diff(now, \x27days\x27, true);\x0a        return diff \x3c -6 ? \x27sameElse\x27 :\x0a                diff \x3c -1 ? \x27lastWeek\x27 :\x0a                diff \x3c 0 ? \x27lastDay\x27 :\x0a                diff \x3c 1 ? \x27sameDay\x27 :\x0a                diff \x3c 2 ? \x27nextDay\x27 :\x0a                diff \x3c 7 ? \x27nextWeek\x27 : \x27sameElse\x27;\x0a    }\x0a\x0a    function calendar$1 (time, formats) {\x0a        // We want to compare the start of today, vs this.\x0a        // Getting start-of-today depends on whether we\x27re local/utc/offset or not.\x0a        var now = time || createLocal(),\x0a            sod = cloneWithOffset(now, this).startOf(\x27day\x27),\x0a            format = hooks.calendarFormat(this, sod) || \x27sameElse\x27;\x0a\x0a        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\x0a\x0a        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\x0a    }\x0a\x0a    function clone () {\x0a        return new Moment(this);\x0a    }\x0a\x0a    function isAfter (input, units) {\x0a        var localInput = isMoment(input) ? input : createLocal(input);\x0a        if (!(this.isValid() && localInput.isValid())) {\x0a            return false;\x0a        }\x0a        units = normalizeUnits(!isUndefined(units) ? units : \x27millisecond\x27);\x0a        if (units === \x27millisecond\x27) {\x0a            return this.valueOf() \x3e localInput.valueOf();\x0a        } else {\x0a            return localInput.valueOf() \x3c this.clone().startOf(units).valueOf();\x0a        }\x0a    }\x0a\x0a    function isBefore (input, units) {\x0a        var localInput = isMoment(input) ? input : createLocal(input);\x0a        if (!(this.isValid() && localInput.isValid())) {\x0a            return false;\x0a        }\x0a        units = normalizeUnits(!isUndefined(units) ? units : \x27millisecond\x27);\x0a        if (units === \x27millisecond\x27) {\x0a            return this.valueOf() \x3c localInput.valueOf();\x0a        } else {\x0a            return this.clone().endOf(units).valueOf() \x3c localInput.valueOf();\x0a        }\x0a    }\x0a\x0a    function isBetween (from, to, units, inclusivity) {\x0a        inclusivity = inclusivity || \x27()\x27;\x0a        return (inclusivity[0] === \x27(\x27 ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\x0a            (inclusivity[1] === \x27)\x27 ? this.isBefore(to, units) : !this.isAfter(to, units));\x0a    }\x0a\x0a    function isSame (input, units) {\x0a        var localInput = isMoment(input) ? input : createLocal(input),\x0a            inputMs;\x0a        if (!(this.isValid() && localInput.isValid())) {\x0a            return false;\x0a        }\x0a        units = normalizeUnits(units || \x27millisecond\x27);\x0a        if (units === \x27millisecond\x27) {\x0a            return this.valueOf() === localInput.valueOf();\x0a        } else {\x0a            inputMs = localInput.valueOf();\x0a            return this.clone().startOf(units).valueOf() \x3c= inputMs && inputMs \x3c= this.clone().endOf(units).valueOf();\x0a        }\x0a    }\x0a\x0a    function isSameOrAfter (input, units) {\x0a        return this.isSame(input, units) || this.isAfter(input,units);\x0a    }\x0a\x0a    function isSameOrBefore (input, units) {\x0a        return this.isSame(input, units) || this.isBefore(input,units);\x0a    }\x0a\x0a    function diff (input, units, asFloat) {\x0a        var that,\x0a            zoneDelta,\x0a            output;\x0a\x0a        if (!this.isValid()) {\x0a            return NaN;\x0a        }\x0a\x0a        that = cloneWithOffset(input, this);\x0a\x0a        if (!that.isValid()) {\x0a            return NaN;\x0a        }\x0a\x0a        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\x0a\x0a        units = normalizeUnits(units);\x0a\x0a        switch (units) {\x0a            case \x27year\x27: output = monthDiff(this, that) / 12; break;\x0a            case \x27month\x27: output = monthDiff(this, that); break;\x0a            case \x27quarter\x27: output = monthDiff(this, that) / 3; break;\x0a            case \x27second\x27: output = (this - that) / 1e3; break; // 1000\x0a            case \x27minute\x27: output = (this - that) / 6e4; break; // 1000 * 60\x0a            case \x27hour\x27: output = (this - that) / 36e5; break; // 1000 * 60 * 60\x0a            case \x27day\x27: output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\x0a            case \x27week\x27: output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst\x0a            default: output = this - that;\x0a        }\x0a\x0a        return asFloat ? output : absFloor(output);\x0a    }\x0a\x0a    function monthDiff (a, b) {\x0a        // difference in months\x0a        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\x0a            // b is in (anchor - 1 month, anchor + 1 month)\x0a            anchor = a.clone().add(wholeMonthDiff, \x27months\x27),\x0a            anchor2, adjust;\x0a\x0a        if (b - anchor \x3c 0) {\x0a            anchor2 = a.clone().add(wholeMonthDiff - 1, \x27months\x27);\x0a            // linear across the month\x0a            adjust = (b - anchor) / (anchor - anchor2);\x0a        } else {\x0a            anchor2 = a.clone().add(wholeMonthDiff + 1, \x27months\x27);\x0a            // linear across the month\x0a            adjust = (b - anchor) / (anchor2 - anchor);\x0a        }\x0a\x0a        //check for negative zero, return zero if negative zero\x0a        return -(wholeMonthDiff + adjust) || 0;\x0a    }\x0a\x0a    hooks.defaultFormat = \x27YYYY-MM-DDTHH:mm:ssZ\x27;\x0a    hooks.defaultFormatUtc = \x27YYYY-MM-DDTHH:mm:ss[Z]\x27;\x0a\x0a    function toString () {\x0a        return this.clone().locale(\x27en\x27).format(\x27ddd MMM DD YYYY HH:mm:ss [GMT]ZZ\x27);\x0a    }\x0a\x0a    function toISOString(keepOffset) {\x0a        if (!this.isValid()) {\x0a            return null;\x0a        }\x0a        var utc = keepOffset !== true;\x0a        var m = utc ? this.clone().utc() : this;\x0a        if (m.year() \x3c 0 || m.year() \x3e 9999) {\x0a            return formatMoment(m, utc ? \x27YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]\x27 : \x27YYYYYY-MM-DD[T]HH:mm:ss.SSSZ\x27);\x0a        }\x0a        if (isFunction(Date.prototype.toISOString)) {\x0a            // native implementation is ~50x faster, use it when we can\x0a            if (utc) {\x0a                return this.toDate().toISOString();\x0a            } else {\x0a                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace(\x27Z\x27, formatMoment(m, \x27Z\x27));\x0a            }\x0a        }\x0a        return formatMoment(m, utc ? \x27YYYY-MM-DD[T]HH:mm:ss.SSS[Z]\x27 : \x27YYYY-MM-DD[T]HH:mm:ss.SSSZ\x27);\x0a    }\x0a\x0a    /**\x0a     * Return a human readable representation of a moment that can\x0a     * also be evaluated to get a new moment which is the same\x0a     *\x0a     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\x0a     */\x0a    function inspect () {\x0a        if (!this.isValid()) {\x0a            return \x27moment.invalid(/* \x27 + this._i + \x27 */)\x27;\x0a        }\x0a        var func = \x27moment\x27;\x0a        var zone = \x27\x27;\x0a        if (!this.isLocal()) {\x0a            func = this.utcOffset() === 0 ? \x27moment.utc\x27 : \x27moment.parseZone\x27;\x0a            zone = \x27Z\x27;\x0a        }\x0a        var prefix = \x27[\x27 + func + \x27(\x22]\x27;\x0a        var year = (0 \x3c= this.year() && this.year() \x3c= 9999) ? \x27YYYY\x27 : \x27YYYYYY\x27;\x0a        var datetime = \x27-MM-DD[T]HH:mm:ss.SSS\x27;\x0a        var suffix = zone + \x27[\x22)]\x27;\x0a\x0a        return this.format(prefix + year + datetime + suffix);\x0a    }\x0a\x0a    function format (inputString) {\x0a        if (!inputString) {\x0a            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\x0a        }\x0a        var output = formatMoment(this, inputString);\x0a        return this.localeData().postformat(output);\x0a    }\x0a\x0a    function from (time, withoutSuffix) {\x0a        if (this.isValid() &&\x0a                ((isMoment(time) && time.isValid()) ||\x0a                 createLocal(time).isValid())) {\x0a            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\x0a        } else {\x0a            return this.localeData().invalidDate();\x0a        }\x0a    }\x0a\x0a    function fromNow (withoutSuffix) {\x0a        return this.from(createLocal(), withoutSuffix);\x0a    }\x0a\x0a    function to (time, withoutSuffix) {\x0a        if (this.isValid() &&\x0a                ((isMoment(time) && time.isValid()) ||\x0a                 createLocal(time).isValid())) {\x0a            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\x0a        } else {\x0a            return this.localeData().invalidDate();\x0a        }\x0a    }\x0a\x0a    function toNow (withoutSuffix) {\x0a        return this.to(createLocal(), withoutSuffix);\x0a    }\x0a\x0a    // If passed a locale key, it will set the locale for this\x0a    // instance.  Otherwise, it will return the locale configuration\x0a    // variables for this instance.\x0a    function locale (key) {\x0a        var newLocaleData;\x0a\x0a        if (key === undefined) {\x0a            return this._locale._abbr;\x0a        } else {\x0a            newLocaleData = getLocale(key);\x0a            if (newLocaleData != null) {\x0a                this._locale = newLocaleData;\x0a            }\x0a            return this;\x0a        }\x0a    }\x0a\x0a    var lang = deprecate(\x0a        \x27moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.\x27,\x0a        function (key) {\x0a            if (key === undefined) {\x0a                return this.localeData();\x0a            } else {\x0a                return this.locale(key);\x0a            }\x0a        }\x0a    );\x0a\x0a    function localeData () {\x0a        return this._locale;\x0a    }\x0a\x0a    function startOf (units) {\x0a        units = normalizeUnits(units);\x0a        // the following switch intentionally omits break keywords\x0a        // to utilize falling through the cases.\x0a        switch (units) {\x0a            case \x27year\x27:\x0a                this.month(0);\x0a                /* falls through */\x0a            case \x27quarter\x27:\x0a            case \x27month\x27:\x0a                this.date(1);\x0a                /* falls through */\x0a            case \x27week\x27:\x0a            case \x27isoWeek\x27:\x0a            case \x27day\x27:\x0a            case \x27date\x27:\x0a                this.hours(0);\x0a                /* falls through */\x0a            case \x27hour\x27:\x0a                this.minutes(0);\x0a                /* falls through */\x0a            case \x27minute\x27:\x0a                this.seconds(0);\x0a                /* falls through */\x0a            case \x27second\x27:\x0a                this.milliseconds(0);\x0a        }\x0a\x0a        // weeks are a special case\x0a        if (units === \x27week\x27) {\x0a            this.weekday(0);\x0a        }\x0a        if (units === \x27isoWeek\x27) {\x0a            this.isoWeekday(1);\x0a        }\x0a\x0a        // quarters are also special\x0a        if (units === \x27quarter\x27) {\x0a            this.month(Math.floor(this.month() / 3) * 3);\x0a        }\x0a\x0a        return this;\x0a    }\x0a\x0a    function endOf (units) {\x0a        units = normalizeUnits(units);\x0a        if (units === undefined || units === \x27millisecond\x27) {\x0a            return this;\x0a        }\x0a\x0a        // \x27date\x27 is an alias for \x27day\x27, so it should be considered as such.\x0a        if (units === \x27date\x27) {\x0a            units = \x27day\x27;\x0a        }\x0a\x0a        return this.startOf(units).add(1, (units === \x27isoWeek\x27 ? \x27week\x27 : units)).subtract(1, \x27ms\x27);\x0a    }\x0a\x0a    function valueOf () {\x0a        return this._d.valueOf() - ((this._offset || 0) * 60000);\x0a    }\x0a\x0a    function unix () {\x0a        return Math.floor(this.valueOf() / 1000);\x0a    }\x0a\x0a    function toDate () {\x0a        return new Date(this.valueOf());\x0a    }\x0a\x0a    function toArray () {\x0a        var m = this;\x0a        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\x0a    }\x0a\x0a    function toObject () {\x0a        var m = this;\x0a        return {\x0a            years: m.year(),\x0a            months: m.month(),\x0a            date: m.date(),\x0a            hours: m.hours(),\x0a            minutes: m.minutes(),\x0a            seconds: m.seconds(),\x0a            milliseconds: m.milliseconds()\x0a        };\x0a    }\x0a\x0a    function toJSON () {\x0a        // new Date(NaN).toJSON() === null\x0a        return this.isValid() ? this.toISOString() : null;\x0a    }\x0a\x0a    function isValid$2 () {\x0a        return isValid(this);\x0a    }\x0a\x0a    function parsingFlags () {\x0a        return extend({}, getParsingFlags(this));\x0a    }\x0a\x0a    function invalidAt () {\x0a        return getParsingFlags(this).overflow;\x0a    }\x0a\x0a    function creationData() {\x0a        return {\x0a            input: this._i,\x0a            format: this._f,\x0a            locale: this._locale,\x0a            isUTC: this._isUTC,\x0a            strict: this._strict\x0a        };\x0a    }\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(0, [\x27gg\x27, 2], 0, function () {\x0a        return this.weekYear() % 100;\x0a    });\x0a\x0a    addFormatToken(0, [\x27GG\x27, 2], 0, function () {\x0a        return this.isoWeekYear() % 100;\x0a    });\x0a\x0a    function addWeekYearFormatToken (token, getter) {\x0a        addFormatToken(0, [token, token.length], 0, getter);\x0a    }\x0a\x0a    addWeekYearFormatToken(\x27gggg\x27,     \x27weekYear\x27);\x0a    addWeekYearFormatToken(\x27ggggg\x27,    \x27weekYear\x27);\x0a    addWeekYearFormatToken(\x27GGGG\x27,  \x27isoWeekYear\x27);\x0a    addWeekYearFormatToken(\x27GGGGG\x27, \x27isoWeekYear\x27);\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27weekYear\x27, \x27gg\x27);\x0a    addUnitAlias(\x27isoWeekYear\x27, \x27GG\x27);\x0a\x0a    // PRIORITY\x0a\x0a    addUnitPriority(\x27weekYear\x27, 1);\x0a    addUnitPriority(\x27isoWeekYear\x27, 1);\x0a\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27G\x27,      matchSigned);\x0a    addRegexToken(\x27g\x27,      matchSigned);\x0a    addRegexToken(\x27GG\x27,     match1to2, match2);\x0a    addRegexToken(\x27gg\x27,     match1to2, match2);\x0a    addRegexToken(\x27GGGG\x27,   match1to4, match4);\x0a    addRegexToken(\x27gggg\x27,   match1to4, match4);\x0a    addRegexToken(\x27GGGGG\x27,  match1to6, match6);\x0a    addRegexToken(\x27ggggg\x27,  match1to6, match6);\x0a\x0a    addWeekParseToken([\x27gggg\x27, \x27ggggg\x27, \x27GGGG\x27, \x27GGGGG\x27], function (input, week, config, token) {\x0a        week[token.substr(0, 2)] = toInt(input);\x0a    });\x0a\x0a    addWeekParseToken([\x27gg\x27, \x27GG\x27], function (input, week, config, token) {\x0a        week[token] = hooks.parseTwoDigitYear(input);\x0a    });\x0a\x0a    // MOMENTS\x0a\x0a    function getSetWeekYear (input) {\x0a        return getSetWeekYearHelper.call(this,\x0a                input,\x0a                this.week(),\x0a                this.weekday(),\x0a                this.localeData()._week.dow,\x0a                this.localeData()._week.doy);\x0a    }\x0a\x0a    function getSetISOWeekYear (input) {\x0a        return getSetWeekYearHelper.call(this,\x0a                input, this.isoWeek(), this.isoWeekday(), 1, 4);\x0a    }\x0a\x0a    function getISOWeeksInYear () {\x0a        return weeksInYear(this.year(), 1, 4);\x0a    }\x0a\x0a    function getWeeksInYear () {\x0a        var weekInfo = this.localeData()._week;\x0a        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\x0a    }\x0a\x0a    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\x0a        var weeksTarget;\x0a        if (input == null) {\x0a            return weekOfYear(this, dow, doy).year;\x0a        } else {\x0a            weeksTarget = weeksInYear(input, dow, doy);\x0a            if (week \x3e weeksTarget) {\x0a                week = weeksTarget;\x0a            }\x0a            return setWeekAll.call(this, input, week, weekday, dow, doy);\x0a        }\x0a    }\x0a\x0a    function setWeekAll(weekYear, week, weekday, dow, doy) {\x0a        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\x0a            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\x0a\x0a        this.year(date.getUTCFullYear());\x0a        this.month(date.getUTCMonth());\x0a        this.date(date.getUTCDate());\x0a        return this;\x0a    }\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27Q\x27, 0, \x27Qo\x27, \x27quarter\x27);\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27quarter\x27, \x27Q\x27);\x0a\x0a    // PRIORITY\x0a\x0a    addUnitPriority(\x27quarter\x27, 7);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27Q\x27, match1);\x0a    addParseToken(\x27Q\x27, function (input, array) {\x0a        array[MONTH] = (toInt(input) - 1) * 3;\x0a    });\x0a\x0a    // MOMENTS\x0a\x0a    function getSetQuarter (input) {\x0a        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\x0a    }\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27D\x27, [\x27DD\x27, 2], \x27Do\x27, \x27date\x27);\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27date\x27, \x27D\x27);\x0a\x0a    // PRIORITY\x0a    addUnitPriority(\x27date\x27, 9);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27D\x27,  match1to2);\x0a    addRegexToken(\x27DD\x27, match1to2, match2);\x0a    addRegexToken(\x27Do\x27, function (isStrict, locale) {\x0a        // TODO: Remove \x22ordinalParse\x22 fallback in next major release.\x0a        return isStrict ?\x0a          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\x0a          locale._dayOfMonthOrdinalParseLenient;\x0a    });\x0a\x0a    addParseToken([\x27D\x27, \x27DD\x27], DATE);\x0a    addParseToken(\x27Do\x27, function (input, array) {\x0a        array[DATE] = toInt(input.match(match1to2)[0]);\x0a    });\x0a\x0a    // MOMENTS\x0a\x0a    var getSetDayOfMonth = makeGetSet(\x27Date\x27, true);\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27DDD\x27, [\x27DDDD\x27, 3], \x27DDDo\x27, \x27dayOfYear\x27);\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27dayOfYear\x27, \x27DDD\x27);\x0a\x0a    // PRIORITY\x0a    addUnitPriority(\x27dayOfYear\x27, 4);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27DDD\x27,  match1to3);\x0a    addRegexToken(\x27DDDD\x27, match3);\x0a    addParseToken([\x27DDD\x27, \x27DDDD\x27], function (input, array, config) {\x0a        config._dayOfYear = toInt(input);\x0a    });\x0a\x0a    // HELPERS\x0a\x0a    // MOMENTS\x0a\x0a    function getSetDayOfYear (input) {\x0a        var dayOfYear = Math.round((this.clone().startOf(\x27day\x27) - this.clone().startOf(\x27year\x27)) / 864e5) + 1;\x0a        return input == null ? dayOfYear : this.add((input - dayOfYear), \x27d\x27);\x0a    }\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27m\x27, [\x27mm\x27, 2], 0, \x27minute\x27);\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27minute\x27, \x27m\x27);\x0a\x0a    // PRIORITY\x0a\x0a    addUnitPriority(\x27minute\x27, 14);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27m\x27,  match1to2);\x0a    addRegexToken(\x27mm\x27, match1to2, match2);\x0a    addParseToken([\x27m\x27, \x27mm\x27], MINUTE);\x0a\x0a    // MOMENTS\x0a\x0a    var getSetMinute = makeGetSet(\x27Minutes\x27, false);\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27s\x27, [\x27ss\x27, 2], 0, \x27second\x27);\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27second\x27, \x27s\x27);\x0a\x0a    // PRIORITY\x0a\x0a    addUnitPriority(\x27second\x27, 15);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27s\x27,  match1to2);\x0a    addRegexToken(\x27ss\x27, match1to2, match2);\x0a    addParseToken([\x27s\x27, \x27ss\x27], SECOND);\x0a\x0a    // MOMENTS\x0a\x0a    var getSetSecond = makeGetSet(\x27Seconds\x27, false);\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27S\x27, 0, 0, function () {\x0a        return ~~(this.millisecond() / 100);\x0a    });\x0a\x0a    addFormatToken(0, [\x27SS\x27, 2], 0, function () {\x0a        return ~~(this.millisecond() / 10);\x0a    });\x0a\x0a    addFormatToken(0, [\x27SSS\x27, 3], 0, \x27millisecond\x27);\x0a    addFormatToken(0, [\x27SSSS\x27, 4], 0, function () {\x0a        return this.millisecond() * 10;\x0a    });\x0a    addFormatToken(0, [\x27SSSSS\x27, 5], 0, function () {\x0a        return this.millisecond() * 100;\x0a    });\x0a    addFormatToken(0, [\x27SSSSSS\x27, 6], 0, function () {\x0a        return this.millisecond() * 1000;\x0a    });\x0a    addFormatToken(0, [\x27SSSSSSS\x27, 7], 0, function () {\x0a        return this.millisecond() * 10000;\x0a    });\x0a    addFormatToken(0, [\x27SSSSSSSS\x27, 8], 0, function () {\x0a        return this.millisecond() * 100000;\x0a    });\x0a    addFormatToken(0, [\x27SSSSSSSSS\x27, 9], 0, function () {\x0a        return this.millisecond() * 1000000;\x0a    });\x0a\x0a\x0a    // ALIASES\x0a\x0a    addUnitAlias(\x27millisecond\x27, \x27ms\x27);\x0a\x0a    // PRIORITY\x0a\x0a    addUnitPriority(\x27millisecond\x27, 16);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27S\x27,    match1to3, match1);\x0a    addRegexToken(\x27SS\x27,   match1to3, match2);\x0a    addRegexToken(\x27SSS\x27,  match1to3, match3);\x0a\x0a    var token;\x0a    for (token = \x27SSSS\x27; token.length \x3c= 9; token += \x27S\x27) {\x0a        addRegexToken(token, matchUnsigned);\x0a    }\x0a\x0a    function parseMs(input, array) {\x0a        array[MILLISECOND] = toInt((\x270.\x27 + input) * 1000);\x0a    }\x0a\x0a    for (token = \x27S\x27; token.length \x3c= 9; token += \x27S\x27) {\x0a        addParseToken(token, parseMs);\x0a    }\x0a    // MOMENTS\x0a\x0a    var getSetMillisecond = makeGetSet(\x27Milliseconds\x27, false);\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27z\x27,  0, 0, \x27zoneAbbr\x27);\x0a    addFormatToken(\x27zz\x27, 0, 0, \x27zoneName\x27);\x0a\x0a    // MOMENTS\x0a\x0a    function getZoneAbbr () {\x0a        return this._isUTC ? \x27UTC\x27 : \x27\x27;\x0a    }\x0a\x0a    function getZoneName () {\x0a        return this._isUTC ? \x27Coordinated Universal Time\x27 : \x27\x27;\x0a    }\x0a\x0a    var proto = Moment.prototype;\x0a\x0a    proto.add               = add;\x0a    proto.calendar          = calendar$1;\x0a    proto.clone             = clone;\x0a    proto.diff              = diff;\x0a    proto.endOf             = endOf;\x0a    proto.format            = format;\x0a    proto.from              = from;\x0a    proto.fromNow           = fromNow;\x0a    proto.to                = to;\x0a    proto.toNow             = toNow;\x0a    proto.get               = stringGet;\x0a    proto.invalidAt         = invalidAt;\x0a    proto.isAfter           = isAfter;\x0a    proto.isBefore          = isBefore;\x0a    proto.isBetween         = isBetween;\x0a    proto.isSame            = isSame;\x0a    proto.isSameOrAfter     = isSameOrAfter;\x0a    proto.isSameOrBefore    = isSameOrBefore;\x0a    proto.isValid           = isValid$2;\x0a    proto.lang              = lang;\x0a    proto.locale            = locale;\x0a    proto.localeData        = localeData;\x0a    proto.max               = prototypeMax;\x0a    proto.min               = prototypeMin;\x0a    proto.parsingFlags      = parsingFlags;\x0a    proto.set               = stringSet;\x0a    proto.startOf           = startOf;\x0a    proto.subtract          = subtract;\x0a    proto.toArray           = toArray;\x0a    proto.toObject          = toObject;\x0a    proto.toDate            = toDate;\x0a    proto.toISOString       = toISOString;\x0a    proto.inspect           = inspect;\x0a    proto.toJSON            = toJSON;\x0a    proto.toString          = toString;\x0a    proto.unix              = unix;\x0a    proto.valueOf           = valueOf;\x0a    proto.creationData      = creationData;\x0a    proto.year       = getSetYear;\x0a    proto.isLeapYear = getIsLeapYear;\x0a    proto.weekYear    = getSetWeekYear;\x0a    proto.isoWeekYear = getSetISOWeekYear;\x0a    proto.quarter = proto.quarters = getSetQuarter;\x0a    proto.month       = getSetMonth;\x0a    proto.daysInMonth = getDaysInMonth;\x0a    proto.week           = proto.weeks        = getSetWeek;\x0a    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\x0a    proto.weeksInYear    = getWeeksInYear;\x0a    proto.isoWeeksInYear = getISOWeeksInYear;\x0a    proto.date       = getSetDayOfMonth;\x0a    proto.day        = proto.days             = getSetDayOfWeek;\x0a    proto.weekday    = getSetLocaleDayOfWeek;\x0a    proto.isoWeekday = getSetISODayOfWeek;\x0a    proto.dayOfYear  = getSetDayOfYear;\x0a    proto.hour = proto.hours = getSetHour;\x0a    proto.minute = proto.minutes = getSetMinute;\x0a    proto.second = proto.seconds = getSetSecond;\x0a    proto.millisecond = proto.milliseconds = getSetMillisecond;\x0a    proto.utcOffset            = getSetOffset;\x0a    proto.utc                  = setOffsetToUTC;\x0a    proto.local                = setOffsetToLocal;\x0a    proto.parseZone            = setOffsetToParsedOffset;\x0a    proto.hasAlignedHourOffset = hasAlignedHourOffset;\x0a    proto.isDST                = isDaylightSavingTime;\x0a    proto.isLocal              = isLocal;\x0a    proto.isUtcOffset          = isUtcOffset;\x0a    proto.isUtc                = isUtc;\x0a    proto.isUTC                = isUtc;\x0a    proto.zoneAbbr = getZoneAbbr;\x0a    proto.zoneName = getZoneName;\x0a    proto.dates  = deprecate(\x27dates accessor is deprecated. Use date instead.\x27, getSetDayOfMonth);\x0a    proto.months = deprecate(\x27months accessor is deprecated. Use month instead\x27, getSetMonth);\x0a    proto.years  = deprecate(\x27years accessor is deprecated. Use year instead\x27, getSetYear);\x0a    proto.zone   = deprecate(\x27moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/\x27, getSetZone);\x0a    proto.isDSTShifted = deprecate(\x27isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information\x27, isDaylightSavingTimeShifted);\x0a\x0a    function createUnix (input) {\x0a        return createLocal(input * 1000);\x0a    }\x0a\x0a    function createInZone () {\x0a        return createLocal.apply(null, arguments).parseZone();\x0a    }\x0a\x0a    function preParsePostFormat (string) {\x0a        return string;\x0a    }\x0a\x0a    var proto$1 = Locale.prototype;\x0a\x0a    proto$1.calendar        = calendar;\x0a    proto$1.longDateFormat  = longDateFormat;\x0a    proto$1.invalidDate     = invalidDate;\x0a    proto$1.ordinal         = ordinal;\x0a    proto$1.preparse        = preParsePostFormat;\x0a    proto$1.postformat      = preParsePostFormat;\x0a    proto$1.relativeTime    = relativeTime;\x0a    proto$1.pastFuture      = pastFuture;\x0a    proto$1.set             = set;\x0a\x0a    proto$1.months            =        localeMonths;\x0a    proto$1.monthsShort       =        localeMonthsShort;\x0a    proto$1.monthsParse       =        localeMonthsParse;\x0a    proto$1.monthsRegex       = monthsRegex;\x0a    proto$1.monthsShortRegex  = monthsShortRegex;\x0a    proto$1.week = localeWeek;\x0a    proto$1.firstDayOfYear = localeFirstDayOfYear;\x0a    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\x0a\x0a    proto$1.weekdays       =        localeWeekdays;\x0a    proto$1.weekdaysMin    =        localeWeekdaysMin;\x0a    proto$1.weekdaysShort  =        localeWeekdaysShort;\x0a    proto$1.weekdaysParse  =        localeWeekdaysParse;\x0a\x0a    proto$1.weekdaysRegex       =        weekdaysRegex;\x0a    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;\x0a    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;\x0a\x0a    proto$1.isPM = localeIsPM;\x0a    proto$1.meridiem = localeMeridiem;\x0a\x0a    function get$1 (format, index, field, setter) {\x0a        var locale = getLocale();\x0a        var utc = createUTC().set(setter, index);\x0a        return locale[field](utc, format);\x0a    }\x0a\x0a    function listMonthsImpl (format, index, field) {\x0a        if (isNumber(format)) {\x0a            index = format;\x0a            format = undefined;\x0a        }\x0a\x0a        format = format || \x27\x27;\x0a\x0a        if (index != null) {\x0a            return get$1(format, index, field, \x27month\x27);\x0a        }\x0a\x0a        var i;\x0a        var out = [];\x0a        for (i = 0; i \x3c 12; i++) {\x0a            out[i] = get$1(format, i, field, \x27month\x27);\x0a        }\x0a        return out;\x0a    }\x0a\x0a    // ()\x0a    // (5)\x0a    // (fmt, 5)\x0a    // (fmt)\x0a    // (true)\x0a    // (true, 5)\x0a    // (true, fmt, 5)\x0a    // (true, fmt)\x0a    function listWeekdaysImpl (localeSorted, format, index, field) {\x0a        if (typeof localeSorted === \x27boolean\x27) {\x0a            if (isNumber(format)) {\x0a                index = format;\x0a                format = undefined;\x0a            }\x0a\x0a            format = format || \x27\x27;\x0a        } else {\x0a            format = localeSorted;\x0a            index = format;\x0a            localeSorted = false;\x0a\x0a            if (isNumber(format)) {\x0a                index = format;\x0a                format = undefined;\x0a            }\x0a\x0a            format = format || \x27\x27;\x0a        }\x0a\x0a        var locale = getLocale(),\x0a            shift = localeSorted ? locale._week.dow : 0;\x0a\x0a        if (index != null) {\x0a            return get$1(format, (index + shift) % 7, field, \x27day\x27);\x0a        }\x0a\x0a        var i;\x0a        var out = [];\x0a        for (i = 0; i \x3c 7; i++) {\x0a            out[i] = get$1(format, (i + shift) % 7, field, \x27day\x27);\x0a        }\x0a        return out;\x0a    }\x0a\x0a    function listMonths (format, index) {\x0a        return listMonthsImpl(format, index, \x27months\x27);\x0a    }\x0a\x0a    function listMonthsShort (format, index) {\x0a        return listMonthsImpl(format, index, \x27monthsShort\x27);\x0a    }\x0a\x0a    function listWeekdays (localeSorted, format, index) {\x0a        return listWeekdaysImpl(localeSorted, format, index, \x27weekdays\x27);\x0a    }\x0a\x0a    function listWeekdaysShort (localeSorted, format, index) {\x0a        return listWeekdaysImpl(localeSorted, format, index, \x27weekdaysShort\x27);\x0a    }\x0a\x0a    function listWeekdaysMin (localeSorted, format, index) {\x0a        return listWeekdaysImpl(localeSorted, format, index, \x27weekdaysMin\x27);\x0a    }\x0a\x0a    getSetGlobalLocale(\x27en\x27, {\x0a        dayOfMonthOrdinalParse: /\x5cd{1,2}(th|st|nd|rd)/,\x0a        ordinal : function (number) {\x0a            var b = number % 10,\x0a                output = (toInt(number % 100 / 10) === 1) ? \x27th\x27 :\x0a                (b === 1) ? \x27st\x27 :\x0a                (b === 2) ? \x27nd\x27 :\x0a                (b === 3) ? \x27rd\x27 : \x27th\x27;\x0a            return number + output;\x0a        }\x0a    });\x0a\x0a    // Side effect imports\x0a\x0a    hooks.lang = deprecate(\x27moment.lang is deprecated. Use moment.locale instead.\x27, getSetGlobalLocale);\x0a    hooks.langData = deprecate(\x27moment.langData is deprecated. Use moment.localeData instead.\x27, getLocale);\x0a\x0a    var mathAbs = Math.abs;\x0a\x0a    function abs () {\x0a        var data           = this._data;\x0a\x0a        this._milliseconds = mathAbs(this._milliseconds);\x0a        this._days         = mathAbs(this._days);\x0a        this._months       = mathAbs(this._months);\x0a\x0a        data.milliseconds  = mathAbs(data.milliseconds);\x0a        data.seconds       = mathAbs(data.seconds);\x0a        data.minutes       = mathAbs(data.minutes);\x0a        data.hours         = mathAbs(data.hours);\x0a        data.months        = mathAbs(data.months);\x0a        data.years         = mathAbs(data.years);\x0a\x0a        return this;\x0a    }\x0a\x0a    function addSubtract$1 (duration, input, value, direction) {\x0a        var other = createDuration(input, value);\x0a\x0a        duration._milliseconds += direction * other._milliseconds;\x0a        duration._days         += direction * other._days;\x0a        duration._months       += direction * other._months;\x0a\x0a        return duration._bubble();\x0a    }\x0a\x0a    // supports only 2.0-style add(1, \x27s\x27) or add(duration)\x0a    function add$1 (input, value) {\x0a        return addSubtract$1(this, input, value, 1);\x0a    }\x0a\x0a    // supports only 2.0-style subtract(1, \x27s\x27) or subtract(duration)\x0a    function subtract$1 (input, value) {\x0a        return addSubtract$1(this, input, value, -1);\x0a    }\x0a\x0a    function absCeil (number) {\x0a        if (number \x3c 0) {\x0a            return Math.floor(number);\x0a        } else {\x0a            return Math.ceil(number);\x0a        }\x0a    }\x0a\x0a    function bubble () {\x0a        var milliseconds = this._milliseconds;\x0a        var days         = this._days;\x0a        var months       = this._months;\x0a        var data         = this._data;\x0a        var seconds, minutes, hours, years, monthsFromDays;\x0a\x0a        // if we have a mix of positive and negative values, bubble down first\x0a        // check: https://github.com/moment/moment/issues/2166\x0a        if (!((milliseconds \x3e= 0 && days \x3e= 0 && months \x3e= 0) ||\x0a                (milliseconds \x3c= 0 && days \x3c= 0 && months \x3c= 0))) {\x0a            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\x0a            days = 0;\x0a            months = 0;\x0a        }\x0a\x0a        // The following code bubbles up values, see the tests for\x0a        // examples of what that means.\x0a        data.milliseconds = milliseconds % 1000;\x0a\x0a        seconds           = absFloor(milliseconds / 1000);\x0a        data.seconds      = seconds % 60;\x0a\x0a        minutes           = absFloor(seconds / 60);\x0a        data.minutes      = minutes % 60;\x0a\x0a        hours             = absFloor(minutes / 60);\x0a        data.hours        = hours % 24;\x0a\x0a        days += absFloor(hours / 24);\x0a\x0a        // convert days to months\x0a        monthsFromDays = absFloor(daysToMonths(days));\x0a        months += monthsFromDays;\x0a        days -= absCeil(monthsToDays(monthsFromDays));\x0a\x0a        // 12 months -\x3e 1 year\x0a        years = absFloor(months / 12);\x0a        months %= 12;\x0a\x0a        data.days   = days;\x0a        data.months = months;\x0a        data.years  = years;\x0a\x0a        return this;\x0a    }\x0a\x0a    function daysToMonths (days) {\x0a        // 400 years have 146097 days (taking into account leap year rules)\x0a        // 400 years have 12 months === 4800\x0a        return days * 4800 / 146097;\x0a    }\x0a\x0a    function monthsToDays (months) {\x0a        // the reverse of daysToMonths\x0a        return months * 146097 / 4800;\x0a    }\x0a\x0a    function as (units) {\x0a        if (!this.isValid()) {\x0a            return NaN;\x0a        }\x0a        var days;\x0a        var months;\x0a        var milliseconds = this._milliseconds;\x0a\x0a        units = normalizeUnits(units);\x0a\x0a        if (units === \x27month\x27 || units === \x27year\x27) {\x0a            days   = this._days   + milliseconds / 864e5;\x0a            months = this._months + daysToMonths(days);\x0a            return units === \x27month\x27 ? months : months / 12;\x0a        } else {\x0a            // handle milliseconds separately because of floating point math errors (issue #1867)\x0a            days = this._days + Math.round(monthsToDays(this._months));\x0a            switch (units) {\x0a                case \x27week\x27   : return days / 7     + milliseconds / 6048e5;\x0a                case \x27day\x27    : return days         + milliseconds / 864e5;\x0a                case \x27hour\x27   : return days * 24    + milliseconds / 36e5;\x0a                case \x27minute\x27 : return days * 1440  + milliseconds / 6e4;\x0a                case \x27second\x27 : return days * 86400 + milliseconds / 1000;\x0a                // Math.floor prevents floating point math errors here\x0a                case \x27millisecond\x27: return Math.floor(days * 864e5) + milliseconds;\x0a                default: throw new Error(\x27Unknown unit \x27 + units);\x0a            }\x0a        }\x0a    }\x0a\x0a    // TODO: Use this.as(\x27ms\x27)?\x0a    function valueOf$1 () {\x0a        if (!this.isValid()) {\x0a            return NaN;\x0a        }\x0a        return (\x0a            this._milliseconds +\x0a            this._days * 864e5 +\x0a            (this._months % 12) * 2592e6 +\x0a            toInt(this._months / 12) * 31536e6\x0a        );\x0a    }\x0a\x0a    function makeAs (alias) {\x0a        return function () {\x0a            return this.as(alias);\x0a        };\x0a    }\x0a\x0a    var asMilliseconds = makeAs(\x27ms\x27);\x0a    var asSeconds      = makeAs(\x27s\x27);\x0a    var asMinutes      = makeAs(\x27m\x27);\x0a    var asHours        = makeAs(\x27h\x27);\x0a    var asDays         = makeAs(\x27d\x27);\x0a    var asWeeks        = makeAs(\x27w\x27);\x0a    var asMonths       = makeAs(\x27M\x27);\x0a    var asYears        = makeAs(\x27y\x27);\x0a\x0a    function clone$1 () {\x0a        return createDuration(this);\x0a    }\x0a\x0a    function get$2 (units) {\x0a        units = normalizeUnits(units);\x0a        return this.isValid() ? this[units + \x27s\x27]() : NaN;\x0a    }\x0a\x0a    function makeGetter(name) {\x0a        return function () {\x0a            return this.isValid() ? this._data[name] : NaN;\x0a        };\x0a    }\x0a\x0a    var milliseconds = makeGetter(\x27milliseconds\x27);\x0a    var seconds      = makeGetter(\x27seconds\x27);\x0a    var minutes      = makeGetter(\x27minutes\x27);\x0a    var hours        = makeGetter(\x27hours\x27);\x0a    var days         = makeGetter(\x27days\x27);\x0a    var months       = makeGetter(\x27months\x27);\x0a    var years        = makeGetter(\x27years\x27);\x0a\x0a    function weeks () {\x0a        return absFloor(this.days() / 7);\x0a    }\x0a\x0a    var round = Math.round;\x0a    var thresholds = {\x0a        ss: 44,         // a few seconds to seconds\x0a        s : 45,         // seconds to minute\x0a        m : 45,         // minutes to hour\x0a        h : 22,         // hours to day\x0a        d : 26,         // days to month\x0a        M : 11          // months to year\x0a    };\x0a\x0a    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\x0a    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\x0a        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\x0a    }\x0a\x0a    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {\x0a        var duration = createDuration(posNegDuration).abs();\x0a        var seconds  = round(duration.as(\x27s\x27));\x0a        var minutes  = round(duration.as(\x27m\x27));\x0a        var hours    = round(duration.as(\x27h\x27));\x0a        var days     = round(duration.as(\x27d\x27));\x0a        var months   = round(duration.as(\x27M\x27));\x0a        var years    = round(duration.as(\x27y\x27));\x0a\x0a        var a = seconds \x3c= thresholds.ss && [\x27s\x27, seconds]  ||\x0a                seconds \x3c thresholds.s   && [\x27ss\x27, seconds] ||\x0a                minutes \x3c= 1             && [\x27m\x27]           ||\x0a                minutes \x3c thresholds.m   && [\x27mm\x27, minutes] ||\x0a                hours   \x3c= 1             && [\x27h\x27]           ||\x0a                hours   \x3c thresholds.h   && [\x27hh\x27, hours]   ||\x0a                days    \x3c= 1             && [\x27d\x27]           ||\x0a                days    \x3c thresholds.d   && [\x27dd\x27, days]    ||\x0a                months  \x3c= 1             && [\x27M\x27]           ||\x0a                months  \x3c thresholds.M   && [\x27MM\x27, months]  ||\x0a                years   \x3c= 1             && [\x27y\x27]           || [\x27yy\x27, years];\x0a\x0a        a[2] = withoutSuffix;\x0a        a[3] = +posNegDuration \x3e 0;\x0a        a[4] = locale;\x0a        return substituteTimeAgo.apply(null, a);\x0a    }\x0a\x0a    // This function allows you to set the rounding function for relative time strings\x0a    function getSetRelativeTimeRounding (roundingFunction) {\x0a        if (roundingFunction === undefined) {\x0a            return round;\x0a        }\x0a        if (typeof(roundingFunction) === \x27function\x27) {\x0a            round = roundingFunction;\x0a            return true;\x0a        }\x0a        return false;\x0a    }\x0a\x0a    // This function allows you to set a threshold for relative time strings\x0a    function getSetRelativeTimeThreshold (threshold, limit) {\x0a        if (thresholds[threshold] === undefined) {\x0a            return false;\x0a        }\x0a        if (limit === undefined) {\x0a            return thresholds[threshold];\x0a        }\x0a        thresholds[threshold] = limit;\x0a        if (threshold === \x27s\x27) {\x0a            thresholds.ss = limit - 1;\x0a        }\x0a        return true;\x0a    }\x0a\x0a    function humanize (withSuffix) {\x0a        if (!this.isValid()) {\x0a            return this.localeData().invalidDate();\x0a        }\x0a\x0a        var locale = this.localeData();\x0a        var output = relativeTime$1(this, !withSuffix, locale);\x0a\x0a        if (withSuffix) {\x0a            output = locale.pastFuture(+this, output);\x0a        }\x0a\x0a        return locale.postformat(output);\x0a    }\x0a\x0a    var abs$1 = Math.abs;\x0a\x0a    function sign(x) {\x0a        return ((x \x3e 0) - (x \x3c 0)) || +x;\x0a    }\x0a\x0a    function toISOString$1() {\x0a        // for ISO strings we do not use the normal bubbling rules:\x0a        //  * milliseconds bubble up until they become hours\x0a        //  * days do not bubble at all\x0a        //  * months bubble up until they become years\x0a        // This is because there is no context-free conversion between hours and days\x0a        // (think of clock changes)\x0a        // and also not between days and months (28-31 days per month)\x0a        if (!this.isValid()) {\x0a            return this.localeData().invalidDate();\x0a        }\x0a\x0a        var seconds = abs$1(this._milliseconds) / 1000;\x0a        var days         = abs$1(this._days);\x0a        var months       = abs$1(this._months);\x0a        var minutes, hours, years;\x0a\x0a        // 3600 seconds -\x3e 60 minutes -\x3e 1 hour\x0a        minutes           = absFloor(seconds / 60);\x0a        hours             = absFloor(minutes / 60);\x0a        seconds %= 60;\x0a        minutes %= 60;\x0a\x0a        // 12 months -\x3e 1 year\x0a        years  = absFloor(months / 12);\x0a        months %= 12;\x0a\x0a\x0a        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\x0a        var Y = years;\x0a        var M = months;\x0a        var D = days;\x0a        var h = hours;\x0a        var m = minutes;\x0a        var s = seconds ? seconds.toFixed(3).replace(/\x5c.?0+$/, \x27\x27) : \x27\x27;\x0a        var total = this.asSeconds();\x0a\x0a        if (!total) {\x0a            // this is the same as C#\x27s (Noda) and python (isodate)...\x0a            // but not other JS (goog.date)\x0a            return \x27P0D\x27;\x0a        }\x0a\x0a        var totalSign = total \x3c 0 ? \x27-\x27 : \x27\x27;\x0a        var ymSign = sign(this._months) !== sign(total) ? \x27-\x27 : \x27\x27;\x0a        var daysSign = sign(this._days) !== sign(total) ? \x27-\x27 : \x27\x27;\x0a        var hmsSign = sign(this._milliseconds) !== sign(total) ? \x27-\x27 : \x27\x27;\x0a\x0a        return totalSign + \x27P\x27 +\x0a            (Y ? ymSign + Y + \x27Y\x27 : \x27\x27) +\x0a            (M ? ymSign + M + \x27M\x27 : \x27\x27) +\x0a            (D ? daysSign + D + \x27D\x27 : \x27\x27) +\x0a            ((h || m || s) ? \x27T\x27 : \x27\x27) +\x0a            (h ? hmsSign + h + \x27H\x27 : \x27\x27) +\x0a            (m ? hmsSign + m + \x27M\x27 : \x27\x27) +\x0a            (s ? hmsSign + s + \x27S\x27 : \x27\x27);\x0a    }\x0a\x0a    var proto$2 = Duration.prototype;\x0a\x0a    proto$2.isValid        = isValid$1;\x0a    proto$2.abs            = abs;\x0a    proto$2.add            = add$1;\x0a    proto$2.subtract       = subtract$1;\x0a    proto$2.as             = as;\x0a    proto$2.asMilliseconds = asMilliseconds;\x0a    proto$2.asSeconds      = asSeconds;\x0a    proto$2.asMinutes      = asMinutes;\x0a    proto$2.asHours        = asHours;\x0a    proto$2.asDays         = asDays;\x0a    proto$2.asWeeks        = asWeeks;\x0a    proto$2.asMonths       = asMonths;\x0a    proto$2.asYears        = asYears;\x0a    proto$2.valueOf        = valueOf$1;\x0a    proto$2._bubble        = bubble;\x0a    proto$2.clone          = clone$1;\x0a    proto$2.get            = get$2;\x0a    proto$2.milliseconds   = milliseconds;\x0a    proto$2.seconds        = seconds;\x0a    proto$2.minutes        = minutes;\x0a    proto$2.hours          = hours;\x0a    proto$2.days           = days;\x0a    proto$2.weeks          = weeks;\x0a    proto$2.months         = months;\x0a    proto$2.years          = years;\x0a    proto$2.humanize       = humanize;\x0a    proto$2.toISOString    = toISOString$1;\x0a    proto$2.toString       = toISOString$1;\x0a    proto$2.toJSON         = toISOString$1;\x0a    proto$2.locale         = locale;\x0a    proto$2.localeData     = localeData;\x0a\x0a    proto$2.toIsoString = deprecate(\x27toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)\x27, toISOString$1);\x0a    proto$2.lang = lang;\x0a\x0a    // Side effect imports\x0a\x0a    // FORMATTING\x0a\x0a    addFormatToken(\x27X\x27, 0, 0, \x27unix\x27);\x0a    addFormatToken(\x27x\x27, 0, 0, \x27valueOf\x27);\x0a\x0a    // PARSING\x0a\x0a    addRegexToken(\x27x\x27, matchSigned);\x0a    addRegexToken(\x27X\x27, matchTimestamp);\x0a    addParseToken(\x27X\x27, function (input, array, config) {\x0a        config._d = new Date(parseFloat(input, 10) * 1000);\x0a    });\x0a    addParseToken(\x27x\x27, function (input, array, config) {\x0a        config._d = new Date(toInt(input));\x0a    });\x0a\x0a    // Side effect imports\x0a\x0a\x0a    hooks.version = \x272.22.2\x27;\x0a\x0a    setHookCallback(createLocal);\x0a\x0a    hooks.fn                    = proto;\x0a    hooks.min                   = min;\x0a    hooks.max                   = max;\x0a    hooks.now                   = now;\x0a    hooks.utc                   = createUTC;\x0a    hooks.unix                  = createUnix;\x0a    hooks.months                = listMonths;\x0a    hooks.isDate                = isDate;\x0a    hooks.locale                = getSetGlobalLocale;\x0a    hooks.invalid               = createInvalid;\x0a    hooks.duration              = createDuration;\x0a    hooks.isMoment              = isMoment;\x0a    hooks.weekdays              = listWeekdays;\x0a    hooks.parseZone             = createInZone;\x0a    hooks.localeData            = getLocale;\x0a    hooks.isDuration            = isDuration;\x0a    hooks.monthsShort           = listMonthsShort;\x0a    hooks.weekdaysMin           = listWeekdaysMin;\x0a    hooks.defineLocale          = defineLocale;\x0a    hooks.updateLocale          = updateLocale;\x0a    hooks.locales               = listLocales;\x0a    hooks.weekdaysShort         = listWeekdaysShort;\x0a    hooks.normalizeUnits        = normalizeUnits;\x0a    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;\x0a    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\x0a    hooks.calendarFormat        = getCalendarFormat;\x0a    hooks.prototype             = proto;\x0a\x0a    // currently HTML5 input type only supports 24-hour formats\x0a    hooks.HTML5_FMT = {\x0a        DATETIME_LOCAL: \x27YYYY-MM-DDTHH:mm\x27,             // \x3cinput type=\x22datetime-local\x22 /\x3e\x0a        DATETIME_LOCAL_SECONDS: \x27YYYY-MM-DDTHH:mm:ss\x27,  // \x3cinput type=\x22datetime-local\x22 step=\x221\x22 /\x3e\x0a        DATETIME_LOCAL_MS: \x27YYYY-MM-DDTHH:mm:ss.SSS\x27,   // \x3cinput type=\x22datetime-local\x22 step=\x220.001\x22 /\x3e\x0a        DATE: \x27YYYY-MM-DD\x27,                             // \x3cinput type=\x22date\x22 /\x3e\x0a        TIME: \x27HH:mm\x27,                                  // \x3cinput type=\x22time\x22 /\x3e\x0a        TIME_SECONDS: \x27HH:mm:ss\x27,                       // \x3cinput type=\x22time\x22 step=\x221\x22 /\x3e\x0a        TIME_MS: \x27HH:mm:ss.SSS\x27,                        // \x3cinput type=\x22time\x22 step=\x220.001\x22 /\x3e\x0a        WEEK: \x27YYYY-[W]WW\x27,                             // \x3cinput type=\x22week\x22 /\x3e\x0a        MONTH: \x27YYYY-MM\x27                                // \x3cinput type=\x22month\x22 /\x3e\x0a    };\x0a\x0a    return hooks;\x0a\x0a})));\x0a\x01'}