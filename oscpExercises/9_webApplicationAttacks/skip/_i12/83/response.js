var res = {'data':'HTTP/1.1 200 OK\x0aDate: Sun, 20 Sep 2020 15:05:14 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Fri, 14 Dec 2018 04:41:57 GMT\x0aETag: \x2283cd1-57cf40d168f40-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aKeep-Alive: timeout=5, max=95\x0aConnection: Keep-Alive\x0aTransfer-Encoding: chunked\x0aContent-Type: application/javascript\x0a\x0a/**\x0a * @license\x0a * Lodash \x3chttps://lodash.com/\x3e\x0a * Copyright JS Foundation and other contributors \x3chttps://js.foundation/\x3e\x0a * Released under MIT license \x3chttps://lodash.com/license\x3e\x0a * Based on Underscore.js 1.8.3 \x3chttp://underscorejs.org/LICENSE\x3e\x0a * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\x0a */\x0a;(function() {\x0a\x0a  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\x0a  var undefined;\x0a\x0a  /** Used as the semantic version number. */\x0a  var VERSION = \x274.17.11\x27;\x0a\x0a  /** Used as the size to enable large array optimizations. */\x0a  var LARGE_ARRAY_SIZE = 200;\x0a\x0a  /** Error message constants. */\x0a  var CORE_ERROR_TEXT = \x27Unsupported core-js use. Try https://npms.io/search?q=ponyfill.\x27,\x0a      FUNC_ERROR_TEXT = \x27Expected a function\x27;\x0a\x0a  /** Used to stand-in for `undefined` hash values. */\x0a  var HASH_UNDEFINED = \x27__lodash_hash_undefined__\x27;\x0a\x0a  /** Used as the maximum memoize cache size. */\x0a  var MAX_MEMOIZE_SIZE = 500;\x0a\x0a  /** Used as the internal argument placeholder. */\x0a  var PLACEHOLDER = \x27__lodash_placeholder__\x27;\x0a\x0a  /** Used to compose bitmasks for cloning. */\x0a  var CLONE_DEEP_FLAG = 1,\x0a      CLONE_FLAT_FLAG = 2,\x0a      CLONE_SYMBOLS_FLAG = 4;\x0a\x0a  /** Used to compose bitmasks for value comparisons. */\x0a  var COMPARE_PARTIAL_FLAG = 1,\x0a      COMPARE_UNORDERED_FLAG = 2;\x0a\x0a  /** Used to compose bitmasks for function metadata. */\x0a  var WRAP_BIND_FLAG = 1,\x0a      WRAP_BIND_KEY_FLAG = 2,\x0a      WRAP_CURRY_BOUND_FLAG = 4,\x0a      WRAP_CURRY_FLAG = 8,\x0a      WRAP_CURRY_RIGHT_FLAG = 16,\x0a      WRAP_PARTIAL_FLAG = 32,\x0a      WRAP_PARTIAL_RIGHT_FLAG = 64,\x0a      WRAP_ARY_FLAG = 128,\x0a      WRAP_REARG_FLAG = 256,\x0a      WRAP_FLIP_FLAG = 512;\x0a\x0a  /** Used as default options for `_.truncate`. */\x0a  var DEFAULT_TRUNC_LENGTH = 30,\x0a      DEFAULT_TRUNC_OMISSION = \x27...\x27;\x0a\x0a  /** Used to detect hot functions by number of calls within a span of milliseconds. */\x0a  var HOT_COUNT = 800,\x0a      HOT_SPAN = 16;\x0a\x0a  /** Used to indicate the type of lazy iteratees. */\x0a  var LAZY_FILTER_FLAG = 1,\x0a      LAZY_MAP_FLAG = 2,\x0a      LAZY_WHILE_FLAG = 3;\x0a\x0a  /** Used as references for various `Number` constants. */\x0a  var INFINITY = 1 / 0,\x0a      MAX_SAFE_INTEGER = 9007199254740991,\x0a      MAX_INTEGER = 1.7976931348623157e+308,\x0a      NAN = 0 / 0;\x0a\x0a  /** Used as references for the maximum length and index of an array. */\x0a  var MAX_ARRAY_LENGTH = 4294967295,\x0a      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\x0a      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH \x3e\x3e\x3e 1;\x0a\x0a  /** Used to associate wrap methods with their bit flags. */\x0a  var wrapFlags = [\x0a    [\x27ary\x27, WRAP_ARY_FLAG],\x0a    [\x27bind\x27, WRAP_BIND_FLAG],\x0a    [\x27bindKey\x27, WRAP_BIND_KEY_FLAG],\x0a    [\x27curry\x27, WRAP_CURRY_FLAG],\x0a    [\x27curryRight\x27, WRAP_CURRY_RIGHT_FLAG],\x0a    [\x27flip\x27, WRAP_FLIP_FLAG],\x0a    [\x27partial\x27, WRAP_PARTIAL_FLAG],\x0a    [\x27partialRight\x27, WRAP_PARTIAL_RIGHT_FLAG],\x0a    [\x27rearg\x27, WRAP_REARG_FLAG]\x0a  ];\x0a\x0a  /** `Object#toString` result references. */\x0a  var argsTag = \x27[object Arguments]\x27,\x0a      arrayTag = \x27[object Array]\x27,\x0a      asyncTag = \x27[object AsyncFunction]\x27,\x0a      boolTag = \x27[object Boolean]\x27,\x0a      dateTag = \x27[object Date]\x27,\x0a      domExcTag = \x27[object DOMException]\x27,\x0a      errorTag = \x27[object Error]\x27,\x0a      funcTag = \x27[object Function]\x27,\x0a      genTag = \x27[object GeneratorFunction]\x27,\x0a      mapTag = \x27[object Map]\x27,\x0a      numberTag = \x27[object Number]\x27,\x0a      nullTag = \x27[object Null]\x27,\x0a      objectTag = \x27[object Object]\x27,\x0a      promiseTag = \x27[object Promise]\x27,\x0a      proxyTag = \x27[object Proxy]\x27,\x0a      regexpTag = \x27[object RegExp]\x27,\x0a      setTag = \x27[object Set]\x27,\x0a      stringTag = \x27[object String]\x27,\x0a      symbolTag = \x27[object Symbol]\x27,\x0a      undefinedTag = \x27[object Undefined]\x27,\x0a      weakMapTag = \x27[object WeakMap]\x27,\x0a      weakSetTag = \x27[object WeakSet]\x27;\x0a\x0a  var arrayBufferTag = \x27[object ArrayBuffer]\x27,\x0a      dataViewTag = \x27[object DataView]\x27,\x0a      float32Tag = \x27[object Float32Array]\x27,\x0a      float64Tag = \x27[object Float64Array]\x27,\x0a      int8Tag = \x27[object Int8Array]\x27,\x0a      int16Tag = \x27[object Int16Array]\x27,\x0a      int32Tag = \x27[object Int32Array]\x27,\x0a      uint8Tag = \x27[object Uint8Array]\x27,\x0a      uint8ClampedTag = \x27[object Uint8ClampedArray]\x27,\x0a      uint16Tag = \x27[object Uint16Array]\x27,\x0a      uint32Tag = \x27[object Uint32Array]\x27;\x0a\x0a  /** Used to match empty string literals in compiled template source. */\x0a  var reEmptyStringLeading = /\x5cb__p \x5c+= \x27\x27;/g,\x0a      reEmptyStringMiddle = /\x5cb(__p \x5c+=) \x27\x27 \x5c+/g,\x0a      reEmptyStringTrailing = /(__e\x5c(.*?\x5c)|\x5cb__t\x5c)) \x5c+\x5cn\x27\x27;/g;\x0a\x0a  /** Used to match HTML entities and HTML characters. */\x0a  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\x0a      reUnescapedHtml = /[&\x3c\x3e\x22\x27]/g,\x0a      reHasEscapedHtml = RegExp(reEscapedHtml.source),\x0a      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\x0a\x0a  /** Used to match template delimiters. */\x0a  var reEscape = /\x3c%-([\x5cs\x5cS]+?)%\x3e/g,\x0a      reEvaluate = /\x3c%([\x5cs\x5cS]+?)%\x3e/g,\x0a      reInterpolate = /\x3c%=([\x5cs\x5cS]+?)%\x3e/g;\x0a\x0a  /** Used to match property names within property paths. */\x0a  var reIsDeepProp = /\x5c.|\x5c[(?:[^[\x5c]]*|([\x22\x27])(?:(?!\x5c1)[^\x5c\x5c]|\x5c\x5c.)*?\x5c1)\x5c]/,\x0a      reIsPlainProp = /^\x5cw*$/,\x0a      rePropName = /[^.[\x5c]]+|\x5c[(?:(-?\x5cd+(?:\x5c.\x5cd+)?)|([\x22\x27])((?:(?!\x5c2)[^\x5c\x5c]|\x5c\x5c.)*?)\x5c2)\x5c]|(?=(?:\x5c.|\x5c[\x5c])(?:\x5c.|\x5c[\x5c]|$))/g;\x0a\x0a  /**\x0a   * Used to match `RegExp`\x0a   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\x0a   */\x0a  var reRegExpChar = /[\x5c\x5c^$.*+?()[\x5c]{}|]/g,\x0a      reHasRegExpChar = RegExp(reRegExpChar.source);\x0a\x0a  /** Used to match leading and trailing whitespace. */\x0a  var reTrim = /^\x5cs+|\x5cs+$/g,\x0a      reTrimStart = /^\x5cs+/,\x0a      reTrimEnd = /\x5cs+$/;\x0a\x0a  /** Used to match wrap detail comments. */\x0a  var reWrapComment = /\x5c{(?:\x5cn\x5c/\x5c* \x5c[wrapped with .+\x5c] \x5c*\x5c/)?\x5cn?/,\x0a      reWrapDetails = /\x5c{\x5cn\x5c/\x5c* \x5c[wrapped with (.+)\x5c] \x5c*/,\x0a      reSplitDetails = /,? & /;\x0a\x0a  /** Used to match words composed of alphanumeric characters. */\x0a  var reAsciiWord = /[^\x5cx00-\x5cx2f\x5cx3a-\x5cx40\x5cx5b-\x5cx60\x5cx7b-\x5cx7f]+/g;\x0a\x0a  /** Used to match backslashes in property paths. */\x0a  var reEscapeChar = /\x5c\x5c(\x5c\x5c)?/g;\x0a\x0a  /**\x0a   * Used to match\x0a   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\x0a   */\x0a  var reEsTemplate = /\x5c$\x5c{([^\x5c\x5c}]*(?:\x5c\x5c.[^\x5c\x5c}]*)*)\x5c}/g;\x0a\x0a  /** Used to match `RegExp` flags from their coerced string values. */\x0a  var reFlags = /\x5cw*$/;\x0a\x0a  /** Used to detect bad signed hexadecimal string values. */\x0a  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\x0a\x0a  /** Used to detect binary string values. */\x0a  var reIsBinary = /^0b[01]+$/i;\x0a\x0a  /** Used to detect host constructors (Safari). */\x0a  var reIsHostCtor = /^\x5c[object .+?Constructor\x5c]$/;\x0a\x0a  /** Used to detect octal string values. */\x0a  var reIsOctal = /^0o[0-7]+$/i;\x0a\x0a  /** Used to detect unsigned integer values. */\x0a  var reIsUint = /^(?:0|[1-9]\x5cd*)$/;\x0a\x0a  /** Used to match Latin Unicode letters (excluding mathematical operators). */\x0a  var reLatin = /[\x5cxc0-\x5cxd6\x5cxd8-\x5cxf6\x5cxf8-\x5cxff\x5cu0100-\x5cu017f]/g;\x0a\x0a  /** Used to ensure capturing order of template delimiters. */\x0a  var reNoMatch = /($^)/;\x0a\x0a  /** Used to match unescaped characters in compiled string literals. */\x0a  var reUnescapedString = /[\x27\x5cn\x5cr\x5cu2028\x5cu2029\x5c\x5c]/g;\x0a\x0a  /** Used to compose unicode character classes. */\x0a  var rsAstralRange = \x27\x5c\x5cud800-\x5c\x5cudfff\x27,\x0a      rsComboMarksRange = \x27\x5c\x5cu0300-\x5c\x5cu036f\x27,\x0a      reComboHalfMarksRange = \x27\x5c\x5cufe20-\x5c\x5cufe2f\x27,\x0a      rsComboSymbolsRange = \x27\x5c\x5cu20d0-\x5c\x5cu20ff\x27,\x0a      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\x0a      rsDingbatRange = \x27\x5c\x5cu2700-\x5c\x5cu27bf\x27,\x0a      rsLowerRange = \x27a-z\x5c\x5cxdf-\x5c\x5cxf6\x5c\x5cxf8-\x5c\x5cxff\x27,\x0a      rsMathOpRange = \x27\x5c\x5cxac\x5c\x5cxb1\x5c\x5cxd7\x5c\x5cxf7\x27,\x0a      rsNonCharRange = \x27\x5c\x5cx00-\x5c\x5cx2f\x5c\x5cx3a-\x5c\x5cx40\x5c\x5cx5b-\x5c\x5cx60\x5c\x5cx7b-\x5c\x5cxbf\x27,\x0a      rsPunctuationRange = \x27\x5c\x5cu2000-\x5c\x5cu206f\x27,\x0a      rsSpaceRange = \x27 \x5c\x5ct\x5c\x5cx0b\x5c\x5cf\x5c\x5cxa0\x5c\x5cufeff\x5c\x5cn\x5c\x5cr\x5c\x5cu2028\x5c\x5cu2029\x5c\x5cu1680\x5c\x5cu180e\x5c\x5cu2000\x5c\x5cu2001\x5c\x5cu2002\x5c\x5cu2003\x5c\x5cu2004\x5c\x5cu2005\x5c\x5cu2006\x5c\x5cu2007\x5c\x5cu2008\x5c\x5cu2009\x5c\x5cu200a\x5c\x5cu202f\x5c\x5cu205f\x5c\x5cu3000\x27,\x0a      rsUpperRange = \x27A-Z\x5c\x5cxc0-\x5c\x5cxd6\x5c\x5cxd8-\x5c\x5cxde\x27,\x0a      rsVarRange = \x27\x5c\x5cufe0e\x5c\x5cufe0f\x27,\x0a      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\x0a\x0a  /** Used to compose unicode capture groups. */\x0a  var rsApos = \x22[\x27\x5cu2019]\x22,\x0a      rsAstral = \x27[\x27 + rsAstralRange + \x27]\x27,\x0a      rsBreak = \x27[\x27 + rsBreakRange + \x27]\x27,\x0a      rsCombo = \x27[\x27 + rsComboRange + \x27]\x27,\x0a      rsDigits = \x27\x5c\x5cd+\x27,\x0a      rsDingbat = \x27[\x27 + rsDingbatRange + \x27]\x27,\x0a      rsLower = \x27[\x27 + rsLowerRange + \x27]\x27,\x0a      rsMisc = \x27[^\x27 + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + \x27]\x27,\x0a      rsFitz = \x27\x5c\x5cud83c[\x5c\x5cudffb-\x5c\x5cudfff]\x27,\x0a      rsModifier = \x27(?:\x27 + rsCombo + \x27|\x27 + rsFitz + \x27)\x27,\x0a      rsNonAstral = \x27[^\x27 + rsAstralRange + \x27]\x27,\x0a      rsRegional = \x27(?:\x5c\x5cud83c[\x5c\x5cudde6-\x5c\x5cuddff]){2}\x27,\x0a      rsSurrPair = \x27[\x5c\x5cud800-\x5c\x5cudbff][\x5c\x5cudc00-\x5c\x5cudfff]\x27,\x0a      rsUpper = \x27[\x27 + rsUpperRange + \x27]\x27,\x0a      rsZWJ = \x27\x5c\x5cu200d\x27;\x0a\x0a  /** Used to compose unicode regexes. */\x0a  var rsMiscLower = \x27(?:\x27 + rsLower + \x27|\x27 + rsMisc + \x27)\x27,\x0a      rsMiscUpper = \x27(?:\x27 + rsUpper + \x27|\x27 + rsMisc + \x27)\x27,\x0a      rsOptContrLower = \x27(?:\x27 + rsApos + \x27(?:d|ll|m|re|s|t|ve))?\x27,\x0a      rsOptContrUpper = \x27(?:\x27 + rsApos + \x27(?:D|LL|M|RE|S|T|VE))?\x27,\x0a      reOptMod = rsModifier + \x27?\x27,\x0a      rsOptVar = \x27[\x27 + rsVarRange + \x27]?\x27,\x0a      rsOptJoin = \x27(?:\x27 + rsZWJ + \x27(?:\x27 + [rsNonAstral, rsRegional, rsSurrPair].join(\x27|\x27) + \x27)\x27 + rsOptVar + reOptMod + \x27)*\x27,\x0a      rsOrdLower = \x27\x5c\x5cd*(?:1st|2nd|3rd|(?![123])\x5c\x5cdth)(?=\x5c\x5cb|[A-Z_])\x27,\x0a      rsOrdUpper = \x27\x5c\x5cd*(?:1ST|2ND|3RD|(?![123])\x5c\x5cdTH)(?=\x5c\x5cb|[a-z_])\x27,\x0a      rsSeq = rsOptVar + reOptMod + rsOptJoin,\x0a      rsEmoji = \x27(?:\x27 + [rsDingbat, rsRegional, rsSurrPair].join(\x27|\x27) + \x27)\x27 + rsSeq,\x0a      rsSymbol = \x27(?:\x27 + [rsNonAstral + rsCombo + \x27?\x27, rsCombo, rsRegional, rsSurrPair, rsAstral].join(\x27|\x27) + \x27)\x27;\x0a\x0a  /** Used to match apostrophes. */\x0a  var reApos = RegExp(rsApos, \x27g\x27);\x0a\x0a  /**\x0a   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\x0a   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\x0a   */\x0a  var reComboMark = RegExp(rsCombo, \x27g\x27);\x0a\x0a  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\x0a  var reUnicode = RegExp(rsFitz + \x27(?=\x27 + rsFitz + \x27)|\x27 + rsSymbol + rsSeq, \x27g\x27);\x0a\x0a  /** Used to match complex or compound words. */\x0a  var reUnicodeWord = RegExp([\x0a    rsUpper + \x27?\x27 + rsLower + \x27+\x27 + rsOptContrLower + \x27(?=\x27 + [rsBreak, rsUpper, \x27$\x27].join(\x27|\x27) + \x27)\x27,\x0a    rsMiscUpper + \x27+\x27 + rsOptContrUpper + \x27(?=\x27 + [rsBreak, rsUpper + rsMiscLower, \x27$\x27].join(\x27|\x27) + \x27)\x27,\x0a    rsUpper + \x27?\x27 + rsMiscLower + \x27+\x27 + rsOptContrLower,\x0a    rsUpper + \x27+\x27 + rsOptContrUpper,\x0a    rsOrdUpper,\x0a    rsOrdLower,\x0a    rsDigits,\x0a    rsEmoji\x0a  ].join(\x27|\x27), \x27g\x27);\x0a\x0a  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\x0a  var reHasUnicode = RegExp(\x27[\x27 + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + \x27]\x27);\x0a\x0a  /** Used to detect strings that need a more robust regexp to match words. */\x0a  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\x0a\x0a  /** Used to assign default `context` object properties. */\x0a  var contextProps = [\x0a    \x27Array\x27, \x27Buffer\x27, \x27DataView\x27, \x27Date\x27, \x27Error\x27, \x27Float32Array\x27, \x27Float64Array\x27,\x0a    \x27Function\x27, \x27Int8Array\x27, \x27Int16Array\x27, \x27Int32Array\x27, \x27Map\x27, \x27Math\x27, \x27Object\x27,\x0a    \x27Promise\x27, \x27RegExp\x27, \x27Set\x27, \x27String\x27, \x27Symbol\x27, \x27TypeError\x27, \x27Uint8Array\x27,\x0a    \x27Uint8ClampedArray\x27, \x27Uint16Array\x27, \x27Uint32Array\x27, \x27WeakMap\x27,\x0a    \x27_\x27, \x27clearTimeout\x27, \x27isFinite\x27, \x27parseInt\x27, \x27setTimeout\x27\x0a  ];\x0a\x0a  /** Used to make template sourceURLs easier to identify. */\x0a  var templateCounter = -1;\x0a\x0a  /** Used to identify `toStringTag` values of typed arrays. */\x0a  var typedArrayTags = {};\x0a  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\x0a  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\x0a  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\x0a  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\x0a  typedArrayTags[uint32Tag] = true;\x0a  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\x0a  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\x0a  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\x0a  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\x0a  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\x0a  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\x0a  typedArrayTags[setTag] = typedArrayTags[stringTag] =\x0a  typedArrayTags[weakMapTag] = false;\x0a\x0a  /** Used to identify `toStringTag` values supported by `_.clone`. */\x0a  var cloneableTags = {};\x0a  cloneableTags[argsTag] = cloneableTags[arrayTag] =\x0a  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\x0a  cloneableTags[boolTag] = cloneableTags[dateTag] =\x0a  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\x0a  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\x0a  cloneableTags[int32Tag] = cloneableTags[mapTag] =\x0a  cloneableTags[numberTag] = cloneableTags[objectTag] =\x0a  cloneableTags[regexpTag] = cloneableTags[setTag] =\x0a  cloneableTags[stringTag] = cloneableTags[symbolTag] =\x0a  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\x0a  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\x0a  cloneableTags[errorTag] = cloneableTags[funcTag] =\x0a  cloneableTags[weakMapTag] = false;\x0a\x0a  /** Used to map Latin Unicode letters to basic Latin letters. */\x0a  var deburredLetters = {\x0a    // Latin-1 Supplement block.\x0a    \x27\x5cxc0\x27: \x27A\x27,  \x27\x5cxc1\x27: \x27A\x27, \x27\x5cxc2\x27: \x27A\x27, \x27\x5cxc3\x27: \x27A\x27, \x27\x5cxc4\x27: \x27A\x27, \x27\x5cxc5\x27: \x27A\x27,\x0a    \x27\x5cxe0\x27: \x27a\x27,  \x27\x5cxe1\x27: \x27a\x27, \x27\x5cxe2\x27: \x27a\x27, \x27\x5cxe3\x27: \x27a\x27, \x27\x5cxe4\x27: \x27a\x27, \x27\x5cxe5\x27: \x27a\x27,\x0a    \x27\x5cxc7\x27: \x27C\x27,  \x27\x5cxe7\x27: \x27c\x27,\x0a    \x27\x5cxd0\x27: \x27D\x27,  \x27\x5cxf0\x27: \x27d\x27,\x0a    \x27\x5cxc8\x27: \x27E\x27,  \x27\x5cxc9\x27: \x27E\x27, \x27\x5cxca\x27: \x27E\x27, \x27\x5cxcb\x27: \x27E\x27,\x0a    \x27\x5cxe8\x27: \x27e\x27,  \x27\x5cxe9\x27: \x27e\x27, \x27\x5cxea\x27: \x27e\x27, \x27\x5cxeb\x27: \x27e\x27,\x0a    \x27\x5cxcc\x27: \x27I\x27,  \x27\x5cxcd\x27: \x27I\x27, \x27\x5cxce\x27: \x27I\x27, \x27\x5cxcf\x27: \x27I\x27,\x0a    \x27\x5cxec\x27: \x27i\x27,  \x27\x5cxed\x27: \x27i\x27, \x27\x5cxee\x27: \x27i\x27, \x27\x5cxef\x27: \x27i\x27,\x0a    \x27\x5cxd1\x27: \x27N\x27,  \x27\x5cxf1\x27: \x27n\x27,\x0a    \x27\x5cxd2\x27: \x27O\x27,  \x27\x5cxd3\x27: \x27O\x27, \x27\x5cxd4\x27: \x27O\x27, \x27\x5cxd5\x27: \x27O\x27, \x27\x5cxd6\x27: \x27O\x27, \x27\x5cxd8\x27: \x27O\x27,\x0a    \x27\x5cxf2\x27: \x27o\x27,  \x27\x5cxf3\x27: \x27o\x27, \x27\x5cxf4\x27: \x27o\x27, \x27\x5cxf5\x27: \x27o\x27, \x27\x5cxf6\x27: \x27o\x27, \x27\x5cxf8\x27: \x27o\x27,\x0a    \x27\x5cxd9\x27: \x27U\x27,  \x27\x5cxda\x27: \x27U\x27, \x27\x5cxdb\x27: \x27U\x27, \x27\x5cxdc\x27: \x27U\x27,\x0a    \x27\x5cxf9\x27: \x27u\x27,  \x27\x5cxfa\x27: \x27u\x27, \x27\x5cxfb\x27: \x27u\x27, \x27\x5cxfc\x27: \x27u\x27,\x0a    \x27\x5cxdd\x27: \x27Y\x27,  \x27\x5cxfd\x27: \x27y\x27, \x27\x5cxff\x27: \x27y\x27,\x0a    \x27\x5cxc6\x27: \x27Ae\x27, \x27\x5cxe6\x27: \x27ae\x27,\x0a    \x27\x5cxde\x27: \x27Th\x27, \x27\x5cxfe\x27: \x27th\x27,\x0a    \x27\x5cxdf\x27: \x27ss\x27,\x0a    // Latin Extended-A block.\x0a    \x27\x5cu0100\x27: \x27A\x27,  \x27\x5cu0102\x27: \x27A\x27, \x27\x5cu0104\x27: \x27A\x27,\x0a    \x27\x5cu0101\x27: \x27a\x27,  \x27\x5cu0103\x27: \x27a\x27, \x27\x5cu0105\x27: \x27a\x27,\x0a    \x27\x5cu0106\x27: \x27C\x27,  \x27\x5cu0108\x27: \x27C\x27, \x27\x5cu010a\x27: \x27C\x27, \x27\x5cu010c\x27: \x27C\x27,\x0a    \x27\x5cu0107\x27: \x27c\x27,  \x27\x5cu0109\x27: \x27c\x27, \x27\x5cu010b\x27: \x27c\x27, \x27\x5cu010d\x27: \x27c\x27,\x0a    \x27\x5cu010e\x27: \x27D\x27,  \x27\x5cu0110\x27: \x27D\x27, \x27\x5cu010f\x27: \x27d\x27, \x27\x5cu0111\x27: \x27d\x27,\x0a    \x27\x5cu0112\x27: \x27E\x27,  \x27\x5cu0114\x27: \x27E\x27, \x27\x5cu0116\x27: \x27E\x27, \x27\x5cu0118\x27: \x27E\x27, \x27\x5cu011a\x27: \x27E\x27,\x0a    \x27\x5cu0113\x27: \x27e\x27,  \x27\x5cu0115\x27: \x27e\x27, \x27\x5cu0117\x27: \x27e\x27, \x27\x5cu0119\x27: \x27e\x27, \x27\x5cu011b\x27: \x27e\x27,\x0a    \x27\x5cu011c\x27: \x27G\x27,  \x27\x5cu011e\x27: \x27G\x27, \x27\x5cu0120\x27: \x27G\x27, \x27\x5cu0122\x27: \x27G\x27,\x0a    \x27\x5cu011d\x27: \x27g\x27,  \x27\x5cu011f\x27: \x27g\x27, \x27\x5cu0121\x27: \x27g\x27, \x27\x5cu0123\x27: \x27g\x27,\x0a    \x27\x5cu0124\x27: \x27H\x27,  \x27\x5cu0126\x27: \x27H\x27, \x27\x5cu0125\x27: \x27h\x27, \x27\x5cu0127\x27: \x27h\x27,\x0a    \x27\x5cu0128\x27: \x27I\x27,  \x27\x5cu012a\x27: \x27I\x27, \x27\x5cu012c\x27: \x27I\x27, \x27\x5cu012e\x27: \x27I\x27, \x27\x5cu0130\x27: \x27I\x27,\x0a    \x27\x5cu0129\x27: \x27i\x27,  \x27\x5cu012b\x27: \x27i\x27, \x27\x5cu012d\x27: \x27i\x27, \x27\x5cu012f\x27: \x27i\x27, \x27\x5cu0131\x27: \x27i\x27,\x0a    \x27\x5cu0134\x27: \x27J\x27,  \x27\x5cu0135\x27: \x27j\x27,\x0a    \x27\x5cu0136\x27: \x27K\x27,  \x27\x5cu0137\x27: \x27k\x27, \x27\x5cu0138\x27: \x27k\x27,\x0a    \x27\x5cu0139\x27: \x27L\x27,  \x27\x5cu013b\x27: \x27L\x27, \x27\x5cu013d\x27: \x27L\x27, \x27\x5cu013f\x27: \x27L\x27, \x27\x5cu0141\x27: \x27L\x27,\x0a    \x27\x5cu013a\x27: \x27l\x27,  \x27\x5cu013c\x27: \x27l\x27, \x27\x5cu013e\x27: \x27l\x27, \x27\x5cu0140\x27: \x27l\x27, \x27\x5cu0142\x27: \x27l\x27,\x0a    \x27\x5cu0143\x27: \x27N\x27,  \x27\x5cu0145\x27: \x27N\x27, \x27\x5cu0147\x27: \x27N\x27, \x27\x5cu014a\x27: \x27N\x27,\x0a    \x27\x5cu0144\x27: \x27n\x27,  \x27\x5cu0146\x27: \x27n\x27, \x27\x5cu0148\x27: \x27n\x27, \x27\x5cu014b\x27: \x27n\x27,\x0a    \x27\x5cu014c\x27: \x27O\x27,  \x27\x5cu014e\x27: \x27O\x27, \x27\x5cu0150\x27: \x27O\x27,\x0a    \x27\x5cu014d\x27: \x27o\x27,  \x27\x5cu014f\x27: \x27o\x27, \x27\x5cu0151\x27: \x27o\x27,\x0a    \x27\x5cu0154\x27: \x27R\x27,  \x27\x5cu0156\x27: \x27R\x27, \x27\x5cu0158\x27: \x27R\x27,\x0a    \x27\x5cu0155\x27: \x27r\x27,  \x27\x5cu0157\x27: \x27r\x27, \x27\x5cu0159\x27: \x27r\x27,\x0a    \x27\x5cu015a\x27: \x27S\x27,  \x27\x5cu015c\x27: \x27S\x27, \x27\x5cu015e\x27: \x27S\x27, \x27\x5cu0160\x27: \x27S\x27,\x0a    \x27\x5cu015b\x27: \x27s\x27,  \x27\x5cu015d\x27: \x27s\x27, \x27\x5cu015f\x27: \x27s\x27, \x27\x5cu0161\x27: \x27s\x27,\x0a    \x27\x5cu0162\x27: \x27T\x27,  \x27\x5cu0164\x27: \x27T\x27, \x27\x5cu0166\x27: \x27T\x27,\x0a    \x27\x5cu0163\x27: \x27t\x27,  \x27\x5cu0165\x27: \x27t\x27, \x27\x5cu0167\x27: \x27t\x27,\x0a    \x27\x5cu0168\x27: \x27U\x27,  \x27\x5cu016a\x27: \x27U\x27, \x27\x5cu016c\x27: \x27U\x27, \x27\x5cu016e\x27: \x27U\x27, \x27\x5cu0170\x27: \x27U\x27, \x27\x5cu0172\x27: \x27U\x27,\x0a    \x27\x5cu0169\x27: \x27u\x27,  \x27\x5cu016b\x27: \x27u\x27, \x27\x5cu016d\x27: \x27u\x27, \x27\x5cu016f\x27: \x27u\x27, \x27\x5cu0171\x27: \x27u\x27, \x27\x5cu0173\x27: \x27u\x27,\x0a    \x27\x5cu0174\x27: \x27W\x27,  \x27\x5cu0175\x27: \x27w\x27,\x0a    \x27\x5cu0176\x27: \x27Y\x27,  \x27\x5cu0177\x27: \x27y\x27, \x27\x5cu0178\x27: \x27Y\x27,\x0a    \x27\x5cu0179\x27: \x27Z\x27,  \x27\x5cu017b\x27: \x27Z\x27, \x27\x5cu017d\x27: \x27Z\x27,\x0a    \x27\x5cu017a\x27: \x27z\x27,  \x27\x5cu017c\x27: \x27z\x27, \x27\x5cu017e\x27: \x27z\x27,\x0a    \x27\x5cu0132\x27: \x27IJ\x27, \x27\x5cu0133\x27: \x27ij\x27,\x0a    \x27\x5cu0152\x27: \x27Oe\x27, \x27\x5cu0153\x27: \x27oe\x27,\x0a    \x27\x5cu0149\x27: \x22\x27n\x22, \x27\x5cu017f\x27: \x27s\x27\x0a  };\x0a\x0a  /** Used to map characters to HTML entities. */\x0a  var htmlEscapes = {\x0a    \x27&\x27: \x27&amp;\x27,\x0a    \x27\x3c\x27: \x27&lt;\x27,\x0a    \x27\x3e\x27: \x27&gt;\x27,\x0a    \x27\x22\x27: \x27&quot;\x27,\x0a    \x22\x27\x22: \x27&#39;\x27\x0a  };\x0a\x0a  /** Used to map HTML entities to characters. */\x0a  var htmlUnescapes = {\x0a    \x27&amp;\x27: \x27&\x27,\x0a    \x27&lt;\x27: \x27\x3c\x27,\x0a    \x27&gt;\x27: \x27\x3e\x27,\x0a    \x27&quot;\x27: \x27\x22\x27,\x0a    \x27&#39;\x27: \x22\x27\x22\x0a  };\x0a\x0a  /** Used to escape characters for inclusion in compiled string literals. */\x0a  var stringEscapes = {\x0a    \x27\x5c\x5c\x27: \x27\x5c\x5c\x27,\x0a    \x22\x27\x22: \x22\x27\x22,\x0a    \x27\x5cn\x27: \x27n\x27,\x0a    \x27\x5cr\x27: \x27r\x27,\x0a    \x27\x5cu2028\x27: \x27u2028\x27,\x0a    \x27\x5cu2029\x27: \x27u2029\x27\x0a  };\x0a\x0a  /** Built-in method references without a dependency on `root`. */\x0a  var freeParseFloat = parseFloat,\x0a      freeParseInt = parseInt;\x0a\x0a  /** Detect free variable `global` from Node.js. */\x0a  var freeGlobal = typeof global == \x27object\x27 && global && global.Object === Object && global;\x0a\x0a  /** Detect free variable `self`. */\x0a  var freeSelf = typeof self == \x27object\x27 && self && self.Object === Object && self;\x0a\x0a  /** Used as a reference to the global object. */\x0a  var root = freeGlobal || freeSelf || Function(\x27return this\x27)();\x0a\x0a  /** Detect free variable `exports`. */\x0a  var freeExports = typeof exports == \x27object\x27 && exports && !exports.nodeType && exports;\x0a\x0a  /** Detect free variable `module`. */\x0a  var freeModule = freeExports && typeof module == \x27object\x27 && module && !module.nodeType && module;\x0a\x0a  /** Detect the popular CommonJS extension `module.exports`. */\x0a  var moduleExports = freeModule && freeModule.exports === freeExports;\x0a\x0a  /** Detect free variable `process` from Node.js. */\x0a  var freeProcess = moduleExports && freeGlobal.process;\x0a\x0a  /** Used to access faster Node.js helpers. */\x0a  var nodeUtil = (function() {\x0a    try {\x0a      // Use `util.types` for Node.js 10+.\x0a      var types = freeModule && freeModule.require && freeModule.require(\x27util\x27).types;\x0a\x0a      if (types) {\x0a        return types;\x0a      }\x0a\x0a      // Legacy `process.binding(\x27util\x27)` for Node.js \x3c 10.\x0a      return freeProcess && freeProcess.binding && freeProcess.binding(\x27util\x27);\x0a    } catch (e) {}\x0a  }());\x0a\x0a  /* Node.js helper references. */\x0a  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\x0a      nodeIsDate = nodeUtil && nodeUtil.isDate,\x0a      nodeIsMap = nodeUtil && nodeUtil.isMap,\x0a      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\x0a      nodeIsSet = nodeUtil && nodeUtil.isSet,\x0a      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\x0a\x0a  /*--------------------------------------------------------------------------*/\x0a\x0a  /**\x0a   * A faster alternative to `Function#apply`, this function invokes `func`\x0a   * with the `this` binding of `thisArg` and the arguments of `args`.\x0a   *\x0a   * @private\x0a   * @param {Function} func The function to invoke.\x0a   * @param {*} thisArg The `this` binding of `func`.\x0a   * @param {Array} args The arguments to invoke `func` with.\x0a   * @returns {*} Returns the result of `func`.\x0a   */\x0a  function apply(func, thisArg, args) {\x0a    switch (args.length) {\x0a      case 0: return func.call(thisArg);\x0a      case 1: return func.call(thisArg, args[0]);\x0a      case 2: return func.call(thisArg, args[0], args[1]);\x0a      case 3: return func.call(thisArg, args[0], args[1], args[2]);\x0a    }\x0a    return func.apply(thisArg, args);\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `baseAggregator` for arrays.\x0a   *\x0a   * @private\x0a   * @param {Array} [array] The array to iterate over.\x0a   * @param {Function} setter The function to set `accumulator` values.\x0a   * @param {Function} iteratee The iteratee to transform keys.\x0a   * @param {Object} accumulator The initial aggregated object.\x0a   * @returns {Function} Returns `accumulator`.\x0a   */\x0a  function arrayAggregator(array, setter, iteratee, accumulator) {\x0a    var index = -1,\x0a        length = array == null ? 0 : array.length;\x0a\x0a    while (++index \x3c length) {\x0a      var value = array[index];\x0a      setter(accumulator, value, iteratee(value), array);\x0a    }\x0a    return accumulator;\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `_.forEach` for arrays without support for\x0a   * iteratee shorthands.\x0a   *\x0a   * @private\x0a   * @param {Array} [array] The array to iterate over.\x0a   * @param {Function} iteratee The function invoked per iteration.\x0a   * @returns {Array} Returns `array`.\x0a   */\x0a  function arrayEach(array, iteratee) {\x0a    var index = -1,\x0a        length = array == null ? 0 : array.length;\x0a\x0a    while (++index \x3c length) {\x0a      if (iteratee(array[index], index, array) === false) {\x0a        break;\x0a      }\x0a    }\x0a    return array;\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `_.forEachRight` for arrays without support for\x0a   * iteratee shorthands.\x0a   *\x0a   * @private\x0a   * @param {Array} [array] The array to iterate over.\x0a   * @param {Function} iteratee The function invoked per iteration.\x0a   * @returns {Array} Returns `array`.\x0a   */\x0a  function arrayEachRight(array, iteratee) {\x0a    var length = array == null ? 0 : array.length;\x0a\x0a    while (length--) {\x0a      if (iteratee(array[length], length, array) === false) {\x0a        break;\x0a      }\x0a    }\x0a    return array;\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `_.every` for arrays without support for\x0a   * iteratee shorthands.\x0a   *\x0a   * @private\x0a   * @param {Array} [array] The array to iterate over.\x0a   * @param {Function} predicate The function invoked per iteration.\x0a   * @returns {boolean} Returns `true` if all elements pass the predicate check,\x0a   *  else `false`.\x0a   */\x0a  function arrayEvery(array, predicate) {\x0a    var index = -1,\x0a        length = array == null ? 0 : array.length;\x0a\x0a    while (++index \x3c length) {\x0a      if (!predicate(array[index], index, array)) {\x0a        return false;\x0a      }\x0a    }\x0a    return true;\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `_.filter` for arrays without support for\x0a   * iteratee shorthands.\x0a   *\x0a   * @private\x0a   * @param {Array} [array] The array to iterate over.\x0a   * @param {Function} predicate The function invoked per iteration.\x0a   * @returns {Array} Returns the new filtered array.\x0a   */\x0a  function arrayFilter(array, predicate) {\x0a    var index = -1,\x0a        length = array == null ? 0 : array.length,\x0a        resIndex = 0,\x0a        result = [];\x0a\x0a    while (++index \x3c length) {\x0a      var value = array[index];\x0a      if (predicate(value, index, array)) {\x0a        result[resIndex++] = value;\x0a      }\x0a    }\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `_.includes` for arrays without support for\x0a   * specifying an index to search from.\x0a   *\x0a   * @private\x0a   * @param {Array} [array] The array to inspect.\x0a   * @param {*} target The value to search for.\x0a   * @returns {boolean} Returns `true` if `target` is found, else `false`.\x0a   */\x0a  function arrayIncludes(array, value) {\x0a    var length = array == null ? 0 : array.length;\x0a    return !!length && baseIndexOf(array, value, 0) \x3e -1;\x0a  }\x0a\x0a  /**\x0a   * This function is like `arrayIncludes` except that it accepts a comparator.\x0a   *\x0a   * @private\x0a   * @param {Array} [array] The array to inspect.\x0a   * @param {*} target The value to search for.\x0a   * @param {Function} comparator The comparator invoked per element.\x0a   * @returns {boolean} Returns `true` if `target` is found, else `false`.\x0a   */\x0a  function arrayIncludesWith(array, value, comparator) {\x0a    var index = -1,\x0a        length = array == null ? 0 : array.length;\x0a\x0a    while (++index \x3c length) {\x0a      if (comparator(value, array[index])) {\x0a        return true;\x0a      }\x0a    }\x0a    return false;\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `_.map` for arrays without support for iteratee\x0a   * shorthands.\x0a   *\x0a   * @private\x0a   * @param {Array} [array] The array to iterate over.\x0a   * @param {Function} iteratee The function invoked per iteration.\x0a   * @returns {Array} Returns the new mapped array.\x0a   */\x0a  function arrayMap(array, iteratee) {\x0a    var index = -1,\x0a        length = array == null ? 0 : array.length,\x0a        result = Array(length);\x0a\x0a    while (++index \x3c length) {\x0a      result[index] = iteratee(array[index], index, array);\x0a    }\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * Appends the elements of `values` to `array`.\x0a   *\x0a   * @private\x0a   * @param {Array} array The array to modify.\x0a   * @param {Array} values The values to append.\x0a   * @returns {Array} Returns `array`.\x0a   */\x0a  function arrayPush(array, values) {\x0a    var index = -1,\x0a        length = values.length,\x0a        offset = array.length;\x0a\x0a    while (++index \x3c length) {\x0a      array[offset + index] = values[index];\x0a    }\x0a    return array;\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `_.reduce` for arrays without support for\x0a   * iteratee shorthands.\x0a   *\x0a   * @private\x0a   * @param {Array} [array] The array to iterate over.\x0a   * @param {Function} iteratee The function invoked per iteration.\x0a   * @param {*} [accumulator] The initial value.\x0a   * @param {boolean} [initAccum] Specify using the first element of `array` as\x0a   *  the initial value.\x0a   * @returns {*} Returns the accumulated value.\x0a   */\x0a  function arrayReduce(array, iteratee, accumulator, initAccum) {\x0a    var index = -1,\x0a        length = array == null ? 0 : array.length;\x0a\x0a    if (initAccum && length) {\x0a      accumulator = array[++index];\x0a    }\x0a    while (++index \x3c length) {\x0a      accumulator = iteratee(accumulator, array[index], index, array);\x0a    }\x0a    return accumulator;\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `_.reduceRight` for arrays without support for\x0a   * iteratee shorthands.\x0a   *\x0a   * @private\x0a   * @param {Array} [array] The array to iterate over.\x0a   * @param {Function} iteratee The function invoked per iteration.\x0a   * @param {*} [accumulator] The initial value.\x0a   * @param {boolean} [initAccum] Specify using the last element of `array` as\x0a   *  the initial value.\x0a   * @returns {*} Returns the accumulated value.\x0a   */\x0a  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\x0a    var length = array == null ? 0 : array.length;\x0a    if (initAccum && length) {\x0a      accumulator = array[--length];\x0a    }\x0a    while (length--) {\x0a      accumulator = iteratee(accumulator, array[length], length, array);\x0a    }\x0a    return accumulator;\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `_.some` for arrays without support for iteratee\x0a   * shorthands.\x0a   *\x0a   * @private\x0a   * @param {Array} [array] The array to iterate over.\x0a   * @param {Function} predicate The function invoked per iteration.\x0a   * @returns {boolean} Returns `true` if any element passes the predicate check,\x0a   *  else `false`.\x0a   */\x0a  function arraySome(array, predicate) {\x0a    var index = -1,\x0a        length = array == null ? 0 : array.length;\x0a\x0a    while (++index \x3c length) {\x0a      if (predicate(array[index], index, array)) {\x0a        return true;\x0a      }\x0a    }\x0a    return false;\x0a  }\x0a\x0a  /**\x0a   * Gets the size of an ASCII `string`.\x0a   *\x0a   * @private\x0a   * @param {string} string The string inspect.\x0a   * @returns {number} Returns the string size.\x0a   */\x0a  var asciiSize = baseProperty(\x27length\x27);\x0a\x0a  /**\x0a   * Converts an ASCII `string` to an array.\x0a   *\x0a   * @private\x0a   * @param {string} string The string to convert.\x0a   * @returns {Array} Returns the converted array.\x0a   */\x0a  function asciiToArray(string) {\x0a    return string.split(\x27\x27);\x0a  }\x0a\x0a  /**\x0a   * Splits an ASCII `string` into an array of its words.\x0a   *\x0a   * @private\x0a   * @param {string} The string to inspect.\x0a   * @returns {Array} Returns the words of `string`.\x0a   */\x0a  function asciiWords(string) {\x0a    return string.match(reAsciiWord) || [];\x0a  }\x0a\x0a  /**\x0a   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\x0a   * without support for iteratee shorthands, which iterates over `collection`\x0a   * using `eachFunc`.\x0a   *\x0a   * @private\x0a   * @param {Array|Object} collection The collection to inspect.\x0a   * @param {Function} predicate The function invoked per iteration.\x0a   * @param {Function} eachFunc The function to iterate over `collection`.\x0a   * @returns {*} Returns the found element or its key, else `undefined`.\x0a   */\x0a  function baseFindKey(collection, predicate, eachFunc) {\x0a    var result;\x0a    eachFunc(collection, function(value, key, collection) {\x0a      if (predicate(value, key, collection)) {\x0a        result = key;\x0a        return false;\x0a      }\x0a    });\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.findIndex` and `_.findLastIndex` without\x0a   * support for iteratee shorthands.\x0a   *\x0a   * @private\x0a   * @param {Array} array The array to inspect.\x0a   * @param {Function} predicate The function invoked per iteration.\x0a   * @param {number} fromIndex The index to search from.\x0a   * @param {boolean} [fromRight] Specify iterating from right to left.\x0a   * @returns {number} Returns the index of the matched value, else `-1`.\x0a   */\x0a  function baseFindIndex(array, predicate, fromIndex, fromRight) {\x0a    var length = array.length,\x0a        index = fromIndex + (fromRight ? 1 : -1);\x0a\x0a    while ((fromRight ? index-- : ++index \x3c length)) {\x0a      if (predicate(array[index], index, array)) {\x0a        return index;\x0a      }\x0a    }\x0a    return -1;\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\x0a   *\x0a   * @private\x0a   * @param {Array} array The array to inspect.\x0a   * @param {*} value The value to search for.\x0a   * @param {number} fromIndex The index to search from.\x0a   * @returns {number} Returns the index of the matched value, else `-1`.\x0a   */\x0a  function baseIndexOf(array, value, fromIndex) {\x0a    return value === value\x0a      ? strictIndexOf(array, value, fromIndex)\x0a      : baseFindIndex(array, baseIsNaN, fromIndex);\x0a  }\x0a\x0a  /**\x0a   * This function is like `baseIndexOf` except that it accepts a comparator.\x0a   *\x0a   * @private\x0a   * @param {Array} array The array to inspect.\x0a   * @param {*} value The value to search for.\x0a   * @param {number} fromIndex The index to search from.\x0a   * @param {Function} comparator The comparator invoked per element.\x0a   * @returns {number} Returns the index of the matched value, else `-1`.\x0a   */\x0a  function baseIndexOfWith(array, value, fromIndex, comparator) {\x0a    var index = fromIndex - 1,\x0a        length = array.length;\x0a\x0a    while (++index \x3c length) {\x0a      if (comparator(array[index], value)) {\x0a        return index;\x0a      }\x0a    }\x0a    return -1;\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.isNaN` without support for number objects.\x0a   *\x0a   * @private\x0a   * @param {*} value The value to check.\x0a   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\x0a   */\x0a  function baseIsNaN(value) {\x0a    return value !== value;\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.mean` and `_.meanBy` without support for\x0a   * iteratee shorthands.\x0a   *\x0a   * @private\x0a   * @param {Array} array The array to iterate over.\x0a   * @param {Function} iteratee The function invoked per iteration.\x0a   * @returns {number} Returns the mean.\x0a   */\x0a  function baseMean(array, iteratee) {\x0a    var length = array == null ? 0 : array.length;\x0a    return length ? (baseSum(array, iteratee) / length) : NAN;\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.property` without support for deep paths.\x0a   *\x0a   * @private\x0a   * @param {string} key The key of the property to get.\x0a   * @returns {Function} Returns the new accessor function.\x0a   */\x0a  function baseProperty(key) {\x0a    return function(object) {\x0a      return object == null ? undefined : object[key];\x0a    };\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.propertyOf` without support for deep paths.\x0a   *\x0a   * @private\x0a   * @param {Object} object The object to query.\x0a   * @returns {Function} Returns the new accessor function.\x0a   */\x0a  function basePropertyOf(object) {\x0a    return function(key) {\x0a      return object == null ? undefined : object[key];\x0a    };\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.reduce` and `_.reduceRight`, without support\x0a   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\x0a   *\x0a   * @private\x0a   * @param {Array|Object} collection The collection to iterate over.\x0a   * @param {Function} iteratee The function invoked per iteration.\x0a   * @param {*} accumulator The initial value.\x0a   * @param {boolean} initAccum Specify using the first or last element of\x0a   *  `collection` as the initial value.\x0a   * @param {Function} eachFunc The function to iterate over `collection`.\x0a   * @returns {*} Returns the accumulated value.\x0a   */\x0a  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\x0a    eachFunc(collection, function(value, index, collection) {\x0a      accumulator = initAccum\x0a        ? (initAccum = false, value)\x0a        : iteratee(accumulator, value, index, collection);\x0a    });\x0a    return accumulator;\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.sortBy` which uses `comparer` to define the\x0a   * sort order of `array` and replaces criteria objects with their corresponding\x0a   * values.\x0a   *\x0a   * @private\x0a   * @param {Array} array The array to sort.\x0a   * @param {Function} comparer The function to define sort order.\x0a   * @returns {Array} Returns `array`.\x0a   */\x0a  function baseSortBy(array, comparer) {\x0a    var length = array.length;\x0a\x0a    array.sort(comparer);\x0a    while (length--) {\x0a      array[length] = array[length].value;\x0a    }\x0a    return array;\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.sum` and `_.sumBy` without support for\x0a   * iteratee shorthands.\x0a   *\x0a   * @private\x0a   * @param {Array} array The array to iterate over.\x0a   * @param {Function} iteratee The function invoked per iteration.\x0a   * @returns {number} Returns the sum.\x0a   */\x0a  function baseSum(array, iteratee) {\x0a    var result,\x0a        index = -1,\x0a        length = array.length;\x0a\x0a    while (++index \x3c length) {\x0a      var current = iteratee(array[index]);\x0a      if (current !== undefined) {\x0a        result = result === undefined ? current : (result + current);\x0a      }\x0a    }\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.times` without support for iteratee shorthands\x0a   * or max array length checks.\x0a   *\x0a   * @private\x0a   * @param {number} n The number of times to invoke `iteratee`.\x0a   * @param {Function} iteratee The function invoked per iteration.\x0a   * @returns {Array} Returns the array of results.\x0a   */\x0a  function baseTimes(n, iteratee) {\x0a    var index = -1,\x0a        result = Array(n);\x0a\x0a    while (++index \x3c n) {\x0a      result[index] = iteratee(index);\x0a    }\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\x0a   * of key-value pairs for `object` corresponding to the property names of `props`.\x0a   *\x0a   * @private\x0a   * @param {Object} object The object to query.\x0a   * @param {Array} props The property names to get values for.\x0a   * @returns {Object} Returns the key-value pairs.\x0a   */\x0a  function baseToPairs(object, props) {\x0a    return arrayMap(props, function(key) {\x0a      return [key, object[key]];\x0a    });\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.unary` without support for storing metadata.\x0a   *\x0a   * @private\x0a   * @param {Function} func The function to cap arguments for.\x0a   * @returns {Function} Returns the new capped function.\x0a   */\x0a  function baseUnary(func) {\x0a    return function(value) {\x0a      return func(value);\x0a    };\x0a  }\x0a\x0a  /**\x0a   * The base implementation of `_.values` and `_.valuesIn` which creates an\x0a   * array of `object` property values corresponding to the property names\x0a   * of `props`.\x0a   *\x0a   * @private\x0a   * @param {Object} object The object to query.\x0a   * @param {Array} props The property names to get values for.\x0a   * @returns {Object} Returns the array of property values.\x0a   */\x0a  function baseValues(object, props) {\x0a    return arrayMap(props, function(key) {\x0a      return object[key];\x0a    });\x0a  }\x0a\x0a  /**\x0a   * Checks if a `cache` value for `key` exists.\x0a   *\x0a   * @private\x0a   * @param {Object} cache The cache to query.\x0a   * @param {string} key The key of the entry to check.\x0a   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\x0a   */\x0a  function cacheHas(cache, key) {\x0a    return cache.has(key);\x0a  }\x0a\x0a  /**\x0a   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\x0a   * that is not found in the character symbols.\x0a   *\x0a   * @private\x0a   * @param {Array} strSymbols The string symbols to inspect.\x0a   * @param {Array} chrSymbols The character symbols to find.\x0a   * @returns {number} Returns the index of the first unmatched string symbol.\x0a   */\x0a  function charsStartIndex(strSymbols, chrSymbols) {\x0a    var index = -1,\x0a        length = strSymbols.length;\x0a\x0a    while (++index \x3c length && baseIndexOf(chrSymbols, strSymbols[index], 0) \x3e -1) {}\x0a    return index;\x0a  }\x0a\x0a  /**\x0a   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\x0a   * that is not found in the character symbols.\x0a   *\x0a   * @private\x0a   * @param {Array} strSymbols The string symbols to inspect.\x0a   * @param {Array} chrSymbols The character symbols to find.\x0a   * @returns {number} Returns the index of the last unmatched string symbol.\x0a   */\x0a  function charsEndIndex(strSymbols, chrSymbols) {\x0a    var index = strSymbols.length;\x0a\x0a    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) \x3e -1) {}\x0a    return index;\x0a  }\x0a\x0a  /**\x0a   * Gets the number of `placeholder` occurrences in `array`.\x0a   *\x0a   * @private\x0a   * @param {Array} array The array to inspect.\x0a   * @param {*} placeholder The placeholder to search for.\x0a   * @returns {number} Returns the placeholder count.\x0a   */\x0a  function countHolders(array, placeholder) {\x0a    var length = array.length,\x0a        result = 0;\x0a\x0a    while (length--) {\x0a      if (array[length] === placeholder) {\x0a        ++result;\x0a      }\x0a    }\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\x0a   * letters to basic Latin letters.\x0a   *\x0a   * @private\x0a   * @param {string} letter The matched letter to deburr.\x0a   * @returns {string} Returns the deburred letter.\x0a   */\x0a  var deburrLetter = basePropertyOf(deburredLetters);\x0a\x0a  /**\x0a   * Used by `_.escape` to convert characters to HTML entities.\x0a   *\x0a   * @private\x0a   * @param {string} chr The matched character to escape.\x0a   * @returns {string} Returns the escaped character.\x0a   */\x0a  var escapeHtmlChar = basePropertyOf(htmlEscapes);\x0a\x0a  /**\x0a   * Used by `_.template` to escape characters for inclusion in compiled string literals.\x0a   *\x0a   * @private\x0a   * @param {string} chr The matched character to escape.\x0a   * @returns {string} Returns the escaped character.\x0a   */\x0a  function escapeStringChar(chr) {\x0a    return \x27\x5c\x5c\x27 + stringEscapes[chr];\x0a  }\x0a\x0a  /**\x0a   * Gets the value at `key` of `object`.\x0a   *\x0a   * @private\x0a   * @param {Object} [object] The object to query.\x0a   * @param {string} key The key of the property to get.\x0a   * @returns {*} Returns the property value.\x0a   */\x0a  function getValue(object, key) {\x0a    return object == null ? undefined : object[key];\x0a  }\x0a\x0a  /**\x0a   * Checks if `string` contains Unicode symbols.\x0a   *\x0a   * @private\x0a   * @param {string} string The string to inspect.\x0a   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\x0a   */\x0a  function hasUnicode(string) {\x0a    return reHasUnicode.test(string);\x0a  }\x0a\x0a  /**\x0a   * Checks if `string` contains a word composed of Unicode symbols.\x0a   *\x0a   * @private\x0a   * @param {string} string The string to inspect.\x0a   * @returns {boolean} Returns `true` if a word is found, else `false`.\x0a   */\x0a  function hasUnicodeWord(string) {\x0a    return reHasUnicodeWord.test(string);\x0a  }\x0a\x0a  /**\x0a   * Converts `iterator` to an array.\x0a   *\x0a   * @private\x0a   * @param {Object} iterator The iterator to convert.\x0a   * @returns {Array} Returns the converted array.\x0a   */\x0a  function iteratorToArray(iterator) {\x0a    var data,\x0a        result = [];\x0a\x0a    while (!(data = iterator.next()).done) {\x0a      result.push(data.value);\x0a    }\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * Converts `map` to its key-value pairs.\x0a   *\x0a   * @private\x0a   * @param {Object} map The map to convert.\x0a   * @returns {Array} Returns the key-value pairs.\x0a   */\x0a  function mapToArray(map) {\x0a    var index = -1,\x0a        result = Array(map.size);\x0a\x0a    map.forEach(function(value, key) {\x0a      result[++index] = [key, value];\x0a    });\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * Creates a unary function that invokes `func` with its argument transformed.\x0a   *\x0a   * @private\x0a   * @param {Function} func The function to wrap.\x0a   * @param {Function} transform The argument transform.\x0a   * @returns {Function} Returns the new function.\x0a   */\x0a  function overArg(func, transform) {\x0a    return function(arg) {\x0a      return func(transform(arg));\x0a    };\x0a  }\x0a\x0a  /**\x0a   * Replaces all `placeholder` elements in `array` with an internal placeholder\x0a   * and returns an array of their indexes.\x0a   *\x0a   * @private\x0a   * @param {Array} array The array to modify.\x0a   * @param {*} placeholder The placeholder to replace.\x0a   * @returns {Array} Returns the new array of placeholder indexes.\x0a   */\x0a  function replaceHolders(array, placeholder) {\x0a    var index = -1,\x0a        length = array.length,\x0a        resIndex = 0,\x0a        result = [];\x0a\x0a    while (++index \x3c length) {\x0a      var value = array[index];\x0a      if (value === placeholder || value === PLACEHOLDER) {\x0a        array[index] = PLACEHOLDER;\x0a        result[resIndex++] = index;\x0a      }\x0a    }\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * Converts `set` to an array of its values.\x0a   *\x0a   * @private\x0a   * @param {Object} set The set to convert.\x0a   * @returns {Array} Returns the values.\x0a   */\x0a  function setToArray(set) {\x0a    var index = -1,\x0a        result = Array(set.size);\x0a\x0a    set.forEach(function(value) {\x0a      result[++index] = value;\x0a    });\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * Converts `set` to its value-value pairs.\x0a   *\x0a   * @private\x0a   * @param {Object} set The set to convert.\x0a   * @returns {Array} Returns the value-value pairs.\x0a   */\x0a  function setToPairs(set) {\x0a    var index = -1,\x0a        result = Array(set.size);\x0a\x0a    set.forEach(function(value) {\x0a      result[++index] = [value, value];\x0a    });\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `_.indexOf` which performs strict equality\x0a   * comparisons of values, i.e. `===`.\x0a   *\x0a   * @private\x0a   * @param {Array} array The array to inspect.\x0a   * @param {*} value The value to search for.\x0a   * @param {number} fromIndex The index to search from.\x0a   * @returns {number} Returns the index of the matched value, else `-1`.\x0a   */\x0a  function strictIndexOf(array, value, fromIndex) {\x0a    var index = fromIndex - 1,\x0a        length = array.length;\x0a\x0a    while (++index \x3c length) {\x0a      if (array[index] === value) {\x0a        return index;\x0a      }\x0a    }\x0a    return -1;\x0a  }\x0a\x0a  /**\x0a   * A specialized version of `_.lastIndexOf` which performs strict equality\x0a   * comparisons of values, i.e. `===`.\x0a   *\x0a   * @private\x0a   * @param {Array} array The array to inspect.\x0a   * @param {*} value The value to search for.\x0a   * @param {number} fromIndex The index to search from.\x0a   * @returns {number} Returns the index of the matched value, else `-1`.\x0a   */\x0a  function strictLastIndexOf(array, value, fromIndex) {\x0a    var index = fromIndex + 1;\x0a    while (index--) {\x0a      if (array[index] === value) {\x0a        return index;\x0a      }\x0a    }\x0a    return index;\x0a  }\x0a\x0a  /**\x0a   * Gets the number of symbols in `string`.\x0a   *\x0a   * @private\x0a   * @param {string} string The string to inspect.\x0a   * @returns {number} Returns the string size.\x0a   */\x0a  function stringSize(string) {\x0a    return hasUnicode(string)\x0a      ? unicodeSize(string)\x0a      : asciiSize(string);\x0a  }\x0a\x0a  /**\x0a   * Converts `string` to an array.\x0a   *\x0a   * @private\x0a   * @param {string} string The string to convert.\x0a   * @returns {Array} Returns the converted array.\x0a   */\x0a  function stringToArray(string) {\x0a    return hasUnicode(string)\x0a      ? unicodeToArray(string)\x0a      : asciiToArray(string);\x0a  }\x0a\x0a  /**\x0a   * Used by `_.unescape` to convert HTML entities to characters.\x0a   *\x0a   * @private\x0a   * @param {string} chr The matched character to unescape.\x0a   * @returns {string} Returns the unescaped character.\x0a   */\x0a  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\x0a\x0a  /**\x0a   * Gets the size of a Unicode `string`.\x0a   *\x0a   * @private\x0a   * @param {string} string The string inspect.\x0a   * @returns {number} Returns the string size.\x0a   */\x0a  function unicodeSize(string) {\x0a    var result = reUnicode.lastIndex = 0;\x0a    while (reUnicode.test(string)) {\x0a      ++result;\x0a    }\x0a    return result;\x0a  }\x0a\x0a  /**\x0a   * Converts a Unicode `string` to an array.\x0a   *\x0a   * @private\x0a   * @param {string} string The string to convert.\x0a   * @returns {Array} Returns the converted array.\x0a   */\x0a  function unicodeToArray(string) {\x0a    return string.match(reUnicode) || [];\x0a  }\x0a\x0a  /**\x0a   * Splits a Unicode `string` into an array of its words.\x0a   *\x0a   * @private\x0a   * @param {string} The string to inspect.\x0a   * @returns {Array} Returns the words of `string`.\x0a   */\x0a  function unicodeWords(string) {\x0a    return string.match(reUnicodeWord) || [];\x0a  }\x0a\x0a  /*--------------------------------------------------------------------------*/\x0a\x0a  /**\x0a   * Create a new pristine `lodash` function using the `context` object.\x0a   *\x0a   * @static\x0a   * @memberOf _\x0a   * @since 1.1.0\x0a   * @category Util\x0a   * @param {Object} [context=root] The context object.\x0a   * @returns {Function} Returns a new `lodash` function.\x0a   * @example\x0a   *\x0a   * _.mixin({ \x27foo\x27: _.constant(\x27foo\x27) });\x0a   *\x0a   * var lodash = _.runInContext();\x0a   * lodash.mixin({ \x27bar\x27: lodash.constant(\x27bar\x27) });\x0a   *\x0a   * _.isFunction(_.foo);\x0a   * // =\x3e true\x0a   * _.isFunction(_.bar);\x0a   * // =\x3e false\x0a   *\x0a   * lodash.isFunction(lodash.foo);\x0a   * // =\x3e false\x0a   * lodash.isFunction(lodash.bar);\x0a   * // =\x3e true\x0a   *\x0a   * // Create a suped-up `defer` in Node.js.\x0a   * var defer = _.runInContext({ \x27setTimeout\x27: setImmediate }).defer;\x0a   */\x0a  var runInContext = (function runInContext(context) {\x0a    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\x0a\x0a    /** Built-in constructor references. */\x0a    var Array = context.Array,\x0a        Date = context.Date,\x0a        Error = context.Error,\x0a        Function = context.Function,\x0a        Math = context.Math,\x0a        Object = context.Object,\x0a        RegExp = context.RegExp,\x0a        String = context.String,\x0a        TypeError = context.TypeError;\x0a\x0a    /** Used for built-in method references. */\x0a    var arrayProto = Array.prototype,\x0a        funcProto = Function.prototype,\x0a        objectProto = Object.prototype;\x0a\x0a    /** Used to detect overreaching core-js shims. */\x0a    var coreJsData = context[\x27__core-js_shared__\x27];\x0a\x0a    /** Used to resolve the decompiled source of functions. */\x0a    var funcToString = funcProto.toString;\x0a\x0a    /** Used to check objects for own properties. */\x0a    var hasOwnProperty = objectProto.hasOwnProperty;\x0a\x0a    /** Used to generate unique IDs. */\x0a    var idCounter = 0;\x0a\x0a    /** Used to detect methods masquerading as native. */\x0a    var maskSrcKey = (function() {\x0a      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \x27\x27);\x0a      return uid ? (\x27Symbol(src)_1.\x27 + uid) : \x27\x27;\x0a    }());\x0a\x0a    /**\x0a     * Used to resolve the\x0a     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\x0a     * of values.\x0a     */\x0a    var nativeObjectToString = objectProto.toString;\x0a\x0a    /** Used to infer the `Object` constructor. */\x0a    var objectCtorString = funcToString.call(Object);\x0a\x0a    /** Used to restore the original `_` reference in `_.noConflict`. */\x0a    var oldDash = root._;\x0a\x0a    /** Used to detect if a method is native. */\x0a    var reIsNative = RegExp(\x27^\x27 +\x0a      funcToString.call(hasOwnProperty).replace(reRegExpChar, \x27\x5c\x5c$&\x27)\x0a      .replace(/hasOwnProperty|(function).*?(?=\x5c\x5c\x5c()| for .+?(?=\x5c\x5c\x5c])/g, \x27$1.*?\x27) + \x27$\x27\x0a    );\x0a\x0a    /** Built-in value references. */\x0a    var Buffer = moduleExports ? context.Buffer : undefined,\x0a        Symbol = context.Symbol,\x0a        Uint8Array = context.Uint8Array,\x0a        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\x0a        getPrototype = overArg(Object.getPrototypeOf, Object),\x0a        objectCreate = Object.create,\x0a        propertyIsEnumerable = objectProto.propertyIsEnumerable,\x0a        splice = arrayProto.splice,\x0a        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\x0a        symIterator = Symbol ? Symbol.iterator : undefined,\x0a        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\x0a\x0a    var defineProperty = (function() {\x0a      try {\x0a        var func = getNative(Object, \x27defineProperty\x27);\x0a        func({}, \x27\x27, {});\x0a        return func;\x0a      } catch (e) {}\x0a    }());\x0a\x0a    /** Mocked built-ins. */\x0a    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\x0a        ctxNow = Date && Date.now !== root.Date.now && Date.now,\x0a        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\x0a\x0a    /* Built-in method references for those with the same name as other `lodash` methods. */\x0a    var nativeCeil = Math.ceil,\x0a        nativeFloor = Math.floor,\x0a        nativeGetSymbols = Object.getOwnPropertySymbols,\x0a        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\x0a        nativeIsFinite = context.isFinite,\x0a        nativeJoin = arrayProto.join,\x0a        nativeKeys = overArg(Object.keys, Object),\x0a        nativeMax = Math.max,\x0a        nativeMin = Math.min,\x0a        nativeNow = Date.now,\x0a        nativeParseInt = context.parseInt,\x0a        nativeRandom = Math.random,\x0a        nativeReverse = arrayProto.reverse;\x0a\x0a    /* Built-in method references that are verified to be native. */\x0a    var DataView = getNative(context, \x27DataView\x27),\x0a        Map = getNative(context, \x27Map\x27),\x0a        Promise = getNative(context, \x27Promise\x27),\x0a        Set = getNative(context, \x27Set\x27),\x0a        WeakMap = getNative(context, \x27WeakMap\x27),\x0a        nativeCreate = getNative(Object, \x27create\x27);\x0a\x0a    /** Used to store function metadata. */\x0a    var metaMap = WeakMap && new WeakMap;\x0a\x0a    /** Used to lookup unminified function names. */\x0a    var realNames = {};\x0a\x0a    /** Used to detect maps, sets, and weakmaps. */\x0a    var dataViewCtorString = toSource(DataView),\x0a        mapCtorString = toSource(Map),\x0a        promiseCtorString = toSource(Promise),\x0a        setCtorString = toSource(Set),\x0a        weakMapCtorString = toSource(WeakMap);\x0a\x0a    /** Used to convert symbols to primitives and strings. */\x0a    var symbolProto = Symbol ? Symbol.prototype : undefined,\x0a        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\x0a        symbolToString = symbolProto ? symbolProto.toString : undefined;\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Creates a `lodash` object which wraps `value` to enable implicit method\x0a     * chain sequences. Methods that operate on and return arrays, collections,\x0a     * and functions can be chained together. Methods that retrieve a single value\x0a     * or may return a primitive value will automatically end the chain sequence\x0a     * and return the unwrapped value. Otherwise, the value must be unwrapped\x0a     * with `_#value`.\x0a     *\x0a     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\x0a     * enabled using `_.chain`.\x0a     *\x0a     * The execution of chained methods is lazy, that is, it\x27s deferred until\x0a     * `_#value` is implicitly or explicitly called.\x0a     *\x0a     * Lazy evaluation allows several methods to support shortcut fusion.\x0a     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\x0a     * the creation of intermediate arrays and can greatly reduce the number of\x0a     * iteratee executions. Sections of a chain sequence qualify for shortcut\x0a     * fusion if the section is applied to an array and iteratees accept only\x0a     * one argument. The heuristic for whether a section qualifies for shortcut\x0a     * fusion is subject to change.\x0a     *\x0a     * Chaining is supported in custom builds as long as the `_#value` method is\x0a     * directly or indirectly included in the build.\x0a     *\x0a     * In addition to lodash methods, wrappers have `Array` and `String` methods.\x0a     *\x0a     * The wrapper `Array` methods are:\x0a     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\x0a     *\x0a     * The wrapper `String` methods are:\x0a     * `replace` and `split`\x0a     *\x0a     * The wrapper methods that support shortcut fusion are:\x0a     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\x0a     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\x0a     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\x0a     *\x0a     * The chainable wrapper methods are:\x0a     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\x0a     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\x0a     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\x0a     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\x0a     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\x0a     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\x0a     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\x0a     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\x0a     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\x0a     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\x0a     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\x0a     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\x0a     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\x0a     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\x0a     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\x0a     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\x0a     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\x0a     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\x0a     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\x0a     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\x0a     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\x0a     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\x0a     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\x0a     * `zipObject`, `zipObjectDeep`, and `zipWith`\x0a     *\x0a     * The wrapper methods that are **not** chainable by default are:\x0a     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\x0a     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\x0a     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\x0a     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\x0a     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\x0a     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\x0a     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\x0a     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\x0a     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\x0a     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\x0a     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\x0a     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\x0a     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\x0a     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\x0a     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\x0a     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\x0a     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\x0a     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\x0a     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\x0a     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\x0a     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\x0a     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\x0a     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\x0a     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\x0a     * `upperFirst`, `value`, and `words`\x0a     *\x0a     * @name _\x0a     * @constructor\x0a     * @category Seq\x0a     * @param {*} value The value to wrap in a `lodash` instance.\x0a     * @returns {Object} Returns the new `lodash` wrapper instance.\x0a     * @example\x0a     *\x0a     * function square(n) {\x0a     *   return n * n;\x0a     * }\x0a     *\x0a     * var wrapped = _([1, 2, 3]);\x0a     *\x0a     * // Returns an unwrapped value.\x0a     * wrapped.reduce(_.add);\x0a     * // =\x3e 6\x0a     *\x0a     * // Returns a wrapped value.\x0a     * var squares = wrapped.map(square);\x0a     *\x0a     * _.isArray(squares);\x0a     * // =\x3e false\x0a     *\x0a     * _.isArray(squares.value());\x0a     * // =\x3e true\x0a     */\x0a    function lodash(value) {\x0a      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\x0a        if (value instanceof LodashWrapper) {\x0a          return value;\x0a        }\x0a        if (hasOwnProperty.call(value, \x27__wrapped__\x27)) {\x0a          return wrapperClone(value);\x0a        }\x0a      }\x0a      return new LodashWrapper(value);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.create` without support for assigning\x0a     * properties to the created object.\x0a     *\x0a     * @private\x0a     * @param {Object} proto The object to inherit from.\x0a     * @returns {Object} Returns the new object.\x0a     */\x0a    var baseCreate = (function() {\x0a      function object() {}\x0a      return function(proto) {\x0a        if (!isObject(proto)) {\x0a          return {};\x0a        }\x0a        if (objectCreate) {\x0a          return objectCreate(proto);\x0a        }\x0a        object.prototype = proto;\x0a        var result = new object;\x0a        object.prototype = undefined;\x0a        return result;\x0a      };\x0a    }());\x0a\x0a    /**\x0a     * The function whose prototype chain sequence wrappers inherit from.\x0a     *\x0a     * @private\x0a     */\x0a    function baseLodash() {\x0a      // No operation performed.\x0a    }\x0a\x0a    /**\x0a     * The base constructor for creating `lodash` wrapper objects.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to wrap.\x0a     * @param {boolean} [chainAll] Enable explicit method chain sequences.\x0a     */\x0a    function LodashWrapper(value, chainAll) {\x0a      this.__wrapped__ = value;\x0a      this.__actions__ = [];\x0a      this.__chain__ = !!chainAll;\x0a      this.__index__ = 0;\x0a      this.__values__ = undefined;\x0a    }\x0a\x0a    /**\x0a     * By default, the template delimiters used by lodash are like those in\x0a     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\x0a     * following template settings to use alternative delimiters.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @type {Object}\x0a     */\x0a    lodash.templateSettings = {\x0a\x0a      /**\x0a       * Used to detect `data` property values to be HTML-escaped.\x0a       *\x0a       * @memberOf _.templateSettings\x0a       * @type {RegExp}\x0a       */\x0a      \x27escape\x27: reEscape,\x0a\x0a      /**\x0a       * Used to detect code to be evaluated.\x0a       *\x0a       * @memberOf _.templateSettings\x0a       * @type {RegExp}\x0a       */\x0a      \x27evaluate\x27: reEvaluate,\x0a\x0a      /**\x0a       * Used to detect `data` property values to inject.\x0a       *\x0a       * @memberOf _.templateSettings\x0a       * @type {RegExp}\x0a       */\x0a      \x27interpolate\x27: reInterpolate,\x0a\x0a      /**\x0a       * Used to reference the data object in the template text.\x0a       *\x0a       * @memberOf _.templateSettings\x0a       * @type {string}\x0a       */\x0a      \x27variable\x27: \x27\x27,\x0a\x0a      /**\x0a       * Used to import variables into the compiled template.\x0a       *\x0a       * @memberOf _.templateSettings\x0a       * @type {Object}\x0a       */\x0a      \x27imports\x27: {\x0a\x0a        /**\x0a         * A reference to the `lodash` function.\x0a         *\x0a         * @memberOf _.templateSettings.imports\x0a         * @type {Function}\x0a         */\x0a        \x27_\x27: lodash\x0a      }\x0a    };\x0a\x0a    // Ensure wrappers are instances of `baseLodash`.\x0a    lodash.prototype = baseLodash.prototype;\x0a    lodash.prototype.constructor = lodash;\x0a\x0a    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\x0a    LodashWrapper.prototype.constructor = LodashWrapper;\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\x0a     *\x0a     * @private\x0a     * @constructor\x0a     * @param {*} value The value to wrap.\x0a     */\x0a    function LazyWrapper(value) {\x0a      this.__wrapped__ = value;\x0a      this.__actions__ = [];\x0a      this.__dir__ = 1;\x0a      this.__filtered__ = false;\x0a      this.__iteratees__ = [];\x0a      this.__takeCount__ = MAX_ARRAY_LENGTH;\x0a      this.__views__ = [];\x0a    }\x0a\x0a    /**\x0a     * Creates a clone of the lazy wrapper object.\x0a     *\x0a     * @private\x0a     * @name clone\x0a     * @memberOf LazyWrapper\x0a     * @returns {Object} Returns the cloned `LazyWrapper` object.\x0a     */\x0a    function lazyClone() {\x0a      var result = new LazyWrapper(this.__wrapped__);\x0a      result.__actions__ = copyArray(this.__actions__);\x0a      result.__dir__ = this.__dir__;\x0a      result.__filtered__ = this.__filtered__;\x0a      result.__iteratees__ = copyArray(this.__iteratees__);\x0a      result.__takeCount__ = this.__takeCount__;\x0a      result.__views__ = copyArray(this.__views__);\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Reverses the direction of lazy iteration.\x0a     *\x0a     * @private\x0a     * @name reverse\x0a     * @memberOf LazyWrapper\x0a     * @returns {Object} Returns the new reversed `LazyWrapper` object.\x0a     */\x0a    function lazyReverse() {\x0a      if (this.__filtered__) {\x0a        var result = new LazyWrapper(this);\x0a        result.__dir__ = -1;\x0a        result.__filtered__ = true;\x0a      } else {\x0a        result = this.clone();\x0a        result.__dir__ *= -1;\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Extracts the unwrapped value from its lazy wrapper.\x0a     *\x0a     * @private\x0a     * @name value\x0a     * @memberOf LazyWrapper\x0a     * @returns {*} Returns the unwrapped value.\x0a     */\x0a    function lazyValue() {\x0a      var array = this.__wrapped__.value(),\x0a          dir = this.__dir__,\x0a          isArr = isArray(array),\x0a          isRight = dir \x3c 0,\x0a          arrLength = isArr ? array.length : 0,\x0a          view = getView(0, arrLength, this.__views__),\x0a          start = view.start,\x0a          end = view.end,\x0a          length = end - start,\x0a          index = isRight ? end : (start - 1),\x0a          iteratees = this.__iteratees__,\x0a          iterLength = iteratees.length,\x0a          resIndex = 0,\x0a          takeCount = nativeMin(length, this.__takeCount__);\x0a\x0a      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\x0a        return baseWrapperValue(array, this.__actions__);\x0a      }\x0a      var result = [];\x0a\x0a      outer:\x0a      while (length-- && resIndex \x3c takeCount) {\x0a        index += dir;\x0a\x0a        var iterIndex = -1,\x0a            value = array[index];\x0a\x0a        while (++iterIndex \x3c iterLength) {\x0a          var data = iteratees[iterIndex],\x0a              iteratee = data.iteratee,\x0a              type = data.type,\x0a              computed = iteratee(value);\x0a\x0a          if (type == LAZY_MAP_FLAG) {\x0a            value = computed;\x0a          } else if (!computed) {\x0a            if (type == LAZY_FILTER_FLAG) {\x0a              continue outer;\x0a            } else {\x0a              break outer;\x0a            }\x0a          }\x0a        }\x0a        result[resIndex++] = value;\x0a      }\x0a      return result;\x0a    }\x0a\x0a    // Ensure `LazyWrapper` is an instance of `baseLodash`.\x0a    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\x0a    LazyWrapper.prototype.constructor = LazyWrapper;\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Creates a hash object.\x0a     *\x0a     * @private\x0a     * @constructor\x0a     * @param {Array} [entries] The key-value pairs to cache.\x0a     */\x0a    function Hash(entries) {\x0a      var index = -1,\x0a          length = entries == null ? 0 : entries.length;\x0a\x0a      this.clear();\x0a      while (++index \x3c length) {\x0a        var entry = entries[index];\x0a        this.set(entry[0], entry[1]);\x0a      }\x0a    }\x0a\x0a    /**\x0a     * Removes all key-value entries from the hash.\x0a     *\x0a     * @private\x0a     * @name clear\x0a     * @memberOf Hash\x0a     */\x0a    function hashClear() {\x0a      this.__data__ = nativeCreate ? nativeCreate(null) : {};\x0a      this.size = 0;\x0a    }\x0a\x0a    /**\x0a     * Removes `key` and its value from the hash.\x0a     *\x0a     * @private\x0a     * @name delete\x0a     * @memberOf Hash\x0a     * @param {Object} hash The hash to modify.\x0a     * @param {string} key The key of the value to remove.\x0a     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\x0a     */\x0a    function hashDelete(key) {\x0a      var result = this.has(key) && delete this.__data__[key];\x0a      this.size -= result ? 1 : 0;\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Gets the hash value for `key`.\x0a     *\x0a     * @private\x0a     * @name get\x0a     * @memberOf Hash\x0a     * @param {string} key The key of the value to get.\x0a     * @returns {*} Returns the entry value.\x0a     */\x0a    function hashGet(key) {\x0a      var data = this.__data__;\x0a      if (nativeCreate) {\x0a        var result = data[key];\x0a        return result === HASH_UNDEFINED ? undefined : result;\x0a      }\x0a      return hasOwnProperty.call(data, key) ? data[key] : undefined;\x0a    }\x0a\x0a    /**\x0a     * Checks if a hash value for `key` exists.\x0a     *\x0a     * @private\x0a     * @name has\x0a     * @memberOf Hash\x0a     * @param {string} key The key of the entry to check.\x0a     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\x0a     */\x0a    function hashHas(key) {\x0a      var data = this.__data__;\x0a      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\x0a    }\x0a\x0a    /**\x0a     * Sets the hash `key` to `value`.\x0a     *\x0a     * @private\x0a     * @name set\x0a     * @memberOf Hash\x0a     * @param {string} key The key of the value to set.\x0a     * @param {*} value The value to set.\x0a     * @returns {Object} Returns the hash instance.\x0a     */\x0a    function hashSet(key, value) {\x0a      var data = this.__data__;\x0a      this.size += this.has(key) ? 0 : 1;\x0a      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\x0a      return this;\x0a    }\x0a\x0a    // Add methods to `Hash`.\x0a    Hash.prototype.clear = hashClear;\x0a    Hash.prototype[\x27delete\x27] = hashDelete;\x0a    Hash.prototype.get = hashGet;\x0a    Hash.prototype.has = hashHas;\x0a    Hash.prototype.set = hashSet;\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Creates an list cache object.\x0a     *\x0a     * @private\x0a     * @constructor\x0a     * @param {Array} [entries] The key-value pairs to cache.\x0a     */\x0a    function ListCache(entries) {\x0a      var index = -1,\x0a          length = entries == null ? 0 : entries.length;\x0a\x0a      this.clear();\x0a      while (++index \x3c length) {\x0a        var entry = entries[index];\x0a        this.set(entry[0], entry[1]);\x0a      }\x0a    }\x0a\x0a    /**\x0a     * Removes all key-value entries from the list cache.\x0a     *\x0a     * @private\x0a     * @name clear\x0a     * @memberOf ListCache\x0a     */\x0a    function listCacheClear() {\x0a      this.__data__ = [];\x0a      this.size = 0;\x0a    }\x0a\x0a    /**\x0a     * Removes `key` and its value from the list cache.\x0a     *\x0a     * @private\x0a     * @name delete\x0a     * @memberOf ListCache\x0a     * @param {string} key The key of the value to remove.\x0a     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\x0a     */\x0a    function listCacheDelete(key) {\x0a      var data = this.__data__,\x0a          index = assocIndexOf(data, key);\x0a\x0a      if (index \x3c 0) {\x0a        return false;\x0a      }\x0a      var lastIndex = data.length - 1;\x0a      if (index == lastIndex) {\x0a        data.pop();\x0a      } else {\x0a        splice.call(data, index, 1);\x0a      }\x0a      --this.size;\x0a      return true;\x0a    }\x0a\x0a    /**\x0a     * Gets the list cache value for `key`.\x0a     *\x0a     * @private\x0a     * @name get\x0a     * @memberOf ListCache\x0a     * @param {string} key The key of the value to get.\x0a     * @returns {*} Returns the entry value.\x0a     */\x0a    function listCacheGet(key) {\x0a      var data = this.__data__,\x0a          index = assocIndexOf(data, key);\x0a\x0a      return index \x3c 0 ? undefined : data[index][1];\x0a    }\x0a\x0a    /**\x0a     * Checks if a list cache value for `key` exists.\x0a     *\x0a     * @private\x0a     * @name has\x0a     * @memberOf ListCache\x0a     * @param {string} key The key of the entry to check.\x0a     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\x0a     */\x0a    function listCacheHas(key) {\x0a      return assocIndexOf(this.__data__, key) \x3e -1;\x0a    }\x0a\x0a    /**\x0a     * Sets the list cache `key` to `value`.\x0a     *\x0a     * @private\x0a     * @name set\x0a     * @memberOf ListCache\x0a     * @param {string} key The key of the value to set.\x0a     * @param {*} value The value to set.\x0a     * @returns {Object} Returns the list cache instance.\x0a     */\x0a    function listCacheSet(key, value) {\x0a      var data = this.__data__,\x0a          index = assocIndexOf(data, key);\x0a\x0a      if (index \x3c 0) {\x0a        ++this.size;\x0a        data.push([key, value]);\x0a      } else {\x0a        data[index][1] = value;\x0a      }\x0a      return this;\x0a    }\x0a\x0a    // Add methods to `ListCache`.\x0a    ListCache.prototype.clear = listCacheClear;\x0a    ListCache.prototype[\x27delete\x27] = listCacheDelete;\x0a    ListCache.prototype.get = listCacheGet;\x0a    ListCache.prototype.has = listCacheHas;\x0a    ListCache.prototype.set = listCacheSet;\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Creates a map cache object to store key-value pairs.\x0a     *\x0a     * @private\x0a     * @constructor\x0a     * @param {Array} [entries] The key-value pairs to cache.\x0a     */\x0a    function MapCache(entries) {\x0a      var index = -1,\x0a          length = entries == null ? 0 : entries.length;\x0a\x0a      this.clear();\x0a      while (++index \x3c length) {\x0a        var entry = entries[index];\x0a        this.set(entry[0], entry[1]);\x0a      }\x0a    }\x0a\x0a    /**\x0a     * Removes all key-value entries from the map.\x0a     *\x0a     * @private\x0a     * @name clear\x0a     * @memberOf MapCache\x0a     */\x0a    function mapCacheClear() {\x0a      this.size = 0;\x0a      this.__data__ = {\x0a        \x27hash\x27: new Hash,\x0a        \x27map\x27: new (Map || ListCache),\x0a        \x27string\x27: new Hash\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Removes `key` and its value from the map.\x0a     *\x0a     * @private\x0a     * @name delete\x0a     * @memberOf MapCache\x0a     * @param {string} key The key of the value to remove.\x0a     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\x0a     */\x0a    function mapCacheDelete(key) {\x0a      var result = getMapData(this, key)[\x27delete\x27](key);\x0a      this.size -= result ? 1 : 0;\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Gets the map value for `key`.\x0a     *\x0a     * @private\x0a     * @name get\x0a     * @memberOf MapCache\x0a     * @param {string} key The key of the value to get.\x0a     * @returns {*} Returns the entry value.\x0a     */\x0a    function mapCacheGet(key) {\x0a      return getMapData(this, key).get(key);\x0a    }\x0a\x0a    /**\x0a     * Checks if a map value for `key` exists.\x0a     *\x0a     * @private\x0a     * @name has\x0a     * @memberOf MapCache\x0a     * @param {string} key The key of the entry to check.\x0a     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\x0a     */\x0a    function mapCacheHas(key) {\x0a      return getMapData(this, key).has(key);\x0a    }\x0a\x0a    /**\x0a     * Sets the map `key` to `value`.\x0a     *\x0a     * @private\x0a     * @name set\x0a     * @memberOf MapCache\x0a     * @param {string} key The key of the value to set.\x0a     * @param {*} value The value to set.\x0a     * @returns {Object} Returns the map cache instance.\x0a     */\x0a    function mapCacheSet(key, value) {\x0a      var data = getMapData(this, key),\x0a          size = data.size;\x0a\x0a      data.set(key, value);\x0a      this.size += data.size == size ? 0 : 1;\x0a      return this;\x0a    }\x0a\x0a    // Add methods to `MapCache`.\x0a    MapCache.prototype.clear = mapCacheClear;\x0a    MapCache.prototype[\x27delete\x27] = mapCacheDelete;\x0a    MapCache.prototype.get = mapCacheGet;\x0a    MapCache.prototype.has = mapCacheHas;\x0a    MapCache.prototype.set = mapCacheSet;\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     *\x0a     * Creates an array cache object to store unique values.\x0a     *\x0a     * @private\x0a     * @constructor\x0a     * @param {Array} [values] The values to cache.\x0a     */\x0a    function SetCache(values) {\x0a      var index = -1,\x0a          length = values == null ? 0 : values.length;\x0a\x0a      this.__data__ = new MapCache;\x0a      while (++index \x3c length) {\x0a        this.add(values[index]);\x0a      }\x0a    }\x0a\x0a    /**\x0a     * Adds `value` to the array cache.\x0a     *\x0a     * @private\x0a     * @name add\x0a     * @memberOf SetCache\x0a     * @alias push\x0a     * @param {*} value The value to cache.\x0a     * @returns {Object} Returns the cache instance.\x0a     */\x0a    function setCacheAdd(value) {\x0a      this.__data__.set(value, HASH_UNDEFINED);\x0a      return this;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is in the array cache.\x0a     *\x0a     * @private\x0a     * @name has\x0a     * @memberOf SetCache\x0a     * @param {*} value The value to search for.\x0a     * @returns {number} Returns `true` if `value` is found, else `false`.\x0a     */\x0a    function setCacheHas(value) {\x0a      return this.__data__.has(value);\x0a    }\x0a\x0a    // Add methods to `SetCache`.\x0a    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\x0a    SetCache.prototype.has = setCacheHas;\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Creates a stack cache object to store key-value pairs.\x0a     *\x0a     * @private\x0a     * @constructor\x0a     * @param {Array} [entries] The key-value pairs to cache.\x0a     */\x0a    function Stack(entries) {\x0a      var data = this.__data__ = new ListCache(entries);\x0a      this.size = data.size;\x0a    }\x0a\x0a    /**\x0a     * Removes all key-value entries from the stack.\x0a     *\x0a     * @private\x0a     * @name clear\x0a     * @memberOf Stack\x0a     */\x0a    function stackClear() {\x0a      this.__data__ = new ListCache;\x0a      this.size = 0;\x0a    }\x0a\x0a    /**\x0a     * Removes `key` and its value from the stack.\x0a     *\x0a     * @private\x0a     * @name delete\x0a     * @memberOf Stack\x0a     * @param {string} key The key of the value to remove.\x0a     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\x0a     */\x0a    function stackDelete(key) {\x0a      var data = this.__data__,\x0a          result = data[\x27delete\x27](key);\x0a\x0a      this.size = data.size;\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Gets the stack value for `key`.\x0a     *\x0a     * @private\x0a     * @name get\x0a     * @memberOf Stack\x0a     * @param {string} key The key of the value to get.\x0a     * @returns {*} Returns the entry value.\x0a     */\x0a    function stackGet(key) {\x0a      return this.__data__.get(key);\x0a    }\x0a\x0a    /**\x0a     * Checks if a stack value for `key` exists.\x0a     *\x0a     * @private\x0a     * @name has\x0a     * @memberOf Stack\x0a     * @param {string} key The key of the entry to check.\x0a     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\x0a     */\x0a    function stackHas(key) {\x0a      return this.__data__.has(key);\x0a    }\x0a\x0a    /**\x0a     * Sets the stack `key` to `value`.\x0a     *\x0a     * @private\x0a     * @name set\x0a     * @memberOf Stack\x0a     * @param {string} key The key of the value to set.\x0a     * @param {*} value The value to set.\x0a     * @returns {Object} Returns the stack cache instance.\x0a     */\x0a    function stackSet(key, value) {\x0a      var data = this.__data__;\x0a      if (data instanceof ListCache) {\x0a        var pairs = data.__data__;\x0a        if (!Map || (pairs.length \x3c LARGE_ARRAY_SIZE - 1)) {\x0a          pairs.push([key, value]);\x0a          this.size = ++data.size;\x0a          return this;\x0a        }\x0a        data = this.__data__ = new MapCache(pairs);\x0a      }\x0a      data.set(key, value);\x0a      this.size = data.size;\x0a      return this;\x0a    }\x0a\x0a    // Add methods to `Stack`.\x0a    Stack.prototype.clear = stackClear;\x0a    Stack.prototype[\x27delete\x27] = stackDelete;\x0a    Stack.prototype.get = stackGet;\x0a    Stack.prototype.has = stackHas;\x0a    Stack.prototype.set = stackSet;\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Creates an array of the enumerable property names of the array-like `value`.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to query.\x0a     * @param {boolean} inherited Specify returning inherited property names.\x0a     * @returns {Array} Returns the array of property names.\x0a     */\x0a    function arrayLikeKeys(value, inherited) {\x0a      var isArr = isArray(value),\x0a          isArg = !isArr && isArguments(value),\x0a          isBuff = !isArr && !isArg && isBuffer(value),\x0a          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\x0a          skipIndexes = isArr || isArg || isBuff || isType,\x0a          result = skipIndexes ? baseTimes(value.length, String) : [],\x0a          length = result.length;\x0a\x0a      for (var key in value) {\x0a        if ((inherited || hasOwnProperty.call(value, key)) &&\x0a            !(skipIndexes && (\x0a               // Safari 9 has enumerable `arguments.length` in strict mode.\x0a               key == \x27length\x27 ||\x0a               // Node.js 0.10 has enumerable non-index properties on buffers.\x0a               (isBuff && (key == \x27offset\x27 || key == \x27parent\x27)) ||\x0a               // PhantomJS 2 has enumerable non-index properties on typed arrays.\x0a               (isType && (key == \x27buffer\x27 || key == \x27byteLength\x27 || key == \x27byteOffset\x27)) ||\x0a               // Skip index properties.\x0a               isIndex(key, length)\x0a            ))) {\x0a          result.push(key);\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `_.sample` for arrays.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to sample.\x0a     * @returns {*} Returns the random element.\x0a     */\x0a    function arraySample(array) {\x0a      var length = array.length;\x0a      return length ? array[baseRandom(0, length - 1)] : undefined;\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `_.sampleSize` for arrays.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to sample.\x0a     * @param {number} n The number of elements to sample.\x0a     * @returns {Array} Returns the random elements.\x0a     */\x0a    function arraySampleSize(array, n) {\x0a      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `_.shuffle` for arrays.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to shuffle.\x0a     * @returns {Array} Returns the new shuffled array.\x0a     */\x0a    function arrayShuffle(array) {\x0a      return shuffleSelf(copyArray(array));\x0a    }\x0a\x0a    /**\x0a     * This function is like `assignValue` except that it doesn\x27t assign\x0a     * `undefined` values.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to modify.\x0a     * @param {string} key The key of the property to assign.\x0a     * @param {*} value The value to assign.\x0a     */\x0a    function assignMergeValue(object, key, value) {\x0a      if ((value !== undefined && !eq(object[key], value)) ||\x0a          (value === undefined && !(key in object))) {\x0a        baseAssignValue(object, key, value);\x0a      }\x0a    }\x0a\x0a    /**\x0a     * Assigns `value` to `key` of `object` if the existing value is not equivalent\x0a     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\x0a     * for equality comparisons.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to modify.\x0a     * @param {string} key The key of the property to assign.\x0a     * @param {*} value The value to assign.\x0a     */\x0a    function assignValue(object, key, value) {\x0a      var objValue = object[key];\x0a      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\x0a          (value === undefined && !(key in object))) {\x0a        baseAssignValue(object, key, value);\x0a      }\x0a    }\x0a\x0a    /**\x0a     * Gets the index at which the `key` is found in `array` of key-value pairs.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to inspect.\x0a     * @param {*} key The key to search for.\x0a     * @returns {number} Returns the index of the matched value, else `-1`.\x0a     */\x0a    function assocIndexOf(array, key) {\x0a      var length = array.length;\x0a      while (length--) {\x0a        if (eq(array[length][0], key)) {\x0a          return length;\x0a        }\x0a      }\x0a      return -1;\x0a    }\x0a\x0a    /**\x0a     * Aggregates elements of `collection` on `accumulator` with keys transformed\x0a     * by `iteratee` and values set by `setter`.\x0a     *\x0a     * @private\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} setter The function to set `accumulator` values.\x0a     * @param {Function} iteratee The iteratee to transform keys.\x0a     * @param {Object} accumulator The initial aggregated object.\x0a     * @returns {Function} Returns `accumulator`.\x0a     */\x0a    function baseAggregator(collection, setter, iteratee, accumulator) {\x0a      baseEach(collection, function(value, key, collection) {\x0a        setter(accumulator, value, iteratee(value), collection);\x0a      });\x0a      return accumulator;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.assign` without support for multiple sources\x0a     * or `customizer` functions.\x0a     *\x0a     * @private\x0a     * @param {Object} object The destination object.\x0a     * @param {Object} source The source object.\x0a     * @returns {Object} Returns `object`.\x0a     */\x0a    function baseAssign(object, source) {\x0a      return object && copyObject(source, keys(source), object);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.assignIn` without support for multiple sources\x0a     * or `customizer` functions.\x0a     *\x0a     * @private\x0a     * @param {Object} object The destination object.\x0a     * @param {Object} source The source object.\x0a     * @returns {Object} Returns `object`.\x0a     */\x0a    function baseAssignIn(object, source) {\x0a      return object && copyObject(source, keysIn(source), object);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `assignValue` and `assignMergeValue` without\x0a     * value checks.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to modify.\x0a     * @param {string} key The key of the property to assign.\x0a     * @param {*} value The value to assign.\x0a     */\x0a    function baseAssignValue(object, key, value) {\x0a      if (key == \x27__proto__\x27 && defineProperty) {\x0a        defineProperty(object, key, {\x0a          \x27configurable\x27: true,\x0a          \x27enumerable\x27: true,\x0a          \x27value\x27: value,\x0a          \x27writable\x27: true\x0a        });\x0a      } else {\x0a        object[key] = value;\x0a      }\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.at` without support for individual paths.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to iterate over.\x0a     * @param {string[]} paths The property paths to pick.\x0a     * @returns {Array} Returns the picked elements.\x0a     */\x0a    function baseAt(object, paths) {\x0a      var index = -1,\x0a          length = paths.length,\x0a          result = Array(length),\x0a          skip = object == null;\x0a\x0a      while (++index \x3c length) {\x0a        result[index] = skip ? undefined : get(object, paths[index]);\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.clamp` which doesn\x27t coerce arguments.\x0a     *\x0a     * @private\x0a     * @param {number} number The number to clamp.\x0a     * @param {number} [lower] The lower bound.\x0a     * @param {number} upper The upper bound.\x0a     * @returns {number} Returns the clamped number.\x0a     */\x0a    function baseClamp(number, lower, upper) {\x0a      if (number === number) {\x0a        if (upper !== undefined) {\x0a          number = number \x3c= upper ? number : upper;\x0a        }\x0a        if (lower !== undefined) {\x0a          number = number \x3e= lower ? number : lower;\x0a        }\x0a      }\x0a      return number;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\x0a     * traversed objects.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to clone.\x0a     * @param {boolean} bitmask The bitmask flags.\x0a     *  1 - Deep clone\x0a     *  2 - Flatten inherited properties\x0a     *  4 - Clone symbols\x0a     * @param {Function} [customizer] The function to customize cloning.\x0a     * @param {string} [key] The key of `value`.\x0a     * @param {Object} [object] The parent object of `value`.\x0a     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\x0a     * @returns {*} Returns the cloned value.\x0a     */\x0a    function baseClone(value, bitmask, customizer, key, object, stack) {\x0a      var result,\x0a          isDeep = bitmask & CLONE_DEEP_FLAG,\x0a          isFlat = bitmask & CLONE_FLAT_FLAG,\x0a          isFull = bitmask & CLONE_SYMBOLS_FLAG;\x0a\x0a      if (customizer) {\x0a        result = object ? customizer(value, key, object, stack) : customizer(value);\x0a      }\x0a      if (result !== undefined) {\x0a        return result;\x0a      }\x0a      if (!isObject(value)) {\x0a        return value;\x0a      }\x0a      var isArr = isArray(value);\x0a      if (isArr) {\x0a        result = initCloneArray(value);\x0a        if (!isDeep) {\x0a          return copyArray(value, result);\x0a        }\x0a      } else {\x0a        var tag = getTag(value),\x0a            isFunc = tag == funcTag || tag == genTag;\x0a\x0a        if (isBuffer(value)) {\x0a          return cloneBuffer(value, isDeep);\x0a        }\x0a        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\x0a          result = (isFlat || isFunc) ? {} : initCloneObject(value);\x0a          if (!isDeep) {\x0a            return isFlat\x0a              ? copySymbolsIn(value, baseAssignIn(result, value))\x0a              : copySymbols(value, baseAssign(result, value));\x0a          }\x0a        } else {\x0a          if (!cloneableTags[tag]) {\x0a            return object ? value : {};\x0a          }\x0a          result = initCloneByTag(value, tag, isDeep);\x0a        }\x0a      }\x0a      // Check for circular references and return its corresponding clone.\x0a      stack || (stack = new Stack);\x0a      var stacked = stack.get(value);\x0a      if (stacked) {\x0a        return stacked;\x0a      }\x0a      stack.set(value, result);\x0a\x0a      if (isSet(value)) {\x0a        value.forEach(function(subValue) {\x0a          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\x0a        });\x0a\x0a        return result;\x0a      }\x0a\x0a      if (isMap(value)) {\x0a        value.forEach(function(subValue, key) {\x0a          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\x0a        });\x0a\x0a        return result;\x0a      }\x0a\x0a      var keysFunc = isFull\x0a        ? (isFlat ? getAllKeysIn : getAllKeys)\x0a        : (isFlat ? keysIn : keys);\x0a\x0a      var props = isArr ? undefined : keysFunc(value);\x0a      arrayEach(props || value, function(subValue, key) {\x0a        if (props) {\x0a          key = subValue;\x0a          subValue = value[key];\x0a        }\x0a        // Recursively populate clone (susceptible to call stack limits).\x0a        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\x0a      });\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.conforms` which doesn\x27t clone `source`.\x0a     *\x0a     * @private\x0a     * @param {Object} source The object of property predicates to conform to.\x0a     * @returns {Function} Returns the new spec function.\x0a     */\x0a    function baseConforms(source) {\x0a      var props = keys(source);\x0a      return function(object) {\x0a        return baseConformsTo(object, source, props);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.conformsTo` which accepts `props` to check.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to inspect.\x0a     * @param {Object} source The object of property predicates to conform to.\x0a     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\x0a     */\x0a    function baseConformsTo(object, source, props) {\x0a      var length = props.length;\x0a      if (object == null) {\x0a        return !length;\x0a      }\x0a      object = Object(object);\x0a      while (length--) {\x0a        var key = props[length],\x0a            predicate = source[key],\x0a            value = object[key];\x0a\x0a        if ((value === undefined && !(key in object)) || !predicate(value)) {\x0a          return false;\x0a        }\x0a      }\x0a      return true;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.delay` and `_.defer` which accepts `args`\x0a     * to provide to `func`.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to delay.\x0a     * @param {number} wait The number of milliseconds to delay invocation.\x0a     * @param {Array} args The arguments to provide to `func`.\x0a     * @returns {number|Object} Returns the timer id or timeout object.\x0a     */\x0a    function baseDelay(func, wait, args) {\x0a      if (typeof func != \x27function\x27) {\x0a        throw new TypeError(FUNC_ERROR_TEXT);\x0a      }\x0a      return setTimeout(function() { func.apply(undefined, args); }, wait);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of methods like `_.difference` without support\x0a     * for excluding multiple arrays or iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to inspect.\x0a     * @param {Array} values The values to exclude.\x0a     * @param {Function} [iteratee] The iteratee invoked per element.\x0a     * @param {Function} [comparator] The comparator invoked per element.\x0a     * @returns {Array} Returns the new array of filtered values.\x0a     */\x0a    function baseDifference(array, values, iteratee, comparator) {\x0a      var index = -1,\x0a          includes = arrayIncludes,\x0a          isCommon = true,\x0a          length = array.length,\x0a          result = [],\x0a          valuesLength = values.length;\x0a\x0a      if (!length) {\x0a        return result;\x0a      }\x0a      if (iteratee) {\x0a        values = arrayMap(values, baseUnary(iteratee));\x0a      }\x0a      if (comparator) {\x0a        includes = arrayIncludesWith;\x0a        isCommon = false;\x0a      }\x0a      else if (values.length \x3e= LARGE_ARRAY_SIZE) {\x0a        includes = cacheHas;\x0a        isCommon = false;\x0a        values = new SetCache(values);\x0a      }\x0a      outer:\x0a      while (++index \x3c length) {\x0a        var value = array[index],\x0a            computed = iteratee == null ? value : iteratee(value);\x0a\x0a        value = (comparator || value !== 0) ? value : 0;\x0a        if (isCommon && computed === computed) {\x0a          var valuesIndex = valuesLength;\x0a          while (valuesIndex--) {\x0a            if (values[valuesIndex] === computed) {\x0a              continue outer;\x0a            }\x0a          }\x0a          result.push(value);\x0a        }\x0a        else if (!includes(values, computed, comparator)) {\x0a          result.push(value);\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.forEach` without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} iteratee The function invoked per iteration.\x0a     * @returns {Array|Object} Returns `collection`.\x0a     */\x0a    var baseEach = createBaseEach(baseForOwn);\x0a\x0a    /**\x0a     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} iteratee The function invoked per iteration.\x0a     * @returns {Array|Object} Returns `collection`.\x0a     */\x0a    var baseEachRight = createBaseEach(baseForOwnRight, true);\x0a\x0a    /**\x0a     * The base implementation of `_.every` without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} predicate The function invoked per iteration.\x0a     * @returns {boolean} Returns `true` if all elements pass the predicate check,\x0a     *  else `false`\x0a     */\x0a    function baseEvery(collection, predicate) {\x0a      var result = true;\x0a      baseEach(collection, function(value, index, collection) {\x0a        result = !!predicate(value, index, collection);\x0a        return result;\x0a      });\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of methods like `_.max` and `_.min` which accepts a\x0a     * `comparator` to determine the extremum value.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to iterate over.\x0a     * @param {Function} iteratee The iteratee invoked per iteration.\x0a     * @param {Function} comparator The comparator used to compare values.\x0a     * @returns {*} Returns the extremum value.\x0a     */\x0a    function baseExtremum(array, iteratee, comparator) {\x0a      var index = -1,\x0a          length = array.length;\x0a\x0a      while (++index \x3c length) {\x0a        var value = array[index],\x0a            current = iteratee(value);\x0a\x0a        if (current != null && (computed === undefined\x0a              ? (current === current && !isSymbol(current))\x0a              : comparator(current, computed)\x0a            )) {\x0a          var computed = current,\x0a              result = value;\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.fill` without an iteratee call guard.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to fill.\x0a     * @param {*} value The value to fill `array` with.\x0a     * @param {number} [start=0] The start position.\x0a     * @param {number} [end=array.length] The end position.\x0a     * @returns {Array} Returns `array`.\x0a     */\x0a    function baseFill(array, value, start, end) {\x0a      var length = array.length;\x0a\x0a      start = toInteger(start);\x0a      if (start \x3c 0) {\x0a        start = -start \x3e length ? 0 : (length + start);\x0a      }\x0a      end = (end === undefined || end \x3e length) ? length : toInteger(end);\x0a      if (end \x3c 0) {\x0a        end += length;\x0a      }\x0a      end = start \x3e end ? 0 : toLength(end);\x0a      while (start \x3c end) {\x0a        array[start++] = value;\x0a      }\x0a      return array;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.filter` without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} predicate The function invoked per iteration.\x0a     * @returns {Array} Returns the new filtered array.\x0a     */\x0a    function baseFilter(collection, predicate) {\x0a      var result = [];\x0a      baseEach(collection, function(value, index, collection) {\x0a        if (predicate(value, index, collection)) {\x0a          result.push(value);\x0a        }\x0a      });\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.flatten` with support for restricting flattening.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to flatten.\x0a     * @param {number} depth The maximum recursion depth.\x0a     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\x0a     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\x0a     * @param {Array} [result=[]] The initial result value.\x0a     * @returns {Array} Returns the new flattened array.\x0a     */\x0a    function baseFlatten(array, depth, predicate, isStrict, result) {\x0a      var index = -1,\x0a          length = array.length;\x0a\x0a      predicate || (predicate = isFlattenable);\x0a      result || (result = []);\x0a\x0a      while (++index \x3c length) {\x0a        var value = array[index];\x0a        if (depth \x3e 0 && predicate(value)) {\x0a          if (depth \x3e 1) {\x0a            // Recursively flatten arrays (susceptible to call stack limits).\x0a            baseFlatten(value, depth - 1, predicate, isStrict, result);\x0a          } else {\x0a            arrayPush(result, value);\x0a          }\x0a        } else if (!isStrict) {\x0a          result[result.length] = value;\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `baseForOwn` which iterates over `object`\x0a     * properties returned by `keysFunc` and invokes `iteratee` for each property.\x0a     * Iteratee functions may exit iteration early by explicitly returning `false`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to iterate over.\x0a     * @param {Function} iteratee The function invoked per iteration.\x0a     * @param {Function} keysFunc The function to get the keys of `object`.\x0a     * @returns {Object} Returns `object`.\x0a     */\x0a    var baseFor = createBaseFor();\x0a\x0a    /**\x0a     * This function is like `baseFor` except that it iterates over properties\x0a     * in the opposite order.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to iterate over.\x0a     * @param {Function} iteratee The function invoked per iteration.\x0a     * @param {Function} keysFunc The function to get the keys of `object`.\x0a     * @returns {Object} Returns `object`.\x0a     */\x0a    var baseForRight = createBaseFor(true);\x0a\x0a    /**\x0a     * The base implementation of `_.forOwn` without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to iterate over.\x0a     * @param {Function} iteratee The function invoked per iteration.\x0a     * @returns {Object} Returns `object`.\x0a     */\x0a    function baseForOwn(object, iteratee) {\x0a      return object && baseFor(object, iteratee, keys);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to iterate over.\x0a     * @param {Function} iteratee The function invoked per iteration.\x0a     * @returns {Object} Returns `object`.\x0a     */\x0a    function baseForOwnRight(object, iteratee) {\x0a      return object && baseForRight(object, iteratee, keys);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.functions` which creates an array of\x0a     * `object` function property names filtered from `props`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to inspect.\x0a     * @param {Array} props The property names to filter.\x0a     * @returns {Array} Returns the function names.\x0a     */\x0a    function baseFunctions(object, props) {\x0a      return arrayFilter(props, function(key) {\x0a        return isFunction(object[key]);\x0a      });\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.get` without support for default values.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @param {Array|string} path The path of the property to get.\x0a     * @returns {*} Returns the resolved value.\x0a     */\x0a    function baseGet(object, path) {\x0a      path = castPath(path, object);\x0a\x0a      var index = 0,\x0a          length = path.length;\x0a\x0a      while (object != null && index \x3c length) {\x0a        object = object[toKey(path[index++])];\x0a      }\x0a      return (index && index == length) ? object : undefined;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\x0a     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\x0a     * symbols of `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @param {Function} keysFunc The function to get the keys of `object`.\x0a     * @param {Function} symbolsFunc The function to get the symbols of `object`.\x0a     * @returns {Array} Returns the array of property names and symbols.\x0a     */\x0a    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\x0a      var result = keysFunc(object);\x0a      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `getTag` without fallbacks for buggy environments.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to query.\x0a     * @returns {string} Returns the `toStringTag`.\x0a     */\x0a    function baseGetTag(value) {\x0a      if (value == null) {\x0a        return value === undefined ? undefinedTag : nullTag;\x0a      }\x0a      return (symToStringTag && symToStringTag in Object(value))\x0a        ? getRawTag(value)\x0a        : objectToString(value);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.gt` which doesn\x27t coerce arguments.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to compare.\x0a     * @param {*} other The other value to compare.\x0a     * @returns {boolean} Returns `true` if `value` is greater than `other`,\x0a     *  else `false`.\x0a     */\x0a    function baseGt(value, other) {\x0a      return value \x3e other;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.has` without support for deep paths.\x0a     *\x0a     * @private\x0a     * @param {Object} [object] The object to query.\x0a     * @param {Array|string} key The key to check.\x0a     * @returns {boolean} Returns `true` if `key` exists, else `false`.\x0a     */\x0a    function baseHas(object, key) {\x0a      return object != null && hasOwnProperty.call(object, key);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.hasIn` without support for deep paths.\x0a     *\x0a     * @private\x0a     * @param {Object} [object] The object to query.\x0a     * @param {Array|string} key The key to check.\x0a     * @returns {boolean} Returns `true` if `key` exists, else `false`.\x0a     */\x0a    function baseHasIn(object, key) {\x0a      return object != null && key in Object(object);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.inRange` which doesn\x27t coerce arguments.\x0a     *\x0a     * @private\x0a     * @param {number} number The number to check.\x0a     * @param {number} start The start of the range.\x0a     * @param {number} end The end of the range.\x0a     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\x0a     */\x0a    function baseInRange(number, start, end) {\x0a      return number \x3e= nativeMin(start, end) && number \x3c nativeMax(start, end);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of methods like `_.intersection`, without support\x0a     * for iteratee shorthands, that accepts an array of arrays to inspect.\x0a     *\x0a     * @private\x0a     * @param {Array} arrays The arrays to inspect.\x0a     * @param {Function} [iteratee] The iteratee invoked per element.\x0a     * @param {Function} [comparator] The comparator invoked per element.\x0a     * @returns {Array} Returns the new array of shared values.\x0a     */\x0a    function baseIntersection(arrays, iteratee, comparator) {\x0a      var includes = comparator ? arrayIncludesWith : arrayIncludes,\x0a          length = arrays[0].length,\x0a          othLength = arrays.length,\x0a          othIndex = othLength,\x0a          caches = Array(othLength),\x0a          maxLength = Infinity,\x0a          result = [];\x0a\x0a      while (othIndex--) {\x0a        var array = arrays[othIndex];\x0a        if (othIndex && iteratee) {\x0a          array = arrayMap(array, baseUnary(iteratee));\x0a        }\x0a        maxLength = nativeMin(array.length, maxLength);\x0a        caches[othIndex] = !comparator && (iteratee || (length \x3e= 120 && array.length \x3e= 120))\x0a          ? new SetCache(othIndex && array)\x0a          : undefined;\x0a      }\x0a      array = arrays[0];\x0a\x0a      var index = -1,\x0a          seen = caches[0];\x0a\x0a      outer:\x0a      while (++index \x3c length && result.length \x3c maxLength) {\x0a        var value = array[index],\x0a            computed = iteratee ? iteratee(value) : value;\x0a\x0a        value = (comparator || value !== 0) ? value : 0;\x0a        if (!(seen\x0a              ? cacheHas(seen, computed)\x0a              : includes(result, computed, comparator)\x0a            )) {\x0a          othIndex = othLength;\x0a          while (--othIndex) {\x0a            var cache = caches[othIndex];\x0a            if (!(cache\x0a                  ? cacheHas(cache, computed)\x0a                  : includes(arrays[othIndex], computed, comparator))\x0a                ) {\x0a              continue outer;\x0a            }\x0a          }\x0a          if (seen) {\x0a            seen.push(computed);\x0a          }\x0a          result.push(value);\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.invert` and `_.invertBy` which inverts\x0a     * `object` with values transformed by `iteratee` and set by `setter`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to iterate over.\x0a     * @param {Function} setter The function to set `accumulator` values.\x0a     * @param {Function} iteratee The iteratee to transform values.\x0a     * @param {Object} accumulator The initial inverted object.\x0a     * @returns {Function} Returns `accumulator`.\x0a     */\x0a    function baseInverter(object, setter, iteratee, accumulator) {\x0a      baseForOwn(object, function(value, key, object) {\x0a        setter(accumulator, iteratee(value), key, object);\x0a      });\x0a      return accumulator;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.invoke` without support for individual\x0a     * method arguments.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @param {Array|string} path The path of the method to invoke.\x0a     * @param {Array} args The arguments to invoke the method with.\x0a     * @returns {*} Returns the result of the invoked method.\x0a     */\x0a    function baseInvoke(object, path, args) {\x0a      path = castPath(path, object);\x0a      object = parent(object, path);\x0a      var func = object == null ? object : object[toKey(last(path))];\x0a      return func == null ? undefined : apply(func, object, args);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.isArguments`.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\x0a     */\x0a    function baseIsArguments(value) {\x0a      return isObjectLike(value) && baseGetTag(value) == argsTag;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\x0a     */\x0a    function baseIsArrayBuffer(value) {\x0a      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.isDate` without Node.js optimizations.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\x0a     */\x0a    function baseIsDate(value) {\x0a      return isObjectLike(value) && baseGetTag(value) == dateTag;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.isEqual` which supports partial comparisons\x0a     * and tracks traversed objects.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to compare.\x0a     * @param {*} other The other value to compare.\x0a     * @param {boolean} bitmask The bitmask flags.\x0a     *  1 - Unordered comparison\x0a     *  2 - Partial comparison\x0a     * @param {Function} [customizer] The function to customize comparisons.\x0a     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\x0a     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\x0a     */\x0a    function baseIsEqual(value, other, bitmask, customizer, stack) {\x0a      if (value === other) {\x0a        return true;\x0a      }\x0a      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\x0a        return value !== value && other !== other;\x0a      }\x0a      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `baseIsEqual` for arrays and objects which performs\x0a     * deep comparisons and tracks traversed objects enabling objects with circular\x0a     * references to be compared.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to compare.\x0a     * @param {Object} other The other object to compare.\x0a     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\x0a     * @param {Function} customizer The function to customize comparisons.\x0a     * @param {Function} equalFunc The function to determine equivalents of values.\x0a     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\x0a     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\x0a     */\x0a    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\x0a      var objIsArr = isArray(object),\x0a          othIsArr = isArray(other),\x0a          objTag = objIsArr ? arrayTag : getTag(object),\x0a          othTag = othIsArr ? arrayTag : getTag(other);\x0a\x0a      objTag = objTag == argsTag ? objectTag : objTag;\x0a      othTag = othTag == argsTag ? objectTag : othTag;\x0a\x0a      var objIsObj = objTag == objectTag,\x0a          othIsObj = othTag == objectTag,\x0a          isSameTag = objTag == othTag;\x0a\x0a      if (isSameTag && isBuffer(object)) {\x0a        if (!isBuffer(other)) {\x0a          return false;\x0a        }\x0a        objIsArr = true;\x0a        objIsObj = false;\x0a      }\x0a      if (isSameTag && !objIsObj) {\x0a        stack || (stack = new Stack);\x0a        return (objIsArr || isTypedArray(object))\x0a          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\x0a          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\x0a      }\x0a      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\x0a        var objIsWrapped = objIsObj && hasOwnProperty.call(object, \x27__wrapped__\x27),\x0a            othIsWrapped = othIsObj && hasOwnProperty.call(other, \x27__wrapped__\x27);\x0a\x0a        if (objIsWrapped || othIsWrapped) {\x0a          var objUnwrapped = objIsWrapped ? object.value() : object,\x0a              othUnwrapped = othIsWrapped ? other.value() : other;\x0a\x0a          stack || (stack = new Stack);\x0a          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\x0a        }\x0a      }\x0a      if (!isSameTag) {\x0a        return false;\x0a      }\x0a      stack || (stack = new Stack);\x0a      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.isMap` without Node.js optimizations.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\x0a     */\x0a    function baseIsMap(value) {\x0a      return isObjectLike(value) && getTag(value) == mapTag;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.isMatch` without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to inspect.\x0a     * @param {Object} source The object of property values to match.\x0a     * @param {Array} matchData The property names, values, and compare flags to match.\x0a     * @param {Function} [customizer] The function to customize comparisons.\x0a     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\x0a     */\x0a    function baseIsMatch(object, source, matchData, customizer) {\x0a      var index = matchData.length,\x0a          length = index,\x0a          noCustomizer = !customizer;\x0a\x0a      if (object == null) {\x0a        return !length;\x0a      }\x0a      object = Object(object);\x0a      while (index--) {\x0a        var data = matchData[index];\x0a        if ((noCustomizer && data[2])\x0a              ? data[1] !== object[data[0]]\x0a              : !(data[0] in object)\x0a            ) {\x0a          return false;\x0a        }\x0a      }\x0a      while (++index \x3c length) {\x0a        data = matchData[index];\x0a        var key = data[0],\x0a            objValue = object[key],\x0a            srcValue = data[1];\x0a\x0a        if (noCustomizer && data[2]) {\x0a          if (objValue === undefined && !(key in object)) {\x0a            return false;\x0a          }\x0a        } else {\x0a          var stack = new Stack;\x0a          if (customizer) {\x0a            var result = customizer(objValue, srcValue, key, object, source, stack);\x0a          }\x0a          if (!(result === undefined\x0a                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\x0a                : result\x0a              )) {\x0a            return false;\x0a          }\x0a        }\x0a      }\x0a      return true;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.isNative` without bad shim checks.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a native function,\x0a     *  else `false`.\x0a     */\x0a    function baseIsNative(value) {\x0a      if (!isObject(value) || isMasked(value)) {\x0a        return false;\x0a      }\x0a      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\x0a      return pattern.test(toSource(value));\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.isRegExp` without Node.js optimizations.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\x0a     */\x0a    function baseIsRegExp(value) {\x0a      return isObjectLike(value) && baseGetTag(value) == regexpTag;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.isSet` without Node.js optimizations.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\x0a     */\x0a    function baseIsSet(value) {\x0a      return isObjectLike(value) && getTag(value) == setTag;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.isTypedArray` without Node.js optimizations.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\x0a     */\x0a    function baseIsTypedArray(value) {\x0a      return isObjectLike(value) &&\x0a        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.iteratee`.\x0a     *\x0a     * @private\x0a     * @param {*} [value=_.identity] The value to convert to an iteratee.\x0a     * @returns {Function} Returns the iteratee.\x0a     */\x0a    function baseIteratee(value) {\x0a      // Don\x27t store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\x0a      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\x0a      if (typeof value == \x27function\x27) {\x0a        return value;\x0a      }\x0a      if (value == null) {\x0a        return identity;\x0a      }\x0a      if (typeof value == \x27object\x27) {\x0a        return isArray(value)\x0a          ? baseMatchesProperty(value[0], value[1])\x0a          : baseMatches(value);\x0a      }\x0a      return property(value);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.keys` which doesn\x27t treat sparse arrays as dense.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @returns {Array} Returns the array of property names.\x0a     */\x0a    function baseKeys(object) {\x0a      if (!isPrototype(object)) {\x0a        return nativeKeys(object);\x0a      }\x0a      var result = [];\x0a      for (var key in Object(object)) {\x0a        if (hasOwnProperty.call(object, key) && key != \x27constructor\x27) {\x0a          result.push(key);\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.keysIn` which doesn\x27t treat sparse arrays as dense.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @returns {Array} Returns the array of property names.\x0a     */\x0a    function baseKeysIn(object) {\x0a      if (!isObject(object)) {\x0a        return nativeKeysIn(object);\x0a      }\x0a      var isProto = isPrototype(object),\x0a          result = [];\x0a\x0a      for (var key in object) {\x0a        if (!(key == \x27constructor\x27 && (isProto || !hasOwnProperty.call(object, key)))) {\x0a          result.push(key);\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.lt` which doesn\x27t coerce arguments.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to compare.\x0a     * @param {*} other The other value to compare.\x0a     * @returns {boolean} Returns `true` if `value` is less than `other`,\x0a     *  else `false`.\x0a     */\x0a    function baseLt(value, other) {\x0a      return value \x3c other;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.map` without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} iteratee The function invoked per iteration.\x0a     * @returns {Array} Returns the new mapped array.\x0a     */\x0a    function baseMap(collection, iteratee) {\x0a      var index = -1,\x0a          result = isArrayLike(collection) ? Array(collection.length) : [];\x0a\x0a      baseEach(collection, function(value, key, collection) {\x0a        result[++index] = iteratee(value, key, collection);\x0a      });\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.matches` which doesn\x27t clone `source`.\x0a     *\x0a     * @private\x0a     * @param {Object} source The object of property values to match.\x0a     * @returns {Function} Returns the new spec function.\x0a     */\x0a    function baseMatches(source) {\x0a      var matchData = getMatchData(source);\x0a      if (matchData.length == 1 && matchData[0][2]) {\x0a        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\x0a      }\x0a      return function(object) {\x0a        return object === source || baseIsMatch(object, source, matchData);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.matchesProperty` which doesn\x27t clone `srcValue`.\x0a     *\x0a     * @private\x0a     * @param {string} path The path of the property to get.\x0a     * @param {*} srcValue The value to match.\x0a     * @returns {Function} Returns the new spec function.\x0a     */\x0a    function baseMatchesProperty(path, srcValue) {\x0a      if (isKey(path) && isStrictComparable(srcValue)) {\x0a        return matchesStrictComparable(toKey(path), srcValue);\x0a      }\x0a      return function(object) {\x0a        var objValue = get(object, path);\x0a        return (objValue === undefined && objValue === srcValue)\x0a          ? hasIn(object, path)\x0a          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.merge` without support for multiple sources.\x0a     *\x0a     * @private\x0a     * @param {Object} object The destination object.\x0a     * @param {Object} source The source object.\x0a     * @param {number} srcIndex The index of `source`.\x0a     * @param {Function} [customizer] The function to customize merged values.\x0a     * @param {Object} [stack] Tracks traversed source values and their merged\x0a     *  counterparts.\x0a     */\x0a    function baseMerge(object, source, srcIndex, customizer, stack) {\x0a      if (object === source) {\x0a        return;\x0a      }\x0a      baseFor(source, function(srcValue, key) {\x0a        if (isObject(srcValue)) {\x0a          stack || (stack = new Stack);\x0a          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\x0a        }\x0a        else {\x0a          var newValue = customizer\x0a            ? customizer(safeGet(object, key), srcValue, (key + \x27\x27), object, source, stack)\x0a            : undefined;\x0a\x0a          if (newValue === undefined) {\x0a            newValue = srcValue;\x0a          }\x0a          assignMergeValue(object, key, newValue);\x0a        }\x0a      }, keysIn);\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `baseMerge` for arrays and objects which performs\x0a     * deep merges and tracks traversed objects enabling objects with circular\x0a     * references to be merged.\x0a     *\x0a     * @private\x0a     * @param {Object} object The destination object.\x0a     * @param {Object} source The source object.\x0a     * @param {string} key The key of the value to merge.\x0a     * @param {number} srcIndex The index of `source`.\x0a     * @param {Function} mergeFunc The function to merge values.\x0a     * @param {Function} [customizer] The function to customize assigned values.\x0a     * @param {Object} [stack] Tracks traversed source values and their merged\x0a     *  counterparts.\x0a     */\x0a    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\x0a      var objValue = safeGet(object, key),\x0a          srcValue = safeGet(source, key),\x0a          stacked = stack.get(srcValue);\x0a\x0a      if (stacked) {\x0a        assignMergeValue(object, key, stacked);\x0a        return;\x0a      }\x0a      var newValue = customizer\x0a        ? customizer(objValue, srcValue, (key + \x27\x27), object, source, stack)\x0a        : undefined;\x0a\x0a      var isCommon = newValue === undefined;\x0a\x0a      if (isCommon) {\x0a        var isArr = isArray(srcValue),\x0a            isBuff = !isArr && isBuffer(srcValue),\x0a            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\x0a\x0a        newValue = srcValue;\x0a        if (isArr || isBuff || isTyped) {\x0a          if (isArray(objValue)) {\x0a            newValue = objValue;\x0a          }\x0a          else if (isArrayLikeObject(objValue)) {\x0a            newValue = copyArray(objValue);\x0a          }\x0a          else if (isBuff) {\x0a            isCommon = false;\x0a            newValue = cloneBuffer(srcValue, true);\x0a          }\x0a          else if (isTyped) {\x0a            isCommon = false;\x0a            newValue = cloneTypedArray(srcValue, true);\x0a          }\x0a          else {\x0a            newValue = [];\x0a          }\x0a        }\x0a        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\x0a          newValue = objValue;\x0a          if (isArguments(objValue)) {\x0a            newValue = toPlainObject(objValue);\x0a          }\x0a          else if (!isObject(objValue) || isFunction(objValue)) {\x0a            newValue = initCloneObject(srcValue);\x0a          }\x0a        }\x0a        else {\x0a          isCommon = false;\x0a        }\x0a      }\x0a      if (isCommon) {\x0a        // Recursively merge objects and arrays (susceptible to call stack limits).\x0a        stack.set(srcValue, newValue);\x0a        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\x0a        stack[\x27delete\x27](srcValue);\x0a      }\x0a      assignMergeValue(object, key, newValue);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.nth` which doesn\x27t coerce arguments.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to query.\x0a     * @param {number} n The index of the element to return.\x0a     * @returns {*} Returns the nth element of `array`.\x0a     */\x0a    function baseNth(array, n) {\x0a      var length = array.length;\x0a      if (!length) {\x0a        return;\x0a      }\x0a      n += n \x3c 0 ? length : 0;\x0a      return isIndex(n, length) ? array[n] : undefined;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.orderBy` without param guards.\x0a     *\x0a     * @private\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\x0a     * @param {string[]} orders The sort orders of `iteratees`.\x0a     * @returns {Array} Returns the new sorted array.\x0a     */\x0a    function baseOrderBy(collection, iteratees, orders) {\x0a      var index = -1;\x0a      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));\x0a\x0a      var result = baseMap(collection, function(value, key, collection) {\x0a        var criteria = arrayMap(iteratees, function(iteratee) {\x0a          return iteratee(value);\x0a        });\x0a        return { \x27criteria\x27: criteria, \x27index\x27: ++index, \x27value\x27: value };\x0a      });\x0a\x0a      return baseSortBy(result, function(object, other) {\x0a        return compareMultiple(object, other, orders);\x0a      });\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.pick` without support for individual\x0a     * property identifiers.\x0a     *\x0a     * @private\x0a     * @param {Object} object The source object.\x0a     * @param {string[]} paths The property paths to pick.\x0a     * @returns {Object} Returns the new object.\x0a     */\x0a    function basePick(object, paths) {\x0a      return basePickBy(object, paths, function(value, path) {\x0a        return hasIn(object, path);\x0a      });\x0a    }\x0a\x0a    /**\x0a     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Object} object The source object.\x0a     * @param {string[]} paths The property paths to pick.\x0a     * @param {Function} predicate The function invoked per property.\x0a     * @returns {Object} Returns the new object.\x0a     */\x0a    function basePickBy(object, paths, predicate) {\x0a      var index = -1,\x0a          length = paths.length,\x0a          result = {};\x0a\x0a      while (++index \x3c length) {\x0a        var path = paths[index],\x0a            value = baseGet(object, path);\x0a\x0a        if (predicate(value, path)) {\x0a          baseSet(result, castPath(path, object), value);\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `baseProperty` which supports deep paths.\x0a     *\x0a     * @private\x0a     * @param {Array|string} path The path of the property to get.\x0a     * @returns {Function} Returns the new accessor function.\x0a     */\x0a    function basePropertyDeep(path) {\x0a      return function(object) {\x0a        return baseGet(object, path);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.pullAllBy` without support for iteratee\x0a     * shorthands.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to modify.\x0a     * @param {Array} values The values to remove.\x0a     * @param {Function} [iteratee] The iteratee invoked per element.\x0a     * @param {Function} [comparator] The comparator invoked per element.\x0a     * @returns {Array} Returns `array`.\x0a     */\x0a    function basePullAll(array, values, iteratee, comparator) {\x0a      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\x0a          index = -1,\x0a          length = values.length,\x0a          seen = array;\x0a\x0a      if (array === values) {\x0a        values = copyArray(values);\x0a      }\x0a      if (iteratee) {\x0a        seen = arrayMap(array, baseUnary(iteratee));\x0a      }\x0a      while (++index \x3c length) {\x0a        var fromIndex = 0,\x0a            value = values[index],\x0a            computed = iteratee ? iteratee(value) : value;\x0a\x0a        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) \x3e -1) {\x0a          if (seen !== array) {\x0a            splice.call(seen, fromIndex, 1);\x0a          }\x0a          splice.call(array, fromIndex, 1);\x0a        }\x0a      }\x0a      return array;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.pullAt` without support for individual\x0a     * indexes or capturing the removed elements.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to modify.\x0a     * @param {number[]} indexes The indexes of elements to remove.\x0a     * @returns {Array} Returns `array`.\x0a     */\x0a    function basePullAt(array, indexes) {\x0a      var length = array ? indexes.length : 0,\x0a          lastIndex = length - 1;\x0a\x0a      while (length--) {\x0a        var index = indexes[length];\x0a        if (length == lastIndex || index !== previous) {\x0a          var previous = index;\x0a          if (isIndex(index)) {\x0a            splice.call(array, index, 1);\x0a          } else {\x0a            baseUnset(array, index);\x0a          }\x0a        }\x0a      }\x0a      return array;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.random` without support for returning\x0a     * floating-point numbers.\x0a     *\x0a     * @private\x0a     * @param {number} lower The lower bound.\x0a     * @param {number} upper The upper bound.\x0a     * @returns {number} Returns the random number.\x0a     */\x0a    function baseRandom(lower, upper) {\x0a      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.range` and `_.rangeRight` which doesn\x27t\x0a     * coerce arguments.\x0a     *\x0a     * @private\x0a     * @param {number} start The start of the range.\x0a     * @param {number} end The end of the range.\x0a     * @param {number} step The value to increment or decrement by.\x0a     * @param {boolean} [fromRight] Specify iterating from right to left.\x0a     * @returns {Array} Returns the range of numbers.\x0a     */\x0a    function baseRange(start, end, step, fromRight) {\x0a      var index = -1,\x0a          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\x0a          result = Array(length);\x0a\x0a      while (length--) {\x0a        result[fromRight ? length : ++index] = start;\x0a        start += step;\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.repeat` which doesn\x27t coerce arguments.\x0a     *\x0a     * @private\x0a     * @param {string} string The string to repeat.\x0a     * @param {number} n The number of times to repeat the string.\x0a     * @returns {string} Returns the repeated string.\x0a     */\x0a    function baseRepeat(string, n) {\x0a      var result = \x27\x27;\x0a      if (!string || n \x3c 1 || n \x3e MAX_SAFE_INTEGER) {\x0a        return result;\x0a      }\x0a      // Leverage the exponentiation by squaring algorithm for a faster repeat.\x0a      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\x0a      do {\x0a        if (n % 2) {\x0a          result += string;\x0a        }\x0a        n = nativeFloor(n / 2);\x0a        if (n) {\x0a          string += string;\x0a        }\x0a      } while (n);\x0a\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.rest` which doesn\x27t validate or coerce arguments.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to apply a rest parameter to.\x0a     * @param {number} [start=func.length-1] The start position of the rest parameter.\x0a     * @returns {Function} Returns the new function.\x0a     */\x0a    function baseRest(func, start) {\x0a      return setToString(overRest(func, start, identity), func + \x27\x27);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.sample`.\x0a     *\x0a     * @private\x0a     * @param {Array|Object} collection The collection to sample.\x0a     * @returns {*} Returns the random element.\x0a     */\x0a    function baseSample(collection) {\x0a      return arraySample(values(collection));\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.sampleSize` without param guards.\x0a     *\x0a     * @private\x0a     * @param {Array|Object} collection The collection to sample.\x0a     * @param {number} n The number of elements to sample.\x0a     * @returns {Array} Returns the random elements.\x0a     */\x0a    function baseSampleSize(collection, n) {\x0a      var array = values(collection);\x0a      return shuffleSelf(array, baseClamp(n, 0, array.length));\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.set`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to modify.\x0a     * @param {Array|string} path The path of the property to set.\x0a     * @param {*} value The value to set.\x0a     * @param {Function} [customizer] The function to customize path creation.\x0a     * @returns {Object} Returns `object`.\x0a     */\x0a    function baseSet(object, path, value, customizer) {\x0a      if (!isObject(object)) {\x0a        return object;\x0a      }\x0a      path = castPath(path, object);\x0a\x0a      var index = -1,\x0a          length = path.length,\x0a          lastIndex = length - 1,\x0a          nested = object;\x0a\x0a      while (nested != null && ++index \x3c length) {\x0a        var key = toKey(path[index]),\x0a            newValue = value;\x0a\x0a        if (index != lastIndex) {\x0a          var objValue = nested[key];\x0a          newValue = customizer ? customizer(objValue, key, nested) : undefined;\x0a          if (newValue === undefined) {\x0a            newValue = isObject(objValue)\x0a              ? objValue\x0a              : (isIndex(path[index + 1]) ? [] : {});\x0a          }\x0a        }\x0a        assignValue(nested, key, newValue);\x0a        nested = nested[key];\x0a      }\x0a      return object;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `setData` without support for hot loop shorting.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to associate metadata with.\x0a     * @param {*} data The metadata.\x0a     * @returns {Function} Returns `func`.\x0a     */\x0a    var baseSetData = !metaMap ? identity : function(func, data) {\x0a      metaMap.set(func, data);\x0a      return func;\x0a    };\x0a\x0a    /**\x0a     * The base implementation of `setToString` without support for hot loop shorting.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to modify.\x0a     * @param {Function} string The `toString` result.\x0a     * @returns {Function} Returns `func`.\x0a     */\x0a    var baseSetToString = !defineProperty ? identity : function(func, string) {\x0a      return defineProperty(func, \x27toString\x27, {\x0a        \x27configurable\x27: true,\x0a        \x27enumerable\x27: false,\x0a        \x27value\x27: constant(string),\x0a        \x27writable\x27: true\x0a      });\x0a    };\x0a\x0a    /**\x0a     * The base implementation of `_.shuffle`.\x0a     *\x0a     * @private\x0a     * @param {Array|Object} collection The collection to shuffle.\x0a     * @returns {Array} Returns the new shuffled array.\x0a     */\x0a    function baseShuffle(collection) {\x0a      return shuffleSelf(values(collection));\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.slice` without an iteratee call guard.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to slice.\x0a     * @param {number} [start=0] The start position.\x0a     * @param {number} [end=array.length] The end position.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     */\x0a    function baseSlice(array, start, end) {\x0a      var index = -1,\x0a          length = array.length;\x0a\x0a      if (start \x3c 0) {\x0a        start = -start \x3e length ? 0 : (length + start);\x0a      }\x0a      end = end \x3e length ? length : end;\x0a      if (end \x3c 0) {\x0a        end += length;\x0a      }\x0a      length = start \x3e end ? 0 : ((end - start) \x3e\x3e\x3e 0);\x0a      start \x3e\x3e\x3e= 0;\x0a\x0a      var result = Array(length);\x0a      while (++index \x3c length) {\x0a        result[index] = array[index + start];\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.some` without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} predicate The function invoked per iteration.\x0a     * @returns {boolean} Returns `true` if any element passes the predicate check,\x0a     *  else `false`.\x0a     */\x0a    function baseSome(collection, predicate) {\x0a      var result;\x0a\x0a      baseEach(collection, function(value, index, collection) {\x0a        result = predicate(value, index, collection);\x0a        return !result;\x0a      });\x0a      return !!result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\x0a     * performs a binary search of `array` to determine the index at which `value`\x0a     * should be inserted into `array` in order to maintain its sort order.\x0a     *\x0a     * @private\x0a     * @param {Array} array The sorted array to inspect.\x0a     * @param {*} value The value to evaluate.\x0a     * @param {boolean} [retHighest] Specify returning the highest qualified index.\x0a     * @returns {number} Returns the index at which `value` should be inserted\x0a     *  into `array`.\x0a     */\x0a    function baseSortedIndex(array, value, retHighest) {\x0a      var low = 0,\x0a          high = array == null ? low : array.length;\x0a\x0a      if (typeof value == \x27number\x27 && value === value && high \x3c= HALF_MAX_ARRAY_LENGTH) {\x0a        while (low \x3c high) {\x0a          var mid = (low + high) \x3e\x3e\x3e 1,\x0a              computed = array[mid];\x0a\x0a          if (computed !== null && !isSymbol(computed) &&\x0a              (retHighest ? (computed \x3c= value) : (computed \x3c value))) {\x0a            low = mid + 1;\x0a          } else {\x0a            high = mid;\x0a          }\x0a        }\x0a        return high;\x0a      }\x0a      return baseSortedIndexBy(array, value, identity, retHighest);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\x0a     * which invokes `iteratee` for `value` and each element of `array` to compute\x0a     * their sort ranking. The iteratee is invoked with one argument; (value).\x0a     *\x0a     * @private\x0a     * @param {Array} array The sorted array to inspect.\x0a     * @param {*} value The value to evaluate.\x0a     * @param {Function} iteratee The iteratee invoked per element.\x0a     * @param {boolean} [retHighest] Specify returning the highest qualified index.\x0a     * @returns {number} Returns the index at which `value` should be inserted\x0a     *  into `array`.\x0a     */\x0a    function baseSortedIndexBy(array, value, iteratee, retHighest) {\x0a      value = iteratee(value);\x0a\x0a      var low = 0,\x0a          high = array == null ? 0 : array.length,\x0a          valIsNaN = value !== value,\x0a          valIsNull = value === null,\x0a          valIsSymbol = isSymbol(value),\x0a          valIsUndefined = value === undefined;\x0a\x0a      while (low \x3c high) {\x0a        var mid = nativeFloor((low + high) / 2),\x0a            computed = iteratee(array[mid]),\x0a            othIsDefined = computed !== undefined,\x0a            othIsNull = computed === null,\x0a            othIsReflexive = computed === computed,\x0a            othIsSymbol = isSymbol(computed);\x0a\x0a        if (valIsNaN) {\x0a          var setLow = retHighest || othIsReflexive;\x0a        } else if (valIsUndefined) {\x0a          setLow = othIsReflexive && (retHighest || othIsDefined);\x0a        } else if (valIsNull) {\x0a          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\x0a        } else if (valIsSymbol) {\x0a          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\x0a        } else if (othIsNull || othIsSymbol) {\x0a          setLow = false;\x0a        } else {\x0a          setLow = retHighest ? (computed \x3c= value) : (computed \x3c value);\x0a        }\x0a        if (setLow) {\x0a          low = mid + 1;\x0a        } else {\x0a          high = mid;\x0a        }\x0a      }\x0a      return nativeMin(high, MAX_ARRAY_INDEX);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\x0a     * support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to inspect.\x0a     * @param {Function} [iteratee] The iteratee invoked per element.\x0a     * @returns {Array} Returns the new duplicate free array.\x0a     */\x0a    function baseSortedUniq(array, iteratee) {\x0a      var index = -1,\x0a          length = array.length,\x0a          resIndex = 0,\x0a          result = [];\x0a\x0a      while (++index \x3c length) {\x0a        var value = array[index],\x0a            computed = iteratee ? iteratee(value) : value;\x0a\x0a        if (!index || !eq(computed, seen)) {\x0a          var seen = computed;\x0a          result[resIndex++] = value === 0 ? 0 : value;\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.toNumber` which doesn\x27t ensure correct\x0a     * conversions of binary, hexadecimal, or octal string values.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to process.\x0a     * @returns {number} Returns the number.\x0a     */\x0a    function baseToNumber(value) {\x0a      if (typeof value == \x27number\x27) {\x0a        return value;\x0a      }\x0a      if (isSymbol(value)) {\x0a        return NAN;\x0a      }\x0a      return +value;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.toString` which doesn\x27t convert nullish\x0a     * values to empty strings.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to process.\x0a     * @returns {string} Returns the string.\x0a     */\x0a    function baseToString(value) {\x0a      // Exit early for strings to avoid a performance hit in some environments.\x0a      if (typeof value == \x27string\x27) {\x0a        return value;\x0a      }\x0a      if (isArray(value)) {\x0a        // Recursively convert values (susceptible to call stack limits).\x0a        return arrayMap(value, baseToString) + \x27\x27;\x0a      }\x0a      if (isSymbol(value)) {\x0a        return symbolToString ? symbolToString.call(value) : \x27\x27;\x0a      }\x0a      var result = (value + \x27\x27);\x0a      return (result == \x270\x27 && (1 / value) == -INFINITY) ? \x27-0\x27 : result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to inspect.\x0a     * @param {Function} [iteratee] The iteratee invoked per element.\x0a     * @param {Function} [comparator] The comparator invoked per element.\x0a     * @returns {Array} Returns the new duplicate free array.\x0a     */\x0a    function baseUniq(array, iteratee, comparator) {\x0a      var index = -1,\x0a          includes = arrayIncludes,\x0a          length = array.length,\x0a          isCommon = true,\x0a          result = [],\x0a          seen = result;\x0a\x0a      if (comparator) {\x0a        isCommon = false;\x0a        includes = arrayIncludesWith;\x0a      }\x0a      else if (length \x3e= LARGE_ARRAY_SIZE) {\x0a        var set = iteratee ? null : createSet(array);\x0a        if (set) {\x0a          return setToArray(set);\x0a        }\x0a        isCommon = false;\x0a        includes = cacheHas;\x0a        seen = new SetCache;\x0a      }\x0a      else {\x0a        seen = iteratee ? [] : result;\x0a      }\x0a      outer:\x0a      while (++index \x3c length) {\x0a        var value = array[index],\x0a            computed = iteratee ? iteratee(value) : value;\x0a\x0a        value = (comparator || value !== 0) ? value : 0;\x0a        if (isCommon && computed === computed) {\x0a          var seenIndex = seen.length;\x0a          while (seenIndex--) {\x0a            if (seen[seenIndex] === computed) {\x0a              continue outer;\x0a            }\x0a          }\x0a          if (iteratee) {\x0a            seen.push(computed);\x0a          }\x0a          result.push(value);\x0a        }\x0a        else if (!includes(seen, computed, comparator)) {\x0a          if (seen !== result) {\x0a            seen.push(computed);\x0a          }\x0a          result.push(value);\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.unset`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to modify.\x0a     * @param {Array|string} path The property path to unset.\x0a     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\x0a     */\x0a    function baseUnset(object, path) {\x0a      path = castPath(path, object);\x0a      object = parent(object, path);\x0a      return object == null || delete object[toKey(last(path))];\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `_.update`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to modify.\x0a     * @param {Array|string} path The path of the property to update.\x0a     * @param {Function} updater The function to produce the updated value.\x0a     * @param {Function} [customizer] The function to customize path creation.\x0a     * @returns {Object} Returns `object`.\x0a     */\x0a    function baseUpdate(object, path, updater, customizer) {\x0a      return baseSet(object, path, updater(baseGet(object, path)), customizer);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\x0a     * without support for iteratee shorthands.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to query.\x0a     * @param {Function} predicate The function invoked per iteration.\x0a     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\x0a     * @param {boolean} [fromRight] Specify iterating from right to left.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     */\x0a    function baseWhile(array, predicate, isDrop, fromRight) {\x0a      var length = array.length,\x0a          index = fromRight ? length : -1;\x0a\x0a      while ((fromRight ? index-- : ++index \x3c length) &&\x0a        predicate(array[index], index, array)) {}\x0a\x0a      return isDrop\x0a        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\x0a        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\x0a    }\x0a\x0a    /**\x0a     * The base implementation of `wrapperValue` which returns the result of\x0a     * performing a sequence of actions on the unwrapped `value`, where each\x0a     * successive action is supplied the return value of the previous.\x0a     *\x0a     * @private\x0a     * @param {*} value The unwrapped value.\x0a     * @param {Array} actions Actions to perform to resolve the unwrapped value.\x0a     * @returns {*} Returns the resolved value.\x0a     */\x0a    function baseWrapperValue(value, actions) {\x0a      var result = value;\x0a      if (result instanceof LazyWrapper) {\x0a        result = result.value();\x0a      }\x0a      return arrayReduce(actions, function(result, action) {\x0a        return action.func.apply(action.thisArg, arrayPush([result], action.args));\x0a      }, result);\x0a    }\x0a\x0a    /**\x0a     * The base implementation of methods like `_.xor`, without support for\x0a     * iteratee shorthands, that accepts an array of arrays to inspect.\x0a     *\x0a     * @private\x0a     * @param {Array} arrays The arrays to inspect.\x0a     * @param {Function} [iteratee] The iteratee invoked per element.\x0a     * @param {Function} [comparator] The comparator invoked per element.\x0a     * @returns {Array} Returns the new array of values.\x0a     */\x0a    function baseXor(arrays, iteratee, comparator) {\x0a      var length = arrays.length;\x0a      if (length \x3c 2) {\x0a        return length ? baseUniq(arrays[0]) : [];\x0a      }\x0a      var index = -1,\x0a          result = Array(length);\x0a\x0a      while (++index \x3c length) {\x0a        var array = arrays[index],\x0a            othIndex = -1;\x0a\x0a        while (++othIndex \x3c length) {\x0a          if (othIndex != index) {\x0a            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\x0a          }\x0a        }\x0a      }\x0a      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\x0a    }\x0a\x0a    /**\x0a     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\x0a     *\x0a     * @private\x0a     * @param {Array} props The property identifiers.\x0a     * @param {Array} values The property values.\x0a     * @param {Function} assignFunc The function to assign values.\x0a     * @returns {Object} Returns the new object.\x0a     */\x0a    function baseZipObject(props, values, assignFunc) {\x0a      var index = -1,\x0a          length = props.length,\x0a          valsLength = values.length,\x0a          result = {};\x0a\x0a      while (++index \x3c length) {\x0a        var value = index \x3c valsLength ? values[index] : undefined;\x0a        assignFunc(result, props[index], value);\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Casts `value` to an empty array if it\x27s not an array like object.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to inspect.\x0a     * @returns {Array|Object} Returns the cast array-like object.\x0a     */\x0a    function castArrayLikeObject(value) {\x0a      return isArrayLikeObject(value) ? value : [];\x0a    }\x0a\x0a    /**\x0a     * Casts `value` to `identity` if it\x27s not a function.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to inspect.\x0a     * @returns {Function} Returns cast function.\x0a     */\x0a    function castFunction(value) {\x0a      return typeof value == \x27function\x27 ? value : identity;\x0a    }\x0a\x0a    /**\x0a     * Casts `value` to a path array if it\x27s not one.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to inspect.\x0a     * @param {Object} [object] The object to query keys on.\x0a     * @returns {Array} Returns the cast property path array.\x0a     */\x0a    function castPath(value, object) {\x0a      if (isArray(value)) {\x0a        return value;\x0a      }\x0a      return isKey(value, object) ? [value] : stringToPath(toString(value));\x0a    }\x0a\x0a    /**\x0a     * A `baseRest` alias which can be replaced with `identity` by module\x0a     * replacement plugins.\x0a     *\x0a     * @private\x0a     * @type {Function}\x0a     * @param {Function} func The function to apply a rest parameter to.\x0a     * @returns {Function} Returns the new function.\x0a     */\x0a    var castRest = baseRest;\x0a\x0a    /**\x0a     * Casts `array` to a slice if it\x27s needed.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to inspect.\x0a     * @param {number} start The start position.\x0a     * @param {number} [end=array.length] The end position.\x0a     * @returns {Array} Returns the cast slice.\x0a     */\x0a    function castSlice(array, start, end) {\x0a      var length = array.length;\x0a      end = end === undefined ? length : end;\x0a      return (!start && end \x3e= length) ? array : baseSlice(array, start, end);\x0a    }\x0a\x0a    /**\x0a     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\x0a     *\x0a     * @private\x0a     * @param {number|Object} id The timer id or timeout object of the timer to clear.\x0a     */\x0a    var clearTimeout = ctxClearTimeout || function(id) {\x0a      return root.clearTimeout(id);\x0a    };\x0a\x0a    /**\x0a     * Creates a clone of  `buffer`.\x0a     *\x0a     * @private\x0a     * @param {Buffer} buffer The buffer to clone.\x0a     * @param {boolean} [isDeep] Specify a deep clone.\x0a     * @returns {Buffer} Returns the cloned buffer.\x0a     */\x0a    function cloneBuffer(buffer, isDeep) {\x0a      if (isDeep) {\x0a        return buffer.slice();\x0a      }\x0a      var length = buffer.length,\x0a          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\x0a\x0a      buffer.copy(result);\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Creates a clone of `arrayBuffer`.\x0a     *\x0a     * @private\x0a     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\x0a     * @returns {ArrayBuffer} Returns the cloned array buffer.\x0a     */\x0a    function cloneArrayBuffer(arrayBuffer) {\x0a      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\x0a      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Creates a clone of `dataView`.\x0a     *\x0a     * @private\x0a     * @param {Object} dataView The data view to clone.\x0a     * @param {boolean} [isDeep] Specify a deep clone.\x0a     * @returns {Object} Returns the cloned data view.\x0a     */\x0a    function cloneDataView(dataView, isDeep) {\x0a      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\x0a      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\x0a    }\x0a\x0a    /**\x0a     * Creates a clone of `regexp`.\x0a     *\x0a     * @private\x0a     * @param {Object} regexp The regexp to clone.\x0a     * @returns {Object} Returns the cloned regexp.\x0a     */\x0a    function cloneRegExp(regexp) {\x0a      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\x0a      result.lastIndex = regexp.lastIndex;\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Creates a clone of the `symbol` object.\x0a     *\x0a     * @private\x0a     * @param {Object} symbol The symbol object to clone.\x0a     * @returns {Object} Returns the cloned symbol object.\x0a     */\x0a    function cloneSymbol(symbol) {\x0a      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\x0a    }\x0a\x0a    /**\x0a     * Creates a clone of `typedArray`.\x0a     *\x0a     * @private\x0a     * @param {Object} typedArray The typed array to clone.\x0a     * @param {boolean} [isDeep] Specify a deep clone.\x0a     * @returns {Object} Returns the cloned typed array.\x0a     */\x0a    function cloneTypedArray(typedArray, isDeep) {\x0a      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\x0a      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\x0a    }\x0a\x0a    /**\x0a     * Compares values to sort them in ascending order.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to compare.\x0a     * @param {*} other The other value to compare.\x0a     * @returns {number} Returns the sort order indicator for `value`.\x0a     */\x0a    function compareAscending(value, other) {\x0a      if (value !== other) {\x0a        var valIsDefined = value !== undefined,\x0a            valIsNull = value === null,\x0a            valIsReflexive = value === value,\x0a            valIsSymbol = isSymbol(value);\x0a\x0a        var othIsDefined = other !== undefined,\x0a            othIsNull = other === null,\x0a            othIsReflexive = other === other,\x0a            othIsSymbol = isSymbol(other);\x0a\x0a        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value \x3e other) ||\x0a            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\x0a            (valIsNull && othIsDefined && othIsReflexive) ||\x0a            (!valIsDefined && othIsReflexive) ||\x0a            !valIsReflexive) {\x0a          return 1;\x0a        }\x0a        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value \x3c other) ||\x0a            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\x0a            (othIsNull && valIsDefined && valIsReflexive) ||\x0a            (!othIsDefined && valIsReflexive) ||\x0a            !othIsReflexive) {\x0a          return -1;\x0a        }\x0a      }\x0a      return 0;\x0a    }\x0a\x0a    /**\x0a     * Used by `_.orderBy` to compare multiple properties of a value to another\x0a     * and stable sort them.\x0a     *\x0a     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\x0a     * specify an order of \x22desc\x22 for descending or \x22asc\x22 for ascending sort order\x0a     * of corresponding values.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to compare.\x0a     * @param {Object} other The other object to compare.\x0a     * @param {boolean[]|string[]} orders The order to sort by for each property.\x0a     * @returns {number} Returns the sort order indicator for `object`.\x0a     */\x0a    function compareMultiple(object, other, orders) {\x0a      var index = -1,\x0a          objCriteria = object.criteria,\x0a          othCriteria = other.criteria,\x0a          length = objCriteria.length,\x0a          ordersLength = orders.length;\x0a\x0a      while (++index \x3c length) {\x0a        var result = compareAscending(objCriteria[index], othCriteria[index]);\x0a        if (result) {\x0a          if (index \x3e= ordersLength) {\x0a            return result;\x0a          }\x0a          var order = orders[index];\x0a          return result * (order == \x27desc\x27 ? -1 : 1);\x0a        }\x0a      }\x0a      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\x0a      // that causes it, under certain circumstances, to provide the same value for\x0a      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\x0a      // for more details.\x0a      //\x0a      // This also ensures a stable sort in V8 and other engines.\x0a      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\x0a      return object.index - other.index;\x0a    }\x0a\x0a    /**\x0a     * Creates an array that is the composition of partially applied arguments,\x0a     * placeholders, and provided arguments into a single array of arguments.\x0a     *\x0a     * @private\x0a     * @param {Array} args The provided arguments.\x0a     * @param {Array} partials The arguments to prepend to those provided.\x0a     * @param {Array} holders The `partials` placeholder indexes.\x0a     * @params {boolean} [isCurried] Specify composing for a curried function.\x0a     * @returns {Array} Returns the new array of composed arguments.\x0a     */\x0a    function composeArgs(args, partials, holders, isCurried) {\x0a      var argsIndex = -1,\x0a          argsLength = args.length,\x0a          holdersLength = holders.length,\x0a          leftIndex = -1,\x0a          leftLength = partials.length,\x0a          rangeLength = nativeMax(argsLength - holdersLength, 0),\x0a          result = Array(leftLength + rangeLength),\x0a          isUncurried = !isCurried;\x0a\x0a      while (++leftIndex \x3c leftLength) {\x0a        result[leftIndex] = partials[leftIndex];\x0a      }\x0a      while (++argsIndex \x3c holdersLength) {\x0a        if (isUncurried || argsIndex \x3c argsLength) {\x0a          result[holders[argsIndex]] = args[argsIndex];\x0a        }\x0a      }\x0a      while (rangeLength--) {\x0a        result[leftIndex++] = args[argsIndex++];\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * This function is like `composeArgs` except that the arguments composition\x0a     * is tailored for `_.partialRight`.\x0a     *\x0a     * @private\x0a     * @param {Array} args The provided arguments.\x0a     * @param {Array} partials The arguments to append to those provided.\x0a     * @param {Array} holders The `partials` placeholder indexes.\x0a     * @params {boolean} [isCurried] Specify composing for a curried function.\x0a     * @returns {Array} Returns the new array of composed arguments.\x0a     */\x0a    function composeArgsRight(args, partials, holders, isCurried) {\x0a      var argsIndex = -1,\x0a          argsLength = args.length,\x0a          holdersIndex = -1,\x0a          holdersLength = holders.length,\x0a          rightIndex = -1,\x0a          rightLength = partials.length,\x0a          rangeLength = nativeMax(argsLength - holdersLength, 0),\x0a          result = Array(rangeLength + rightLength),\x0a          isUncurried = !isCurried;\x0a\x0a      while (++argsIndex \x3c rangeLength) {\x0a        result[argsIndex] = args[argsIndex];\x0a      }\x0a      var offset = argsIndex;\x0a      while (++rightIndex \x3c rightLength) {\x0a        result[offset + rightIndex] = partials[rightIndex];\x0a      }\x0a      while (++holdersIndex \x3c holdersLength) {\x0a        if (isUncurried || argsIndex \x3c argsLength) {\x0a          result[offset + holders[holdersIndex]] = args[argsIndex++];\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Copies the values of `source` to `array`.\x0a     *\x0a     * @private\x0a     * @param {Array} source The array to copy values from.\x0a     * @param {Array} [array=[]] The array to copy values to.\x0a     * @returns {Array} Returns `array`.\x0a     */\x0a    function copyArray(source, array) {\x0a      var index = -1,\x0a          length = source.length;\x0a\x0a      array || (array = Array(length));\x0a      while (++index \x3c length) {\x0a        array[index] = source[index];\x0a      }\x0a      return array;\x0a    }\x0a\x0a    /**\x0a     * Copies properties of `source` to `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} source The object to copy properties from.\x0a     * @param {Array} props The property identifiers to copy.\x0a     * @param {Object} [object={}] The object to copy properties to.\x0a     * @param {Function} [customizer] The function to customize copied values.\x0a     * @returns {Object} Returns `object`.\x0a     */\x0a    function copyObject(source, props, object, customizer) {\x0a      var isNew = !object;\x0a      object || (object = {});\x0a\x0a      var index = -1,\x0a          length = props.length;\x0a\x0a      while (++index \x3c length) {\x0a        var key = props[index];\x0a\x0a        var newValue = customizer\x0a          ? customizer(object[key], source[key], key, object, source)\x0a          : undefined;\x0a\x0a        if (newValue === undefined) {\x0a          newValue = source[key];\x0a        }\x0a        if (isNew) {\x0a          baseAssignValue(object, key, newValue);\x0a        } else {\x0a          assignValue(object, key, newValue);\x0a        }\x0a      }\x0a      return object;\x0a    }\x0a\x0a    /**\x0a     * Copies own symbols of `source` to `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} source The object to copy symbols from.\x0a     * @param {Object} [object={}] The object to copy symbols to.\x0a     * @returns {Object} Returns `object`.\x0a     */\x0a    function copySymbols(source, object) {\x0a      return copyObject(source, getSymbols(source), object);\x0a    }\x0a\x0a    /**\x0a     * Copies own and inherited symbols of `source` to `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} source The object to copy symbols from.\x0a     * @param {Object} [object={}] The object to copy symbols to.\x0a     * @returns {Object} Returns `object`.\x0a     */\x0a    function copySymbolsIn(source, object) {\x0a      return copyObject(source, getSymbolsIn(source), object);\x0a    }\x0a\x0a    /**\x0a     * Creates a function like `_.groupBy`.\x0a     *\x0a     * @private\x0a     * @param {Function} setter The function to set accumulator values.\x0a     * @param {Function} [initializer] The accumulator object initializer.\x0a     * @returns {Function} Returns the new aggregator function.\x0a     */\x0a    function createAggregator(setter, initializer) {\x0a      return function(collection, iteratee) {\x0a        var func = isArray(collection) ? arrayAggregator : baseAggregator,\x0a            accumulator = initializer ? initializer() : {};\x0a\x0a        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function like `_.assign`.\x0a     *\x0a     * @private\x0a     * @param {Function} assigner The function to assign values.\x0a     * @returns {Function} Returns the new assigner function.\x0a     */\x0a    function createAssigner(assigner) {\x0a      return baseRest(function(object, sources) {\x0a        var index = -1,\x0a            length = sources.length,\x0a            customizer = length \x3e 1 ? sources[length - 1] : undefined,\x0a            guard = length \x3e 2 ? sources[2] : undefined;\x0a\x0a        customizer = (assigner.length \x3e 3 && typeof customizer == \x27function\x27)\x0a          ? (length--, customizer)\x0a          : undefined;\x0a\x0a        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\x0a          customizer = length \x3c 3 ? undefined : customizer;\x0a          length = 1;\x0a        }\x0a        object = Object(object);\x0a        while (++index \x3c length) {\x0a          var source = sources[index];\x0a          if (source) {\x0a            assigner(object, source, index, customizer);\x0a          }\x0a        }\x0a        return object;\x0a      });\x0a    }\x0a\x0a    /**\x0a     * Creates a `baseEach` or `baseEachRight` function.\x0a     *\x0a     * @private\x0a     * @param {Function} eachFunc The function to iterate over a collection.\x0a     * @param {boolean} [fromRight] Specify iterating from right to left.\x0a     * @returns {Function} Returns the new base function.\x0a     */\x0a    function createBaseEach(eachFunc, fromRight) {\x0a      return function(collection, iteratee) {\x0a        if (collection == null) {\x0a          return collection;\x0a        }\x0a        if (!isArrayLike(collection)) {\x0a          return eachFunc(collection, iteratee);\x0a        }\x0a        var length = collection.length,\x0a            index = fromRight ? length : -1,\x0a            iterable = Object(collection);\x0a\x0a        while ((fromRight ? index-- : ++index \x3c length)) {\x0a          if (iteratee(iterable[index], index, iterable) === false) {\x0a            break;\x0a          }\x0a        }\x0a        return collection;\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\x0a     *\x0a     * @private\x0a     * @param {boolean} [fromRight] Specify iterating from right to left.\x0a     * @returns {Function} Returns the new base function.\x0a     */\x0a    function createBaseFor(fromRight) {\x0a      return function(object, iteratee, keysFunc) {\x0a        var index = -1,\x0a            iterable = Object(object),\x0a            props = keysFunc(object),\x0a            length = props.length;\x0a\x0a        while (length--) {\x0a          var key = props[fromRight ? length : ++index];\x0a          if (iteratee(iterable[key], key, iterable) === false) {\x0a            break;\x0a          }\x0a        }\x0a        return object;\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function that wraps `func` to invoke it with the optional `this`\x0a     * binding of `thisArg`.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to wrap.\x0a     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\x0a     * @param {*} [thisArg] The `this` binding of `func`.\x0a     * @returns {Function} Returns the new wrapped function.\x0a     */\x0a    function createBind(func, bitmask, thisArg) {\x0a      var isBind = bitmask & WRAP_BIND_FLAG,\x0a          Ctor = createCtor(func);\x0a\x0a      function wrapper() {\x0a        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\x0a        return fn.apply(isBind ? thisArg : this, arguments);\x0a      }\x0a      return wrapper;\x0a    }\x0a\x0a    /**\x0a     * Creates a function like `_.lowerFirst`.\x0a     *\x0a     * @private\x0a     * @param {string} methodName The name of the `String` case method to use.\x0a     * @returns {Function} Returns the new case function.\x0a     */\x0a    function createCaseFirst(methodName) {\x0a      return function(string) {\x0a        string = toString(string);\x0a\x0a        var strSymbols = hasUnicode(string)\x0a          ? stringToArray(string)\x0a          : undefined;\x0a\x0a        var chr = strSymbols\x0a          ? strSymbols[0]\x0a          : string.charAt(0);\x0a\x0a        var trailing = strSymbols\x0a          ? castSlice(strSymbols, 1).join(\x27\x27)\x0a          : string.slice(1);\x0a\x0a        return chr[methodName]() + trailing;\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function like `_.camelCase`.\x0a     *\x0a     * @private\x0a     * @param {Function} callback The function to combine each word.\x0a     * @returns {Function} Returns the new compounder function.\x0a     */\x0a    function createCompounder(callback) {\x0a      return function(string) {\x0a        return arrayReduce(words(deburr(string).replace(reApos, \x27\x27)), callback, \x27\x27);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function that produces an instance of `Ctor` regardless of\x0a     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\x0a     *\x0a     * @private\x0a     * @param {Function} Ctor The constructor to wrap.\x0a     * @returns {Function} Returns the new wrapped function.\x0a     */\x0a    function createCtor(Ctor) {\x0a      return function() {\x0a        // Use a `switch` statement to work with class constructors. See\x0a        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\x0a        // for more details.\x0a        var args = arguments;\x0a        switch (args.length) {\x0a          case 0: return new Ctor;\x0a          case 1: return new Ctor(args[0]);\x0a          case 2: return new Ctor(args[0], args[1]);\x0a          case 3: return new Ctor(args[0], args[1], args[2]);\x0a          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\x0a          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\x0a          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\x0a          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\x0a        }\x0a        var thisBinding = baseCreate(Ctor.prototype),\x0a            result = Ctor.apply(thisBinding, args);\x0a\x0a        // Mimic the constructor\x27s `return` behavior.\x0a        // See https://es5.github.io/#x13.2.2 for more details.\x0a        return isObject(result) ? result : thisBinding;\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function that wraps `func` to enable currying.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to wrap.\x0a     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\x0a     * @param {number} arity The arity of `func`.\x0a     * @returns {Function} Returns the new wrapped function.\x0a     */\x0a    function createCurry(func, bitmask, arity) {\x0a      var Ctor = createCtor(func);\x0a\x0a      function wrapper() {\x0a        var length = arguments.length,\x0a            args = Array(length),\x0a            index = length,\x0a            placeholder = getHolder(wrapper);\x0a\x0a        while (index--) {\x0a          args[index] = arguments[index];\x0a        }\x0a        var holders = (length \x3c 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\x0a          ? []\x0a          : replaceHolders(args, placeholder);\x0a\x0a        length -= holders.length;\x0a        if (length \x3c arity) {\x0a          return createRecurry(\x0a            func, bitmask, createHybrid, wrapper.placeholder, undefined,\x0a            args, holders, undefined, undefined, arity - length);\x0a        }\x0a        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\x0a        return apply(fn, this, args);\x0a      }\x0a      return wrapper;\x0a    }\x0a\x0a    /**\x0a     * Creates a `_.find` or `_.findLast` function.\x0a     *\x0a     * @private\x0a     * @param {Function} findIndexFunc The function to find the collection index.\x0a     * @returns {Function} Returns the new find function.\x0a     */\x0a    function createFind(findIndexFunc) {\x0a      return function(collection, predicate, fromIndex) {\x0a        var iterable = Object(collection);\x0a        if (!isArrayLike(collection)) {\x0a          var iteratee = getIteratee(predicate, 3);\x0a          collection = keys(collection);\x0a          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\x0a        }\x0a        var index = findIndexFunc(collection, predicate, fromIndex);\x0a        return index \x3e -1 ? iterable[iteratee ? collection[index] : index] : undefined;\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a `_.flow` or `_.flowRight` function.\x0a     *\x0a     * @private\x0a     * @param {boolean} [fromRight] Specify iterating from right to left.\x0a     * @returns {Function} Returns the new flow function.\x0a     */\x0a    function createFlow(fromRight) {\x0a      return flatRest(function(funcs) {\x0a        var length = funcs.length,\x0a            index = length,\x0a            prereq = LodashWrapper.prototype.thru;\x0a\x0a        if (fromRight) {\x0a          funcs.reverse();\x0a        }\x0a        while (index--) {\x0a          var func = funcs[index];\x0a          if (typeof func != \x27function\x27) {\x0a            throw new TypeError(FUNC_ERROR_TEXT);\x0a          }\x0a          if (prereq && !wrapper && getFuncName(func) == \x27wrapper\x27) {\x0a            var wrapper = new LodashWrapper([], true);\x0a          }\x0a        }\x0a        index = wrapper ? index : length;\x0a        while (++index \x3c length) {\x0a          func = funcs[index];\x0a\x0a          var funcName = getFuncName(func),\x0a              data = funcName == \x27wrapper\x27 ? getData(func) : undefined;\x0a\x0a          if (data && isLaziable(data[0]) &&\x0a                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\x0a                !data[4].length && data[9] == 1\x0a              ) {\x0a            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\x0a          } else {\x0a            wrapper = (func.length == 1 && isLaziable(func))\x0a              ? wrapper[funcName]()\x0a              : wrapper.thru(func);\x0a          }\x0a        }\x0a        return function() {\x0a          var args = arguments,\x0a              value = args[0];\x0a\x0a          if (wrapper && args.length == 1 && isArray(value)) {\x0a            return wrapper.plant(value).value();\x0a          }\x0a          var index = 0,\x0a              result = length ? funcs[index].apply(this, args) : value;\x0a\x0a          while (++index \x3c length) {\x0a            result = funcs[index].call(this, result);\x0a          }\x0a          return result;\x0a        };\x0a      });\x0a    }\x0a\x0a    /**\x0a     * Creates a function that wraps `func` to invoke it with optional `this`\x0a     * binding of `thisArg`, partial application, and currying.\x0a     *\x0a     * @private\x0a     * @param {Function|string} func The function or method name to wrap.\x0a     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\x0a     * @param {*} [thisArg] The `this` binding of `func`.\x0a     * @param {Array} [partials] The arguments to prepend to those provided to\x0a     *  the new function.\x0a     * @param {Array} [holders] The `partials` placeholder indexes.\x0a     * @param {Array} [partialsRight] The arguments to append to those provided\x0a     *  to the new function.\x0a     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\x0a     * @param {Array} [argPos] The argument positions of the new function.\x0a     * @param {number} [ary] The arity cap of `func`.\x0a     * @param {number} [arity] The arity of `func`.\x0a     * @returns {Function} Returns the new wrapped function.\x0a     */\x0a    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\x0a      var isAry = bitmask & WRAP_ARY_FLAG,\x0a          isBind = bitmask & WRAP_BIND_FLAG,\x0a          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\x0a          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\x0a          isFlip = bitmask & WRAP_FLIP_FLAG,\x0a          Ctor = isBindKey ? undefined : createCtor(func);\x0a\x0a      function wrapper() {\x0a        var length = arguments.length,\x0a            args = Array(length),\x0a            index = length;\x0a\x0a        while (index--) {\x0a          args[index] = arguments[index];\x0a        }\x0a        if (isCurried) {\x0a          var placeholder = getHolder(wrapper),\x0a              holdersCount = countHolders(args, placeholder);\x0a        }\x0a        if (partials) {\x0a          args = composeArgs(args, partials, holders, isCurried);\x0a        }\x0a        if (partialsRight) {\x0a          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\x0a        }\x0a        length -= holdersCount;\x0a        if (isCurried && length \x3c arity) {\x0a          var newHolders = replaceHolders(args, placeholder);\x0a          return createRecurry(\x0a            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\x0a            args, newHolders, argPos, ary, arity - length\x0a          );\x0a        }\x0a        var thisBinding = isBind ? thisArg : this,\x0a            fn = isBindKey ? thisBinding[func] : func;\x0a\x0a        length = args.length;\x0a        if (argPos) {\x0a          args = reorder(args, argPos);\x0a        } else if (isFlip && length \x3e 1) {\x0a          args.reverse();\x0a        }\x0a        if (isAry && ary \x3c length) {\x0a          args.length = ary;\x0a        }\x0a        if (this && this !== root && this instanceof wrapper) {\x0a          fn = Ctor || createCtor(fn);\x0a        }\x0a        return fn.apply(thisBinding, args);\x0a      }\x0a      return wrapper;\x0a    }\x0a\x0a    /**\x0a     * Creates a function like `_.invertBy`.\x0a     *\x0a     * @private\x0a     * @param {Function} setter The function to set accumulator values.\x0a     * @param {Function} toIteratee The function to resolve iteratees.\x0a     * @returns {Function} Returns the new inverter function.\x0a     */\x0a    function createInverter(setter, toIteratee) {\x0a      return function(object, iteratee) {\x0a        return baseInverter(object, setter, toIteratee(iteratee), {});\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function that performs a mathematical operation on two values.\x0a     *\x0a     * @private\x0a     * @param {Function} operator The function to perform the operation.\x0a     * @param {number} [defaultValue] The value used for `undefined` arguments.\x0a     * @returns {Function} Returns the new mathematical operation function.\x0a     */\x0a    function createMathOperation(operator, defaultValue) {\x0a      return function(value, other) {\x0a        var result;\x0a        if (value === undefined && other === undefined) {\x0a          return defaultValue;\x0a        }\x0a        if (value !== undefined) {\x0a          result = value;\x0a        }\x0a        if (other !== undefined) {\x0a          if (result === undefined) {\x0a            return other;\x0a          }\x0a          if (typeof value == \x27string\x27 || typeof other == \x27string\x27) {\x0a            value = baseToString(value);\x0a            other = baseToString(other);\x0a          } else {\x0a            value = baseToNumber(value);\x0a            other = baseToNumber(other);\x0a          }\x0a          result = operator(value, other);\x0a        }\x0a        return result;\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function like `_.over`.\x0a     *\x0a     * @private\x0a     * @param {Function} arrayFunc The function to iterate over iteratees.\x0a     * @returns {Function} Returns the new over function.\x0a     */\x0a    function createOver(arrayFunc) {\x0a      return flatRest(function(iteratees) {\x0a        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\x0a        return baseRest(function(args) {\x0a          var thisArg = this;\x0a          return arrayFunc(iteratees, function(iteratee) {\x0a            return apply(iteratee, thisArg, args);\x0a          });\x0a        });\x0a      });\x0a    }\x0a\x0a    /**\x0a     * Creates the padding for `string` based on `length`. The `chars` string\x0a     * is truncated if the number of characters exceeds `length`.\x0a     *\x0a     * @private\x0a     * @param {number} length The padding length.\x0a     * @param {string} [chars=\x27 \x27] The string used as padding.\x0a     * @returns {string} Returns the padding for `string`.\x0a     */\x0a    function createPadding(length, chars) {\x0a      chars = chars === undefined ? \x27 \x27 : baseToString(chars);\x0a\x0a      var charsLength = chars.length;\x0a      if (charsLength \x3c 2) {\x0a        return charsLength ? baseRepeat(chars, length) : chars;\x0a      }\x0a      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\x0a      return hasUnicode(chars)\x0a        ? castSlice(stringToArray(result), 0, length).join(\x27\x27)\x0a        : result.slice(0, length);\x0a    }\x0a\x0a    /**\x0a     * Creates a function that wraps `func` to invoke it with the `this` binding\x0a     * of `thisArg` and `partials` prepended to the arguments it receives.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to wrap.\x0a     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\x0a     * @param {*} thisArg The `this` binding of `func`.\x0a     * @param {Array} partials The arguments to prepend to those provided to\x0a     *  the new function.\x0a     * @returns {Function} Returns the new wrapped function.\x0a     */\x0a    function createPartial(func, bitmask, thisArg, partials) {\x0a      var isBind = bitmask & WRAP_BIND_FLAG,\x0a          Ctor = createCtor(func);\x0a\x0a      function wrapper() {\x0a        var argsIndex = -1,\x0a            argsLength = arguments.length,\x0a            leftIndex = -1,\x0a            leftLength = partials.length,\x0a            args = Array(leftLength + argsLength),\x0a            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\x0a\x0a        while (++leftIndex \x3c leftLength) {\x0a          args[leftIndex] = partials[leftIndex];\x0a        }\x0a        while (argsLength--) {\x0a          args[leftIndex++] = arguments[++argsIndex];\x0a        }\x0a        return apply(fn, isBind ? thisArg : this, args);\x0a      }\x0a      return wrapper;\x0a    }\x0a\x0a    /**\x0a     * Creates a `_.range` or `_.rangeRight` function.\x0a     *\x0a     * @private\x0a     * @param {boolean} [fromRight] Specify iterating from right to left.\x0a     * @returns {Function} Returns the new range function.\x0a     */\x0a    function createRange(fromRight) {\x0a      return function(start, end, step) {\x0a        if (step && typeof step != \x27number\x27 && isIterateeCall(start, end, step)) {\x0a          end = step = undefined;\x0a        }\x0a        // Ensure the sign of `-0` is preserved.\x0a        start = toFinite(start);\x0a        if (end === undefined) {\x0a          end = start;\x0a          start = 0;\x0a        } else {\x0a          end = toFinite(end);\x0a        }\x0a        step = step === undefined ? (start \x3c end ? 1 : -1) : toFinite(step);\x0a        return baseRange(start, end, step, fromRight);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function that performs a relational operation on two values.\x0a     *\x0a     * @private\x0a     * @param {Function} operator The function to perform the operation.\x0a     * @returns {Function} Returns the new relational operation function.\x0a     */\x0a    function createRelationalOperation(operator) {\x0a      return function(value, other) {\x0a        if (!(typeof value == \x27string\x27 && typeof other == \x27string\x27)) {\x0a          value = toNumber(value);\x0a          other = toNumber(other);\x0a        }\x0a        return operator(value, other);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function that wraps `func` to continue currying.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to wrap.\x0a     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\x0a     * @param {Function} wrapFunc The function to create the `func` wrapper.\x0a     * @param {*} placeholder The placeholder value.\x0a     * @param {*} [thisArg] The `this` binding of `func`.\x0a     * @param {Array} [partials] The arguments to prepend to those provided to\x0a     *  the new function.\x0a     * @param {Array} [holders] The `partials` placeholder indexes.\x0a     * @param {Array} [argPos] The argument positions of the new function.\x0a     * @param {number} [ary] The arity cap of `func`.\x0a     * @param {number} [arity] The arity of `func`.\x0a     * @returns {Function} Returns the new wrapped function.\x0a     */\x0a    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\x0a      var isCurry = bitmask & WRAP_CURRY_FLAG,\x0a          newHolders = isCurry ? holders : undefined,\x0a          newHoldersRight = isCurry ? undefined : holders,\x0a          newPartials = isCurry ? partials : undefined,\x0a          newPartialsRight = isCurry ? undefined : partials;\x0a\x0a      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\x0a      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\x0a\x0a      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\x0a        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\x0a      }\x0a      var newData = [\x0a        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\x0a        newHoldersRight, argPos, ary, arity\x0a      ];\x0a\x0a      var result = wrapFunc.apply(undefined, newData);\x0a      if (isLaziable(func)) {\x0a        setData(result, newData);\x0a      }\x0a      result.placeholder = placeholder;\x0a      return setWrapToString(result, func, bitmask);\x0a    }\x0a\x0a    /**\x0a     * Creates a function like `_.round`.\x0a     *\x0a     * @private\x0a     * @param {string} methodName The name of the `Math` method to use when rounding.\x0a     * @returns {Function} Returns the new round function.\x0a     */\x0a    function createRound(methodName) {\x0a      var func = Math[methodName];\x0a      return function(number, precision) {\x0a        number = toNumber(number);\x0a        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\x0a        if (precision) {\x0a          // Shift with exponential notation to avoid floating-point issues.\x0a          // See [MDN](https://mdn.io/round#Examples) for more details.\x0a          var pair = (toString(number) + \x27e\x27).split(\x27e\x27),\x0a              value = func(pair[0] + \x27e\x27 + (+pair[1] + precision));\x0a\x0a          pair = (toString(value) + \x27e\x27).split(\x27e\x27);\x0a          return +(pair[0] + \x27e\x27 + (+pair[1] - precision));\x0a        }\x0a        return func(number);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a set object of `values`.\x0a     *\x0a     * @private\x0a     * @param {Array} values The values to add to the set.\x0a     * @returns {Object} Returns the new set.\x0a     */\x0a    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\x0a      return new Set(values);\x0a    };\x0a\x0a    /**\x0a     * Creates a `_.toPairs` or `_.toPairsIn` function.\x0a     *\x0a     * @private\x0a     * @param {Function} keysFunc The function to get the keys of a given object.\x0a     * @returns {Function} Returns the new pairs function.\x0a     */\x0a    function createToPairs(keysFunc) {\x0a      return function(object) {\x0a        var tag = getTag(object);\x0a        if (tag == mapTag) {\x0a          return mapToArray(object);\x0a        }\x0a        if (tag == setTag) {\x0a          return setToPairs(object);\x0a        }\x0a        return baseToPairs(object, keysFunc(object));\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function that either curries or invokes `func` with optional\x0a     * `this` binding and partially applied arguments.\x0a     *\x0a     * @private\x0a     * @param {Function|string} func The function or method name to wrap.\x0a     * @param {number} bitmask The bitmask flags.\x0a     *    1 - `_.bind`\x0a     *    2 - `_.bindKey`\x0a     *    4 - `_.curry` or `_.curryRight` of a bound function\x0a     *    8 - `_.curry`\x0a     *   16 - `_.curryRight`\x0a     *   32 - `_.partial`\x0a     *   64 - `_.partialRight`\x0a     *  128 - `_.rearg`\x0a     *  256 - `_.ary`\x0a     *  512 - `_.flip`\x0a     * @param {*} [thisArg] The `this` binding of `func`.\x0a     * @param {Array} [partials] The arguments to be partially applied.\x0a     * @param {Array} [holders] The `partials` placeholder indexes.\x0a     * @param {Array} [argPos] The argument positions of the new function.\x0a     * @param {number} [ary] The arity cap of `func`.\x0a     * @param {number} [arity] The arity of `func`.\x0a     * @returns {Function} Returns the new wrapped function.\x0a     */\x0a    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\x0a      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\x0a      if (!isBindKey && typeof func != \x27function\x27) {\x0a        throw new TypeError(FUNC_ERROR_TEXT);\x0a      }\x0a      var length = partials ? partials.length : 0;\x0a      if (!length) {\x0a        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\x0a        partials = holders = undefined;\x0a      }\x0a      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\x0a      arity = arity === undefined ? arity : toInteger(arity);\x0a      length -= holders ? holders.length : 0;\x0a\x0a      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\x0a        var partialsRight = partials,\x0a            holdersRight = holders;\x0a\x0a        partials = holders = undefined;\x0a      }\x0a      var data = isBindKey ? undefined : getData(func);\x0a\x0a      var newData = [\x0a        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\x0a        argPos, ary, arity\x0a      ];\x0a\x0a      if (data) {\x0a        mergeData(newData, data);\x0a      }\x0a      func = newData[0];\x0a      bitmask = newData[1];\x0a      thisArg = newData[2];\x0a      partials = newData[3];\x0a      holders = newData[4];\x0a      arity = newData[9] = newData[9] === undefined\x0a        ? (isBindKey ? 0 : func.length)\x0a        : nativeMax(newData[9] - length, 0);\x0a\x0a      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\x0a        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\x0a      }\x0a      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\x0a        var result = createBind(func, bitmask, thisArg);\x0a      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\x0a        result = createCurry(func, bitmask, arity);\x0a      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\x0a        result = createPartial(func, bitmask, thisArg, partials);\x0a      } else {\x0a        result = createHybrid.apply(undefined, newData);\x0a      }\x0a      var setter = data ? baseSetData : setData;\x0a      return setWrapToString(setter(result, newData), func, bitmask);\x0a    }\x0a\x0a    /**\x0a     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\x0a     * of source objects to the destination object for all destination properties\x0a     * that resolve to `undefined`.\x0a     *\x0a     * @private\x0a     * @param {*} objValue The destination value.\x0a     * @param {*} srcValue The source value.\x0a     * @param {string} key The key of the property to assign.\x0a     * @param {Object} object The parent object of `objValue`.\x0a     * @returns {*} Returns the value to assign.\x0a     */\x0a    function customDefaultsAssignIn(objValue, srcValue, key, object) {\x0a      if (objValue === undefined ||\x0a          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\x0a        return srcValue;\x0a      }\x0a      return objValue;\x0a    }\x0a\x0a    /**\x0a     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\x0a     * objects into destination objects that are passed thru.\x0a     *\x0a     * @private\x0a     * @param {*} objValue The destination value.\x0a     * @param {*} srcValue The source value.\x0a     * @param {string} key The key of the property to merge.\x0a     * @param {Object} object The parent object of `objValue`.\x0a     * @param {Object} source The parent object of `srcValue`.\x0a     * @param {Object} [stack] Tracks traversed source values and their merged\x0a     *  counterparts.\x0a     * @returns {*} Returns the value to assign.\x0a     */\x0a    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\x0a      if (isObject(objValue) && isObject(srcValue)) {\x0a        // Recursively merge objects and arrays (susceptible to call stack limits).\x0a        stack.set(srcValue, objValue);\x0a        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\x0a        stack[\x27delete\x27](srcValue);\x0a      }\x0a      return objValue;\x0a    }\x0a\x0a    /**\x0a     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\x0a     * objects.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to inspect.\x0a     * @param {string} key The key of the property to inspect.\x0a     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\x0a     */\x0a    function customOmitClone(value) {\x0a      return isPlainObject(value) ? undefined : value;\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `baseIsEqualDeep` for arrays with support for\x0a     * partial deep comparisons.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to compare.\x0a     * @param {Array} other The other array to compare.\x0a     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\x0a     * @param {Function} customizer The function to customize comparisons.\x0a     * @param {Function} equalFunc The function to determine equivalents of values.\x0a     * @param {Object} stack Tracks traversed `array` and `other` objects.\x0a     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\x0a     */\x0a    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\x0a      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\x0a          arrLength = array.length,\x0a          othLength = other.length;\x0a\x0a      if (arrLength != othLength && !(isPartial && othLength \x3e arrLength)) {\x0a        return false;\x0a      }\x0a      // Assume cyclic values are equal.\x0a      var stacked = stack.get(array);\x0a      if (stacked && stack.get(other)) {\x0a        return stacked == other;\x0a      }\x0a      var index = -1,\x0a          result = true,\x0a          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\x0a\x0a      stack.set(array, other);\x0a      stack.set(other, array);\x0a\x0a      // Ignore non-index properties.\x0a      while (++index \x3c arrLength) {\x0a        var arrValue = array[index],\x0a            othValue = other[index];\x0a\x0a        if (customizer) {\x0a          var compared = isPartial\x0a            ? customizer(othValue, arrValue, index, other, array, stack)\x0a            : customizer(arrValue, othValue, index, array, other, stack);\x0a        }\x0a        if (compared !== undefined) {\x0a          if (compared) {\x0a            continue;\x0a          }\x0a          result = false;\x0a          break;\x0a        }\x0a        // Recursively compare arrays (susceptible to call stack limits).\x0a        if (seen) {\x0a          if (!arraySome(other, function(othValue, othIndex) {\x0a                if (!cacheHas(seen, othIndex) &&\x0a                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\x0a                  return seen.push(othIndex);\x0a                }\x0a              })) {\x0a            result = false;\x0a            break;\x0a          }\x0a        } else if (!(\x0a              arrValue === othValue ||\x0a                equalFunc(arrValue, othValue, bitmask, customizer, stack)\x0a            )) {\x0a          result = false;\x0a          break;\x0a        }\x0a      }\x0a      stack[\x27delete\x27](array);\x0a      stack[\x27delete\x27](other);\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `baseIsEqualDeep` for comparing objects of\x0a     * the same `toStringTag`.\x0a     *\x0a     * **Note:** This function only supports comparing values with tags of\x0a     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to compare.\x0a     * @param {Object} other The other object to compare.\x0a     * @param {string} tag The `toStringTag` of the objects to compare.\x0a     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\x0a     * @param {Function} customizer The function to customize comparisons.\x0a     * @param {Function} equalFunc The function to determine equivalents of values.\x0a     * @param {Object} stack Tracks traversed `object` and `other` objects.\x0a     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\x0a     */\x0a    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\x0a      switch (tag) {\x0a        case dataViewTag:\x0a          if ((object.byteLength != other.byteLength) ||\x0a              (object.byteOffset != other.byteOffset)) {\x0a            return false;\x0a          }\x0a          object = object.buffer;\x0a          other = other.buffer;\x0a\x0a        case arrayBufferTag:\x0a          if ((object.byteLength != other.byteLength) ||\x0a              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\x0a            return false;\x0a          }\x0a          return true;\x0a\x0a        case boolTag:\x0a        case dateTag:\x0a        case numberTag:\x0a          // Coerce booleans to `1` or `0` and dates to milliseconds.\x0a          // Invalid dates are coerced to `NaN`.\x0a          return eq(+object, +other);\x0a\x0a        case errorTag:\x0a          return object.name == other.name && object.message == other.message;\x0a\x0a        case regexpTag:\x0a        case stringTag:\x0a          // Coerce regexes to strings and treat strings, primitives and objects,\x0a          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\x0a          // for more details.\x0a          return object == (other + \x27\x27);\x0a\x0a        case mapTag:\x0a          var convert = mapToArray;\x0a\x0a        case setTag:\x0a          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\x0a          convert || (convert = setToArray);\x0a\x0a          if (object.size != other.size && !isPartial) {\x0a            return false;\x0a          }\x0a          // Assume cyclic values are equal.\x0a          var stacked = stack.get(object);\x0a          if (stacked) {\x0a            return stacked == other;\x0a          }\x0a          bitmask |= COMPARE_UNORDERED_FLAG;\x0a\x0a          // Recursively compare objects (susceptible to call stack limits).\x0a          stack.set(object, other);\x0a          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\x0a          stack[\x27delete\x27](object);\x0a          return result;\x0a\x0a        case symbolTag:\x0a          if (symbolValueOf) {\x0a            return symbolValueOf.call(object) == symbolValueOf.call(other);\x0a          }\x0a      }\x0a      return false;\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `baseIsEqualDeep` for objects with support for\x0a     * partial deep comparisons.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to compare.\x0a     * @param {Object} other The other object to compare.\x0a     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\x0a     * @param {Function} customizer The function to customize comparisons.\x0a     * @param {Function} equalFunc The function to determine equivalents of values.\x0a     * @param {Object} stack Tracks traversed `object` and `other` objects.\x0a     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\x0a     */\x0a    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\x0a      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\x0a          objProps = getAllKeys(object),\x0a          objLength = objProps.length,\x0a          othProps = getAllKeys(other),\x0a          othLength = othProps.length;\x0a\x0a      if (objLength != othLength && !isPartial) {\x0a        return false;\x0a      }\x0a      var index = objLength;\x0a      while (index--) {\x0a        var key = objProps[index];\x0a        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\x0a          return false;\x0a        }\x0a      }\x0a      // Assume cyclic values are equal.\x0a      var stacked = stack.get(object);\x0a      if (stacked && stack.get(other)) {\x0a        return stacked == other;\x0a      }\x0a      var result = true;\x0a      stack.set(object, other);\x0a      stack.set(other, object);\x0a\x0a      var skipCtor = isPartial;\x0a      while (++index \x3c objLength) {\x0a        key = objProps[index];\x0a        var objValue = object[key],\x0a            othValue = other[key];\x0a\x0a        if (customizer) {\x0a          var compared = isPartial\x0a            ? customizer(othValue, objValue, key, other, object, stack)\x0a            : customizer(objValue, othValue, key, object, other, stack);\x0a        }\x0a        // Recursively compare objects (susceptible to call stack limits).\x0a        if (!(compared === undefined\x0a              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\x0a              : compared\x0a            )) {\x0a          result = false;\x0a          break;\x0a        }\x0a        skipCtor || (skipCtor = key == \x27constructor\x27);\x0a      }\x0a      if (result && !skipCtor) {\x0a        var objCtor = object.constructor,\x0a            othCtor = other.constructor;\x0a\x0a        // Non `Object` object instances with different constructors are not equal.\x0a        if (objCtor != othCtor &&\x0a            (\x27constructor\x27 in object && \x27constructor\x27 in other) &&\x0a            !(typeof objCtor == \x27function\x27 && objCtor instanceof objCtor &&\x0a              typeof othCtor == \x27function\x27 && othCtor instanceof othCtor)) {\x0a          result = false;\x0a        }\x0a      }\x0a      stack[\x27delete\x27](object);\x0a      stack[\x27delete\x27](other);\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `baseRest` which flattens the rest array.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to apply a rest parameter to.\x0a     * @returns {Function} Returns the new function.\x0a     */\x0a    function flatRest(func) {\x0a      return setToString(overRest(func, undefined, flatten), func + \x27\x27);\x0a    }\x0a\x0a    /**\x0a     * Creates an array of own enumerable property names and symbols of `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @returns {Array} Returns the array of property names and symbols.\x0a     */\x0a    function getAllKeys(object) {\x0a      return baseGetAllKeys(object, keys, getSymbols);\x0a    }\x0a\x0a    /**\x0a     * Creates an array of own and inherited enumerable property names and\x0a     * symbols of `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @returns {Array} Returns the array of property names and symbols.\x0a     */\x0a    function getAllKeysIn(object) {\x0a      return baseGetAllKeys(object, keysIn, getSymbolsIn);\x0a    }\x0a\x0a    /**\x0a     * Gets metadata for `func`.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to query.\x0a     * @returns {*} Returns the metadata for `func`.\x0a     */\x0a    var getData = !metaMap ? noop : function(func) {\x0a      return metaMap.get(func);\x0a    };\x0a\x0a    /**\x0a     * Gets the name of `func`.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to query.\x0a     * @returns {string} Returns the function name.\x0a     */\x0a    function getFuncName(func) {\x0a      var result = (func.name + \x27\x27),\x0a          array = realNames[result],\x0a          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\x0a\x0a      while (length--) {\x0a        var data = array[length],\x0a            otherFunc = data.func;\x0a        if (otherFunc == null || otherFunc == func) {\x0a          return data.name;\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Gets the argument placeholder value for `func`.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to inspect.\x0a     * @returns {*} Returns the placeholder value.\x0a     */\x0a    function getHolder(func) {\x0a      var object = hasOwnProperty.call(lodash, \x27placeholder\x27) ? lodash : func;\x0a      return object.placeholder;\x0a    }\x0a\x0a    /**\x0a     * Gets the appropriate \x22iteratee\x22 function. If `_.iteratee` is customized,\x0a     * this function returns the custom method, otherwise it returns `baseIteratee`.\x0a     * If arguments are provided, the chosen function is invoked with them and\x0a     * its result is returned.\x0a     *\x0a     * @private\x0a     * @param {*} [value] The value to convert to an iteratee.\x0a     * @param {number} [arity] The arity of the created iteratee.\x0a     * @returns {Function} Returns the chosen function or its result.\x0a     */\x0a    function getIteratee() {\x0a      var result = lodash.iteratee || iteratee;\x0a      result = result === iteratee ? baseIteratee : result;\x0a      return arguments.length ? result(arguments[0], arguments[1]) : result;\x0a    }\x0a\x0a    /**\x0a     * Gets the data for `map`.\x0a     *\x0a     * @private\x0a     * @param {Object} map The map to query.\x0a     * @param {string} key The reference key.\x0a     * @returns {*} Returns the map data.\x0a     */\x0a    function getMapData(map, key) {\x0a      var data = map.__data__;\x0a      return isKeyable(key)\x0a        ? data[typeof key == \x27string\x27 ? \x27string\x27 : \x27hash\x27]\x0a        : data.map;\x0a    }\x0a\x0a    /**\x0a     * Gets the property names, values, and compare flags of `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @returns {Array} Returns the match data of `object`.\x0a     */\x0a    function getMatchData(object) {\x0a      var result = keys(object),\x0a          length = result.length;\x0a\x0a      while (length--) {\x0a        var key = result[length],\x0a            value = object[key];\x0a\x0a        result[length] = [key, value, isStrictComparable(value)];\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Gets the native function at `key` of `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @param {string} key The key of the method to get.\x0a     * @returns {*} Returns the function if it\x27s native, else `undefined`.\x0a     */\x0a    function getNative(object, key) {\x0a      var value = getValue(object, key);\x0a      return baseIsNative(value) ? value : undefined;\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to query.\x0a     * @returns {string} Returns the raw `toStringTag`.\x0a     */\x0a    function getRawTag(value) {\x0a      var isOwn = hasOwnProperty.call(value, symToStringTag),\x0a          tag = value[symToStringTag];\x0a\x0a      try {\x0a        value[symToStringTag] = undefined;\x0a        var unmasked = true;\x0a      } catch (e) {}\x0a\x0a      var result = nativeObjectToString.call(value);\x0a      if (unmasked) {\x0a        if (isOwn) {\x0a          value[symToStringTag] = tag;\x0a        } else {\x0a          delete value[symToStringTag];\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Creates an array of the own enumerable symbols of `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @returns {Array} Returns the array of symbols.\x0a     */\x0a    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\x0a      if (object == null) {\x0a        return [];\x0a      }\x0a      object = Object(object);\x0a      return arrayFilter(nativeGetSymbols(object), function(symbol) {\x0a        return propertyIsEnumerable.call(object, symbol);\x0a      });\x0a    };\x0a\x0a    /**\x0a     * Creates an array of the own and inherited enumerable symbols of `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @returns {Array} Returns the array of symbols.\x0a     */\x0a    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\x0a      var result = [];\x0a      while (object) {\x0a        arrayPush(result, getSymbols(object));\x0a        object = getPrototype(object);\x0a      }\x0a      return result;\x0a    };\x0a\x0a    /**\x0a     * Gets the `toStringTag` of `value`.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to query.\x0a     * @returns {string} Returns the `toStringTag`.\x0a     */\x0a    var getTag = baseGetTag;\x0a\x0a    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js \x3c 6.\x0a    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\x0a        (Map && getTag(new Map) != mapTag) ||\x0a        (Promise && getTag(Promise.resolve()) != promiseTag) ||\x0a        (Set && getTag(new Set) != setTag) ||\x0a        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\x0a      getTag = function(value) {\x0a        var result = baseGetTag(value),\x0a            Ctor = result == objectTag ? value.constructor : undefined,\x0a            ctorString = Ctor ? toSource(Ctor) : \x27\x27;\x0a\x0a        if (ctorString) {\x0a          switch (ctorString) {\x0a            case dataViewCtorString: return dataViewTag;\x0a            case mapCtorString: return mapTag;\x0a            case promiseCtorString: return promiseTag;\x0a            case setCtorString: return setTag;\x0a            case weakMapCtorString: return weakMapTag;\x0a          }\x0a        }\x0a        return result;\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Gets the view, applying any `transforms` to the `start` and `end` positions.\x0a     *\x0a     * @private\x0a     * @param {number} start The start of the view.\x0a     * @param {number} end The end of the view.\x0a     * @param {Array} transforms The transformations to apply to the view.\x0a     * @returns {Object} Returns an object containing the `start` and `end`\x0a     *  positions of the view.\x0a     */\x0a    function getView(start, end, transforms) {\x0a      var index = -1,\x0a          length = transforms.length;\x0a\x0a      while (++index \x3c length) {\x0a        var data = transforms[index],\x0a            size = data.size;\x0a\x0a        switch (data.type) {\x0a          case \x27drop\x27:      start += size; break;\x0a          case \x27dropRight\x27: end -= size; break;\x0a          case \x27take\x27:      end = nativeMin(end, start + size); break;\x0a          case \x27takeRight\x27: start = nativeMax(start, end - size); break;\x0a        }\x0a      }\x0a      return { \x27start\x27: start, \x27end\x27: end };\x0a    }\x0a\x0a    /**\x0a     * Extracts wrapper details from the `source` body comment.\x0a     *\x0a     * @private\x0a     * @param {string} source The source to inspect.\x0a     * @returns {Array} Returns the wrapper details.\x0a     */\x0a    function getWrapDetails(source) {\x0a      var match = source.match(reWrapDetails);\x0a      return match ? match[1].split(reSplitDetails) : [];\x0a    }\x0a\x0a    /**\x0a     * Checks if `path` exists on `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @param {Array|string} path The path to check.\x0a     * @param {Function} hasFunc The function to check properties.\x0a     * @returns {boolean} Returns `true` if `path` exists, else `false`.\x0a     */\x0a    function hasPath(object, path, hasFunc) {\x0a      path = castPath(path, object);\x0a\x0a      var index = -1,\x0a          length = path.length,\x0a          result = false;\x0a\x0a      while (++index \x3c length) {\x0a        var key = toKey(path[index]);\x0a        if (!(result = object != null && hasFunc(object, key))) {\x0a          break;\x0a        }\x0a        object = object[key];\x0a      }\x0a      if (result || ++index != length) {\x0a        return result;\x0a      }\x0a      length = object == null ? 0 : object.length;\x0a      return !!length && isLength(length) && isIndex(key, length) &&\x0a        (isArray(object) || isArguments(object));\x0a    }\x0a\x0a    /**\x0a     * Initializes an array clone.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to clone.\x0a     * @returns {Array} Returns the initialized clone.\x0a     */\x0a    function initCloneArray(array) {\x0a      var length = array.length,\x0a          result = new array.constructor(length);\x0a\x0a      // Add properties assigned by `RegExp#exec`.\x0a      if (length && typeof array[0] == \x27string\x27 && hasOwnProperty.call(array, \x27index\x27)) {\x0a        result.index = array.index;\x0a        result.input = array.input;\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Initializes an object clone.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to clone.\x0a     * @returns {Object} Returns the initialized clone.\x0a     */\x0a    function initCloneObject(object) {\x0a      return (typeof object.constructor == \x27function\x27 && !isPrototype(object))\x0a        ? baseCreate(getPrototype(object))\x0a        : {};\x0a    }\x0a\x0a    /**\x0a     * Initializes an object clone based on its `toStringTag`.\x0a     *\x0a     * **Note:** This function only supports cloning values with tags of\x0a     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to clone.\x0a     * @param {string} tag The `toStringTag` of the object to clone.\x0a     * @param {boolean} [isDeep] Specify a deep clone.\x0a     * @returns {Object} Returns the initialized clone.\x0a     */\x0a    function initCloneByTag(object, tag, isDeep) {\x0a      var Ctor = object.constructor;\x0a      switch (tag) {\x0a        case arrayBufferTag:\x0a          return cloneArrayBuffer(object);\x0a\x0a        case boolTag:\x0a        case dateTag:\x0a          return new Ctor(+object);\x0a\x0a        case dataViewTag:\x0a          return cloneDataView(object, isDeep);\x0a\x0a        case float32Tag: case float64Tag:\x0a        case int8Tag: case int16Tag: case int32Tag:\x0a        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\x0a          return cloneTypedArray(object, isDeep);\x0a\x0a        case mapTag:\x0a          return new Ctor;\x0a\x0a        case numberTag:\x0a        case stringTag:\x0a          return new Ctor(object);\x0a\x0a        case regexpTag:\x0a          return cloneRegExp(object);\x0a\x0a        case setTag:\x0a          return new Ctor;\x0a\x0a        case symbolTag:\x0a          return cloneSymbol(object);\x0a      }\x0a    }\x0a\x0a    /**\x0a     * Inserts wrapper `details` in a comment at the top of the `source` body.\x0a     *\x0a     * @private\x0a     * @param {string} source The source to modify.\x0a     * @returns {Array} details The details to insert.\x0a     * @returns {string} Returns the modified source.\x0a     */\x0a    function insertWrapDetails(source, details) {\x0a      var length = details.length;\x0a      if (!length) {\x0a        return source;\x0a      }\x0a      var lastIndex = length - 1;\x0a      details[lastIndex] = (length \x3e 1 ? \x27& \x27 : \x27\x27) + details[lastIndex];\x0a      details = details.join(length \x3e 2 ? \x27, \x27 : \x27 \x27);\x0a      return source.replace(reWrapComment, \x27{\x5cn/* [wrapped with \x27 + details + \x27] */\x5cn\x27);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is a flattenable `arguments` object or array.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\x0a     */\x0a    function isFlattenable(value) {\x0a      return isArray(value) || isArguments(value) ||\x0a        !!(spreadableSymbol && value && value[spreadableSymbol]);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is a valid array-like index.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\x0a     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\x0a     */\x0a    function isIndex(value, length) {\x0a      var type = typeof value;\x0a      length = length == null ? MAX_SAFE_INTEGER : length;\x0a\x0a      return !!length &&\x0a        (type == \x27number\x27 ||\x0a          (type != \x27symbol\x27 && reIsUint.test(value))) &&\x0a            (value \x3e -1 && value % 1 == 0 && value \x3c length);\x0a    }\x0a\x0a    /**\x0a     * Checks if the given arguments are from an iteratee call.\x0a     *\x0a     * @private\x0a     * @param {*} value The potential iteratee value argument.\x0a     * @param {*} index The potential iteratee index or key argument.\x0a     * @param {*} object The potential iteratee object argument.\x0a     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\x0a     *  else `false`.\x0a     */\x0a    function isIterateeCall(value, index, object) {\x0a      if (!isObject(object)) {\x0a        return false;\x0a      }\x0a      var type = typeof index;\x0a      if (type == \x27number\x27\x0a            ? (isArrayLike(object) && isIndex(index, object.length))\x0a            : (type == \x27string\x27 && index in object)\x0a          ) {\x0a        return eq(object[index], value);\x0a      }\x0a      return false;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is a property name and not a property path.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @param {Object} [object] The object to query keys on.\x0a     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\x0a     */\x0a    function isKey(value, object) {\x0a      if (isArray(value)) {\x0a        return false;\x0a      }\x0a      var type = typeof value;\x0a      if (type == \x27number\x27 || type == \x27symbol\x27 || type == \x27boolean\x27 ||\x0a          value == null || isSymbol(value)) {\x0a        return true;\x0a      }\x0a      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\x0a        (object != null && value in Object(object));\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is suitable for use as unique object key.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\x0a     */\x0a    function isKeyable(value) {\x0a      var type = typeof value;\x0a      return (type == \x27string\x27 || type == \x27number\x27 || type == \x27symbol\x27 || type == \x27boolean\x27)\x0a        ? (value !== \x27__proto__\x27)\x0a        : (value === null);\x0a    }\x0a\x0a    /**\x0a     * Checks if `func` has a lazy counterpart.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to check.\x0a     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\x0a     *  else `false`.\x0a     */\x0a    function isLaziable(func) {\x0a      var funcName = getFuncName(func),\x0a          other = lodash[funcName];\x0a\x0a      if (typeof other != \x27function\x27 || !(funcName in LazyWrapper.prototype)) {\x0a        return false;\x0a      }\x0a      if (func === other) {\x0a        return true;\x0a      }\x0a      var data = getData(other);\x0a      return !!data && func === data[0];\x0a    }\x0a\x0a    /**\x0a     * Checks if `func` has its source masked.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to check.\x0a     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\x0a     */\x0a    function isMasked(func) {\x0a      return !!maskSrcKey && (maskSrcKey in func);\x0a    }\x0a\x0a    /**\x0a     * Checks if `func` is capable of being masked.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\x0a     */\x0a    var isMaskable = coreJsData ? isFunction : stubFalse;\x0a\x0a    /**\x0a     * Checks if `value` is likely a prototype object.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\x0a     */\x0a    function isPrototype(value) {\x0a      var Ctor = value && value.constructor,\x0a          proto = (typeof Ctor == \x27function\x27 && Ctor.prototype) || objectProto;\x0a\x0a      return value === proto;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` if suitable for strict\x0a     *  equality comparisons, else `false`.\x0a     */\x0a    function isStrictComparable(value) {\x0a      return value === value && !isObject(value);\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `matchesProperty` for source values suitable\x0a     * for strict equality comparisons, i.e. `===`.\x0a     *\x0a     * @private\x0a     * @param {string} key The key of the property to get.\x0a     * @param {*} srcValue The value to match.\x0a     * @returns {Function} Returns the new spec function.\x0a     */\x0a    function matchesStrictComparable(key, srcValue) {\x0a      return function(object) {\x0a        if (object == null) {\x0a          return false;\x0a        }\x0a        return object[key] === srcValue &&\x0a          (srcValue !== undefined || (key in Object(object)));\x0a      };\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `_.memoize` which clears the memoized function\x27s\x0a     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to have its output memoized.\x0a     * @returns {Function} Returns the new memoized function.\x0a     */\x0a    function memoizeCapped(func) {\x0a      var result = memoize(func, function(key) {\x0a        if (cache.size === MAX_MEMOIZE_SIZE) {\x0a          cache.clear();\x0a        }\x0a        return key;\x0a      });\x0a\x0a      var cache = result.cache;\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Merges the function metadata of `source` into `data`.\x0a     *\x0a     * Merging metadata reduces the number of wrappers used to invoke a function.\x0a     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\x0a     * may be applied regardless of execution order. Methods like `_.ary` and\x0a     * `_.rearg` modify function arguments, making the order in which they are\x0a     * executed important, preventing the merging of metadata. However, we make\x0a     * an exception for a safe combined case where curried functions have `_.ary`\x0a     * and or `_.rearg` applied.\x0a     *\x0a     * @private\x0a     * @param {Array} data The destination metadata.\x0a     * @param {Array} source The source metadata.\x0a     * @returns {Array} Returns `data`.\x0a     */\x0a    function mergeData(data, source) {\x0a      var bitmask = data[1],\x0a          srcBitmask = source[1],\x0a          newBitmask = bitmask | srcBitmask,\x0a          isCommon = newBitmask \x3c (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\x0a\x0a      var isCombo =\x0a        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\x0a        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length \x3c= source[8])) ||\x0a        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length \x3c= source[8]) && (bitmask == WRAP_CURRY_FLAG));\x0a\x0a      // Exit early if metadata can\x27t be merged.\x0a      if (!(isCommon || isCombo)) {\x0a        return data;\x0a      }\x0a      // Use source `thisArg` if available.\x0a      if (srcBitmask & WRAP_BIND_FLAG) {\x0a        data[2] = source[2];\x0a        // Set when currying a bound function.\x0a        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\x0a      }\x0a      // Compose partial arguments.\x0a      var value = source[3];\x0a      if (value) {\x0a        var partials = data[3];\x0a        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\x0a        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\x0a      }\x0a      // Compose partial right arguments.\x0a      value = source[5];\x0a      if (value) {\x0a        partials = data[5];\x0a        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\x0a        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\x0a      }\x0a      // Use source `argPos` if available.\x0a      value = source[7];\x0a      if (value) {\x0a        data[7] = value;\x0a      }\x0a      // Use source `ary` if it\x27s smaller.\x0a      if (srcBitmask & WRAP_ARY_FLAG) {\x0a        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\x0a      }\x0a      // Use source `arity` if one is not provided.\x0a      if (data[9] == null) {\x0a        data[9] = source[9];\x0a      }\x0a      // Use source `func` and merge bitmasks.\x0a      data[0] = source[0];\x0a      data[1] = newBitmask;\x0a\x0a      return data;\x0a    }\x0a\x0a    /**\x0a     * This function is like\x0a     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\x0a     * except that it includes inherited enumerable properties.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @returns {Array} Returns the array of property names.\x0a     */\x0a    function nativeKeysIn(object) {\x0a      var result = [];\x0a      if (object != null) {\x0a        for (var key in Object(object)) {\x0a          result.push(key);\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Converts `value` to a string using `Object.prototype.toString`.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to convert.\x0a     * @returns {string} Returns the converted string.\x0a     */\x0a    function objectToString(value) {\x0a      return nativeObjectToString.call(value);\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `baseRest` which transforms the rest array.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to apply a rest parameter to.\x0a     * @param {number} [start=func.length-1] The start position of the rest parameter.\x0a     * @param {Function} transform The rest array transform.\x0a     * @returns {Function} Returns the new function.\x0a     */\x0a    function overRest(func, start, transform) {\x0a      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\x0a      return function() {\x0a        var args = arguments,\x0a            index = -1,\x0a            length = nativeMax(args.length - start, 0),\x0a            array = Array(length);\x0a\x0a        while (++index \x3c length) {\x0a          array[index] = args[start + index];\x0a        }\x0a        index = -1;\x0a        var otherArgs = Array(start + 1);\x0a        while (++index \x3c start) {\x0a          otherArgs[index] = args[index];\x0a        }\x0a        otherArgs[start] = transform(array);\x0a        return apply(func, this, otherArgs);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Gets the parent value at `path` of `object`.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @param {Array} path The path to get the parent value of.\x0a     * @returns {*} Returns the parent value.\x0a     */\x0a    function parent(object, path) {\x0a      return path.length \x3c 2 ? object : baseGet(object, baseSlice(path, 0, -1));\x0a    }\x0a\x0a    /**\x0a     * Reorder `array` according to the specified indexes where the element at\x0a     * the first index is assigned as the first element, the element at\x0a     * the second index is assigned as the second element, and so on.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to reorder.\x0a     * @param {Array} indexes The arranged array indexes.\x0a     * @returns {Array} Returns `array`.\x0a     */\x0a    function reorder(array, indexes) {\x0a      var arrLength = array.length,\x0a          length = nativeMin(indexes.length, arrLength),\x0a          oldArray = copyArray(array);\x0a\x0a      while (length--) {\x0a        var index = indexes[length];\x0a        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\x0a      }\x0a      return array;\x0a    }\x0a\x0a    /**\x0a     * Gets the value at `key`, unless `key` is \x22__proto__\x22.\x0a     *\x0a     * @private\x0a     * @param {Object} object The object to query.\x0a     * @param {string} key The key of the property to get.\x0a     * @returns {*} Returns the property value.\x0a     */\x0a    function safeGet(object, key) {\x0a      if (key == \x27__proto__\x27) {\x0a        return;\x0a      }\x0a\x0a      return object[key];\x0a    }\x0a\x0a    /**\x0a     * Sets metadata for `func`.\x0a     *\x0a     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\x0a     * period of time, it will trip its breaker and transition to an identity\x0a     * function to avoid garbage collection pauses in V8. See\x0a     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\x0a     * for more details.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to associate metadata with.\x0a     * @param {*} data The metadata.\x0a     * @returns {Function} Returns `func`.\x0a     */\x0a    var setData = shortOut(baseSetData);\x0a\x0a    /**\x0a     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to delay.\x0a     * @param {number} wait The number of milliseconds to delay invocation.\x0a     * @returns {number|Object} Returns the timer id or timeout object.\x0a     */\x0a    var setTimeout = ctxSetTimeout || function(func, wait) {\x0a      return root.setTimeout(func, wait);\x0a    };\x0a\x0a    /**\x0a     * Sets the `toString` method of `func` to return `string`.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to modify.\x0a     * @param {Function} string The `toString` result.\x0a     * @returns {Function} Returns `func`.\x0a     */\x0a    var setToString = shortOut(baseSetToString);\x0a\x0a    /**\x0a     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\x0a     * with wrapper details in a comment at the top of the source body.\x0a     *\x0a     * @private\x0a     * @param {Function} wrapper The function to modify.\x0a     * @param {Function} reference The reference function.\x0a     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\x0a     * @returns {Function} Returns `wrapper`.\x0a     */\x0a    function setWrapToString(wrapper, reference, bitmask) {\x0a      var source = (reference + \x27\x27);\x0a      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\x0a    }\x0a\x0a    /**\x0a     * Creates a function that\x27ll short out and invoke `identity` instead\x0a     * of `func` when it\x27s called `HOT_COUNT` or more times in `HOT_SPAN`\x0a     * milliseconds.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to restrict.\x0a     * @returns {Function} Returns the new shortable function.\x0a     */\x0a    function shortOut(func) {\x0a      var count = 0,\x0a          lastCalled = 0;\x0a\x0a      return function() {\x0a        var stamp = nativeNow(),\x0a            remaining = HOT_SPAN - (stamp - lastCalled);\x0a\x0a        lastCalled = stamp;\x0a        if (remaining \x3e 0) {\x0a          if (++count \x3e= HOT_COUNT) {\x0a            return arguments[0];\x0a          }\x0a        } else {\x0a          count = 0;\x0a        }\x0a        return func.apply(undefined, arguments);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\x0a     *\x0a     * @private\x0a     * @param {Array} array The array to shuffle.\x0a     * @param {number} [size=array.length] The size of `array`.\x0a     * @returns {Array} Returns `array`.\x0a     */\x0a    function shuffleSelf(array, size) {\x0a      var index = -1,\x0a          length = array.length,\x0a          lastIndex = length - 1;\x0a\x0a      size = size === undefined ? length : size;\x0a      while (++index \x3c size) {\x0a        var rand = baseRandom(index, lastIndex),\x0a            value = array[rand];\x0a\x0a        array[rand] = array[index];\x0a        array[index] = value;\x0a      }\x0a      array.length = size;\x0a      return array;\x0a    }\x0a\x0a    /**\x0a     * Converts `string` to a property path array.\x0a     *\x0a     * @private\x0a     * @param {string} string The string to convert.\x0a     * @returns {Array} Returns the property path array.\x0a     */\x0a    var stringToPath = memoizeCapped(function(string) {\x0a      var result = [];\x0a      if (string.charCodeAt(0) === 46 /* . */) {\x0a        result.push(\x27\x27);\x0a      }\x0a      string.replace(rePropName, function(match, number, quote, subString) {\x0a        result.push(quote ? subString.replace(reEscapeChar, \x27$1\x27) : (number || match));\x0a      });\x0a      return result;\x0a    });\x0a\x0a    /**\x0a     * Converts `value` to a string key if it\x27s not a string or symbol.\x0a     *\x0a     * @private\x0a     * @param {*} value The value to inspect.\x0a     * @returns {string|symbol} Returns the key.\x0a     */\x0a    function toKey(value) {\x0a      if (typeof value == \x27string\x27 || isSymbol(value)) {\x0a        return value;\x0a      }\x0a      var result = (value + \x27\x27);\x0a      return (result == \x270\x27 && (1 / value) == -INFINITY) ? \x27-0\x27 : result;\x0a    }\x0a\x0a    /**\x0a     * Converts `func` to its source code.\x0a     *\x0a     * @private\x0a     * @param {Function} func The function to convert.\x0a     * @returns {string} Returns the source code.\x0a     */\x0a    function toSource(func) {\x0a      if (func != null) {\x0a        try {\x0a          return funcToString.call(func);\x0a        } catch (e) {}\x0a        try {\x0a          return (func + \x27\x27);\x0a        } catch (e) {}\x0a      }\x0a      return \x27\x27;\x0a    }\x0a\x0a    /**\x0a     * Updates wrapper `details` based on `bitmask` flags.\x0a     *\x0a     * @private\x0a     * @returns {Array} details The details to modify.\x0a     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\x0a     * @returns {Array} Returns `details`.\x0a     */\x0a    function updateWrapDetails(details, bitmask) {\x0a      arrayEach(wrapFlags, function(pair) {\x0a        var value = \x27_.\x27 + pair[0];\x0a        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\x0a          details.push(value);\x0a        }\x0a      });\x0a      return details.sort();\x0a    }\x0a\x0a    /**\x0a     * Creates a clone of `wrapper`.\x0a     *\x0a     * @private\x0a     * @param {Object} wrapper The wrapper to clone.\x0a     * @returns {Object} Returns the cloned wrapper.\x0a     */\x0a    function wrapperClone(wrapper) {\x0a      if (wrapper instanceof LazyWrapper) {\x0a        return wrapper.clone();\x0a      }\x0a      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\x0a      result.__actions__ = copyArray(wrapper.__actions__);\x0a      result.__index__  = wrapper.__index__;\x0a      result.__values__ = wrapper.__values__;\x0a      return result;\x0a    }\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Creates an array of elements split into groups the length of `size`.\x0a     * If `array` can\x27t be split evenly, the final chunk will be the remaining\x0a     * elements.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to process.\x0a     * @param {number} [size=1] The length of each chunk\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\x0a     * @returns {Array} Returns the new array of chunks.\x0a     * @example\x0a     *\x0a     * _.chunk([\x27a\x27, \x27b\x27, \x27c\x27, \x27d\x27], 2);\x0a     * // =\x3e [[\x27a\x27, \x27b\x27], [\x27c\x27, \x27d\x27]]\x0a     *\x0a     * _.chunk([\x27a\x27, \x27b\x27, \x27c\x27, \x27d\x27], 3);\x0a     * // =\x3e [[\x27a\x27, \x27b\x27, \x27c\x27], [\x27d\x27]]\x0a     */\x0a    function chunk(array, size, guard) {\x0a      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\x0a        size = 1;\x0a      } else {\x0a        size = nativeMax(toInteger(size), 0);\x0a      }\x0a      var length = array == null ? 0 : array.length;\x0a      if (!length || size \x3c 1) {\x0a        return [];\x0a      }\x0a      var index = 0,\x0a          resIndex = 0,\x0a          result = Array(nativeCeil(length / size));\x0a\x0a      while (index \x3c length) {\x0a        result[resIndex++] = baseSlice(array, index, (index += size));\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Creates an array with all falsey values removed. The values `false`, `null`,\x0a     * `0`, `\x22\x22`, `undefined`, and `NaN` are falsey.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {Array} array The array to compact.\x0a     * @returns {Array} Returns the new array of filtered values.\x0a     * @example\x0a     *\x0a     * _.compact([0, 1, false, 2, \x27\x27, 3]);\x0a     * // =\x3e [1, 2, 3]\x0a     */\x0a    function compact(array) {\x0a      var index = -1,\x0a          length = array == null ? 0 : array.length,\x0a          resIndex = 0,\x0a          result = [];\x0a\x0a      while (++index \x3c length) {\x0a        var value = array[index];\x0a        if (value) {\x0a          result[resIndex++] = value;\x0a        }\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Creates a new array concatenating `array` with any additional arrays\x0a     * and/or values.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to concatenate.\x0a     * @param {...*} [values] The values to concatenate.\x0a     * @returns {Array} Returns the new concatenated array.\x0a     * @example\x0a     *\x0a     * var array = [1];\x0a     * var other = _.concat(array, 2, [3], [[4]]);\x0a     *\x0a     * console.log(other);\x0a     * // =\x3e [1, 2, 3, [4]]\x0a     *\x0a     * console.log(array);\x0a     * // =\x3e [1]\x0a     */\x0a    function concat() {\x0a      var length = arguments.length;\x0a      if (!length) {\x0a        return [];\x0a      }\x0a      var args = Array(length - 1),\x0a          array = arguments[0],\x0a          index = length;\x0a\x0a      while (index--) {\x0a        args[index - 1] = arguments[index];\x0a      }\x0a      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\x0a    }\x0a\x0a    /**\x0a     * Creates an array of `array` values not included in the other given arrays\x0a     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\x0a     * for equality comparisons. The order and references of result values are\x0a     * determined by the first array.\x0a     *\x0a     * **Note:** Unlike `_.pullAll`, this method returns a new array.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {...Array} [values] The values to exclude.\x0a     * @returns {Array} Returns the new array of filtered values.\x0a     * @see _.without, _.xor\x0a     * @example\x0a     *\x0a     * _.difference([2, 1], [2, 3]);\x0a     * // =\x3e [1]\x0a     */\x0a    var difference = baseRest(function(array, values) {\x0a      return isArrayLikeObject(array)\x0a        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\x0a        : [];\x0a    });\x0a\x0a    /**\x0a     * This method is like `_.difference` except that it accepts `iteratee` which\x0a     * is invoked for each element of `array` and `values` to generate the criterion\x0a     * by which they\x27re compared. The order and references of result values are\x0a     * determined by the first array. The iteratee is invoked with one argument:\x0a     * (value).\x0a     *\x0a     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {...Array} [values] The values to exclude.\x0a     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\x0a     * @returns {Array} Returns the new array of filtered values.\x0a     * @example\x0a     *\x0a     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\x0a     * // =\x3e [1.2]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.differenceBy([{ \x27x\x27: 2 }, { \x27x\x27: 1 }], [{ \x27x\x27: 1 }], \x27x\x27);\x0a     * // =\x3e [{ \x27x\x27: 2 }]\x0a     */\x0a    var differenceBy = baseRest(function(array, values) {\x0a      var iteratee = last(values);\x0a      if (isArrayLikeObject(iteratee)) {\x0a        iteratee = undefined;\x0a      }\x0a      return isArrayLikeObject(array)\x0a        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\x0a        : [];\x0a    });\x0a\x0a    /**\x0a     * This method is like `_.difference` except that it accepts `comparator`\x0a     * which is invoked to compare elements of `array` to `values`. The order and\x0a     * references of result values are determined by the first array. The comparator\x0a     * is invoked with two arguments: (arrVal, othVal).\x0a     *\x0a     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {...Array} [values] The values to exclude.\x0a     * @param {Function} [comparator] The comparator invoked per element.\x0a     * @returns {Array} Returns the new array of filtered values.\x0a     * @example\x0a     *\x0a     * var objects = [{ \x27x\x27: 1, \x27y\x27: 2 }, { \x27x\x27: 2, \x27y\x27: 1 }];\x0a     *\x0a     * _.differenceWith(objects, [{ \x27x\x27: 1, \x27y\x27: 2 }], _.isEqual);\x0a     * // =\x3e [{ \x27x\x27: 2, \x27y\x27: 1 }]\x0a     */\x0a    var differenceWith = baseRest(function(array, values) {\x0a      var comparator = last(values);\x0a      if (isArrayLikeObject(comparator)) {\x0a        comparator = undefined;\x0a      }\x0a      return isArrayLikeObject(array)\x0a        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\x0a        : [];\x0a    });\x0a\x0a    /**\x0a     * Creates a slice of `array` with `n` elements dropped from the beginning.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.5.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @param {number} [n=1] The number of elements to drop.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     * @example\x0a     *\x0a     * _.drop([1, 2, 3]);\x0a     * // =\x3e [2, 3]\x0a     *\x0a     * _.drop([1, 2, 3], 2);\x0a     * // =\x3e [3]\x0a     *\x0a     * _.drop([1, 2, 3], 5);\x0a     * // =\x3e []\x0a     *\x0a     * _.drop([1, 2, 3], 0);\x0a     * // =\x3e [1, 2, 3]\x0a     */\x0a    function drop(array, n, guard) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (!length) {\x0a        return [];\x0a      }\x0a      n = (guard || n === undefined) ? 1 : toInteger(n);\x0a      return baseSlice(array, n \x3c 0 ? 0 : n, length);\x0a    }\x0a\x0a    /**\x0a     * Creates a slice of `array` with `n` elements dropped from the end.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @param {number} [n=1] The number of elements to drop.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     * @example\x0a     *\x0a     * _.dropRight([1, 2, 3]);\x0a     * // =\x3e [1, 2]\x0a     *\x0a     * _.dropRight([1, 2, 3], 2);\x0a     * // =\x3e [1]\x0a     *\x0a     * _.dropRight([1, 2, 3], 5);\x0a     * // =\x3e []\x0a     *\x0a     * _.dropRight([1, 2, 3], 0);\x0a     * // =\x3e [1, 2, 3]\x0a     */\x0a    function dropRight(array, n, guard) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (!length) {\x0a        return [];\x0a      }\x0a      n = (guard || n === undefined) ? 1 : toInteger(n);\x0a      n = length - n;\x0a      return baseSlice(array, 0, n \x3c 0 ? 0 : n);\x0a    }\x0a\x0a    /**\x0a     * Creates a slice of `array` excluding elements dropped from the end.\x0a     * Elements are dropped until `predicate` returns falsey. The predicate is\x0a     * invoked with three arguments: (value, index, array).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27,  \x27active\x27: true },\x0a     *   { \x27user\x27: \x27fred\x27,    \x27active\x27: false },\x0a     *   { \x27user\x27: \x27pebbles\x27, \x27active\x27: false }\x0a     * ];\x0a     *\x0a     * _.dropRightWhile(users, function(o) { return !o.active; });\x0a     * // =\x3e objects for [\x27barney\x27]\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.dropRightWhile(users, { \x27user\x27: \x27pebbles\x27, \x27active\x27: false });\x0a     * // =\x3e objects for [\x27barney\x27, \x27fred\x27]\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.dropRightWhile(users, [\x27active\x27, false]);\x0a     * // =\x3e objects for [\x27barney\x27]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.dropRightWhile(users, \x27active\x27);\x0a     * // =\x3e objects for [\x27barney\x27, \x27fred\x27, \x27pebbles\x27]\x0a     */\x0a    function dropRightWhile(array, predicate) {\x0a      return (array && array.length)\x0a        ? baseWhile(array, getIteratee(predicate, 3), true, true)\x0a        : [];\x0a    }\x0a\x0a    /**\x0a     * Creates a slice of `array` excluding elements dropped from the beginning.\x0a     * Elements are dropped until `predicate` returns falsey. The predicate is\x0a     * invoked with three arguments: (value, index, array).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27,  \x27active\x27: false },\x0a     *   { \x27user\x27: \x27fred\x27,    \x27active\x27: false },\x0a     *   { \x27user\x27: \x27pebbles\x27, \x27active\x27: true }\x0a     * ];\x0a     *\x0a     * _.dropWhile(users, function(o) { return !o.active; });\x0a     * // =\x3e objects for [\x27pebbles\x27]\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.dropWhile(users, { \x27user\x27: \x27barney\x27, \x27active\x27: false });\x0a     * // =\x3e objects for [\x27fred\x27, \x27pebbles\x27]\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.dropWhile(users, [\x27active\x27, false]);\x0a     * // =\x3e objects for [\x27pebbles\x27]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.dropWhile(users, \x27active\x27);\x0a     * // =\x3e objects for [\x27barney\x27, \x27fred\x27, \x27pebbles\x27]\x0a     */\x0a    function dropWhile(array, predicate) {\x0a      return (array && array.length)\x0a        ? baseWhile(array, getIteratee(predicate, 3), true)\x0a        : [];\x0a    }\x0a\x0a    /**\x0a     * Fills elements of `array` with `value` from `start` up to, but not\x0a     * including, `end`.\x0a     *\x0a     * **Note:** This method mutates `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.2.0\x0a     * @category Array\x0a     * @param {Array} array The array to fill.\x0a     * @param {*} value The value to fill `array` with.\x0a     * @param {number} [start=0] The start position.\x0a     * @param {number} [end=array.length] The end position.\x0a     * @returns {Array} Returns `array`.\x0a     * @example\x0a     *\x0a     * var array = [1, 2, 3];\x0a     *\x0a     * _.fill(array, \x27a\x27);\x0a     * console.log(array);\x0a     * // =\x3e [\x27a\x27, \x27a\x27, \x27a\x27]\x0a     *\x0a     * _.fill(Array(3), 2);\x0a     * // =\x3e [2, 2, 2]\x0a     *\x0a     * _.fill([4, 6, 8, 10], \x27*\x27, 1, 3);\x0a     * // =\x3e [4, \x27*\x27, \x27*\x27, 10]\x0a     */\x0a    function fill(array, value, start, end) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (!length) {\x0a        return [];\x0a      }\x0a      if (start && typeof start != \x27number\x27 && isIterateeCall(array, value, start)) {\x0a        start = 0;\x0a        end = length;\x0a      }\x0a      return baseFill(array, value, start, end);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.find` except that it returns the index of the first\x0a     * element `predicate` returns truthy for instead of the element itself.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 1.1.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @param {number} [fromIndex=0] The index to search from.\x0a     * @returns {number} Returns the index of the found element, else `-1`.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27,  \x27active\x27: false },\x0a     *   { \x27user\x27: \x27fred\x27,    \x27active\x27: false },\x0a     *   { \x27user\x27: \x27pebbles\x27, \x27active\x27: true }\x0a     * ];\x0a     *\x0a     * _.findIndex(users, function(o) { return o.user == \x27barney\x27; });\x0a     * // =\x3e 0\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.findIndex(users, { \x27user\x27: \x27fred\x27, \x27active\x27: false });\x0a     * // =\x3e 1\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.findIndex(users, [\x27active\x27, false]);\x0a     * // =\x3e 0\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.findIndex(users, \x27active\x27);\x0a     * // =\x3e 2\x0a     */\x0a    function findIndex(array, predicate, fromIndex) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (!length) {\x0a        return -1;\x0a      }\x0a      var index = fromIndex == null ? 0 : toInteger(fromIndex);\x0a      if (index \x3c 0) {\x0a        index = nativeMax(length + index, 0);\x0a      }\x0a      return baseFindIndex(array, getIteratee(predicate, 3), index);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.findIndex` except that it iterates over elements\x0a     * of `collection` from right to left.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 2.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @param {number} [fromIndex=array.length-1] The index to search from.\x0a     * @returns {number} Returns the index of the found element, else `-1`.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27,  \x27active\x27: true },\x0a     *   { \x27user\x27: \x27fred\x27,    \x27active\x27: false },\x0a     *   { \x27user\x27: \x27pebbles\x27, \x27active\x27: false }\x0a     * ];\x0a     *\x0a     * _.findLastIndex(users, function(o) { return o.user == \x27pebbles\x27; });\x0a     * // =\x3e 2\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.findLastIndex(users, { \x27user\x27: \x27barney\x27, \x27active\x27: true });\x0a     * // =\x3e 0\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.findLastIndex(users, [\x27active\x27, false]);\x0a     * // =\x3e 2\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.findLastIndex(users, \x27active\x27);\x0a     * // =\x3e 0\x0a     */\x0a    function findLastIndex(array, predicate, fromIndex) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (!length) {\x0a        return -1;\x0a      }\x0a      var index = length - 1;\x0a      if (fromIndex !== undefined) {\x0a        index = toInteger(fromIndex);\x0a        index = fromIndex \x3c 0\x0a          ? nativeMax(length + index, 0)\x0a          : nativeMin(index, length - 1);\x0a      }\x0a      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\x0a    }\x0a\x0a    /**\x0a     * Flattens `array` a single level deep.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {Array} array The array to flatten.\x0a     * @returns {Array} Returns the new flattened array.\x0a     * @example\x0a     *\x0a     * _.flatten([1, [2, [3, [4]], 5]]);\x0a     * // =\x3e [1, 2, [3, [4]], 5]\x0a     */\x0a    function flatten(array) {\x0a      var length = array == null ? 0 : array.length;\x0a      return length ? baseFlatten(array, 1) : [];\x0a    }\x0a\x0a    /**\x0a     * Recursively flattens `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to flatten.\x0a     * @returns {Array} Returns the new flattened array.\x0a     * @example\x0a     *\x0a     * _.flattenDeep([1, [2, [3, [4]], 5]]);\x0a     * // =\x3e [1, 2, 3, 4, 5]\x0a     */\x0a    function flattenDeep(array) {\x0a      var length = array == null ? 0 : array.length;\x0a      return length ? baseFlatten(array, INFINITY) : [];\x0a    }\x0a\x0a    /**\x0a     * Recursively flatten `array` up to `depth` times.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.4.0\x0a     * @category Array\x0a     * @param {Array} array The array to flatten.\x0a     * @param {number} [depth=1] The maximum recursion depth.\x0a     * @returns {Array} Returns the new flattened array.\x0a     * @example\x0a     *\x0a     * var array = [1, [2, [3, [4]], 5]];\x0a     *\x0a     * _.flattenDepth(array, 1);\x0a     * // =\x3e [1, 2, [3, [4]], 5]\x0a     *\x0a     * _.flattenDepth(array, 2);\x0a     * // =\x3e [1, 2, 3, [4], 5]\x0a     */\x0a    function flattenDepth(array, depth) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (!length) {\x0a        return [];\x0a      }\x0a      depth = depth === undefined ? 1 : toInteger(depth);\x0a      return baseFlatten(array, depth);\x0a    }\x0a\x0a    /**\x0a     * The inverse of `_.toPairs`; this method returns an object composed\x0a     * from key-value `pairs`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} pairs The key-value pairs.\x0a     * @returns {Object} Returns the new object.\x0a     * @example\x0a     *\x0a     * _.fromPairs([[\x27a\x27, 1], [\x27b\x27, 2]]);\x0a     * // =\x3e { \x27a\x27: 1, \x27b\x27: 2 }\x0a     */\x0a    function fromPairs(pairs) {\x0a      var index = -1,\x0a          length = pairs == null ? 0 : pairs.length,\x0a          result = {};\x0a\x0a      while (++index \x3c length) {\x0a        var pair = pairs[index];\x0a        result[pair[0]] = pair[1];\x0a      }\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Gets the first element of `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @alias first\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @returns {*} Returns the first element of `array`.\x0a     * @example\x0a     *\x0a     * _.head([1, 2, 3]);\x0a     * // =\x3e 1\x0a     *\x0a     * _.head([]);\x0a     * // =\x3e undefined\x0a     */\x0a    function head(array) {\x0a      return (array && array.length) ? array[0] : undefined;\x0a    }\x0a\x0a    /**\x0a     * Gets the index at which the first occurrence of `value` is found in `array`\x0a     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\x0a     * for equality comparisons. If `fromIndex` is negative, it\x27s used as the\x0a     * offset from the end of `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {*} value The value to search for.\x0a     * @param {number} [fromIndex=0] The index to search from.\x0a     * @returns {number} Returns the index of the matched value, else `-1`.\x0a     * @example\x0a     *\x0a     * _.indexOf([1, 2, 1, 2], 2);\x0a     * // =\x3e 1\x0a     *\x0a     * // Search from the `fromIndex`.\x0a     * _.indexOf([1, 2, 1, 2], 2, 2);\x0a     * // =\x3e 3\x0a     */\x0a    function indexOf(array, value, fromIndex) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (!length) {\x0a        return -1;\x0a      }\x0a      var index = fromIndex == null ? 0 : toInteger(fromIndex);\x0a      if (index \x3c 0) {\x0a        index = nativeMax(length + index, 0);\x0a      }\x0a      return baseIndexOf(array, value, index);\x0a    }\x0a\x0a    /**\x0a     * Gets all but the last element of `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     * @example\x0a     *\x0a     * _.initial([1, 2, 3]);\x0a     * // =\x3e [1, 2]\x0a     */\x0a    function initial(array) {\x0a      var length = array == null ? 0 : array.length;\x0a      return length ? baseSlice(array, 0, -1) : [];\x0a    }\x0a\x0a    /**\x0a     * Creates an array of unique values that are included in all given arrays\x0a     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\x0a     * for equality comparisons. The order and references of result values are\x0a     * determined by the first array.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {...Array} [arrays] The arrays to inspect.\x0a     * @returns {Array} Returns the new array of intersecting values.\x0a     * @example\x0a     *\x0a     * _.intersection([2, 1], [2, 3]);\x0a     * // =\x3e [2]\x0a     */\x0a    var intersection = baseRest(function(arrays) {\x0a      var mapped = arrayMap(arrays, castArrayLikeObject);\x0a      return (mapped.length && mapped[0] === arrays[0])\x0a        ? baseIntersection(mapped)\x0a        : [];\x0a    });\x0a\x0a    /**\x0a     * This method is like `_.intersection` except that it accepts `iteratee`\x0a     * which is invoked for each element of each `arrays` to generate the criterion\x0a     * by which they\x27re compared. The order and references of result values are\x0a     * determined by the first array. The iteratee is invoked with one argument:\x0a     * (value).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {...Array} [arrays] The arrays to inspect.\x0a     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\x0a     * @returns {Array} Returns the new array of intersecting values.\x0a     * @example\x0a     *\x0a     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\x0a     * // =\x3e [2.1]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.intersectionBy([{ \x27x\x27: 1 }], [{ \x27x\x27: 2 }, { \x27x\x27: 1 }], \x27x\x27);\x0a     * // =\x3e [{ \x27x\x27: 1 }]\x0a     */\x0a    var intersectionBy = baseRest(function(arrays) {\x0a      var iteratee = last(arrays),\x0a          mapped = arrayMap(arrays, castArrayLikeObject);\x0a\x0a      if (iteratee === last(mapped)) {\x0a        iteratee = undefined;\x0a      } else {\x0a        mapped.pop();\x0a      }\x0a      return (mapped.length && mapped[0] === arrays[0])\x0a        ? baseIntersection(mapped, getIteratee(iteratee, 2))\x0a        : [];\x0a    });\x0a\x0a    /**\x0a     * This method is like `_.intersection` except that it accepts `comparator`\x0a     * which is invoked to compare elements of `arrays`. The order and references\x0a     * of result values are determined by the first array. The comparator is\x0a     * invoked with two arguments: (arrVal, othVal).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {...Array} [arrays] The arrays to inspect.\x0a     * @param {Function} [comparator] The comparator invoked per element.\x0a     * @returns {Array} Returns the new array of intersecting values.\x0a     * @example\x0a     *\x0a     * var objects = [{ \x27x\x27: 1, \x27y\x27: 2 }, { \x27x\x27: 2, \x27y\x27: 1 }];\x0a     * var others = [{ \x27x\x27: 1, \x27y\x27: 1 }, { \x27x\x27: 1, \x27y\x27: 2 }];\x0a     *\x0a     * _.intersectionWith(objects, others, _.isEqual);\x0a     * // =\x3e [{ \x27x\x27: 1, \x27y\x27: 2 }]\x0a     */\x0a    var intersectionWith = baseRest(function(arrays) {\x0a      var comparator = last(arrays),\x0a          mapped = arrayMap(arrays, castArrayLikeObject);\x0a\x0a      comparator = typeof comparator == \x27function\x27 ? comparator : undefined;\x0a      if (comparator) {\x0a        mapped.pop();\x0a      }\x0a      return (mapped.length && mapped[0] === arrays[0])\x0a        ? baseIntersection(mapped, undefined, comparator)\x0a        : [];\x0a    });\x0a\x0a    /**\x0a     * Converts all elements in `array` into a string separated by `separator`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to convert.\x0a     * @param {string} [separator=\x27,\x27] The element separator.\x0a     * @returns {string} Returns the joined string.\x0a     * @example\x0a     *\x0a     * _.join([\x27a\x27, \x27b\x27, \x27c\x27], \x27~\x27);\x0a     * // =\x3e \x27a~b~c\x27\x0a     */\x0a    function join(array, separator) {\x0a      return array == null ? \x27\x27 : nativeJoin.call(array, separator);\x0a    }\x0a\x0a    /**\x0a     * Gets the last element of `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @returns {*} Returns the last element of `array`.\x0a     * @example\x0a     *\x0a     * _.last([1, 2, 3]);\x0a     * // =\x3e 3\x0a     */\x0a    function last(array) {\x0a      var length = array == null ? 0 : array.length;\x0a      return length ? array[length - 1] : undefined;\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.indexOf` except that it iterates over elements of\x0a     * `array` from right to left.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {*} value The value to search for.\x0a     * @param {number} [fromIndex=array.length-1] The index to search from.\x0a     * @returns {number} Returns the index of the matched value, else `-1`.\x0a     * @example\x0a     *\x0a     * _.lastIndexOf([1, 2, 1, 2], 2);\x0a     * // =\x3e 3\x0a     *\x0a     * // Search from the `fromIndex`.\x0a     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\x0a     * // =\x3e 1\x0a     */\x0a    function lastIndexOf(array, value, fromIndex) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (!length) {\x0a        return -1;\x0a      }\x0a      var index = length;\x0a      if (fromIndex !== undefined) {\x0a        index = toInteger(fromIndex);\x0a        index = index \x3c 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\x0a      }\x0a      return value === value\x0a        ? strictLastIndexOf(array, value, index)\x0a        : baseFindIndex(array, baseIsNaN, index, true);\x0a    }\x0a\x0a    /**\x0a     * Gets the element at index `n` of `array`. If `n` is negative, the nth\x0a     * element from the end is returned.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.11.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @param {number} [n=0] The index of the element to return.\x0a     * @returns {*} Returns the nth element of `array`.\x0a     * @example\x0a     *\x0a     * var array = [\x27a\x27, \x27b\x27, \x27c\x27, \x27d\x27];\x0a     *\x0a     * _.nth(array, 1);\x0a     * // =\x3e \x27b\x27\x0a     *\x0a     * _.nth(array, -2);\x0a     * // =\x3e \x27c\x27;\x0a     */\x0a    function nth(array, n) {\x0a      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\x0a    }\x0a\x0a    /**\x0a     * Removes all given values from `array` using\x0a     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\x0a     * for equality comparisons.\x0a     *\x0a     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\x0a     * to remove elements from an array by predicate.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 2.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to modify.\x0a     * @param {...*} [values] The values to remove.\x0a     * @returns {Array} Returns `array`.\x0a     * @example\x0a     *\x0a     * var array = [\x27a\x27, \x27b\x27, \x27c\x27, \x27a\x27, \x27b\x27, \x27c\x27];\x0a     *\x0a     * _.pull(array, \x27a\x27, \x27c\x27);\x0a     * console.log(array);\x0a     * // =\x3e [\x27b\x27, \x27b\x27]\x0a     */\x0a    var pull = baseRest(pullAll);\x0a\x0a    /**\x0a     * This method is like `_.pull` except that it accepts an array of values to remove.\x0a     *\x0a     * **Note:** Unlike `_.difference`, this method mutates `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to modify.\x0a     * @param {Array} values The values to remove.\x0a     * @returns {Array} Returns `array`.\x0a     * @example\x0a     *\x0a     * var array = [\x27a\x27, \x27b\x27, \x27c\x27, \x27a\x27, \x27b\x27, \x27c\x27];\x0a     *\x0a     * _.pullAll(array, [\x27a\x27, \x27c\x27]);\x0a     * console.log(array);\x0a     * // =\x3e [\x27b\x27, \x27b\x27]\x0a     */\x0a    function pullAll(array, values) {\x0a      return (array && array.length && values && values.length)\x0a        ? basePullAll(array, values)\x0a        : array;\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.pullAll` except that it accepts `iteratee` which is\x0a     * invoked for each element of `array` and `values` to generate the criterion\x0a     * by which they\x27re compared. The iteratee is invoked with one argument: (value).\x0a     *\x0a     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to modify.\x0a     * @param {Array} values The values to remove.\x0a     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\x0a     * @returns {Array} Returns `array`.\x0a     * @example\x0a     *\x0a     * var array = [{ \x27x\x27: 1 }, { \x27x\x27: 2 }, { \x27x\x27: 3 }, { \x27x\x27: 1 }];\x0a     *\x0a     * _.pullAllBy(array, [{ \x27x\x27: 1 }, { \x27x\x27: 3 }], \x27x\x27);\x0a     * console.log(array);\x0a     * // =\x3e [{ \x27x\x27: 2 }]\x0a     */\x0a    function pullAllBy(array, values, iteratee) {\x0a      return (array && array.length && values && values.length)\x0a        ? basePullAll(array, values, getIteratee(iteratee, 2))\x0a        : array;\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.pullAll` except that it accepts `comparator` which\x0a     * is invoked to compare elements of `array` to `values`. The comparator is\x0a     * invoked with two arguments: (arrVal, othVal).\x0a     *\x0a     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.6.0\x0a     * @category Array\x0a     * @param {Array} array The array to modify.\x0a     * @param {Array} values The values to remove.\x0a     * @param {Function} [comparator] The comparator invoked per element.\x0a     * @returns {Array} Returns `array`.\x0a     * @example\x0a     *\x0a     * var array = [{ \x27x\x27: 1, \x27y\x27: 2 }, { \x27x\x27: 3, \x27y\x27: 4 }, { \x27x\x27: 5, \x27y\x27: 6 }];\x0a     *\x0a     * _.pullAllWith(array, [{ \x27x\x27: 3, \x27y\x27: 4 }], _.isEqual);\x0a     * console.log(array);\x0a     * // =\x3e [{ \x27x\x27: 1, \x27y\x27: 2 }, { \x27x\x27: 5, \x27y\x27: 6 }]\x0a     */\x0a    function pullAllWith(array, values, comparator) {\x0a      return (array && array.length && values && values.length)\x0a        ? basePullAll(array, values, undefined, comparator)\x0a        : array;\x0a    }\x0a\x0a    /**\x0a     * Removes elements from `array` corresponding to `indexes` and returns an\x0a     * array of removed elements.\x0a     *\x0a     * **Note:** Unlike `_.at`, this method mutates `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to modify.\x0a     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\x0a     * @returns {Array} Returns the new array of removed elements.\x0a     * @example\x0a     *\x0a     * var array = [\x27a\x27, \x27b\x27, \x27c\x27, \x27d\x27];\x0a     * var pulled = _.pullAt(array, [1, 3]);\x0a     *\x0a     * console.log(array);\x0a     * // =\x3e [\x27a\x27, \x27c\x27]\x0a     *\x0a     * console.log(pulled);\x0a     * // =\x3e [\x27b\x27, \x27d\x27]\x0a     */\x0a    var pullAt = flatRest(function(array, indexes) {\x0a      var length = array == null ? 0 : array.length,\x0a          result = baseAt(array, indexes);\x0a\x0a      basePullAt(array, arrayMap(indexes, function(index) {\x0a        return isIndex(index, length) ? +index : index;\x0a      }).sort(compareAscending));\x0a\x0a      return result;\x0a    });\x0a\x0a    /**\x0a     * Removes all elements from `array` that `predicate` returns truthy for\x0a     * and returns an array of the removed elements. The predicate is invoked\x0a     * with three arguments: (value, index, array).\x0a     *\x0a     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\x0a     * to pull elements from an array by value.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 2.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to modify.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @returns {Array} Returns the new array of removed elements.\x0a     * @example\x0a     *\x0a     * var array = [1, 2, 3, 4];\x0a     * var evens = _.remove(array, function(n) {\x0a     *   return n % 2 == 0;\x0a     * });\x0a     *\x0a     * console.log(array);\x0a     * // =\x3e [1, 3]\x0a     *\x0a     * console.log(evens);\x0a     * // =\x3e [2, 4]\x0a     */\x0a    function remove(array, predicate) {\x0a      var result = [];\x0a      if (!(array && array.length)) {\x0a        return result;\x0a      }\x0a      var index = -1,\x0a          indexes = [],\x0a          length = array.length;\x0a\x0a      predicate = getIteratee(predicate, 3);\x0a      while (++index \x3c length) {\x0a        var value = array[index];\x0a        if (predicate(value, index, array)) {\x0a          result.push(value);\x0a          indexes.push(index);\x0a        }\x0a      }\x0a      basePullAt(array, indexes);\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Reverses `array` so that the first element becomes the last, the second\x0a     * element becomes the second to last, and so on.\x0a     *\x0a     * **Note:** This method mutates `array` and is based on\x0a     * [`Array#reverse`](https://mdn.io/Array/reverse).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to modify.\x0a     * @returns {Array} Returns `array`.\x0a     * @example\x0a     *\x0a     * var array = [1, 2, 3];\x0a     *\x0a     * _.reverse(array);\x0a     * // =\x3e [3, 2, 1]\x0a     *\x0a     * console.log(array);\x0a     * // =\x3e [3, 2, 1]\x0a     */\x0a    function reverse(array) {\x0a      return array == null ? array : nativeReverse.call(array);\x0a    }\x0a\x0a    /**\x0a     * Creates a slice of `array` from `start` up to, but not including, `end`.\x0a     *\x0a     * **Note:** This method is used instead of\x0a     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\x0a     * returned.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to slice.\x0a     * @param {number} [start=0] The start position.\x0a     * @param {number} [end=array.length] The end position.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     */\x0a    function slice(array, start, end) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (!length) {\x0a        return [];\x0a      }\x0a      if (end && typeof end != \x27number\x27 && isIterateeCall(array, start, end)) {\x0a        start = 0;\x0a        end = length;\x0a      }\x0a      else {\x0a        start = start == null ? 0 : toInteger(start);\x0a        end = end === undefined ? length : toInteger(end);\x0a      }\x0a      return baseSlice(array, start, end);\x0a    }\x0a\x0a    /**\x0a     * Uses a binary search to determine the lowest index at which `value`\x0a     * should be inserted into `array` in order to maintain its sort order.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {Array} array The sorted array to inspect.\x0a     * @param {*} value The value to evaluate.\x0a     * @returns {number} Returns the index at which `value` should be inserted\x0a     *  into `array`.\x0a     * @example\x0a     *\x0a     * _.sortedIndex([30, 50], 40);\x0a     * // =\x3e 1\x0a     */\x0a    function sortedIndex(array, value) {\x0a      return baseSortedIndex(array, value);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.sortedIndex` except that it accepts `iteratee`\x0a     * which is invoked for `value` and each element of `array` to compute their\x0a     * sort ranking. The iteratee is invoked with one argument: (value).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The sorted array to inspect.\x0a     * @param {*} value The value to evaluate.\x0a     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\x0a     * @returns {number} Returns the index at which `value` should be inserted\x0a     *  into `array`.\x0a     * @example\x0a     *\x0a     * var objects = [{ \x27x\x27: 4 }, { \x27x\x27: 5 }];\x0a     *\x0a     * _.sortedIndexBy(objects, { \x27x\x27: 4 }, function(o) { return o.x; });\x0a     * // =\x3e 0\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.sortedIndexBy(objects, { \x27x\x27: 4 }, \x27x\x27);\x0a     * // =\x3e 0\x0a     */\x0a    function sortedIndexBy(array, value, iteratee) {\x0a      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.indexOf` except that it performs a binary\x0a     * search on a sorted `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {*} value The value to search for.\x0a     * @returns {number} Returns the index of the matched value, else `-1`.\x0a     * @example\x0a     *\x0a     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\x0a     * // =\x3e 1\x0a     */\x0a    function sortedIndexOf(array, value) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (length) {\x0a        var index = baseSortedIndex(array, value);\x0a        if (index \x3c length && eq(array[index], value)) {\x0a          return index;\x0a        }\x0a      }\x0a      return -1;\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.sortedIndex` except that it returns the highest\x0a     * index at which `value` should be inserted into `array` in order to\x0a     * maintain its sort order.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Array\x0a     * @param {Array} array The sorted array to inspect.\x0a     * @param {*} value The value to evaluate.\x0a     * @returns {number} Returns the index at which `value` should be inserted\x0a     *  into `array`.\x0a     * @example\x0a     *\x0a     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\x0a     * // =\x3e 4\x0a     */\x0a    function sortedLastIndex(array, value) {\x0a      return baseSortedIndex(array, value, true);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\x0a     * which is invoked for `value` and each element of `array` to compute their\x0a     * sort ranking. The iteratee is invoked with one argument: (value).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The sorted array to inspect.\x0a     * @param {*} value The value to evaluate.\x0a     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\x0a     * @returns {number} Returns the index at which `value` should be inserted\x0a     *  into `array`.\x0a     * @example\x0a     *\x0a     * var objects = [{ \x27x\x27: 4 }, { \x27x\x27: 5 }];\x0a     *\x0a     * _.sortedLastIndexBy(objects, { \x27x\x27: 4 }, function(o) { return o.x; });\x0a     * // =\x3e 1\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.sortedLastIndexBy(objects, { \x27x\x27: 4 }, \x27x\x27);\x0a     * // =\x3e 1\x0a     */\x0a    function sortedLastIndexBy(array, value, iteratee) {\x0a      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.lastIndexOf` except that it performs a binary\x0a     * search on a sorted `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {*} value The value to search for.\x0a     * @returns {number} Returns the index of the matched value, else `-1`.\x0a     * @example\x0a     *\x0a     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\x0a     * // =\x3e 3\x0a     */\x0a    function sortedLastIndexOf(array, value) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (length) {\x0a        var index = baseSortedIndex(array, value, true) - 1;\x0a        if (eq(array[index], value)) {\x0a          return index;\x0a        }\x0a      }\x0a      return -1;\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.uniq` except that it\x27s designed and optimized\x0a     * for sorted arrays.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @returns {Array} Returns the new duplicate free array.\x0a     * @example\x0a     *\x0a     * _.sortedUniq([1, 1, 2]);\x0a     * // =\x3e [1, 2]\x0a     */\x0a    function sortedUniq(array) {\x0a      return (array && array.length)\x0a        ? baseSortedUniq(array)\x0a        : [];\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.uniqBy` except that it\x27s designed and optimized\x0a     * for sorted arrays.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {Function} [iteratee] The iteratee invoked per element.\x0a     * @returns {Array} Returns the new duplicate free array.\x0a     * @example\x0a     *\x0a     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\x0a     * // =\x3e [1.1, 2.3]\x0a     */\x0a    function sortedUniqBy(array, iteratee) {\x0a      return (array && array.length)\x0a        ? baseSortedUniq(array, getIteratee(iteratee, 2))\x0a        : [];\x0a    }\x0a\x0a    /**\x0a     * Gets all but the first element of `array`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     * @example\x0a     *\x0a     * _.tail([1, 2, 3]);\x0a     * // =\x3e [2, 3]\x0a     */\x0a    function tail(array) {\x0a      var length = array == null ? 0 : array.length;\x0a      return length ? baseSlice(array, 1, length) : [];\x0a    }\x0a\x0a    /**\x0a     * Creates a slice of `array` with `n` elements taken from the beginning.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @param {number} [n=1] The number of elements to take.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     * @example\x0a     *\x0a     * _.take([1, 2, 3]);\x0a     * // =\x3e [1]\x0a     *\x0a     * _.take([1, 2, 3], 2);\x0a     * // =\x3e [1, 2]\x0a     *\x0a     * _.take([1, 2, 3], 5);\x0a     * // =\x3e [1, 2, 3]\x0a     *\x0a     * _.take([1, 2, 3], 0);\x0a     * // =\x3e []\x0a     */\x0a    function take(array, n, guard) {\x0a      if (!(array && array.length)) {\x0a        return [];\x0a      }\x0a      n = (guard || n === undefined) ? 1 : toInteger(n);\x0a      return baseSlice(array, 0, n \x3c 0 ? 0 : n);\x0a    }\x0a\x0a    /**\x0a     * Creates a slice of `array` with `n` elements taken from the end.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @param {number} [n=1] The number of elements to take.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     * @example\x0a     *\x0a     * _.takeRight([1, 2, 3]);\x0a     * // =\x3e [3]\x0a     *\x0a     * _.takeRight([1, 2, 3], 2);\x0a     * // =\x3e [2, 3]\x0a     *\x0a     * _.takeRight([1, 2, 3], 5);\x0a     * // =\x3e [1, 2, 3]\x0a     *\x0a     * _.takeRight([1, 2, 3], 0);\x0a     * // =\x3e []\x0a     */\x0a    function takeRight(array, n, guard) {\x0a      var length = array == null ? 0 : array.length;\x0a      if (!length) {\x0a        return [];\x0a      }\x0a      n = (guard || n === undefined) ? 1 : toInteger(n);\x0a      n = length - n;\x0a      return baseSlice(array, n \x3c 0 ? 0 : n, length);\x0a    }\x0a\x0a    /**\x0a     * Creates a slice of `array` with elements taken from the end. Elements are\x0a     * taken until `predicate` returns falsey. The predicate is invoked with\x0a     * three arguments: (value, index, array).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27,  \x27active\x27: true },\x0a     *   { \x27user\x27: \x27fred\x27,    \x27active\x27: false },\x0a     *   { \x27user\x27: \x27pebbles\x27, \x27active\x27: false }\x0a     * ];\x0a     *\x0a     * _.takeRightWhile(users, function(o) { return !o.active; });\x0a     * // =\x3e objects for [\x27fred\x27, \x27pebbles\x27]\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.takeRightWhile(users, { \x27user\x27: \x27pebbles\x27, \x27active\x27: false });\x0a     * // =\x3e objects for [\x27pebbles\x27]\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.takeRightWhile(users, [\x27active\x27, false]);\x0a     * // =\x3e objects for [\x27fred\x27, \x27pebbles\x27]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.takeRightWhile(users, \x27active\x27);\x0a     * // =\x3e []\x0a     */\x0a    function takeRightWhile(array, predicate) {\x0a      return (array && array.length)\x0a        ? baseWhile(array, getIteratee(predicate, 3), false, true)\x0a        : [];\x0a    }\x0a\x0a    /**\x0a     * Creates a slice of `array` with elements taken from the beginning. Elements\x0a     * are taken until `predicate` returns falsey. The predicate is invoked with\x0a     * three arguments: (value, index, array).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to query.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @returns {Array} Returns the slice of `array`.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27,  \x27active\x27: false },\x0a     *   { \x27user\x27: \x27fred\x27,    \x27active\x27: false },\x0a     *   { \x27user\x27: \x27pebbles\x27, \x27active\x27: true }\x0a     * ];\x0a     *\x0a     * _.takeWhile(users, function(o) { return !o.active; });\x0a     * // =\x3e objects for [\x27barney\x27, \x27fred\x27]\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.takeWhile(users, { \x27user\x27: \x27barney\x27, \x27active\x27: false });\x0a     * // =\x3e objects for [\x27barney\x27]\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.takeWhile(users, [\x27active\x27, false]);\x0a     * // =\x3e objects for [\x27barney\x27, \x27fred\x27]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.takeWhile(users, \x27active\x27);\x0a     * // =\x3e []\x0a     */\x0a    function takeWhile(array, predicate) {\x0a      return (array && array.length)\x0a        ? baseWhile(array, getIteratee(predicate, 3))\x0a        : [];\x0a    }\x0a\x0a    /**\x0a     * Creates an array of unique values, in order, from all given arrays using\x0a     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\x0a     * for equality comparisons.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {...Array} [arrays] The arrays to inspect.\x0a     * @returns {Array} Returns the new array of combined values.\x0a     * @example\x0a     *\x0a     * _.union([2], [1, 2]);\x0a     * // =\x3e [2, 1]\x0a     */\x0a    var union = baseRest(function(arrays) {\x0a      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\x0a    });\x0a\x0a    /**\x0a     * This method is like `_.union` except that it accepts `iteratee` which is\x0a     * invoked for each element of each `arrays` to generate the criterion by\x0a     * which uniqueness is computed. Result values are chosen from the first\x0a     * array in which the value occurs. The iteratee is invoked with one argument:\x0a     * (value).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {...Array} [arrays] The arrays to inspect.\x0a     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\x0a     * @returns {Array} Returns the new array of combined values.\x0a     * @example\x0a     *\x0a     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\x0a     * // =\x3e [2.1, 1.2]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.unionBy([{ \x27x\x27: 1 }], [{ \x27x\x27: 2 }, { \x27x\x27: 1 }], \x27x\x27);\x0a     * // =\x3e [{ \x27x\x27: 1 }, { \x27x\x27: 2 }]\x0a     */\x0a    var unionBy = baseRest(function(arrays) {\x0a      var iteratee = last(arrays);\x0a      if (isArrayLikeObject(iteratee)) {\x0a        iteratee = undefined;\x0a      }\x0a      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\x0a    });\x0a\x0a    /**\x0a     * This method is like `_.union` except that it accepts `comparator` which\x0a     * is invoked to compare elements of `arrays`. Result values are chosen from\x0a     * the first array in which the value occurs. The comparator is invoked\x0a     * with two arguments: (arrVal, othVal).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {...Array} [arrays] The arrays to inspect.\x0a     * @param {Function} [comparator] The comparator invoked per element.\x0a     * @returns {Array} Returns the new array of combined values.\x0a     * @example\x0a     *\x0a     * var objects = [{ \x27x\x27: 1, \x27y\x27: 2 }, { \x27x\x27: 2, \x27y\x27: 1 }];\x0a     * var others = [{ \x27x\x27: 1, \x27y\x27: 1 }, { \x27x\x27: 1, \x27y\x27: 2 }];\x0a     *\x0a     * _.unionWith(objects, others, _.isEqual);\x0a     * // =\x3e [{ \x27x\x27: 1, \x27y\x27: 2 }, { \x27x\x27: 2, \x27y\x27: 1 }, { \x27x\x27: 1, \x27y\x27: 1 }]\x0a     */\x0a    var unionWith = baseRest(function(arrays) {\x0a      var comparator = last(arrays);\x0a      comparator = typeof comparator == \x27function\x27 ? comparator : undefined;\x0a      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\x0a    });\x0a\x0a    /**\x0a     * Creates a duplicate-free version of an array, using\x0a     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\x0a     * for equality comparisons, in which only the first occurrence of each element\x0a     * is kept. The order of result values is determined by the order they occur\x0a     * in the array.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @returns {Array} Returns the new duplicate free array.\x0a     * @example\x0a     *\x0a     * _.uniq([2, 1, 2]);\x0a     * // =\x3e [2, 1]\x0a     */\x0a    function uniq(array) {\x0a      return (array && array.length) ? baseUniq(array) : [];\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.uniq` except that it accepts `iteratee` which is\x0a     * invoked for each element in `array` to generate the criterion by which\x0a     * uniqueness is computed. The order of result values is determined by the\x0a     * order they occur in the array. The iteratee is invoked with one argument:\x0a     * (value).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\x0a     * @returns {Array} Returns the new duplicate free array.\x0a     * @example\x0a     *\x0a     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\x0a     * // =\x3e [2.1, 1.2]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.uniqBy([{ \x27x\x27: 1 }, { \x27x\x27: 2 }, { \x27x\x27: 1 }], \x27x\x27);\x0a     * // =\x3e [{ \x27x\x27: 1 }, { \x27x\x27: 2 }]\x0a     */\x0a    function uniqBy(array, iteratee) {\x0a      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.uniq` except that it accepts `comparator` which\x0a     * is invoked to compare elements of `array`. The order of result values is\x0a     * determined by the order they occur in the array.The comparator is invoked\x0a     * with two arguments: (arrVal, othVal).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {Function} [comparator] The comparator invoked per element.\x0a     * @returns {Array} Returns the new duplicate free array.\x0a     * @example\x0a     *\x0a     * var objects = [{ \x27x\x27: 1, \x27y\x27: 2 }, { \x27x\x27: 2, \x27y\x27: 1 }, { \x27x\x27: 1, \x27y\x27: 2 }];\x0a     *\x0a     * _.uniqWith(objects, _.isEqual);\x0a     * // =\x3e [{ \x27x\x27: 1, \x27y\x27: 2 }, { \x27x\x27: 2, \x27y\x27: 1 }]\x0a     */\x0a    function uniqWith(array, comparator) {\x0a      comparator = typeof comparator == \x27function\x27 ? comparator : undefined;\x0a      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.zip` except that it accepts an array of grouped\x0a     * elements and creates an array regrouping the elements to their pre-zip\x0a     * configuration.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 1.2.0\x0a     * @category Array\x0a     * @param {Array} array The array of grouped elements to process.\x0a     * @returns {Array} Returns the new array of regrouped elements.\x0a     * @example\x0a     *\x0a     * var zipped = _.zip([\x27a\x27, \x27b\x27], [1, 2], [true, false]);\x0a     * // =\x3e [[\x27a\x27, 1, true], [\x27b\x27, 2, false]]\x0a     *\x0a     * _.unzip(zipped);\x0a     * // =\x3e [[\x27a\x27, \x27b\x27], [1, 2], [true, false]]\x0a     */\x0a    function unzip(array) {\x0a      if (!(array && array.length)) {\x0a        return [];\x0a      }\x0a      var length = 0;\x0a      array = arrayFilter(array, function(group) {\x0a        if (isArrayLikeObject(group)) {\x0a          length = nativeMax(group.length, length);\x0a          return true;\x0a        }\x0a      });\x0a      return baseTimes(length, function(index) {\x0a        return arrayMap(array, baseProperty(index));\x0a      });\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.unzip` except that it accepts `iteratee` to specify\x0a     * how regrouped values should be combined. The iteratee is invoked with the\x0a     * elements of each group: (...group).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.8.0\x0a     * @category Array\x0a     * @param {Array} array The array of grouped elements to process.\x0a     * @param {Function} [iteratee=_.identity] The function to combine\x0a     *  regrouped values.\x0a     * @returns {Array} Returns the new array of regrouped elements.\x0a     * @example\x0a     *\x0a     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\x0a     * // =\x3e [[1, 10, 100], [2, 20, 200]]\x0a     *\x0a     * _.unzipWith(zipped, _.add);\x0a     * // =\x3e [3, 30, 300]\x0a     */\x0a    function unzipWith(array, iteratee) {\x0a      if (!(array && array.length)) {\x0a        return [];\x0a      }\x0a      var result = unzip(array);\x0a      if (iteratee == null) {\x0a        return result;\x0a      }\x0a      return arrayMap(result, function(group) {\x0a        return apply(iteratee, undefined, group);\x0a      });\x0a    }\x0a\x0a    /**\x0a     * Creates an array excluding all given values using\x0a     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\x0a     * for equality comparisons.\x0a     *\x0a     * **Note:** Unlike `_.pull`, this method returns a new array.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {Array} array The array to inspect.\x0a     * @param {...*} [values] The values to exclude.\x0a     * @returns {Array} Returns the new array of filtered values.\x0a     * @see _.difference, _.xor\x0a     * @example\x0a     *\x0a     * _.without([2, 1, 2, 3], 1, 2);\x0a     * // =\x3e [3]\x0a     */\x0a    var without = baseRest(function(array, values) {\x0a      return isArrayLikeObject(array)\x0a        ? baseDifference(array, values)\x0a        : [];\x0a    });\x0a\x0a    /**\x0a     * Creates an array of unique values that is the\x0a     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\x0a     * of the given arrays. The order of result values is determined by the order\x0a     * they occur in the arrays.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 2.4.0\x0a     * @category Array\x0a     * @param {...Array} [arrays] The arrays to inspect.\x0a     * @returns {Array} Returns the new array of filtered values.\x0a     * @see _.difference, _.without\x0a     * @example\x0a     *\x0a     * _.xor([2, 1], [2, 3]);\x0a     * // =\x3e [1, 3]\x0a     */\x0a    var xor = baseRest(function(arrays) {\x0a      return baseXor(arrayFilter(arrays, isArrayLikeObject));\x0a    });\x0a\x0a    /**\x0a     * This method is like `_.xor` except that it accepts `iteratee` which is\x0a     * invoked for each element of each `arrays` to generate the criterion by\x0a     * which by which they\x27re compared. The order of result values is determined\x0a     * by the order they occur in the arrays. The iteratee is invoked with one\x0a     * argument: (value).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {...Array} [arrays] The arrays to inspect.\x0a     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\x0a     * @returns {Array} Returns the new array of filtered values.\x0a     * @example\x0a     *\x0a     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\x0a     * // =\x3e [1.2, 3.4]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.xorBy([{ \x27x\x27: 1 }], [{ \x27x\x27: 2 }, { \x27x\x27: 1 }], \x27x\x27);\x0a     * // =\x3e [{ \x27x\x27: 2 }]\x0a     */\x0a    var xorBy = baseRest(function(arrays) {\x0a      var iteratee = last(arrays);\x0a      if (isArrayLikeObject(iteratee)) {\x0a        iteratee = undefined;\x0a      }\x0a      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\x0a    });\x0a\x0a    /**\x0a     * This method is like `_.xor` except that it accepts `comparator` which is\x0a     * invoked to compare elements of `arrays`. The order of result values is\x0a     * determined by the order they occur in the arrays. The comparator is invoked\x0a     * with two arguments: (arrVal, othVal).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Array\x0a     * @param {...Array} [arrays] The arrays to inspect.\x0a     * @param {Function} [comparator] The comparator invoked per element.\x0a     * @returns {Array} Returns the new array of filtered values.\x0a     * @example\x0a     *\x0a     * var objects = [{ \x27x\x27: 1, \x27y\x27: 2 }, { \x27x\x27: 2, \x27y\x27: 1 }];\x0a     * var others = [{ \x27x\x27: 1, \x27y\x27: 1 }, { \x27x\x27: 1, \x27y\x27: 2 }];\x0a     *\x0a     * _.xorWith(objects, others, _.isEqual);\x0a     * // =\x3e [{ \x27x\x27: 2, \x27y\x27: 1 }, { \x27x\x27: 1, \x27y\x27: 1 }]\x0a     */\x0a    var xorWith = baseRest(function(arrays) {\x0a      var comparator = last(arrays);\x0a      comparator = typeof comparator == \x27function\x27 ? comparator : undefined;\x0a      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\x0a    });\x0a\x0a    /**\x0a     * Creates an array of grouped elements, the first of which contains the\x0a     * first elements of the given arrays, the second of which contains the\x0a     * second elements of the given arrays, and so on.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Array\x0a     * @param {...Array} [arrays] The arrays to process.\x0a     * @returns {Array} Returns the new array of grouped elements.\x0a     * @example\x0a     *\x0a     * _.zip([\x27a\x27, \x27b\x27], [1, 2], [true, false]);\x0a     * // =\x3e [[\x27a\x27, 1, true], [\x27b\x27, 2, false]]\x0a     */\x0a    var zip = baseRest(unzip);\x0a\x0a    /**\x0a     * This method is like `_.fromPairs` except that it accepts two arrays,\x0a     * one of property identifiers and one of corresponding values.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.4.0\x0a     * @category Array\x0a     * @param {Array} [props=[]] The property identifiers.\x0a     * @param {Array} [values=[]] The property values.\x0a     * @returns {Object} Returns the new object.\x0a     * @example\x0a     *\x0a     * _.zipObject([\x27a\x27, \x27b\x27], [1, 2]);\x0a     * // =\x3e { \x27a\x27: 1, \x27b\x27: 2 }\x0a     */\x0a    function zipObject(props, values) {\x0a      return baseZipObject(props || [], values || [], assignValue);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.zipObject` except that it supports property paths.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.1.0\x0a     * @category Array\x0a     * @param {Array} [props=[]] The property identifiers.\x0a     * @param {Array} [values=[]] The property values.\x0a     * @returns {Object} Returns the new object.\x0a     * @example\x0a     *\x0a     * _.zipObjectDeep([\x27a.b[0].c\x27, \x27a.b[1].d\x27], [1, 2]);\x0a     * // =\x3e { \x27a\x27: { \x27b\x27: [{ \x27c\x27: 1 }, { \x27d\x27: 2 }] } }\x0a     */\x0a    function zipObjectDeep(props, values) {\x0a      return baseZipObject(props || [], values || [], baseSet);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.zip` except that it accepts `iteratee` to specify\x0a     * how grouped values should be combined. The iteratee is invoked with the\x0a     * elements of each group: (...group).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.8.0\x0a     * @category Array\x0a     * @param {...Array} [arrays] The arrays to process.\x0a     * @param {Function} [iteratee=_.identity] The function to combine\x0a     *  grouped values.\x0a     * @returns {Array} Returns the new array of grouped elements.\x0a     * @example\x0a     *\x0a     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\x0a     *   return a + b + c;\x0a     * });\x0a     * // =\x3e [111, 222]\x0a     */\x0a    var zipWith = baseRest(function(arrays) {\x0a      var length = arrays.length,\x0a          iteratee = length \x3e 1 ? arrays[length - 1] : undefined;\x0a\x0a      iteratee = typeof iteratee == \x27function\x27 ? (arrays.pop(), iteratee) : undefined;\x0a      return unzipWith(arrays, iteratee);\x0a    });\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\x0a     * chain sequences enabled. The result of such sequences must be unwrapped\x0a     * with `_#value`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 1.3.0\x0a     * @category Seq\x0a     * @param {*} value The value to wrap.\x0a     * @returns {Object} Returns the new `lodash` wrapper instance.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27,  \x27age\x27: 36 },\x0a     *   { \x27user\x27: \x27fred\x27,    \x27age\x27: 40 },\x0a     *   { \x27user\x27: \x27pebbles\x27, \x27age\x27: 1 }\x0a     * ];\x0a     *\x0a     * var youngest = _\x0a     *   .chain(users)\x0a     *   .sortBy(\x27age\x27)\x0a     *   .map(function(o) {\x0a     *     return o.user + \x27 is \x27 + o.age;\x0a     *   })\x0a     *   .head()\x0a     *   .value();\x0a     * // =\x3e \x27pebbles is 1\x27\x0a     */\x0a    function chain(value) {\x0a      var result = lodash(value);\x0a      result.__chain__ = true;\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * This method invokes `interceptor` and returns `value`. The interceptor\x0a     * is invoked with one argument; (value). The purpose of this method is to\x0a     * \x22tap into\x22 a method chain sequence in order to modify intermediate results.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Seq\x0a     * @param {*} value The value to provide to `interceptor`.\x0a     * @param {Function} interceptor The function to invoke.\x0a     * @returns {*} Returns `value`.\x0a     * @example\x0a     *\x0a     * _([1, 2, 3])\x0a     *  .tap(function(array) {\x0a     *    // Mutate input array.\x0a     *    array.pop();\x0a     *  })\x0a     *  .reverse()\x0a     *  .value();\x0a     * // =\x3e [2, 1]\x0a     */\x0a    function tap(value, interceptor) {\x0a      interceptor(value);\x0a      return value;\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.tap` except that it returns the result of `interceptor`.\x0a     * The purpose of this method is to \x22pass thru\x22 values replacing intermediate\x0a     * results in a method chain sequence.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Seq\x0a     * @param {*} value The value to provide to `interceptor`.\x0a     * @param {Function} interceptor The function to invoke.\x0a     * @returns {*} Returns the result of `interceptor`.\x0a     * @example\x0a     *\x0a     * _(\x27  abc  \x27)\x0a     *  .chain()\x0a     *  .trim()\x0a     *  .thru(function(value) {\x0a     *    return [value];\x0a     *  })\x0a     *  .value();\x0a     * // =\x3e [\x27abc\x27]\x0a     */\x0a    function thru(value, interceptor) {\x0a      return interceptor(value);\x0a    }\x0a\x0a    /**\x0a     * This method is the wrapper version of `_.at`.\x0a     *\x0a     * @name at\x0a     * @memberOf _\x0a     * @since 1.0.0\x0a     * @category Seq\x0a     * @param {...(string|string[])} [paths] The property paths to pick.\x0a     * @returns {Object} Returns the new `lodash` wrapper instance.\x0a     * @example\x0a     *\x0a     * var object = { \x27a\x27: [{ \x27b\x27: { \x27c\x27: 3 } }, 4] };\x0a     *\x0a     * _(object).at([\x27a[0].b.c\x27, \x27a[1]\x27]).value();\x0a     * // =\x3e [3, 4]\x0a     */\x0a    var wrapperAt = flatRest(function(paths) {\x0a      var length = paths.length,\x0a          start = length ? paths[0] : 0,\x0a          value = this.__wrapped__,\x0a          interceptor = function(object) { return baseAt(object, paths); };\x0a\x0a      if (length \x3e 1 || this.__actions__.length ||\x0a          !(value instanceof LazyWrapper) || !isIndex(start)) {\x0a        return this.thru(interceptor);\x0a      }\x0a      value = value.slice(start, +start + (length ? 1 : 0));\x0a      value.__actions__.push({\x0a        \x27func\x27: thru,\x0a        \x27args\x27: [interceptor],\x0a        \x27thisArg\x27: undefined\x0a      });\x0a      return new LodashWrapper(value, this.__chain__).thru(function(array) {\x0a        if (length && !array.length) {\x0a          array.push(undefined);\x0a        }\x0a        return array;\x0a      });\x0a    });\x0a\x0a    /**\x0a     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\x0a     *\x0a     * @name chain\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Seq\x0a     * @returns {Object} Returns the new `lodash` wrapper instance.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27, \x27age\x27: 36 },\x0a     *   { \x27user\x27: \x27fred\x27,   \x27age\x27: 40 }\x0a     * ];\x0a     *\x0a     * // A sequence without explicit chaining.\x0a     * _(users).head();\x0a     * // =\x3e { \x27user\x27: \x27barney\x27, \x27age\x27: 36 }\x0a     *\x0a     * // A sequence with explicit chaining.\x0a     * _(users)\x0a     *   .chain()\x0a     *   .head()\x0a     *   .pick(\x27user\x27)\x0a     *   .value();\x0a     * // =\x3e { \x27user\x27: \x27barney\x27 }\x0a     */\x0a    function wrapperChain() {\x0a      return chain(this);\x0a    }\x0a\x0a    /**\x0a     * Executes the chain sequence and returns the wrapped result.\x0a     *\x0a     * @name commit\x0a     * @memberOf _\x0a     * @since 3.2.0\x0a     * @category Seq\x0a     * @returns {Object} Returns the new `lodash` wrapper instance.\x0a     * @example\x0a     *\x0a     * var array = [1, 2];\x0a     * var wrapped = _(array).push(3);\x0a     *\x0a     * console.log(array);\x0a     * // =\x3e [1, 2]\x0a     *\x0a     * wrapped = wrapped.commit();\x0a     * console.log(array);\x0a     * // =\x3e [1, 2, 3]\x0a     *\x0a     * wrapped.last();\x0a     * // =\x3e 3\x0a     *\x0a     * console.log(array);\x0a     * // =\x3e [1, 2, 3]\x0a     */\x0a    function wrapperCommit() {\x0a      return new LodashWrapper(this.value(), this.__chain__);\x0a    }\x0a\x0a    /**\x0a     * Gets the next value on a wrapped object following the\x0a     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\x0a     *\x0a     * @name next\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Seq\x0a     * @returns {Object} Returns the next iterator value.\x0a     * @example\x0a     *\x0a     * var wrapped = _([1, 2]);\x0a     *\x0a     * wrapped.next();\x0a     * // =\x3e { \x27done\x27: false, \x27value\x27: 1 }\x0a     *\x0a     * wrapped.next();\x0a     * // =\x3e { \x27done\x27: false, \x27value\x27: 2 }\x0a     *\x0a     * wrapped.next();\x0a     * // =\x3e { \x27done\x27: true, \x27value\x27: undefined }\x0a     */\x0a    function wrapperNext() {\x0a      if (this.__values__ === undefined) {\x0a        this.__values__ = toArray(this.value());\x0a      }\x0a      var done = this.__index__ \x3e= this.__values__.length,\x0a          value = done ? undefined : this.__values__[this.__index__++];\x0a\x0a      return { \x27done\x27: done, \x27value\x27: value };\x0a    }\x0a\x0a    /**\x0a     * Enables the wrapper to be iterable.\x0a     *\x0a     * @name Symbol.iterator\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Seq\x0a     * @returns {Object} Returns the wrapper object.\x0a     * @example\x0a     *\x0a     * var wrapped = _([1, 2]);\x0a     *\x0a     * wrapped[Symbol.iterator]() === wrapped;\x0a     * // =\x3e true\x0a     *\x0a     * Array.from(wrapped);\x0a     * // =\x3e [1, 2]\x0a     */\x0a    function wrapperToIterator() {\x0a      return this;\x0a    }\x0a\x0a    /**\x0a     * Creates a clone of the chain sequence planting `value` as the wrapped value.\x0a     *\x0a     * @name plant\x0a     * @memberOf _\x0a     * @since 3.2.0\x0a     * @category Seq\x0a     * @param {*} value The value to plant.\x0a     * @returns {Object} Returns the new `lodash` wrapper instance.\x0a     * @example\x0a     *\x0a     * function square(n) {\x0a     *   return n * n;\x0a     * }\x0a     *\x0a     * var wrapped = _([1, 2]).map(square);\x0a     * var other = wrapped.plant([3, 4]);\x0a     *\x0a     * other.value();\x0a     * // =\x3e [9, 16]\x0a     *\x0a     * wrapped.value();\x0a     * // =\x3e [1, 4]\x0a     */\x0a    function wrapperPlant(value) {\x0a      var result,\x0a          parent = this;\x0a\x0a      while (parent instanceof baseLodash) {\x0a        var clone = wrapperClone(parent);\x0a        clone.__index__ = 0;\x0a        clone.__values__ = undefined;\x0a        if (result) {\x0a          previous.__wrapped__ = clone;\x0a        } else {\x0a          result = clone;\x0a        }\x0a        var previous = clone;\x0a        parent = parent.__wrapped__;\x0a      }\x0a      previous.__wrapped__ = value;\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * This method is the wrapper version of `_.reverse`.\x0a     *\x0a     * **Note:** This method mutates the wrapped array.\x0a     *\x0a     * @name reverse\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Seq\x0a     * @returns {Object} Returns the new `lodash` wrapper instance.\x0a     * @example\x0a     *\x0a     * var array = [1, 2, 3];\x0a     *\x0a     * _(array).reverse().value()\x0a     * // =\x3e [3, 2, 1]\x0a     *\x0a     * console.log(array);\x0a     * // =\x3e [3, 2, 1]\x0a     */\x0a    function wrapperReverse() {\x0a      var value = this.__wrapped__;\x0a      if (value instanceof LazyWrapper) {\x0a        var wrapped = value;\x0a        if (this.__actions__.length) {\x0a          wrapped = new LazyWrapper(this);\x0a        }\x0a        wrapped = wrapped.reverse();\x0a        wrapped.__actions__.push({\x0a          \x27func\x27: thru,\x0a          \x27args\x27: [reverse],\x0a          \x27thisArg\x27: undefined\x0a        });\x0a        return new LodashWrapper(wrapped, this.__chain__);\x0a      }\x0a      return this.thru(reverse);\x0a    }\x0a\x0a    /**\x0a     * Executes the chain sequence to resolve the unwrapped value.\x0a     *\x0a     * @name value\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @alias toJSON, valueOf\x0a     * @category Seq\x0a     * @returns {*} Returns the resolved unwrapped value.\x0a     * @example\x0a     *\x0a     * _([1, 2, 3]).value();\x0a     * // =\x3e [1, 2, 3]\x0a     */\x0a    function wrapperValue() {\x0a      return baseWrapperValue(this.__wrapped__, this.__actions__);\x0a    }\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Creates an object composed of keys generated from the results of running\x0a     * each element of `collection` thru `iteratee`. The corresponding value of\x0a     * each key is the number of times the key was returned by `iteratee`. The\x0a     * iteratee is invoked with one argument: (value).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.5.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\x0a     * @returns {Object} Returns the composed aggregate object.\x0a     * @example\x0a     *\x0a     * _.countBy([6.1, 4.2, 6.3], Math.floor);\x0a     * // =\x3e { \x274\x27: 1, \x276\x27: 2 }\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.countBy([\x27one\x27, \x27two\x27, \x27three\x27], \x27length\x27);\x0a     * // =\x3e { \x273\x27: 2, \x275\x27: 1 }\x0a     */\x0a    var countBy = createAggregator(function(result, value, key) {\x0a      if (hasOwnProperty.call(result, key)) {\x0a        ++result[key];\x0a      } else {\x0a        baseAssignValue(result, key, 1);\x0a      }\x0a    });\x0a\x0a    /**\x0a     * Checks if `predicate` returns truthy for **all** elements of `collection`.\x0a     * Iteration is stopped once `predicate` returns falsey. The predicate is\x0a     * invoked with three arguments: (value, index|key, collection).\x0a     *\x0a     * **Note:** This method returns `true` for\x0a     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\x0a     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\x0a     * elements of empty collections.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\x0a     * @returns {boolean} Returns `true` if all elements pass the predicate check,\x0a     *  else `false`.\x0a     * @example\x0a     *\x0a     * _.every([true, 1, null, \x27yes\x27], Boolean);\x0a     * // =\x3e false\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27, \x27age\x27: 36, \x27active\x27: false },\x0a     *   { \x27user\x27: \x27fred\x27,   \x27age\x27: 40, \x27active\x27: false }\x0a     * ];\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.every(users, { \x27user\x27: \x27barney\x27, \x27active\x27: false });\x0a     * // =\x3e false\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.every(users, [\x27active\x27, false]);\x0a     * // =\x3e true\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.every(users, \x27active\x27);\x0a     * // =\x3e false\x0a     */\x0a    function every(collection, predicate, guard) {\x0a      var func = isArray(collection) ? arrayEvery : baseEvery;\x0a      if (guard && isIterateeCall(collection, predicate, guard)) {\x0a        predicate = undefined;\x0a      }\x0a      return func(collection, getIteratee(predicate, 3));\x0a    }\x0a\x0a    /**\x0a     * Iterates over elements of `collection`, returning an array of all elements\x0a     * `predicate` returns truthy for. The predicate is invoked with three\x0a     * arguments: (value, index|key, collection).\x0a     *\x0a     * **Note:** Unlike `_.remove`, this method returns a new array.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @returns {Array} Returns the new filtered array.\x0a     * @see _.reject\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27, \x27age\x27: 36, \x27active\x27: true },\x0a     *   { \x27user\x27: \x27fred\x27,   \x27age\x27: 40, \x27active\x27: false }\x0a     * ];\x0a     *\x0a     * _.filter(users, function(o) { return !o.active; });\x0a     * // =\x3e objects for [\x27fred\x27]\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.filter(users, { \x27age\x27: 36, \x27active\x27: true });\x0a     * // =\x3e objects for [\x27barney\x27]\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.filter(users, [\x27active\x27, false]);\x0a     * // =\x3e objects for [\x27fred\x27]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.filter(users, \x27active\x27);\x0a     * // =\x3e objects for [\x27barney\x27]\x0a     */\x0a    function filter(collection, predicate) {\x0a      var func = isArray(collection) ? arrayFilter : baseFilter;\x0a      return func(collection, getIteratee(predicate, 3));\x0a    }\x0a\x0a    /**\x0a     * Iterates over elements of `collection`, returning the first element\x0a     * `predicate` returns truthy for. The predicate is invoked with three\x0a     * arguments: (value, index|key, collection).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to inspect.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @param {number} [fromIndex=0] The index to search from.\x0a     * @returns {*} Returns the matched element, else `undefined`.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27,  \x27age\x27: 36, \x27active\x27: true },\x0a     *   { \x27user\x27: \x27fred\x27,    \x27age\x27: 40, \x27active\x27: false },\x0a     *   { \x27user\x27: \x27pebbles\x27, \x27age\x27: 1,  \x27active\x27: true }\x0a     * ];\x0a     *\x0a     * _.find(users, function(o) { return o.age \x3c 40; });\x0a     * // =\x3e object for \x27barney\x27\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.find(users, { \x27age\x27: 1, \x27active\x27: true });\x0a     * // =\x3e object for \x27pebbles\x27\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.find(users, [\x27active\x27, false]);\x0a     * // =\x3e object for \x27fred\x27\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.find(users, \x27active\x27);\x0a     * // =\x3e object for \x27barney\x27\x0a     */\x0a    var find = createFind(findIndex);\x0a\x0a    /**\x0a     * This method is like `_.find` except that it iterates over elements of\x0a     * `collection` from right to left.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 2.0.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to inspect.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @param {number} [fromIndex=collection.length-1] The index to search from.\x0a     * @returns {*} Returns the matched element, else `undefined`.\x0a     * @example\x0a     *\x0a     * _.findLast([1, 2, 3, 4], function(n) {\x0a     *   return n % 2 == 1;\x0a     * });\x0a     * // =\x3e 3\x0a     */\x0a    var findLast = createFind(findLastIndex);\x0a\x0a    /**\x0a     * Creates a flattened array of values by running each element in `collection`\x0a     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\x0a     * with three arguments: (value, index|key, collection).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\x0a     * @returns {Array} Returns the new flattened array.\x0a     * @example\x0a     *\x0a     * function duplicate(n) {\x0a     *   return [n, n];\x0a     * }\x0a     *\x0a     * _.flatMap([1, 2], duplicate);\x0a     * // =\x3e [1, 1, 2, 2]\x0a     */\x0a    function flatMap(collection, iteratee) {\x0a      return baseFlatten(map(collection, iteratee), 1);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.flatMap` except that it recursively flattens the\x0a     * mapped results.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.7.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\x0a     * @returns {Array} Returns the new flattened array.\x0a     * @example\x0a     *\x0a     * function duplicate(n) {\x0a     *   return [[[n, n]]];\x0a     * }\x0a     *\x0a     * _.flatMapDeep([1, 2], duplicate);\x0a     * // =\x3e [1, 1, 2, 2]\x0a     */\x0a    function flatMapDeep(collection, iteratee) {\x0a      return baseFlatten(map(collection, iteratee), INFINITY);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.flatMap` except that it recursively flattens the\x0a     * mapped results up to `depth` times.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.7.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\x0a     * @param {number} [depth=1] The maximum recursion depth.\x0a     * @returns {Array} Returns the new flattened array.\x0a     * @example\x0a     *\x0a     * function duplicate(n) {\x0a     *   return [[[n, n]]];\x0a     * }\x0a     *\x0a     * _.flatMapDepth([1, 2], duplicate, 2);\x0a     * // =\x3e [[1, 1], [2, 2]]\x0a     */\x0a    function flatMapDepth(collection, iteratee, depth) {\x0a      depth = depth === undefined ? 1 : toInteger(depth);\x0a      return baseFlatten(map(collection, iteratee), depth);\x0a    }\x0a\x0a    /**\x0a     * Iterates over elements of `collection` and invokes `iteratee` for each element.\x0a     * The iteratee is invoked with three arguments: (value, index|key, collection).\x0a     * Iteratee functions may exit iteration early by explicitly returning `false`.\x0a     *\x0a     * **Note:** As with other \x22Collections\x22 methods, objects with a \x22length\x22\x0a     * property are iterated like arrays. To avoid this behavior use `_.forIn`\x0a     * or `_.forOwn` for object iteration.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @alias each\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\x0a     * @returns {Array|Object} Returns `collection`.\x0a     * @see _.forEachRight\x0a     * @example\x0a     *\x0a     * _.forEach([1, 2], function(value) {\x0a     *   console.log(value);\x0a     * });\x0a     * // =\x3e Logs `1` then `2`.\x0a     *\x0a     * _.forEach({ \x27a\x27: 1, \x27b\x27: 2 }, function(value, key) {\x0a     *   console.log(key);\x0a     * });\x0a     * // =\x3e Logs \x27a\x27 then \x27b\x27 (iteration order is not guaranteed).\x0a     */\x0a    function forEach(collection, iteratee) {\x0a      var func = isArray(collection) ? arrayEach : baseEach;\x0a      return func(collection, getIteratee(iteratee, 3));\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.forEach` except that it iterates over elements of\x0a     * `collection` from right to left.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 2.0.0\x0a     * @alias eachRight\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\x0a     * @returns {Array|Object} Returns `collection`.\x0a     * @see _.forEach\x0a     * @example\x0a     *\x0a     * _.forEachRight([1, 2], function(value) {\x0a     *   console.log(value);\x0a     * });\x0a     * // =\x3e Logs `2` then `1`.\x0a     */\x0a    function forEachRight(collection, iteratee) {\x0a      var func = isArray(collection) ? arrayEachRight : baseEachRight;\x0a      return func(collection, getIteratee(iteratee, 3));\x0a    }\x0a\x0a    /**\x0a     * Creates an object composed of keys generated from the results of running\x0a     * each element of `collection` thru `iteratee`. The order of grouped values\x0a     * is determined by the order they occur in `collection`. The corresponding\x0a     * value of each key is an array of elements responsible for generating the\x0a     * key. The iteratee is invoked with one argument: (value).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\x0a     * @returns {Object} Returns the composed aggregate object.\x0a     * @example\x0a     *\x0a     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\x0a     * // =\x3e { \x274\x27: [4.2], \x276\x27: [6.1, 6.3] }\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.groupBy([\x27one\x27, \x27two\x27, \x27three\x27], \x27length\x27);\x0a     * // =\x3e { \x273\x27: [\x27one\x27, \x27two\x27], \x275\x27: [\x27three\x27] }\x0a     */\x0a    var groupBy = createAggregator(function(result, value, key) {\x0a      if (hasOwnProperty.call(result, key)) {\x0a        result[key].push(value);\x0a      } else {\x0a        baseAssignValue(result, key, [value]);\x0a      }\x0a    });\x0a\x0a    /**\x0a     * Checks if `value` is in `collection`. If `collection` is a string, it\x27s\x0a     * checked for a substring of `value`, otherwise\x0a     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\x0a     * is used for equality comparisons. If `fromIndex` is negative, it\x27s used as\x0a     * the offset from the end of `collection`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object|string} collection The collection to inspect.\x0a     * @param {*} value The value to search for.\x0a     * @param {number} [fromIndex=0] The index to search from.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\x0a     * @returns {boolean} Returns `true` if `value` is found, else `false`.\x0a     * @example\x0a     *\x0a     * _.includes([1, 2, 3], 1);\x0a     * // =\x3e true\x0a     *\x0a     * _.includes([1, 2, 3], 1, 2);\x0a     * // =\x3e false\x0a     *\x0a     * _.includes({ \x27a\x27: 1, \x27b\x27: 2 }, 1);\x0a     * // =\x3e true\x0a     *\x0a     * _.includes(\x27abcd\x27, \x27bc\x27);\x0a     * // =\x3e true\x0a     */\x0a    function includes(collection, value, fromIndex, guard) {\x0a      collection = isArrayLike(collection) ? collection : values(collection);\x0a      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\x0a\x0a      var length = collection.length;\x0a      if (fromIndex \x3c 0) {\x0a        fromIndex = nativeMax(length + fromIndex, 0);\x0a      }\x0a      return isString(collection)\x0a        ? (fromIndex \x3c= length && collection.indexOf(value, fromIndex) \x3e -1)\x0a        : (!!length && baseIndexOf(collection, value, fromIndex) \x3e -1);\x0a    }\x0a\x0a    /**\x0a     * Invokes the method at `path` of each element in `collection`, returning\x0a     * an array of the results of each invoked method. Any additional arguments\x0a     * are provided to each invoked method. If `path` is a function, it\x27s invoked\x0a     * for, and `this` bound to, each element in `collection`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Array|Function|string} path The path of the method to invoke or\x0a     *  the function invoked per iteration.\x0a     * @param {...*} [args] The arguments to invoke each method with.\x0a     * @returns {Array} Returns the array of results.\x0a     * @example\x0a     *\x0a     * _.invokeMap([[5, 1, 7], [3, 2, 1]], \x27sort\x27);\x0a     * // =\x3e [[1, 5, 7], [1, 2, 3]]\x0a     *\x0a     * _.invokeMap([123, 456], String.prototype.split, \x27\x27);\x0a     * // =\x3e [[\x271\x27, \x272\x27, \x273\x27], [\x274\x27, \x275\x27, \x276\x27]]\x0a     */\x0a    var invokeMap = baseRest(function(collection, path, args) {\x0a      var index = -1,\x0a          isFunc = typeof path == \x27function\x27,\x0a          result = isArrayLike(collection) ? Array(collection.length) : [];\x0a\x0a      baseEach(collection, function(value) {\x0a        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\x0a      });\x0a      return result;\x0a    });\x0a\x0a    /**\x0a     * Creates an object composed of keys generated from the results of running\x0a     * each element of `collection` thru `iteratee`. The corresponding value of\x0a     * each key is the last element responsible for generating the key. The\x0a     * iteratee is invoked with one argument: (value).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\x0a     * @returns {Object} Returns the composed aggregate object.\x0a     * @example\x0a     *\x0a     * var array = [\x0a     *   { \x27dir\x27: \x27left\x27, \x27code\x27: 97 },\x0a     *   { \x27dir\x27: \x27right\x27, \x27code\x27: 100 }\x0a     * ];\x0a     *\x0a     * _.keyBy(array, function(o) {\x0a     *   return String.fromCharCode(o.code);\x0a     * });\x0a     * // =\x3e { \x27a\x27: { \x27dir\x27: \x27left\x27, \x27code\x27: 97 }, \x27d\x27: { \x27dir\x27: \x27right\x27, \x27code\x27: 100 } }\x0a     *\x0a     * _.keyBy(array, \x27dir\x27);\x0a     * // =\x3e { \x27left\x27: { \x27dir\x27: \x27left\x27, \x27code\x27: 97 }, \x27right\x27: { \x27dir\x27: \x27right\x27, \x27code\x27: 100 } }\x0a     */\x0a    var keyBy = createAggregator(function(result, value, key) {\x0a      baseAssignValue(result, key, value);\x0a    });\x0a\x0a    /**\x0a     * Creates an array of values by running each element in `collection` thru\x0a     * `iteratee`. The iteratee is invoked with three arguments:\x0a     * (value, index|key, collection).\x0a     *\x0a     * Many lodash methods are guarded to work as iteratees for methods like\x0a     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\x0a     *\x0a     * The guarded methods are:\x0a     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\x0a     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\x0a     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\x0a     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\x0a     * @returns {Array} Returns the new mapped array.\x0a     * @example\x0a     *\x0a     * function square(n) {\x0a     *   return n * n;\x0a     * }\x0a     *\x0a     * _.map([4, 8], square);\x0a     * // =\x3e [16, 64]\x0a     *\x0a     * _.map({ \x27a\x27: 4, \x27b\x27: 8 }, square);\x0a     * // =\x3e [16, 64] (iteration order is not guaranteed)\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27 },\x0a     *   { \x27user\x27: \x27fred\x27 }\x0a     * ];\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.map(users, \x27user\x27);\x0a     * // =\x3e [\x27barney\x27, \x27fred\x27]\x0a     */\x0a    function map(collection, iteratee) {\x0a      var func = isArray(collection) ? arrayMap : baseMap;\x0a      return func(collection, getIteratee(iteratee, 3));\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.sortBy` except that it allows specifying the sort\x0a     * orders of the iteratees to sort by. If `orders` is unspecified, all values\x0a     * are sorted in ascending order. Otherwise, specify an order of \x22desc\x22 for\x0a     * descending or \x22asc\x22 for ascending sort order of corresponding values.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\x0a     *  The iteratees to sort by.\x0a     * @param {string[]} [orders] The sort orders of `iteratees`.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\x0a     * @returns {Array} Returns the new sorted array.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27fred\x27,   \x27age\x27: 48 },\x0a     *   { \x27user\x27: \x27barney\x27, \x27age\x27: 34 },\x0a     *   { \x27user\x27: \x27fred\x27,   \x27age\x27: 40 },\x0a     *   { \x27user\x27: \x27barney\x27, \x27age\x27: 36 }\x0a     * ];\x0a     *\x0a     * // Sort by `user` in ascending order and by `age` in descending order.\x0a     * _.orderBy(users, [\x27user\x27, \x27age\x27], [\x27asc\x27, \x27desc\x27]);\x0a     * // =\x3e objects for [[\x27barney\x27, 36], [\x27barney\x27, 34], [\x27fred\x27, 48], [\x27fred\x27, 40]]\x0a     */\x0a    function orderBy(collection, iteratees, orders, guard) {\x0a      if (collection == null) {\x0a        return [];\x0a      }\x0a      if (!isArray(iteratees)) {\x0a        iteratees = iteratees == null ? [] : [iteratees];\x0a      }\x0a      orders = guard ? undefined : orders;\x0a      if (!isArray(orders)) {\x0a        orders = orders == null ? [] : [orders];\x0a      }\x0a      return baseOrderBy(collection, iteratees, orders);\x0a    }\x0a\x0a    /**\x0a     * Creates an array of elements split into two groups, the first of which\x0a     * contains elements `predicate` returns truthy for, the second of which\x0a     * contains elements `predicate` returns falsey for. The predicate is\x0a     * invoked with one argument: (value).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @returns {Array} Returns the array of grouped elements.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27,  \x27age\x27: 36, \x27active\x27: false },\x0a     *   { \x27user\x27: \x27fred\x27,    \x27age\x27: 40, \x27active\x27: true },\x0a     *   { \x27user\x27: \x27pebbles\x27, \x27age\x27: 1,  \x27active\x27: false }\x0a     * ];\x0a     *\x0a     * _.partition(users, function(o) { return o.active; });\x0a     * // =\x3e objects for [[\x27fred\x27], [\x27barney\x27, \x27pebbles\x27]]\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.partition(users, { \x27age\x27: 1, \x27active\x27: false });\x0a     * // =\x3e objects for [[\x27pebbles\x27], [\x27barney\x27, \x27fred\x27]]\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.partition(users, [\x27active\x27, false]);\x0a     * // =\x3e objects for [[\x27barney\x27, \x27pebbles\x27], [\x27fred\x27]]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.partition(users, \x27active\x27);\x0a     * // =\x3e objects for [[\x27fred\x27], [\x27barney\x27, \x27pebbles\x27]]\x0a     */\x0a    var partition = createAggregator(function(result, value, key) {\x0a      result[key ? 0 : 1].push(value);\x0a    }, function() { return [[], []]; });\x0a\x0a    /**\x0a     * Reduces `collection` to a value which is the accumulated result of running\x0a     * each element in `collection` thru `iteratee`, where each successive\x0a     * invocation is supplied the return value of the previous. If `accumulator`\x0a     * is not given, the first element of `collection` is used as the initial\x0a     * value. The iteratee is invoked with four arguments:\x0a     * (accumulator, value, index|key, collection).\x0a     *\x0a     * Many lodash methods are guarded to work as iteratees for methods like\x0a     * `_.reduce`, `_.reduceRight`, and `_.transform`.\x0a     *\x0a     * The guarded methods are:\x0a     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\x0a     * and `sortBy`\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\x0a     * @param {*} [accumulator] The initial value.\x0a     * @returns {*} Returns the accumulated value.\x0a     * @see _.reduceRight\x0a     * @example\x0a     *\x0a     * _.reduce([1, 2], function(sum, n) {\x0a     *   return sum + n;\x0a     * }, 0);\x0a     * // =\x3e 3\x0a     *\x0a     * _.reduce({ \x27a\x27: 1, \x27b\x27: 2, \x27c\x27: 1 }, function(result, value, key) {\x0a     *   (result[value] || (result[value] = [])).push(key);\x0a     *   return result;\x0a     * }, {});\x0a     * // =\x3e { \x271\x27: [\x27a\x27, \x27c\x27], \x272\x27: [\x27b\x27] } (iteration order is not guaranteed)\x0a     */\x0a    function reduce(collection, iteratee, accumulator) {\x0a      var func = isArray(collection) ? arrayReduce : baseReduce,\x0a          initAccum = arguments.length \x3c 3;\x0a\x0a      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.reduce` except that it iterates over elements of\x0a     * `collection` from right to left.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\x0a     * @param {*} [accumulator] The initial value.\x0a     * @returns {*} Returns the accumulated value.\x0a     * @see _.reduce\x0a     * @example\x0a     *\x0a     * var array = [[0, 1], [2, 3], [4, 5]];\x0a     *\x0a     * _.reduceRight(array, function(flattened, other) {\x0a     *   return flattened.concat(other);\x0a     * }, []);\x0a     * // =\x3e [4, 5, 2, 3, 0, 1]\x0a     */\x0a    function reduceRight(collection, iteratee, accumulator) {\x0a      var func = isArray(collection) ? arrayReduceRight : baseReduce,\x0a          initAccum = arguments.length \x3c 3;\x0a\x0a      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\x0a    }\x0a\x0a    /**\x0a     * The opposite of `_.filter`; this method returns the elements of `collection`\x0a     * that `predicate` does **not** return truthy for.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @returns {Array} Returns the new filtered array.\x0a     * @see _.filter\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27, \x27age\x27: 36, \x27active\x27: false },\x0a     *   { \x27user\x27: \x27fred\x27,   \x27age\x27: 40, \x27active\x27: true }\x0a     * ];\x0a     *\x0a     * _.reject(users, function(o) { return !o.active; });\x0a     * // =\x3e objects for [\x27fred\x27]\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.reject(users, { \x27age\x27: 40, \x27active\x27: true });\x0a     * // =\x3e objects for [\x27barney\x27]\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.reject(users, [\x27active\x27, false]);\x0a     * // =\x3e objects for [\x27fred\x27]\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.reject(users, \x27active\x27);\x0a     * // =\x3e objects for [\x27barney\x27]\x0a     */\x0a    function reject(collection, predicate) {\x0a      var func = isArray(collection) ? arrayFilter : baseFilter;\x0a      return func(collection, negate(getIteratee(predicate, 3)));\x0a    }\x0a\x0a    /**\x0a     * Gets a random element from `collection`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 2.0.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to sample.\x0a     * @returns {*} Returns the random element.\x0a     * @example\x0a     *\x0a     * _.sample([1, 2, 3, 4]);\x0a     * // =\x3e 2\x0a     */\x0a    function sample(collection) {\x0a      var func = isArray(collection) ? arraySample : baseSample;\x0a      return func(collection);\x0a    }\x0a\x0a    /**\x0a     * Gets `n` random elements at unique keys from `collection` up to the\x0a     * size of `collection`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to sample.\x0a     * @param {number} [n=1] The number of elements to sample.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\x0a     * @returns {Array} Returns the random elements.\x0a     * @example\x0a     *\x0a     * _.sampleSize([1, 2, 3], 2);\x0a     * // =\x3e [3, 1]\x0a     *\x0a     * _.sampleSize([1, 2, 3], 4);\x0a     * // =\x3e [2, 3, 1]\x0a     */\x0a    function sampleSize(collection, n, guard) {\x0a      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\x0a        n = 1;\x0a      } else {\x0a        n = toInteger(n);\x0a      }\x0a      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\x0a      return func(collection, n);\x0a    }\x0a\x0a    /**\x0a     * Creates an array of shuffled values, using a version of the\x0a     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to shuffle.\x0a     * @returns {Array} Returns the new shuffled array.\x0a     * @example\x0a     *\x0a     * _.shuffle([1, 2, 3, 4]);\x0a     * // =\x3e [4, 1, 3, 2]\x0a     */\x0a    function shuffle(collection) {\x0a      var func = isArray(collection) ? arrayShuffle : baseShuffle;\x0a      return func(collection);\x0a    }\x0a\x0a    /**\x0a     * Gets the size of `collection` by returning its length for array-like\x0a     * values or the number of own enumerable string keyed properties for objects.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object|string} collection The collection to inspect.\x0a     * @returns {number} Returns the collection size.\x0a     * @example\x0a     *\x0a     * _.size([1, 2, 3]);\x0a     * // =\x3e 3\x0a     *\x0a     * _.size({ \x27a\x27: 1, \x27b\x27: 2 });\x0a     * // =\x3e 2\x0a     *\x0a     * _.size(\x27pebbles\x27);\x0a     * // =\x3e 7\x0a     */\x0a    function size(collection) {\x0a      if (collection == null) {\x0a        return 0;\x0a      }\x0a      if (isArrayLike(collection)) {\x0a        return isString(collection) ? stringSize(collection) : collection.length;\x0a      }\x0a      var tag = getTag(collection);\x0a      if (tag == mapTag || tag == setTag) {\x0a        return collection.size;\x0a      }\x0a      return baseKeys(collection).length;\x0a    }\x0a\x0a    /**\x0a     * Checks if `predicate` returns truthy for **any** element of `collection`.\x0a     * Iteration is stopped once `predicate` returns truthy. The predicate is\x0a     * invoked with three arguments: (value, index|key, collection).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {Function} [predicate=_.identity] The function invoked per iteration.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\x0a     * @returns {boolean} Returns `true` if any element passes the predicate check,\x0a     *  else `false`.\x0a     * @example\x0a     *\x0a     * _.some([null, 0, \x27yes\x27, false], Boolean);\x0a     * // =\x3e true\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27barney\x27, \x27active\x27: true },\x0a     *   { \x27user\x27: \x27fred\x27,   \x27active\x27: false }\x0a     * ];\x0a     *\x0a     * // The `_.matches` iteratee shorthand.\x0a     * _.some(users, { \x27user\x27: \x27barney\x27, \x27active\x27: false });\x0a     * // =\x3e false\x0a     *\x0a     * // The `_.matchesProperty` iteratee shorthand.\x0a     * _.some(users, [\x27active\x27, false]);\x0a     * // =\x3e true\x0a     *\x0a     * // The `_.property` iteratee shorthand.\x0a     * _.some(users, \x27active\x27);\x0a     * // =\x3e true\x0a     */\x0a    function some(collection, predicate, guard) {\x0a      var func = isArray(collection) ? arraySome : baseSome;\x0a      if (guard && isIterateeCall(collection, predicate, guard)) {\x0a        predicate = undefined;\x0a      }\x0a      return func(collection, getIteratee(predicate, 3));\x0a    }\x0a\x0a    /**\x0a     * Creates an array of elements, sorted in ascending order by the results of\x0a     * running each element in a collection thru each iteratee. This method\x0a     * performs a stable sort, that is, it preserves the original sort order of\x0a     * equal elements. The iteratees are invoked with one argument: (value).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Collection\x0a     * @param {Array|Object} collection The collection to iterate over.\x0a     * @param {...(Function|Function[])} [iteratees=[_.identity]]\x0a     *  The iteratees to sort by.\x0a     * @returns {Array} Returns the new sorted array.\x0a     * @example\x0a     *\x0a     * var users = [\x0a     *   { \x27user\x27: \x27fred\x27,   \x27age\x27: 48 },\x0a     *   { \x27user\x27: \x27barney\x27, \x27age\x27: 36 },\x0a     *   { \x27user\x27: \x27fred\x27,   \x27age\x27: 40 },\x0a     *   { \x27user\x27: \x27barney\x27, \x27age\x27: 34 }\x0a     * ];\x0a     *\x0a     * _.sortBy(users, [function(o) { return o.user; }]);\x0a     * // =\x3e objects for [[\x27barney\x27, 36], [\x27barney\x27, 34], [\x27fred\x27, 48], [\x27fred\x27, 40]]\x0a     *\x0a     * _.sortBy(users, [\x27user\x27, \x27age\x27]);\x0a     * // =\x3e objects for [[\x27barney\x27, 34], [\x27barney\x27, 36], [\x27fred\x27, 40], [\x27fred\x27, 48]]\x0a     */\x0a    var sortBy = baseRest(function(collection, iteratees) {\x0a      if (collection == null) {\x0a        return [];\x0a      }\x0a      var length = iteratees.length;\x0a      if (length \x3e 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\x0a        iteratees = [];\x0a      } else if (length \x3e 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\x0a        iteratees = [iteratees[0]];\x0a      }\x0a      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\x0a    });\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Gets the timestamp of the number of milliseconds that have elapsed since\x0a     * the Unix epoch (1 January 1970 00:00:00 UTC).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 2.4.0\x0a     * @category Date\x0a     * @returns {number} Returns the timestamp.\x0a     * @example\x0a     *\x0a     * _.defer(function(stamp) {\x0a     *   console.log(_.now() - stamp);\x0a     * }, _.now());\x0a     * // =\x3e Logs the number of milliseconds it took for the deferred invocation.\x0a     */\x0a    var now = ctxNow || function() {\x0a      return root.Date.now();\x0a    };\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * The opposite of `_.before`; this method creates a function that invokes\x0a     * `func` once it\x27s called `n` or more times.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Function\x0a     * @param {number} n The number of calls before `func` is invoked.\x0a     * @param {Function} func The function to restrict.\x0a     * @returns {Function} Returns the new restricted function.\x0a     * @example\x0a     *\x0a     * var saves = [\x27profile\x27, \x27settings\x27];\x0a     *\x0a     * var done = _.after(saves.length, function() {\x0a     *   console.log(\x27done saving!\x27);\x0a     * });\x0a     *\x0a     * _.forEach(saves, function(type) {\x0a     *   asyncSave({ \x27type\x27: type, \x27complete\x27: done });\x0a     * });\x0a     * // =\x3e Logs \x27done saving!\x27 after the two async saves have completed.\x0a     */\x0a    function after(n, func) {\x0a      if (typeof func != \x27function\x27) {\x0a        throw new TypeError(FUNC_ERROR_TEXT);\x0a      }\x0a      n = toInteger(n);\x0a      return function() {\x0a        if (--n \x3c 1) {\x0a          return func.apply(this, arguments);\x0a        }\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function that invokes `func`, with up to `n` arguments,\x0a     * ignoring any additional arguments.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Function\x0a     * @param {Function} func The function to cap arguments for.\x0a     * @param {number} [n=func.length] The arity cap.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\x0a     * @returns {Function} Returns the new capped function.\x0a     * @example\x0a     *\x0a     * _.map([\x276\x27, \x278\x27, \x2710\x27], _.ary(parseInt, 1));\x0a     * // =\x3e [6, 8, 10]\x0a     */\x0a    function ary(func, n, guard) {\x0a      n = guard ? undefined : n;\x0a      n = (func && n == null) ? func.length : n;\x0a      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\x0a    }\x0a\x0a    /**\x0a     * Creates a function that invokes `func`, with the `this` binding and arguments\x0a     * of the created function, while it\x27s called less than `n` times. Subsequent\x0a     * calls to the created function return the result of the last `func` invocation.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Function\x0a     * @param {number} n The number of calls at which `func` is no longer invoked.\x0a     * @param {Function} func The function to restrict.\x0a     * @returns {Function} Returns the new restricted function.\x0a     * @example\x0a     *\x0a     * jQuery(element).on(\x27click\x27, _.before(5, addContactToList));\x0a     * // =\x3e Allows adding up to 4 contacts to the list.\x0a     */\x0a    function before(n, func) {\x0a      var result;\x0a      if (typeof func != \x27function\x27) {\x0a        throw new TypeError(FUNC_ERROR_TEXT);\x0a      }\x0a      n = toInteger(n);\x0a      return function() {\x0a        if (--n \x3e 0) {\x0a          result = func.apply(this, arguments);\x0a        }\x0a        if (n \x3c= 1) {\x0a          func = undefined;\x0a        }\x0a        return result;\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function that invokes `func` with the `this` binding of `thisArg`\x0a     * and `partials` prepended to the arguments it receives.\x0a     *\x0a     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\x0a     * may be used as a placeholder for partially applied arguments.\x0a     *\x0a     * **Note:** Unlike native `Function#bind`, this method doesn\x27t set the \x22length\x22\x0a     * property of bound functions.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Function\x0a     * @param {Function} func The function to bind.\x0a     * @param {*} thisArg The `this` binding of `func`.\x0a     * @param {...*} [partials] The arguments to be partially applied.\x0a     * @returns {Function} Returns the new bound function.\x0a     * @example\x0a     *\x0a     * function greet(greeting, punctuation) {\x0a     *   return greeting + \x27 \x27 + this.user + punctuation;\x0a     * }\x0a     *\x0a     * var object = { \x27user\x27: \x27fred\x27 };\x0a     *\x0a     * var bound = _.bind(greet, object, \x27hi\x27);\x0a     * bound(\x27!\x27);\x0a     * // =\x3e \x27hi fred!\x27\x0a     *\x0a     * // Bound with placeholders.\x0a     * var bound = _.bind(greet, object, _, \x27!\x27);\x0a     * bound(\x27hi\x27);\x0a     * // =\x3e \x27hi fred!\x27\x0a     */\x0a    var bind = baseRest(function(func, thisArg, partials) {\x0a      var bitmask = WRAP_BIND_FLAG;\x0a      if (partials.length) {\x0a        var holders = replaceHolders(partials, getHolder(bind));\x0a        bitmask |= WRAP_PARTIAL_FLAG;\x0a      }\x0a      return createWrap(func, bitmask, thisArg, partials, holders);\x0a    });\x0a\x0a    /**\x0a     * Creates a function that invokes the method at `object[key]` with `partials`\x0a     * prepended to the arguments it receives.\x0a     *\x0a     * This method differs from `_.bind` by allowing bound functions to reference\x0a     * methods that may be redefined or don\x27t yet exist. See\x0a     * [Peter Michaux\x27s article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\x0a     * for more details.\x0a     *\x0a     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\x0a     * builds, may be used as a placeholder for partially applied arguments.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.10.0\x0a     * @category Function\x0a     * @param {Object} object The object to invoke the method on.\x0a     * @param {string} key The key of the method.\x0a     * @param {...*} [partials] The arguments to be partially applied.\x0a     * @returns {Function} Returns the new bound function.\x0a     * @example\x0a     *\x0a     * var object = {\x0a     *   \x27user\x27: \x27fred\x27,\x0a     *   \x27greet\x27: function(greeting, punctuation) {\x0a     *     return greeting + \x27 \x27 + this.user + punctuation;\x0a     *   }\x0a     * };\x0a     *\x0a     * var bound = _.bindKey(object, \x27greet\x27, \x27hi\x27);\x0a     * bound(\x27!\x27);\x0a     * // =\x3e \x27hi fred!\x27\x0a     *\x0a     * object.greet = function(greeting, punctuation) {\x0a     *   return greeting + \x27ya \x27 + this.user + punctuation;\x0a     * };\x0a     *\x0a     * bound(\x27!\x27);\x0a     * // =\x3e \x27hiya fred!\x27\x0a     *\x0a     * // Bound with placeholders.\x0a     * var bound = _.bindKey(object, \x27greet\x27, _, \x27!\x27);\x0a     * bound(\x27hi\x27);\x0a     * // =\x3e \x27hiya fred!\x27\x0a     */\x0a    var bindKey = baseRest(function(object, key, partials) {\x0a      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\x0a      if (partials.length) {\x0a        var holders = replaceHolders(partials, getHolder(bindKey));\x0a        bitmask |= WRAP_PARTIAL_FLAG;\x0a      }\x0a      return createWrap(key, bitmask, object, partials, holders);\x0a    });\x0a\x0a    /**\x0a     * Creates a function that accepts arguments of `func` and either invokes\x0a     * `func` returning its result, if at least `arity` number of arguments have\x0a     * been provided, or returns a function that accepts the remaining `func`\x0a     * arguments, and so on. The arity of `func` may be specified if `func.length`\x0a     * is not sufficient.\x0a     *\x0a     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\x0a     * may be used as a placeholder for provided arguments.\x0a     *\x0a     * **Note:** This method doesn\x27t set the \x22length\x22 property of curried functions.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 2.0.0\x0a     * @category Function\x0a     * @param {Function} func The function to curry.\x0a     * @param {number} [arity=func.length] The arity of `func`.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\x0a     * @returns {Function} Returns the new curried function.\x0a     * @example\x0a     *\x0a     * var abc = function(a, b, c) {\x0a     *   return [a, b, c];\x0a     * };\x0a     *\x0a     * var curried = _.curry(abc);\x0a     *\x0a     * curried(1)(2)(3);\x0a     * // =\x3e [1, 2, 3]\x0a     *\x0a     * curried(1, 2)(3);\x0a     * // =\x3e [1, 2, 3]\x0a     *\x0a     * curried(1, 2, 3);\x0a     * // =\x3e [1, 2, 3]\x0a     *\x0a     * // Curried with placeholders.\x0a     * curried(1)(_, 3)(2);\x0a     * // =\x3e [1, 2, 3]\x0a     */\x0a    function curry(func, arity, guard) {\x0a      arity = guard ? undefined : arity;\x0a      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\x0a      result.placeholder = curry.placeholder;\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.curry` except that arguments are applied to `func`\x0a     * in the manner of `_.partialRight` instead of `_.partial`.\x0a     *\x0a     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\x0a     * builds, may be used as a placeholder for provided arguments.\x0a     *\x0a     * **Note:** This method doesn\x27t set the \x22length\x22 property of curried functions.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Function\x0a     * @param {Function} func The function to curry.\x0a     * @param {number} [arity=func.length] The arity of `func`.\x0a     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\x0a     * @returns {Function} Returns the new curried function.\x0a     * @example\x0a     *\x0a     * var abc = function(a, b, c) {\x0a     *   return [a, b, c];\x0a     * };\x0a     *\x0a     * var curried = _.curryRight(abc);\x0a     *\x0a     * curried(3)(2)(1);\x0a     * // =\x3e [1, 2, 3]\x0a     *\x0a     * curried(2, 3)(1);\x0a     * // =\x3e [1, 2, 3]\x0a     *\x0a     * curried(1, 2, 3);\x0a     * // =\x3e [1, 2, 3]\x0a     *\x0a     * // Curried with placeholders.\x0a     * curried(3)(1, _)(2);\x0a     * // =\x3e [1, 2, 3]\x0a     */\x0a    function curryRight(func, arity, guard) {\x0a      arity = guard ? undefined : arity;\x0a      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\x0a      result.placeholder = curryRight.placeholder;\x0a      return result;\x0a    }\x0a\x0a    /**\x0a     * Creates a debounced function that delays invoking `func` until after `wait`\x0a     * milliseconds have elapsed since the last time the debounced function was\x0a     * invoked. The debounced function comes with a `cancel` method to cancel\x0a     * delayed `func` invocations and a `flush` method to immediately invoke them.\x0a     * Provide `options` to indicate whether `func` should be invoked on the\x0a     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\x0a     * with the last arguments provided to the debounced function. Subsequent\x0a     * calls to the debounced function return the result of the last `func`\x0a     * invocation.\x0a     *\x0a     * **Note:** If `leading` and `trailing` options are `true`, `func` is\x0a     * invoked on the trailing edge of the timeout only if the debounced function\x0a     * is invoked more than once during the `wait` timeout.\x0a     *\x0a     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\x0a     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\x0a     *\x0a     * See [David Corbacho\x27s article](https://css-tricks.com/debouncing-throttling-explained-examples/)\x0a     * for details over the differences between `_.debounce` and `_.throttle`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Function\x0a     * @param {Function} func The function to debounce.\x0a     * @param {number} [wait=0] The number of milliseconds to delay.\x0a     * @param {Object} [options={}] The options object.\x0a     * @param {boolean} [options.leading=false]\x0a     *  Specify invoking on the leading edge of the timeout.\x0a     * @param {number} [options.maxWait]\x0a     *  The maximum time `func` is allowed to be delayed before it\x27s invoked.\x0a     * @param {boolean} [options.trailing=true]\x0a     *  Specify invoking on the trailing edge of the timeout.\x0a     * @returns {Function} Returns the new debounced function.\x0a     * @example\x0a     *\x0a     * // Avoid costly calculations while the window size is in flux.\x0a     * jQuery(window).on(\x27resize\x27, _.debounce(calculateLayout, 150));\x0a     *\x0a     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\x0a     * jQuery(element).on(\x27click\x27, _.debounce(sendMail, 300, {\x0a     *   \x27leading\x27: true,\x0a     *   \x27trailing\x27: false\x0a     * }));\x0a     *\x0a     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\x0a     * var debounced = _.debounce(batchLog, 250, { \x27maxWait\x27: 1000 });\x0a     * var source = new EventSource(\x27/stream\x27);\x0a     * jQuery(source).on(\x27message\x27, debounced);\x0a     *\x0a     * // Cancel the trailing debounced invocation.\x0a     * jQuery(window).on(\x27popstate\x27, debounced.cancel);\x0a     */\x0a    function debounce(func, wait, options) {\x0a      var lastArgs,\x0a          lastThis,\x0a          maxWait,\x0a          result,\x0a          timerId,\x0a          lastCallTime,\x0a          lastInvokeTime = 0,\x0a          leading = false,\x0a          maxing = false,\x0a          trailing = true;\x0a\x0a      if (typeof func != \x27function\x27) {\x0a        throw new TypeError(FUNC_ERROR_TEXT);\x0a      }\x0a      wait = toNumber(wait) || 0;\x0a      if (isObject(options)) {\x0a        leading = !!options.leading;\x0a        maxing = \x27maxWait\x27 in options;\x0a        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\x0a        trailing = \x27trailing\x27 in options ? !!options.trailing : trailing;\x0a      }\x0a\x0a      function invokeFunc(time) {\x0a        var args = lastArgs,\x0a            thisArg = lastThis;\x0a\x0a        lastArgs = lastThis = undefined;\x0a        lastInvokeTime = time;\x0a        result = func.apply(thisArg, args);\x0a        return result;\x0a      }\x0a\x0a      function leadingEdge(time) {\x0a        // Reset any `maxWait` timer.\x0a        lastInvokeTime = time;\x0a        // Start the timer for the trailing edge.\x0a        timerId = setTimeout(timerExpired, wait);\x0a        // Invoke the leading edge.\x0a        return leading ? invokeFunc(time) : result;\x0a      }\x0a\x0a      function remainingWait(time) {\x0a        var timeSinceLastCall = time - lastCallTime,\x0a            timeSinceLastInvoke = time - lastInvokeTime,\x0a            timeWaiting = wait - timeSinceLastCall;\x0a\x0a        return maxing\x0a          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\x0a          : timeWaiting;\x0a      }\x0a\x0a      function shouldInvoke(time) {\x0a        var timeSinceLastCall = time - lastCallTime,\x0a            timeSinceLastInvoke = time - lastInvokeTime;\x0a\x0a        // Either this is the first call, activity has stopped and we\x27re at the\x0a        // trailing edge, the system time has gone backwards and we\x27re treating\x0a        // it as the trailing edge, or we\x27ve hit the `maxWait` limit.\x0a        return (lastCallTime === undefined || (timeSinceLastCall \x3e= wait) ||\x0a          (timeSinceLastCall \x3c 0) || (maxing && timeSinceLastInvoke \x3e= maxWait));\x0a      }\x0a\x0a      function timerExpired() {\x0a        var time = now();\x0a        if (shouldInvoke(time)) {\x0a          return trailingEdge(time);\x0a        }\x0a        // Restart the timer.\x0a        timerId = setTimeout(timerExpired, remainingWait(time));\x0a      }\x0a\x0a      function trailingEdge(time) {\x0a        timerId = undefined;\x0a\x0a        // Only invoke if we have `lastArgs` which means `func` has been\x0a        // debounced at least once.\x0a        if (trailing && lastArgs) {\x0a          return invokeFunc(time);\x0a        }\x0a        lastArgs = lastThis = undefined;\x0a        return result;\x0a      }\x0a\x0a      function cancel() {\x0a        if (timerId !== undefined) {\x0a          clearTimeout(timerId);\x0a        }\x0a        lastInvokeTime = 0;\x0a        lastArgs = lastCallTime = lastThis = timerId = undefined;\x0a      }\x0a\x0a      function flush() {\x0a        return timerId === undefined ? result : trailingEdge(now());\x0a      }\x0a\x0a      function debounced() {\x0a        var time = now(),\x0a            isInvoking = shouldInvoke(time);\x0a\x0a        lastArgs = arguments;\x0a        lastThis = this;\x0a        lastCallTime = time;\x0a\x0a        if (isInvoking) {\x0a          if (timerId === undefined) {\x0a            return leadingEdge(lastCallTime);\x0a          }\x0a          if (maxing) {\x0a            // Handle invocations in a tight loop.\x0a            timerId = setTimeout(timerExpired, wait);\x0a            return invokeFunc(lastCallTime);\x0a          }\x0a        }\x0a        if (timerId === undefined) {\x0a          timerId = setTimeout(timerExpired, wait);\x0a        }\x0a        return result;\x0a      }\x0a      debounced.cancel = cancel;\x0a      debounced.flush = flush;\x0a      return debounced;\x0a    }\x0a\x0a    /**\x0a     * Defers invoking the `func` until the current call stack has cleared. Any\x0a     * additional arguments are provided to `func` when it\x27s invoked.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Function\x0a     * @param {Function} func The function to defer.\x0a     * @param {...*} [args] The arguments to invoke `func` with.\x0a     * @returns {number} Returns the timer id.\x0a     * @example\x0a     *\x0a     * _.defer(function(text) {\x0a     *   console.log(text);\x0a     * }, \x27deferred\x27);\x0a     * // =\x3e Logs \x27deferred\x27 after one millisecond.\x0a     */\x0a    var defer = baseRest(function(func, args) {\x0a      return baseDelay(func, 1, args);\x0a    });\x0a\x0a    /**\x0a     * Invokes `func` after `wait` milliseconds. Any additional arguments are\x0a     * provided to `func` when it\x27s invoked.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Function\x0a     * @param {Function} func The function to delay.\x0a     * @param {number} wait The number of milliseconds to delay invocation.\x0a     * @param {...*} [args] The arguments to invoke `func` with.\x0a     * @returns {number} Returns the timer id.\x0a     * @example\x0a     *\x0a     * _.delay(function(text) {\x0a     *   console.log(text);\x0a     * }, 1000, \x27later\x27);\x0a     * // =\x3e Logs \x27later\x27 after one second.\x0a     */\x0a    var delay = baseRest(function(func, wait, args) {\x0a      return baseDelay(func, toNumber(wait) || 0, args);\x0a    });\x0a\x0a    /**\x0a     * Creates a function that invokes `func` with arguments reversed.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Function\x0a     * @param {Function} func The function to flip arguments for.\x0a     * @returns {Function} Returns the new flipped function.\x0a     * @example\x0a     *\x0a     * var flipped = _.flip(function() {\x0a     *   return _.toArray(arguments);\x0a     * });\x0a     *\x0a     * flipped(\x27a\x27, \x27b\x27, \x27c\x27, \x27d\x27);\x0a     * // =\x3e [\x27d\x27, \x27c\x27, \x27b\x27, \x27a\x27]\x0a     */\x0a    function flip(func) {\x0a      return createWrap(func, WRAP_FLIP_FLAG);\x0a    }\x0a\x0a    /**\x0a     * Creates a function that memoizes the result of `func`. If `resolver` is\x0a     * provided, it determines the cache key for storing the result based on the\x0a     * arguments provided to the memoized function. By default, the first argument\x0a     * provided to the memoized function is used as the map cache key. The `func`\x0a     * is invoked with the `this` binding of the memoized function.\x0a     *\x0a     * **Note:** The cache is exposed as the `cache` property on the memoized\x0a     * function. Its creation may be customized by replacing the `_.memoize.Cache`\x0a     * constructor with one whose instances implement the\x0a     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\x0a     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Function\x0a     * @param {Function} func The function to have its output memoized.\x0a     * @param {Function} [resolver] The function to resolve the cache key.\x0a     * @returns {Function} Returns the new memoized function.\x0a     * @example\x0a     *\x0a     * var object = { \x27a\x27: 1, \x27b\x27: 2 };\x0a     * var other = { \x27c\x27: 3, \x27d\x27: 4 };\x0a     *\x0a     * var values = _.memoize(_.values);\x0a     * values(object);\x0a     * // =\x3e [1, 2]\x0a     *\x0a     * values(other);\x0a     * // =\x3e [3, 4]\x0a     *\x0a     * object.a = 2;\x0a     * values(object);\x0a     * // =\x3e [1, 2]\x0a     *\x0a     * // Modify the result cache.\x0a     * values.cache.set(object, [\x27a\x27, \x27b\x27]);\x0a     * values(object);\x0a     * // =\x3e [\x27a\x27, \x27b\x27]\x0a     *\x0a     * // Replace `_.memoize.Cache`.\x0a     * _.memoize.Cache = WeakMap;\x0a     */\x0a    function memoize(func, resolver) {\x0a      if (typeof func != \x27function\x27 || (resolver != null && typeof resolver != \x27function\x27)) {\x0a        throw new TypeError(FUNC_ERROR_TEXT);\x0a      }\x0a      var memoized = function() {\x0a        var args = arguments,\x0a            key = resolver ? resolver.apply(this, args) : args[0],\x0a            cache = memoized.cache;\x0a\x0a        if (cache.has(key)) {\x0a          return cache.get(key);\x0a        }\x0a        var result = func.apply(this, args);\x0a        memoized.cache = cache.set(key, result) || cache;\x0a        return result;\x0a      };\x0a      memoized.cache = new (memoize.Cache || MapCache);\x0a      return memoized;\x0a    }\x0a\x0a    // Expose `MapCache`.\x0a    memoize.Cache = MapCache;\x0a\x0a    /**\x0a     * Creates a function that negates the result of the predicate `func`. The\x0a     * `func` predicate is invoked with the `this` binding and arguments of the\x0a     * created function.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Function\x0a     * @param {Function} predicate The predicate to negate.\x0a     * @returns {Function} Returns the new negated function.\x0a     * @example\x0a     *\x0a     * function isEven(n) {\x0a     *   return n % 2 == 0;\x0a     * }\x0a     *\x0a     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\x0a     * // =\x3e [1, 3, 5]\x0a     */\x0a    function negate(predicate) {\x0a      if (typeof predicate != \x27function\x27) {\x0a        throw new TypeError(FUNC_ERROR_TEXT);\x0a      }\x0a      return function() {\x0a        var args = arguments;\x0a        switch (args.length) {\x0a          case 0: return !predicate.call(this);\x0a          case 1: return !predicate.call(this, args[0]);\x0a          case 2: return !predicate.call(this, args[0], args[1]);\x0a          case 3: return !predicate.call(this, args[0], args[1], args[2]);\x0a        }\x0a        return !predicate.apply(this, args);\x0a      };\x0a    }\x0a\x0a    /**\x0a     * Creates a function that is restricted to invoking `func` once. Repeat calls\x0a     * to the function return the value of the first invocation. The `func` is\x0a     * invoked with the `this` binding and arguments of the created function.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Function\x0a     * @param {Function} func The function to restrict.\x0a     * @returns {Function} Returns the new restricted function.\x0a     * @example\x0a     *\x0a     * var initialize = _.once(createApplication);\x0a     * initialize();\x0a     * initialize();\x0a     * // =\x3e `createApplication` is invoked once\x0a     */\x0a    function once(func) {\x0a      return before(2, func);\x0a    }\x0a\x0a    /**\x0a     * Creates a function that invokes `func` with its arguments transformed.\x0a     *\x0a     * @static\x0a     * @since 4.0.0\x0a     * @memberOf _\x0a     * @category Function\x0a     * @param {Function} func The function to wrap.\x0a     * @param {...(Function|Function[])} [transforms=[_.identity]]\x0a     *  The argument transforms.\x0a     * @returns {Function} Returns the new function.\x0a     * @example\x0a     *\x0a     * function doubled(n) {\x0a     *   return n * 2;\x0a     * }\x0a     *\x0a     * function square(n) {\x0a     *   return n * n;\x0a     * }\x0a     *\x0a     * var func = _.overArgs(function(x, y) {\x0a     *   return [x, y];\x0a     * }, [square, doubled]);\x0a     *\x0a     * func(9, 3);\x0a     * // =\x3e [81, 6]\x0a     *\x0a     * func(10, 5);\x0a     * // =\x3e [100, 10]\x0a     */\x0a    var overArgs = castRest(function(func, transforms) {\x0a      transforms = (transforms.length == 1 && isArray(transforms[0]))\x0a        ? arrayMap(transforms[0], baseUnary(getIteratee()))\x0a        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\x0a\x0a      var funcsLength = transforms.length;\x0a      return baseRest(function(args) {\x0a        var index = -1,\x0a            length = nativeMin(args.length, funcsLength);\x0a\x0a        while (++index \x3c length) {\x0a          args[index] = transforms[index].call(this, args[index]);\x0a        }\x0a        return apply(func, this, args);\x0a      });\x0a    });\x0a\x0a    /**\x0a     * Creates a function that invokes `func` with `partials` prepended to the\x0a     * arguments it receives. This method is like `_.bind` except it does **not**\x0a     * alter the `this` binding.\x0a     *\x0a     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\x0a     * builds, may be used as a placeholder for partially applied arguments.\x0a     *\x0a     * **Note:** This method doesn\x27t set the \x22length\x22 property of partially\x0a     * applied functions.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.2.0\x0a     * @category Function\x0a     * @param {Function} func The function to partially apply arguments to.\x0a     * @param {...*} [partials] The arguments to be partially applied.\x0a     * @returns {Function} Returns the new partially applied function.\x0a     * @example\x0a     *\x0a     * function greet(greeting, name) {\x0a     *   return greeting + \x27 \x27 + name;\x0a     * }\x0a     *\x0a     * var sayHelloTo = _.partial(greet, \x27hello\x27);\x0a     * sayHelloTo(\x27fred\x27);\x0a     * // =\x3e \x27hello fred\x27\x0a     *\x0a     * // Partially applied with placeholders.\x0a     * var greetFred = _.partial(greet, _, \x27fred\x27);\x0a     * greetFred(\x27hi\x27);\x0a     * // =\x3e \x27hi fred\x27\x0a     */\x0a    var partial = baseRest(function(func, partials) {\x0a      var holders = replaceHolders(partials, getHolder(partial));\x0a      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\x0a    });\x0a\x0a    /**\x0a     * This method is like `_.partial` except that partially applied arguments\x0a     * are appended to the arguments it receives.\x0a     *\x0a     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\x0a     * builds, may be used as a placeholder for partially applied arguments.\x0a     *\x0a     * **Note:** This method doesn\x27t set the \x22length\x22 property of partially\x0a     * applied functions.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 1.0.0\x0a     * @category Function\x0a     * @param {Function} func The function to partially apply arguments to.\x0a     * @param {...*} [partials] The arguments to be partially applied.\x0a     * @returns {Function} Returns the new partially applied function.\x0a     * @example\x0a     *\x0a     * function greet(greeting, name) {\x0a     *   return greeting + \x27 \x27 + name;\x0a     * }\x0a     *\x0a     * var greetFred = _.partialRight(greet, \x27fred\x27);\x0a     * greetFred(\x27hi\x27);\x0a     * // =\x3e \x27hi fred\x27\x0a     *\x0a     * // Partially applied with placeholders.\x0a     * var sayHelloTo = _.partialRight(greet, \x27hello\x27, _);\x0a     * sayHelloTo(\x27fred\x27);\x0a     * // =\x3e \x27hello fred\x27\x0a     */\x0a    var partialRight = baseRest(function(func, partials) {\x0a      var holders = replaceHolders(partials, getHolder(partialRight));\x0a      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\x0a    });\x0a\x0a    /**\x0a     * Creates a function that invokes `func` with arguments arranged according\x0a     * to the specified `indexes` where the argument value at the first index is\x0a     * provided as the first argument, the argument value at the second index is\x0a     * provided as the second argument, and so on.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Function\x0a     * @param {Function} func The function to rearrange arguments for.\x0a     * @param {...(number|number[])} indexes The arranged argument indexes.\x0a     * @returns {Function} Returns the new function.\x0a     * @example\x0a     *\x0a     * var rearged = _.rearg(function(a, b, c) {\x0a     *   return [a, b, c];\x0a     * }, [2, 0, 1]);\x0a     *\x0a     * rearged(\x27b\x27, \x27c\x27, \x27a\x27)\x0a     * // =\x3e [\x27a\x27, \x27b\x27, \x27c\x27]\x0a     */\x0a    var rearg = flatRest(function(func, indexes) {\x0a      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\x0a    });\x0a\x0a    /**\x0a     * Creates a function that invokes `func` with the `this` binding of the\x0a     * created function and arguments from `start` and beyond provided as\x0a     * an array.\x0a     *\x0a     * **Note:** This method is based on the\x0a     * [rest parameter](https://mdn.io/rest_parameters).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Function\x0a     * @param {Function} func The function to apply a rest parameter to.\x0a     * @param {number} [start=func.length-1] The start position of the rest parameter.\x0a     * @returns {Function} Returns the new function.\x0a     * @example\x0a     *\x0a     * var say = _.rest(function(what, names) {\x0a     *   return what + \x27 \x27 + _.initial(names).join(\x27, \x27) +\x0a     *     (_.size(names) \x3e 1 ? \x27, & \x27 : \x27\x27) + _.last(names);\x0a     * });\x0a     *\x0a     * say(\x27hello\x27, \x27fred\x27, \x27barney\x27, \x27pebbles\x27);\x0a     * // =\x3e \x27hello fred, barney, & pebbles\x27\x0a     */\x0a    function rest(func, start) {\x0a      if (typeof func != \x27function\x27) {\x0a        throw new TypeError(FUNC_ERROR_TEXT);\x0a      }\x0a      start = start === undefined ? start : toInteger(start);\x0a      return baseRest(func, start);\x0a    }\x0a\x0a    /**\x0a     * Creates a function that invokes `func` with the `this` binding of the\x0a     * create function and an array of arguments much like\x0a     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\x0a     *\x0a     * **Note:** This method is based on the\x0a     * [spread operator](https://mdn.io/spread_operator).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.2.0\x0a     * @category Function\x0a     * @param {Function} func The function to spread arguments over.\x0a     * @param {number} [start=0] The start position of the spread.\x0a     * @returns {Function} Returns the new function.\x0a     * @example\x0a     *\x0a     * var say = _.spread(function(who, what) {\x0a     *   return who + \x27 says \x27 + what;\x0a     * });\x0a     *\x0a     * say([\x27fred\x27, \x27hello\x27]);\x0a     * // =\x3e \x27fred says hello\x27\x0a     *\x0a     * var numbers = Promise.all([\x0a     *   Promise.resolve(40),\x0a     *   Promise.resolve(36)\x0a     * ]);\x0a     *\x0a     * numbers.then(_.spread(function(x, y) {\x0a     *   return x + y;\x0a     * }));\x0a     * // =\x3e a Promise of 76\x0a     */\x0a    function spread(func, start) {\x0a      if (typeof func != \x27function\x27) {\x0a        throw new TypeError(FUNC_ERROR_TEXT);\x0a      }\x0a      start = start == null ? 0 : nativeMax(toInteger(start), 0);\x0a      return baseRest(function(args) {\x0a        var array = args[start],\x0a            otherArgs = castSlice(args, 0, start);\x0a\x0a        if (array) {\x0a          arrayPush(otherArgs, array);\x0a        }\x0a        return apply(func, this, otherArgs);\x0a      });\x0a    }\x0a\x0a    /**\x0a     * Creates a throttled function that only invokes `func` at most once per\x0a     * every `wait` milliseconds. The throttled function comes with a `cancel`\x0a     * method to cancel delayed `func` invocations and a `flush` method to\x0a     * immediately invoke them. Provide `options` to indicate whether `func`\x0a     * should be invoked on the leading and/or trailing edge of the `wait`\x0a     * timeout. The `func` is invoked with the last arguments provided to the\x0a     * throttled function. Subsequent calls to the throttled function return the\x0a     * result of the last `func` invocation.\x0a     *\x0a     * **Note:** If `leading` and `trailing` options are `true`, `func` is\x0a     * invoked on the trailing edge of the timeout only if the throttled function\x0a     * is invoked more than once during the `wait` timeout.\x0a     *\x0a     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\x0a     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\x0a     *\x0a     * See [David Corbacho\x27s article](https://css-tricks.com/debouncing-throttling-explained-examples/)\x0a     * for details over the differences between `_.throttle` and `_.debounce`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Function\x0a     * @param {Function} func The function to throttle.\x0a     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\x0a     * @param {Object} [options={}] The options object.\x0a     * @param {boolean} [options.leading=true]\x0a     *  Specify invoking on the leading edge of the timeout.\x0a     * @param {boolean} [options.trailing=true]\x0a     *  Specify invoking on the trailing edge of the timeout.\x0a     * @returns {Function} Returns the new throttled function.\x0a     * @example\x0a     *\x0a     * // Avoid excessively updating the position while scrolling.\x0a     * jQuery(window).on(\x27scroll\x27, _.throttle(updatePosition, 100));\x0a     *\x0a     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\x0a     * var throttled = _.throttle(renewToken, 300000, { \x27trailing\x27: false });\x0a     * jQuery(element).on(\x27click\x27, throttled);\x0a     *\x0a     * // Cancel the trailing throttled invocation.\x0a     * jQuery(window).on(\x27popstate\x27, throttled.cancel);\x0a     */\x0a    function throttle(func, wait, options) {\x0a      var leading = true,\x0a          trailing = true;\x0a\x0a      if (typeof func != \x27function\x27) {\x0a        throw new TypeError(FUNC_ERROR_TEXT);\x0a      }\x0a      if (isObject(options)) {\x0a        leading = \x27leading\x27 in options ? !!options.leading : leading;\x0a        trailing = \x27trailing\x27 in options ? !!options.trailing : trailing;\x0a      }\x0a      return debounce(func, wait, {\x0a        \x27leading\x27: leading,\x0a        \x27maxWait\x27: wait,\x0a        \x27trailing\x27: trailing\x0a      });\x0a    }\x0a\x0a    /**\x0a     * Creates a function that accepts up to one argument, ignoring any\x0a     * additional arguments.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Function\x0a     * @param {Function} func The function to cap arguments for.\x0a     * @returns {Function} Returns the new capped function.\x0a     * @example\x0a     *\x0a     * _.map([\x276\x27, \x278\x27, \x2710\x27], _.unary(parseInt));\x0a     * // =\x3e [6, 8, 10]\x0a     */\x0a    function unary(func) {\x0a      return ary(func, 1);\x0a    }\x0a\x0a    /**\x0a     * Creates a function that provides `value` to `wrapper` as its first\x0a     * argument. Any additional arguments provided to the function are appended\x0a     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\x0a     * binding of the created function.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Function\x0a     * @param {*} value The value to wrap.\x0a     * @param {Function} [wrapper=identity] The wrapper function.\x0a     * @returns {Function} Returns the new function.\x0a     * @example\x0a     *\x0a     * var p = _.wrap(_.escape, function(func, text) {\x0a     *   return \x27\x3cp\x3e\x27 + func(text) + \x27\x3c/p\x3e\x27;\x0a     * });\x0a     *\x0a     * p(\x27fred, barney, & pebbles\x27);\x0a     * // =\x3e \x27\x3cp\x3efred, barney, &amp; pebbles\x3c/p\x3e\x27\x0a     */\x0a    function wrap(value, wrapper) {\x0a      return partial(castFunction(wrapper), value);\x0a    }\x0a\x0a    /*------------------------------------------------------------------------*/\x0a\x0a    /**\x0a     * Casts `value` as an array if it\x27s not one.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.4.0\x0a     * @category Lang\x0a     * @param {*} value The value to inspect.\x0a     * @returns {Array} Returns the cast array.\x0a     * @example\x0a     *\x0a     * _.castArray(1);\x0a     * // =\x3e [1]\x0a     *\x0a     * _.castArray({ \x27a\x27: 1 });\x0a     * // =\x3e [{ \x27a\x27: 1 }]\x0a     *\x0a     * _.castArray(\x27abc\x27);\x0a     * // =\x3e [\x27abc\x27]\x0a     *\x0a     * _.castArray(null);\x0a     * // =\x3e [null]\x0a     *\x0a     * _.castArray(undefined);\x0a     * // =\x3e [undefined]\x0a     *\x0a     * _.castArray();\x0a     * // =\x3e []\x0a     *\x0a     * var array = [1, 2, 3];\x0a     * console.log(_.castArray(array) === array);\x0a     * // =\x3e true\x0a     */\x0a    function castArray() {\x0a      if (!arguments.length) {\x0a        return [];\x0a      }\x0a      var value = arguments[0];\x0a      return isArray(value) ? value : [value];\x0a    }\x0a\x0a    /**\x0a     * Creates a shallow clone of `value`.\x0a     *\x0a     * **Note:** This method is loosely based on the\x0a     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\x0a     * and supports cloning arrays, array buffers, booleans, date objects, maps,\x0a     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\x0a     * arrays. The own enumerable properties of `arguments` objects are cloned\x0a     * as plain objects. An empty object is returned for uncloneable values such\x0a     * as error objects, functions, DOM nodes, and WeakMaps.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to clone.\x0a     * @returns {*} Returns the cloned value.\x0a     * @see _.cloneDeep\x0a     * @example\x0a     *\x0a     * var objects = [{ \x27a\x27: 1 }, { \x27b\x27: 2 }];\x0a     *\x0a     * var shallow = _.clone(objects);\x0a     * console.log(shallow[0] === objects[0]);\x0a     * // =\x3e true\x0a     */\x0a    function clone(value) {\x0a      return baseClone(value, CLONE_SYMBOLS_FLAG);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.clone` except that it accepts `customizer` which\x0a     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\x0a     * cloning is handled by the method instead. The `customizer` is invoked with\x0a     * up to four arguments; (value [, index|key, object, stack]).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to clone.\x0a     * @param {Function} [customizer] The function to customize cloning.\x0a     * @returns {*} Returns the cloned value.\x0a     * @see _.cloneDeepWith\x0a     * @example\x0a     *\x0a     * function customizer(value) {\x0a     *   if (_.isElement(value)) {\x0a     *     return value.cloneNode(false);\x0a     *   }\x0a     * }\x0a     *\x0a     * var el = _.cloneWith(document.body, customizer);\x0a     *\x0a     * console.log(el === document.body);\x0a     * // =\x3e false\x0a     * console.log(el.nodeName);\x0a     * // =\x3e \x27BODY\x27\x0a     * console.log(el.childNodes.length);\x0a     * // =\x3e 0\x0a     */\x0a    function cloneWith(value, customizer) {\x0a      customizer = typeof customizer == \x27function\x27 ? customizer : undefined;\x0a      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.clone` except that it recursively clones `value`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 1.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to recursively clone.\x0a     * @returns {*} Returns the deep cloned value.\x0a     * @see _.clone\x0a     * @example\x0a     *\x0a     * var objects = [{ \x27a\x27: 1 }, { \x27b\x27: 2 }];\x0a     *\x0a     * var deep = _.cloneDeep(objects);\x0a     * console.log(deep[0] === objects[0]);\x0a     * // =\x3e false\x0a     */\x0a    function cloneDeep(value) {\x0a      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.cloneWith` except that it recursively clones `value`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to recursively clone.\x0a     * @param {Function} [customizer] The function to customize cloning.\x0a     * @returns {*} Returns the deep cloned value.\x0a     * @see _.cloneWith\x0a     * @example\x0a     *\x0a     * function customizer(value) {\x0a     *   if (_.isElement(value)) {\x0a     *     return value.cloneNode(true);\x0a     *   }\x0a     * }\x0a     *\x0a     * var el = _.cloneDeepWith(document.body, customizer);\x0a     *\x0a     * console.log(el === document.body);\x0a     * // =\x3e false\x0a     * console.log(el.nodeName);\x0a     * // =\x3e \x27BODY\x27\x0a     * console.log(el.childNodes.length);\x0a     * // =\x3e 20\x0a     */\x0a    function cloneDeepWith(value, customizer) {\x0a      customizer = typeof customizer == \x27function\x27 ? customizer : undefined;\x0a      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\x0a    }\x0a\x0a    /**\x0a     * Checks if `object` conforms to `source` by invoking the predicate\x0a     * properties of `source` with the corresponding property values of `object`.\x0a     *\x0a     * **Note:** This method is equivalent to `_.conforms` when `source` is\x0a     * partially applied.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.14.0\x0a     * @category Lang\x0a     * @param {Object} object The object to inspect.\x0a     * @param {Object} source The object of property predicates to conform to.\x0a     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\x0a     * @example\x0a     *\x0a     * var object = { \x27a\x27: 1, \x27b\x27: 2 };\x0a     *\x0a     * _.conformsTo(object, { \x27b\x27: function(n) { return n \x3e 1; } });\x0a     * // =\x3e true\x0a     *\x0a     * _.conformsTo(object, { \x27b\x27: function(n) { return n \x3e 2; } });\x0a     * // =\x3e false\x0a     */\x0a    function conformsTo(object, source) {\x0a      return source == null || baseConformsTo(object, source, keys(source));\x0a    }\x0a\x0a    /**\x0a     * Performs a\x0a     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\x0a     * comparison between two values to determine if they are equivalent.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to compare.\x0a     * @param {*} other The other value to compare.\x0a     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\x0a     * @example\x0a     *\x0a     * var object = { \x27a\x27: 1 };\x0a     * var other = { \x27a\x27: 1 };\x0a     *\x0a     * _.eq(object, object);\x0a     * // =\x3e true\x0a     *\x0a     * _.eq(object, other);\x0a     * // =\x3e false\x0a     *\x0a     * _.eq(\x27a\x27, \x27a\x27);\x0a     * // =\x3e true\x0a     *\x0a     * _.eq(\x27a\x27, Object(\x27a\x27));\x0a     * // =\x3e false\x0a     *\x0a     * _.eq(NaN, NaN);\x0a     * // =\x3e true\x0a     */\x0a    function eq(value, other) {\x0a      return value === other || (value !== value && other !== other);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is greater than `other`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.9.0\x0a     * @category Lang\x0a     * @param {*} value The value to compare.\x0a     * @param {*} other The other value to compare.\x0a     * @returns {boolean} Returns `true` if `value` is greater than `other`,\x0a     *  else `false`.\x0a     * @see _.lt\x0a     * @example\x0a     *\x0a     * _.gt(3, 1);\x0a     * // =\x3e true\x0a     *\x0a     * _.gt(3, 3);\x0a     * // =\x3e false\x0a     *\x0a     * _.gt(1, 3);\x0a     * // =\x3e false\x0a     */\x0a    var gt = createRelationalOperation(baseGt);\x0a\x0a    /**\x0a     * Checks if `value` is greater than or equal to `other`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.9.0\x0a     * @category Lang\x0a     * @param {*} value The value to compare.\x0a     * @param {*} other The other value to compare.\x0a     * @returns {boolean} Returns `true` if `value` is greater than or equal to\x0a     *  `other`, else `false`.\x0a     * @see _.lte\x0a     * @example\x0a     *\x0a     * _.gte(3, 1);\x0a     * // =\x3e true\x0a     *\x0a     * _.gte(3, 3);\x0a     * // =\x3e true\x0a     *\x0a     * _.gte(1, 3);\x0a     * // =\x3e false\x0a     */\x0a    var gte = createRelationalOperation(function(value, other) {\x0a      return value \x3e= other;\x0a    });\x0a\x0a    /**\x0a     * Checks if `value` is likely an `arguments` object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\x0a     *  else `false`.\x0a     * @example\x0a     *\x0a     * _.isArguments(function() { return arguments; }());\x0a     * // =\x3e true\x0a     *\x0a     * _.isArguments([1, 2, 3]);\x0a     * // =\x3e false\x0a     */\x0a    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\x0a      return isObjectLike(value) && hasOwnProperty.call(value, \x27callee\x27) &&\x0a        !propertyIsEnumerable.call(value, \x27callee\x27);\x0a    };\x0a\x0a    /**\x0a     * Checks if `value` is classified as an `Array` object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\x0a     * @example\x0a     *\x0a     * _.isArray([1, 2, 3]);\x0a     * // =\x3e true\x0a     *\x0a     * _.isArray(document.body.children);\x0a     * // =\x3e false\x0a     *\x0a     * _.isArray(\x27abc\x27);\x0a     * // =\x3e false\x0a     *\x0a     * _.isArray(_.noop);\x0a     * // =\x3e false\x0a     */\x0a    var isArray = Array.isArray;\x0a\x0a    /**\x0a     * Checks if `value` is classified as an `ArrayBuffer` object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.3.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\x0a     * @example\x0a     *\x0a     * _.isArrayBuffer(new ArrayBuffer(2));\x0a     * // =\x3e true\x0a     *\x0a     * _.isArrayBuffer(new Array(2));\x0a     * // =\x3e false\x0a     */\x0a    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\x0a\x0a    /**\x0a     * Checks if `value` is array-like. A value is considered array-like if it\x27s\x0a     * not a function and has a `value.length` that\x27s an integer greater than or\x0a     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\x0a     * @example\x0a     *\x0a     * _.isArrayLike([1, 2, 3]);\x0a     * // =\x3e true\x0a     *\x0a     * _.isArrayLike(document.body.children);\x0a     * // =\x3e true\x0a     *\x0a     * _.isArrayLike(\x27abc\x27);\x0a     * // =\x3e true\x0a     *\x0a     * _.isArrayLike(_.noop);\x0a     * // =\x3e false\x0a     */\x0a    function isArrayLike(value) {\x0a      return value != null && isLength(value.length) && !isFunction(value);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.isArrayLike` except that it also checks if `value`\x0a     * is an object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is an array-like object,\x0a     *  else `false`.\x0a     * @example\x0a     *\x0a     * _.isArrayLikeObject([1, 2, 3]);\x0a     * // =\x3e true\x0a     *\x0a     * _.isArrayLikeObject(document.body.children);\x0a     * // =\x3e true\x0a     *\x0a     * _.isArrayLikeObject(\x27abc\x27);\x0a     * // =\x3e false\x0a     *\x0a     * _.isArrayLikeObject(_.noop);\x0a     * // =\x3e false\x0a     */\x0a    function isArrayLikeObject(value) {\x0a      return isObjectLike(value) && isArrayLike(value);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is classified as a boolean primitive or object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\x0a     * @example\x0a     *\x0a     * _.isBoolean(false);\x0a     * // =\x3e true\x0a     *\x0a     * _.isBoolean(null);\x0a     * // =\x3e false\x0a     */\x0a    function isBoolean(value) {\x0a      return value === true || value === false ||\x0a        (isObjectLike(value) && baseGetTag(value) == boolTag);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is a buffer.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.3.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\x0a     * @example\x0a     *\x0a     * _.isBuffer(new Buffer(2));\x0a     * // =\x3e true\x0a     *\x0a     * _.isBuffer(new Uint8Array(2));\x0a     * // =\x3e false\x0a     */\x0a    var isBuffer = nativeIsBuffer || stubFalse;\x0a\x0a    /**\x0a     * Checks if `value` is classified as a `Date` object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\x0a     * @example\x0a     *\x0a     * _.isDate(new Date);\x0a     * // =\x3e true\x0a     *\x0a     * _.isDate(\x27Mon April 23 2012\x27);\x0a     * // =\x3e false\x0a     */\x0a    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\x0a\x0a    /**\x0a     * Checks if `value` is likely a DOM element.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\x0a     * @example\x0a     *\x0a     * _.isElement(document.body);\x0a     * // =\x3e true\x0a     *\x0a     * _.isElement(\x27\x3cbody\x3e\x27);\x0a     * // =\x3e false\x0a     */\x0a    function isElement(value) {\x0a      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is an empty object, collection, map, or set.\x0a     *\x0a     * Objects are considered empty if they have no own enumerable string keyed\x0a     * properties.\x0a     *\x0a     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\x0a     * jQuery-like collections are considered empty if they have a `length` of `0`.\x0a     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\x0a     * @example\x0a     *\x0a     * _.isEmpty(null);\x0a     * // =\x3e true\x0a     *\x0a     * _.isEmpty(true);\x0a     * // =\x3e true\x0a     *\x0a     * _.isEmpty(1);\x0a     * // =\x3e true\x0a     *\x0a     * _.isEmpty([1, 2, 3]);\x0a     * // =\x3e false\x0a     *\x0a     * _.isEmpty({ \x27a\x27: 1 });\x0a     * // =\x3e false\x0a     */\x0a    function isEmpty(value) {\x0a      if (value == null) {\x0a        return true;\x0a      }\x0a      if (isArrayLike(value) &&\x0a          (isArray(value) || typeof value == \x27string\x27 || typeof value.splice == \x27function\x27 ||\x0a            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\x0a        return !value.length;\x0a      }\x0a      var tag = getTag(value);\x0a      if (tag == mapTag || tag == setTag) {\x0a        return !value.size;\x0a      }\x0a      if (isPrototype(value)) {\x0a        return !baseKeys(value).length;\x0a      }\x0a      for (var key in value) {\x0a        if (hasOwnProperty.call(value, key)) {\x0a          return false;\x0a        }\x0a      }\x0a      return true;\x0a    }\x0a\x0a    /**\x0a     * Performs a deep comparison between two values to determine if they are\x0a     * equivalent.\x0a     *\x0a     * **Note:** This method supports comparing arrays, array buffers, booleans,\x0a     * date objects, error objects, maps, numbers, `Object` objects, regexes,\x0a     * sets, strings, symbols, and typed arrays. `Object` objects are compared\x0a     * by their own, not inherited, enumerable properties. Functions and DOM\x0a     * nodes are compared by strict equality, i.e. `===`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to compare.\x0a     * @param {*} other The other value to compare.\x0a     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\x0a     * @example\x0a     *\x0a     * var object = { \x27a\x27: 1 };\x0a     * var other = { \x27a\x27: 1 };\x0a     *\x0a     * _.isEqual(object, other);\x0a     * // =\x3e true\x0a     *\x0a     * object === other;\x0a     * // =\x3e false\x0a     */\x0a    function isEqual(value, other) {\x0a      return baseIsEqual(value, other);\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.isEqual` except that it accepts `customizer` which\x0a     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\x0a     * are handled by the method instead. The `customizer` is invoked with up to\x0a     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to compare.\x0a     * @param {*} other The other value to compare.\x0a     * @param {Function} [customizer] The function to customize comparisons.\x0a     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\x0a     * @example\x0a     *\x0a     * function isGreeting(value) {\x0a     *   return /^h(?:i|ello)$/.test(value);\x0a     * }\x0a     *\x0a     * function customizer(objValue, othValue) {\x0a     *   if (isGreeting(objValue) && isGreeting(othValue)) {\x0a     *     return true;\x0a     *   }\x0a     * }\x0a     *\x0a     * var array = [\x27hello\x27, \x27goodbye\x27];\x0a     * var other = [\x27hi\x27, \x27goodbye\x27];\x0a     *\x0a     * _.isEqualWith(array, other, customizer);\x0a     * // =\x3e true\x0a     */\x0a    function isEqualWith(value, other, customizer) {\x0a      customizer = typeof customizer == \x27function\x27 ? customizer : undefined;\x0a      var result = customizer ? customizer(value, other) : undefined;\x0a      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\x0a     * `SyntaxError`, `TypeError`, or `URIError` object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\x0a     * @example\x0a     *\x0a     * _.isError(new Error);\x0a     * // =\x3e true\x0a     *\x0a     * _.isError(Error);\x0a     * // =\x3e false\x0a     */\x0a    function isError(value) {\x0a      if (!isObjectLike(value)) {\x0a        return false;\x0a      }\x0a      var tag = baseGetTag(value);\x0a      return tag == errorTag || tag == domExcTag ||\x0a        (typeof value.message == \x27string\x27 && typeof value.name == \x27string\x27 && !isPlainObject(value));\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is a finite primitive number.\x0a     *\x0a     * **Note:** This method is based on\x0a     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\x0a     * @example\x0a     *\x0a     * _.isFinite(3);\x0a     * // =\x3e true\x0a     *\x0a     * _.isFinite(Number.MIN_VALUE);\x0a     * // =\x3e true\x0a     *\x0a     * _.isFinite(Infinity);\x0a     * // =\x3e false\x0a     *\x0a     * _.isFinite(\x273\x27);\x0a     * // =\x3e false\x0a     */\x0a    function isFinite(value) {\x0a      return typeof value == \x27number\x27 && nativeIsFinite(value);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is classified as a `Function` object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\x0a     * @example\x0a     *\x0a     * _.isFunction(_);\x0a     * // =\x3e true\x0a     *\x0a     * _.isFunction(/abc/);\x0a     * // =\x3e false\x0a     */\x0a    function isFunction(value) {\x0a      if (!isObject(value)) {\x0a        return false;\x0a      }\x0a      // The use of `Object#toString` avoids issues with the `typeof` operator\x0a      // in Safari 9 which returns \x27object\x27 for typed arrays and other constructors.\x0a      var tag = baseGetTag(value);\x0a      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is an integer.\x0a     *\x0a     * **Note:** This method is based on\x0a     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\x0a     * @example\x0a     *\x0a     * _.isInteger(3);\x0a     * // =\x3e true\x0a     *\x0a     * _.isInteger(Number.MIN_VALUE);\x0a     * // =\x3e false\x0a     *\x0a     * _.isInteger(Infinity);\x0a     * // =\x3e false\x0a     *\x0a     * _.isInteger(\x273\x27);\x0a     * // =\x3e false\x0a     */\x0a    function isInteger(value) {\x0a      return typeof value == \x27number\x27 && value == toInteger(value);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is a valid array-like length.\x0a     *\x0a     * **Note:** This method is loosely based on\x0a     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\x0a     * @example\x0a     *\x0a     * _.isLength(3);\x0a     * // =\x3e true\x0a     *\x0a     * _.isLength(Number.MIN_VALUE);\x0a     * // =\x3e false\x0a     *\x0a     * _.isLength(Infinity);\x0a     * // =\x3e false\x0a     *\x0a     * _.isLength(\x273\x27);\x0a     * // =\x3e false\x0a     */\x0a    function isLength(value) {\x0a      return typeof value == \x27number\x27 &&\x0a        value \x3e -1 && value % 1 == 0 && value \x3c= MAX_SAFE_INTEGER;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is the\x0a     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\x0a     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String(\x27\x27)`)\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\x0a     * @example\x0a     *\x0a     * _.isObject({});\x0a     * // =\x3e true\x0a     *\x0a     * _.isObject([1, 2, 3]);\x0a     * // =\x3e true\x0a     *\x0a     * _.isObject(_.noop);\x0a     * // =\x3e true\x0a     *\x0a     * _.isObject(null);\x0a     * // =\x3e false\x0a     */\x0a    function isObject(value) {\x0a      var type = typeof value;\x0a      return value != null && (type == \x27object\x27 || type == \x27function\x27);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is object-like. A value is object-like if it\x27s not `null`\x0a     * and has a `typeof` result of \x22object\x22.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\x0a     * @example\x0a     *\x0a     * _.isObjectLike({});\x0a     * // =\x3e true\x0a     *\x0a     * _.isObjectLike([1, 2, 3]);\x0a     * // =\x3e true\x0a     *\x0a     * _.isObjectLike(_.noop);\x0a     * // =\x3e false\x0a     *\x0a     * _.isObjectLike(null);\x0a     * // =\x3e false\x0a     */\x0a    function isObjectLike(value) {\x0a      return value != null && typeof value == \x27object\x27;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is classified as a `Map` object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.3.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\x0a     * @example\x0a     *\x0a     * _.isMap(new Map);\x0a     * // =\x3e true\x0a     *\x0a     * _.isMap(new WeakMap);\x0a     * // =\x3e false\x0a     */\x0a    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\x0a\x0a    /**\x0a     * Performs a partial deep comparison between `object` and `source` to\x0a     * determine if `object` contains equivalent property values.\x0a     *\x0a     * **Note:** This method is equivalent to `_.matches` when `source` is\x0a     * partially applied.\x0a     *\x0a     * Partial comparisons will match empty array and empty object `source`\x0a     * values against any array or object value, respectively. See `_.isEqual`\x0a     * for a list of supported value comparisons.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Lang\x0a     * @param {Object} object The object to inspect.\x0a     * @param {Object} source The object of property values to match.\x0a     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\x0a     * @example\x0a     *\x0a     * var object = { \x27a\x27: 1, \x27b\x27: 2 };\x0a     *\x0a     * _.isMatch(object, { \x27b\x27: 2 });\x0a     * // =\x3e true\x0a     *\x0a     * _.isMatch(object, { \x27b\x27: 1 });\x0a     * // =\x3e false\x0a     */\x0a    function isMatch(object, source) {\x0a      return object === source || baseIsMatch(object, source, getMatchData(source));\x0a    }\x0a\x0a    /**\x0a     * This method is like `_.isMatch` except that it accepts `customizer` which\x0a     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\x0a     * are handled by the method instead. The `customizer` is invoked with five\x0a     * arguments: (objValue, srcValue, index|key, object, source).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {Object} object The object to inspect.\x0a     * @param {Object} source The object of property values to match.\x0a     * @param {Function} [customizer] The function to customize comparisons.\x0a     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\x0a     * @example\x0a     *\x0a     * function isGreeting(value) {\x0a     *   return /^h(?:i|ello)$/.test(value);\x0a     * }\x0a     *\x0a     * function customizer(objValue, srcValue) {\x0a     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\x0a     *     return true;\x0a     *   }\x0a     * }\x0a     *\x0a     * var object = { \x27greeting\x27: \x27hello\x27 };\x0a     * var source = { \x27greeting\x27: \x27hi\x27 };\x0a     *\x0a     * _.isMatchWith(object, source, customizer);\x0a     * // =\x3e true\x0a     */\x0a    function isMatchWith(object, source, customizer) {\x0a      customizer = typeof customizer == \x27function\x27 ? customizer : undefined;\x0a      return baseIsMatch(object, source, getMatchData(source), customizer);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is `NaN`.\x0a     *\x0a     * **Note:** This method is based on\x0a     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\x0a     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\x0a     * `undefined` and other non-number values.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\x0a     * @example\x0a     *\x0a     * _.isNaN(NaN);\x0a     * // =\x3e true\x0a     *\x0a     * _.isNaN(new Number(NaN));\x0a     * // =\x3e true\x0a     *\x0a     * isNaN(undefined);\x0a     * // =\x3e true\x0a     *\x0a     * _.isNaN(undefined);\x0a     * // =\x3e false\x0a     */\x0a    function isNaN(value) {\x0a      // An `NaN` primitive is the only value that is not equal to itself.\x0a      // Perform the `toStringTag` check first to avoid errors with some\x0a      // ActiveX objects in IE.\x0a      return isNumber(value) && value != +value;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is a pristine native function.\x0a     *\x0a     * **Note:** This method can\x27t reliably detect native functions in the presence\x0a     * of the core-js package because core-js circumvents this kind of detection.\x0a     * Despite multiple requests, the core-js maintainer has made it clear: any\x0a     * attempt to fix the detection will be obstructed. As a result, we\x27re left\x0a     * with little choice but to throw an error. Unfortunately, this also affects\x0a     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\x0a     * which rely on core-js.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a native function,\x0a     *  else `false`.\x0a     * @example\x0a     *\x0a     * _.isNative(Array.prototype.push);\x0a     * // =\x3e true\x0a     *\x0a     * _.isNative(_);\x0a     * // =\x3e false\x0a     */\x0a    function isNative(value) {\x0a      if (isMaskable(value)) {\x0a        throw new Error(CORE_ERROR_TEXT);\x0a      }\x0a      return baseIsNative(value);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is `null`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\x0a     * @example\x0a     *\x0a     * _.isNull(null);\x0a     * // =\x3e true\x0a     *\x0a     * _.isNull(void 0);\x0a     * // =\x3e false\x0a     */\x0a    function isNull(value) {\x0a      return value === null;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is `null` or `undefined`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\x0a     * @example\x0a     *\x0a     * _.isNil(null);\x0a     * // =\x3e true\x0a     *\x0a     * _.isNil(void 0);\x0a     * // =\x3e true\x0a     *\x0a     * _.isNil(NaN);\x0a     * // =\x3e false\x0a     */\x0a    function isNil(value) {\x0a      return value == null;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is classified as a `Number` primitive or object.\x0a     *\x0a     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\x0a     * classified as numbers, use the `_.isFinite` method.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\x0a     * @example\x0a     *\x0a     * _.isNumber(3);\x0a     * // =\x3e true\x0a     *\x0a     * _.isNumber(Number.MIN_VALUE);\x0a     * // =\x3e true\x0a     *\x0a     * _.isNumber(Infinity);\x0a     * // =\x3e true\x0a     *\x0a     * _.isNumber(\x273\x27);\x0a     * // =\x3e false\x0a     */\x0a    function isNumber(value) {\x0a      return typeof value == \x27number\x27 ||\x0a        (isObjectLike(value) && baseGetTag(value) == numberTag);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is a plain object, that is, an object created by the\x0a     * `Object` constructor or one with a `[[Prototype]]` of `null`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.8.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\x0a     * @example\x0a     *\x0a     * function Foo() {\x0a     *   this.a = 1;\x0a     * }\x0a     *\x0a     * _.isPlainObject(new Foo);\x0a     * // =\x3e false\x0a     *\x0a     * _.isPlainObject([1, 2, 3]);\x0a     * // =\x3e false\x0a     *\x0a     * _.isPlainObject({ \x27x\x27: 0, \x27y\x27: 0 });\x0a     * // =\x3e true\x0a     *\x0a     * _.isPlainObject(Object.create(null));\x0a     * // =\x3e true\x0a     */\x0a    function isPlainObject(value) {\x0a      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\x0a        return false;\x0a      }\x0a      var proto = getPrototype(value);\x0a      if (proto === null) {\x0a        return true;\x0a      }\x0a      var Ctor = hasOwnProperty.call(proto, \x27constructor\x27) && proto.constructor;\x0a      return typeof Ctor == \x27function\x27 && Ctor instanceof Ctor &&\x0a        funcToString.call(Ctor) == objectCtorString;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is classified as a `RegExp` object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 0.1.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\x0a     * @example\x0a     *\x0a     * _.isRegExp(/abc/);\x0a     * // =\x3e true\x0a     *\x0a     * _.isRegExp(\x27/abc/\x27);\x0a     * // =\x3e false\x0a     */\x0a    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\x0a\x0a    /**\x0a     * Checks if `value` is a safe integer. An integer is safe if it\x27s an IEEE-754\x0a     * double precision number which isn\x27t the result of a rounded unsafe integer.\x0a     *\x0a     * **Note:** This method is based on\x0a     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\x0a     * @example\x0a     *\x0a     * _.isSafeInteger(3);\x0a     * // =\x3e true\x0a     *\x0a     * _.isSafeInteger(Number.MIN_VALUE);\x0a     * // =\x3e false\x0a     *\x0a     * _.isSafeInteger(Infinity);\x0a     * // =\x3e false\x0a     *\x0a     * _.isSafeInteger(\x273\x27);\x0a     * // =\x3e false\x0a     */\x0a    function isSafeInteger(value) {\x0a      return isInteger(value) && value \x3e= -MAX_SAFE_INTEGER && value \x3c= MAX_SAFE_INTEGER;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is classified as a `Set` object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.3.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\x0a     * @example\x0a     *\x0a     * _.isSet(new Set);\x0a     * // =\x3e true\x0a     *\x0a     * _.isSet(new WeakSet);\x0a     * // =\x3e false\x0a     */\x0a    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\x0a\x0a    /**\x0a     * Checks if `value` is classified as a `String` primitive or object.\x0a     *\x0a     * @static\x0a     * @since 0.1.0\x0a     * @memberOf _\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\x0a     * @example\x0a     *\x0a     * _.isString(\x27abc\x27);\x0a     * // =\x3e true\x0a     *\x0a     * _.isString(1);\x0a     * // =\x3e false\x0a     */\x0a    function isString(value) {\x0a      return typeof value == \x27string\x27 ||\x0a        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is classified as a `Symbol` primitive or object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\x0a     * @example\x0a     *\x0a     * _.isSymbol(Symbol.iterator);\x0a     * // =\x3e true\x0a     *\x0a     * _.isSymbol(\x27abc\x27);\x0a     * // =\x3e false\x0a     */\x0a    function isSymbol(value) {\x0a      return typeof value == \x27symbol\x27 ||\x0a        (isObjectLike(value) && baseGetTag(value) == symbolTag);\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is classified as a typed array.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\x0a     * @example\x0a     *\x0a     * _.isTypedArray(new Uint8Array);\x0a     * // =\x3e true\x0a     *\x0a     * _.isTypedArray([]);\x0a     * // =\x3e false\x0a     */\x0a    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\x0a\x0a    /**\x0a     * Checks if `value` is `undefined`.\x0a     *\x0a     * @static\x0a     * @since 0.1.0\x0a     * @memberOf _\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\x0a     * @example\x0a     *\x0a     * _.isUndefined(void 0);\x0a     * // =\x3e true\x0a     *\x0a     * _.isUndefined(null);\x0a     * // =\x3e false\x0a     */\x0a    function isUndefined(value) {\x0a      return value === undefined;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is classified as a `WeakMap` object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.3.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\x0a     * @example\x0a     *\x0a     * _.isWeakMap(new WeakMap);\x0a     * // =\x3e true\x0a     *\x0a     * _.isWeakMap(new Map);\x0a     * // =\x3e false\x0a     */\x0a    function isWeakMap(value) {\x0a      return isObjectLike(value) && getTag(value) == weakMapTag;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is classified as a `WeakSet` object.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.3.0\x0a     * @category Lang\x0a     * @param {*} value The value to check.\x0a     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\x0a     * @example\x0a     *\x0a     * _.isWeakSet(new WeakSet);\x0a     * // =\x3e true\x0a     *\x0a     * _.isWeakSet(new Set);\x0a     * // =\x3e false\x0a     */\x0a    function isWeakSet(value) {\x0a      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\x0a    }\x0a\x0a    /**\x0a     * Checks if `value` is less than `other`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.9.0\x0a     * @category Lang\x0a     * @param {*} value The value to compare.\x0a     * @param {*} other The other value to compare.\x0a     * @returns {boolean} Returns `true` if `value` is less than `other`,\x0a     *  else `false`.\x0a     * @see _.gt\x0a     * @example\x0a     *\x0a     * _.lt(1, 3);\x0a     * // =\x3e true\x0a     *\x0a     * _.lt(3, 3);\x0a     * // =\x3e false\x0a     *\x0a     * _.lt(3, 1);\x0a     * // =\x3e false\x0a     */\x0a    var lt = createRelationalOperation(baseLt);\x0a\x0a    /**\x0a     * Checks if `value` is less than or equal to `other`.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 3.9.0\x0a     * @category Lang\x0a     * @param {*} value The value to compare.\x0a     * @param {*} other The other value to compare.\x0a     * @returns {boolean} Returns `true` if `value` is less than or equal to\x0a     *  `other`, else `false`.\x0a     * @see _.gte\x0a     * @example\x0a     *\x0a     * _.lte(1, 3);\x0a     * // =\x3e true\x0a     *\x0a     * _.lte(3, 3);\x0a     * // =\x3e true\x0a     *\x0a     * _.lte(3, 1);\x0a     * // =\x3e false\x0a     */\x0a    var lte = createRelationalOperation(function(value, other) {\x0a      return value \x3c= other;\x0a    });\x0a\x0a    /**\x0a     * Converts `value` to an array.\x0a     *\x0a     * @static\x0a     * @since 0.1.0\x0a     * @memberOf _\x0a     * @category Lang\x0a     * @param {*} value The value to convert.\x0a     * @returns {Array} Returns the converted array.\x0a     * @example\x0a     *\x0a     * _.toArray({ \x27a\x27: 1, \x27b\x27: 2 });\x0a     * // =\x3e [1, 2]\x0a     *\x0a     * _.toArray(\x27abc\x27);\x0a     * // =\x3e [\x27a\x27, \x27b\x27, \x27c\x27]\x0a     *\x0a     * _.toArray(1);\x0a     * // =\x3e []\x0a     *\x0a     * _.toArray(null);\x0a     * // =\x3e []\x0a     */\x0a    function toArray(value) {\x0a      if (!value) {\x0a        return [];\x0a      }\x0a      if (isArrayLike(value)) {\x0a        return isString(value) ? stringToArray(value) : copyArray(value);\x0a      }\x0a      if (symIterator && value[symIterator]) {\x0a        return iteratorToArray(value[symIterator]());\x0a      }\x0a      var tag = getTag(value),\x0a          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\x0a\x0a      return func(value);\x0a    }\x0a\x0a    /**\x0a     * Converts `value` to a finite number.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.12.0\x0a     * @category Lang\x0a     * @param {*} value The value to convert.\x0a     * @returns {number} Returns the converted number.\x0a     * @example\x0a     *\x0a     * _.toFinite(3.2);\x0a     * // =\x3e 3.2\x0a     *\x0a     * _.toFinite(Number.MIN_VALUE);\x0a     * // =\x3e 5e-324\x0a     *\x0a     * _.toFinite(Infinity);\x0a     * // =\x3e 1.7976931348623157e+308\x0a     *\x0a     * _.toFinite(\x273.2\x27);\x0a     * // =\x3e 3.2\x0a     */\x0a    function toFinite(value) {\x0a      if (!value) {\x0a        return value === 0 ? value : 0;\x0a      }\x0a      value = toNumber(value);\x0a      if (value === INFINITY || value === -INFINITY) {\x0a        var sign = (value \x3c 0 ? -1 : 1);\x0a        return sign * MAX_INTEGER;\x0a      }\x0a      return value === value ? value : 0;\x0a    }\x0a\x0a    /**\x0a     * Converts `value` to an integer.\x0a     *\x0a     * **Note:** This method is loosely based on\x0a     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to convert.\x0a     * @returns {number} Returns the converted integer.\x0a     * @example\x0a     *\x0a     * _.toInteger(3.2);\x0a     * // =\x3e 3\x0a     *\x0a     * _.toInteger(Number.MIN_VALUE);\x0a     * // =\x3e 0\x0a     *\x0a     * _.toInteger(Infinity);\x0a     * // =\x3e 1.7976931348623157e+308\x0a     *\x0a     * _.toInteger(\x273.2\x27);\x0a     * // =\x3e 3\x0a     */\x0a    function toInteger(value) {\x0a      var result = toFinite(value),\x0a          remainder = result % 1;\x0a\x0a      return result === result ? (remainder ? result - remainder : result) : 0;\x0a    }\x0a\x0a    /**\x0a     * Converts `value` to an integer suitable for use as the length of an\x0a     * array-like object.\x0a     *\x0a     * **Note:** This method is based on\x0a     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to convert.\x0a     * @returns {number} Returns the converted integer.\x0a     * @example\x0a     *\x0a     * _.toLength(3.2);\x0a     * // =\x3e 3\x0a     *\x0a     * _.toLength(Number.MIN_VALUE);\x0a     * // =\x3e 0\x0a     *\x0a     * _.toLength(Infinity);\x0a     * // =\x3e 4294967295\x0a     *\x0a     * _.toLength(\x273.2\x27);\x0a     * // =\x3e 3\x0a     */\x0a    function toLength(value) {\x0a      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\x0a    }\x0a\x0a    /**\x0a     * Converts `value` to a number.\x0a     *\x0a     * @static\x0a     * @memberOf _\x0a     * @since 4.0.0\x0a     * @category Lang\x0a     * @param {*} value The value to process.\x0a     * @returns {number} Returns the number.\x0a     * @example\x0a     *\x0a     * _.toNumber(3.2);\x0a     * // =\x3e 3.2\x0a     *\x0a     * _.toNumber(Number.MIN_VALUE);\x0a     * // =\x3e 5e-324\x0a     *\x0a     * _.toNumber(Infinity);\x0a     * // =\x3e Infinity\x0a     *\x0a     * _.toNumber(\x273.2\x27);\x0a     * // =\x3e 3.2\x0a     */\x0a    function toNumber(value) {\x0a      if (typeof value == \x27number\x27) {\x0a        return value;\x0a      }\x0a      if (isSymbol(value)) {\x0a        return NAN;\x0a      }\x0a      if (isObject(value)) {\x0a        var other = typeof value.valueOf == \x27function\x27 ? value.valueOf() : value;\x0a        value = isObject(other) ? (other + \x27\x27) : other;\x0a      }\x0a      if (typeof value != \x27string\x27) {\x0a        return value === 0 ? value : +value;\x0a      }\x0a      value = value.replace(reTrim, \x27\x27);\x0a      var isBinary = reIsBinary.test(value);\x0a      return (isBinary || reIsOctal.test(value))\x0a        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\x0a        : (reIsBadHex.test(value) ? NAN : +value);\x0a    }\x0a\x0a    /**\x0a     * Converts `value` to a plain object flattening inherited enumerable string\x0a     * keyed properties of `value` to own pr'}