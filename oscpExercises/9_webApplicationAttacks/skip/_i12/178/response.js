var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:05:01 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 21 Mar 2019 12:48:00 GMT\x0aETag: \x229a9f-5849a25f20000-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-9148/9149\x0aContent-Length: 9149\x0aKeep-Alive: timeout=5, max=100\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0athis[\x22wp\x22] = this[\x22wp\x22] || {}; this[\x22wp\x22][\x22url\x22] =\x0a/******/ (function(modules) { // webpackBootstrap\x0a/******/ \x09// The module cache\x0a/******/ \x09var installedModules = {};\x0a/******/\x0a/******/ \x09// The require function\x0a/******/ \x09function __webpack_require__(moduleId) {\x0a/******/\x0a/******/ \x09\x09// Check if module is in cache\x0a/******/ \x09\x09if(installedModules[moduleId]) {\x0a/******/ \x09\x09\x09return installedModules[moduleId].exports;\x0a/******/ \x09\x09}\x0a/******/ \x09\x09// Create a new module (and put it into the cache)\x0a/******/ \x09\x09var module = installedModules[moduleId] = {\x0a/******/ \x09\x09\x09i: moduleId,\x0a/******/ \x09\x09\x09l: false,\x0a/******/ \x09\x09\x09exports: {}\x0a/******/ \x09\x09};\x0a/******/\x0a/******/ \x09\x09// Execute the module function\x0a/******/ \x09\x09modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\x0a/******/\x0a/******/ \x09\x09// Flag the module as loaded\x0a/******/ \x09\x09module.l = true;\x0a/******/\x0a/******/ \x09\x09// Return the exports of the module\x0a/******/ \x09\x09return module.exports;\x0a/******/ \x09}\x0a/******/\x0a/******/\x0a/******/ \x09// expose the modules object (__webpack_modules__)\x0a/******/ \x09__webpack_require__.m = modules;\x0a/******/\x0a/******/ \x09// expose the module cache\x0a/******/ \x09__webpack_require__.c = installedModules;\x0a/******/\x0a/******/ \x09// define getter function for harmony exports\x0a/******/ \x09__webpack_require__.d = function(exports, name, getter) {\x0a/******/ \x09\x09if(!__webpack_require__.o(exports, name)) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, name, { enumerable: true, get: getter });\x0a/******/ \x09\x09}\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// define __esModule on exports\x0a/******/ \x09__webpack_require__.r = function(exports) {\x0a/******/ \x09\x09if(typeof Symbol !== \x27undefined\x27 && Symbol.toStringTag) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, Symbol.toStringTag, { value: \x27Module\x27 });\x0a/******/ \x09\x09}\x0a/******/ \x09\x09Object.defineProperty(exports, \x27__esModule\x27, { value: true });\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// create a fake namespace object\x0a/******/ \x09// mode & 1: value is a module id, require it\x0a/******/ \x09// mode & 2: merge all properties of value into the ns\x0a/******/ \x09// mode & 4: return value when already ns object\x0a/******/ \x09// mode & 8|1: behave like require\x0a/******/ \x09__webpack_require__.t = function(value, mode) {\x0a/******/ \x09\x09if(mode & 1) value = __webpack_require__(value);\x0a/******/ \x09\x09if(mode & 8) return value;\x0a/******/ \x09\x09if((mode & 4) && typeof value === \x27object\x27 && value && value.__esModule) return value;\x0a/******/ \x09\x09var ns = Object.create(null);\x0a/******/ \x09\x09__webpack_require__.r(ns);\x0a/******/ \x09\x09Object.defineProperty(ns, \x27default\x27, { enumerable: true, value: value });\x0a/******/ \x09\x09if(mode & 2 && typeof value != \x27string\x27) for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\x0a/******/ \x09\x09return ns;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// getDefaultExport function for compatibility with non-harmony modules\x0a/******/ \x09__webpack_require__.n = function(module) {\x0a/******/ \x09\x09var getter = module && module.__esModule ?\x0a/******/ \x09\x09\x09function getDefault() { return module[\x27default\x27]; } :\x0a/******/ \x09\x09\x09function getModuleExports() { return module; };\x0a/******/ \x09\x09__webpack_require__.d(getter, \x27a\x27, getter);\x0a/******/ \x09\x09return getter;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// Object.prototype.hasOwnProperty.call\x0a/******/ \x09__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\x0a/******/\x0a/******/ \x09// __webpack_public_path__\x0a/******/ \x09__webpack_require__.p = \x22\x22;\x0a/******/\x0a/******/\x0a/******/ \x09// Load entry module and return exports\x0a/******/ \x09return __webpack_require__(__webpack_require__.s = 354);\x0a/******/ })\x0a/************************************************************************/\x0a/******/ ({\x0a\x0a/***/ 201:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0avar has = Object.prototype.hasOwnProperty;\x0a\x0avar hexTable = (function () {\x0a    var array = [];\x0a    for (var i = 0; i \x3c 256; ++i) {\x0a        array.push(\x27%\x27 + ((i \x3c 16 ? \x270\x27 : \x27\x27) + i.toString(16)).toUpperCase());\x0a    }\x0a\x0a    return array;\x0a}());\x0a\x0avar compactQueue = function compactQueue(queue) {\x0a    while (queue.length \x3e 1) {\x0a        var item = queue.pop();\x0a        var obj = item.obj[item.prop];\x0a\x0a        if (Array.isArray(obj)) {\x0a            var compacted = [];\x0a\x0a            for (var j = 0; j \x3c obj.length; ++j) {\x0a                if (typeof obj[j] !== \x27undefined\x27) {\x0a                    compacted.push(obj[j]);\x0a                }\x0a            }\x0a\x0a            item.obj[item.prop] = compacted;\x0a        }\x0a    }\x0a};\x0a\x0avar arrayToObject = function arrayToObject(source, options) {\x0a    var obj = options && options.plainObjects ? Object.create(null) : {};\x0a    for (var i = 0; i \x3c source.length; ++i) {\x0a        if (typeof source[i] !== \x27undefined\x27) {\x0a            obj[i] = source[i];\x0a        }\x0a    }\x0a\x0a    return obj;\x0a};\x0a\x0avar merge = function merge(target, source, options) {\x0a    if (!source) {\x0a        return target;\x0a    }\x0a\x0a    if (typeof source !== \x27object\x27) {\x0a        if (Array.isArray(target)) {\x0a            target.push(source);\x0a        } else if (typeof target === \x27object\x27) {\x0a            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {\x0a                target[source] = true;\x0a            }\x0a        } else {\x0a            return [target, source];\x0a        }\x0a\x0a        return target;\x0a    }\x0a\x0a    if (typeof target !== \x27object\x27) {\x0a        return [target].concat(source);\x0a    }\x0a\x0a    var mergeTarget = target;\x0a    if (Array.isArray(target) && !Array.isArray(source)) {\x0a        mergeTarget = arrayToObject(target, options);\x0a    }\x0a\x0a    if (Array.isArray(target) && Array.isArray(source)) {\x0a        source.forEach(function (item, i) {\x0a            if (has.call(target, i)) {\x0a                if (target[i] && typeof target[i] === \x27object\x27) {\x0a                    target[i] = merge(target[i], item, options);\x0a                } else {\x0a                    target.push(item);\x0a                }\x0a            } else {\x0a                target[i] = item;\x0a            }\x0a        });\x0a        return target;\x0a    }\x0a\x0a    return Object.keys(source).reduce(function (acc, key) {\x0a        var value = source[key];\x0a\x0a        if (has.call(acc, key)) {\x0a            acc[key] = merge(acc[key], value, options);\x0a        } else {\x0a            acc[key] = value;\x0a        }\x0a        return acc;\x0a    }, mergeTarget);\x0a};\x0a\x0avar assign = function assignSingleSource(target, source) {\x0a    return Object.keys(source).reduce(function (acc, key) {\x0a        acc[key] = source[key];\x0a        return acc;\x0a    }, target);\x0a};\x0a\x0avar decode = function (str, decoder, charset) {\x0a    var strWithoutPlus = str.replace(/\x5c+/g, \x27 \x27);\x0a    if (charset === \x27iso-8859-1\x27) {\x0a        // unescape never throws, no try...catch needed:\x0a        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\x0a    }\x0a    // utf-8\x0a    try {\x0a        return decodeURIComponent(strWithoutPlus);\x0a    } catch (e) {\x0a        return strWithoutPlus;\x0a    }\x0a};\x0a\x0avar encode = function encode(str, defaultEncoder, charset) {\x0a    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\x0a    // It has been adapted here for stricter adherence to RFC 3986\x0a    if (str.length === 0) {\x0a        return str;\x0a    }\x0a\x0a    var string = typeof str === \x27string\x27 ? str : String(str);\x0a\x0a    if (charset === \x27iso-8859-1\x27) {\x0a        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\x0a            return \x27%26%23\x27 + parseInt($0.slice(2), 16) + \x27%3B\x27;\x0a        });\x0a    }\x0a\x0a    var out = \x27\x27;\x0a    for (var i = 0; i \x3c string.length; ++i) {\x0a        var c = string.charCodeAt(i);\x0a\x0a        if (\x0a            c === 0x2D // -\x0a            || c === 0x2E // .\x0a            || c === 0x5F // _\x0a            || c === 0x7E // ~\x0a            || (c \x3e= 0x30 && c \x3c= 0x39) // 0-9\x0a            || (c \x3e= 0x41 && c \x3c= 0x5A) // a-z\x0a            || (c \x3e= 0x61 && c \x3c= 0x7A) // A-Z\x0a        ) {\x0a            out += string.charAt(i);\x0a            continue;\x0a        }\x0a\x0a        if (c \x3c 0x80) {\x0a            out = out + hexTable[c];\x0a            continue;\x0a        }\x0a\x0a        if (c \x3c 0x800) {\x0a            out = out + (hexTable[0xC0 | (c \x3e\x3e 6)] + hexTable[0x80 | (c & 0x3F)]);\x0a            continue;\x0a        }\x0a\x0a        if (c \x3c 0xD800 || c \x3e= 0xE000) {\x0a            out = out + (hexTable[0xE0 | (c \x3e\x3e 12)] + hexTable[0x80 | ((c \x3e\x3e 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\x0a            continue;\x0a        }\x0a\x0a        i += 1;\x0a        c = 0x10000 + (((c & 0x3FF) \x3c\x3c 10) | (string.charCodeAt(i) & 0x3FF));\x0a        out += hexTable[0xF0 | (c \x3e\x3e 18)]\x0a            + hexTable[0x80 | ((c \x3e\x3e 12) & 0x3F)]\x0a            + hexTable[0x80 | ((c \x3e\x3e 6) & 0x3F)]\x0a            + hexTable[0x80 | (c & 0x3F)];\x0a    }\x0a\x0a    return out;\x0a};\x0a\x0avar compact = function compact(value) {\x0a    var queue = [{ obj: { o: value }, prop: \x27o\x27 }];\x0a    var refs = [];\x0a\x0a    for (var i = 0; i \x3c queue.length; ++i) {\x0a        var item = queue[i];\x0a        var obj = item.obj[item.prop];\x0a\x0a        var keys = Object.keys(obj);\x0a        for (var j = 0; j \x3c keys.length; ++j) {\x0a            var key = keys[j];\x0a            var val = obj[key];\x0a            if (typeof val === \x27object\x27 && val !== null && refs.indexOf(val) === -1) {\x0a                queue.push({ obj: obj, prop: key });\x0a                refs.push(val);\x0a            }\x0a        }\x0a    }\x0a\x0a    compactQueue(queue);\x0a\x0a    return value;\x0a};\x0a\x0avar isRegExp = function isRegExp(obj) {\x0a    return Object.prototype.toString.call(obj) === \x27[object RegExp]\x27;\x0a};\x0a\x0avar isBuffer = function isBuffer(obj) {\x0a    if (obj === null || typeof obj === \x27undefined\x27) {\x0a        return false;\x0a    }\x0a\x0a    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\x0a};\x0a\x0avar combine = function combine(a, b) {\x0a    return [].concat(a, b);\x0a};\x0a\x0amodule.exports = {\x0a    arrayToObject: arrayToObject,\x0a    assign: assign,\x0a    combine: combine,\x0a    compact: compact,\x0a    decode: decode,\x0a    encode: encode,\x0a    isBuffer: isBuffer,\x0a    isRegExp: isRegExp,\x0a    merge: merge\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 202:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0avar replace = String.prototype.replace;\x0avar percentTwenties = /%20/g;\x0a\x0amodule.exports = {\x0a    \x27default\x27: \x27RFC3986\x27,\x0a    formatters: {\x0a        RFC1738: function (value) {\x0a            return replace.call(value, percentTwenties, \x27+\x27);\x0a        },\x0a        RFC3986: function (value) {\x0a            return value;\x0a        }\x0a    },\x0a    RFC1738: \x27RFC1738\x27,\x0a    RFC3986: \x27RFC3986\x27\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 354:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22isURL\x22, function() { return isURL; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22getProtocol\x22, function() { return getProtocol; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22isValidProtocol\x22, function() { return isValidProtocol; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22getAuthority\x22, function() { return getAuthority; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22isValidAuthority\x22, function() { return isValidAuthority; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22getPath\x22, function() { return getPath; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22isValidPath\x22, function() { return isValidPath; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22getQueryString\x22, function() { return getQueryString; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22isValidQueryString\x22, function() { return isValidQueryString; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22getFragment\x22, function() { return getFragment; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22isValidFragment\x22, function() { return isValidFragment; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22addQueryArgs\x22, function() { return addQueryArgs; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22getQueryArg\x22, function() { return getQueryArg; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22hasQueryArg\x22, function() { return hasQueryArg; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22removeQueryArgs\x22, function() { return removeQueryArgs; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22prependHTTP\x22, function() { return prependHTTP; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22safeDecodeURI\x22, function() { return safeDecodeURI; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22filterURLForDisplay\x22, function() { return filterURLForDisplay; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22safeDecodeURIComponent\x22, function() { return safeDecodeURIComponent; });\x0a/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);\x0a/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(qs__WEBPACK_IMPORTED_MODULE_0__);\x0a/**\x0a * External dependencies\x0a */\x0a\x0avar URL_REGEXP = /^(?:https?:)?\x5c/\x5c/\x5cS+$/i;\x0avar EMAIL_REGEXP = /^(mailto:)?[a-z0-9._%+-]+@[a-z0-9][a-z0-9.-]*\x5c.[a-z]{2,63}$/i;\x0avar USABLE_HREF_REGEXP = /^(?:[a-z]+:|#|\x5c?|\x5c.|\x5c/)/i;\x0a/**\x0a * Determines whether the given string looks like a URL.\x0a *\x0a * @param {string} url The string to scrutinise.\x0a *\x0a * @example\x0a * ```js\x0a * const isURL = isURL( \x27https://wordpress.org\x27 ); // true\x0a * ```\x0a *\x0a * @return {boolean} Whether or not it looks like a URL.\x0a */\x0a\x0afunction isURL(url) {\x0a  return URL_REGEXP.test(url);\x0a}\x0a/**\x0a * Returns the protocol part of the URL.\x0a *\x0a * @param {string} url The full URL.\x0a *\x0a * @example\x0a * ```js\x0a * const protocol1 = getProtocol( \x27tel:012345678\x27 ); // \x27tel:\x27\x0a * const protocol2 = getProtocol( \x27https://wordpress.org\x27 ); // \x27https:\x27\x0a * ```\x0a *\x0a * @return {?string} The protocol part of the URL.\x0a */\x0a\x0afunction getProtocol(url) {\x0a  var matches = /^([^\x5cs:]+:)/.exec(url);\x0a\x0a  if (matches) {\x0a    return matches[1];\x0a  }\x0a}\x0a/**\x0a * Tests if a url protocol is valid.\x0a *\x0a * @param {string} protocol The url protocol.\x0a *\x0a * @example\x0a * ```js\x0a * const isValid = isValidProtocol( \x27https:\x27 ); // true\x0a * const isNotValid = isValidProtocol( \x27https :\x27 ); // false\x0a * ```\x0a *\x0a * @return {boolean} True if the argument is a valid protocol (e.g. http:, tel:).\x0a */\x0a\x0afunction isValidProtocol(protocol) {\x0a  if (!protocol) {\x0a    return false;\x0a  }\x0a\x0a  return /^[a-z\x5c-.\x5c+]+[0-9]*:$/i.test(protocol);\x0a}\x0a/**\x0a * Returns the authority part of the URL.\x0a *\x0a * @param {string} url The full URL.\x0a *\x0a * @example\x0a * ```js\x0a * const authority1 = getAuthority( \x27https://wordpress.org/help/\x27 ); // \x27wordpress.org\x27\x0a * const authority2 = getAuthority( \x27https://localhost:8080/test/\x27 ); // \x27localhost:8080\x27\x0a * ```\x0a *\x0a * @return {?string} The authority part of the URL.\x0a */\x0a\x0afunction getAuthority(url) {\x0a  var matches = /^[^\x5c/\x5cs:]+:(?:\x5c/\x5c/)?\x5c/?([^\x5c/\x5cs#?]+)[\x5c/#?]{0,1}\x5cS*$/.exec(url);\x0a\x0a  if (matches) {\x0a    return matches[1];\x0a  }\x0a}\x0a/**\x0a * Checks for invalid characters within the provided authority.\x0a *\x0a * @param {string} authority A string containing the URL authority.\x0a *\x0a * @example\x0a * ```js\x0a * const isValid = isValidAuthority( \x27wordpress.org\x27 ); // true\x0a * const isNotValid = isValidAuthority( \x27wordpress#org\x27 ); // false\x0a * ```\x0a *\x0a * @return {boolean} True if the argument contains a valid authority.\x0a */\x0a\x0afunction isValidAuthority(authority) {\x0a  if (!authority) {\x0a    return false;\x0a  }\x0a\x0a  return /^[^\x5cs#?]+$/.test(authority);\x0a}\x0a/**\x0a * Returns the path part of the URL.\x0a *\x0a * @param {string} url The full URL.\x0a *\x0a * @example\x0a * ```js\x0a * const path1 = getPath( \x27http://localhost:8080/this/is/a/test?query=true\x27 ); // \x27this/is/a/test\x27\x0a * const path2 = getPath( \x27https://wordpress.org/help/faq/\x27 ); // \x27help/faq\x27\x0a * ```\x0a *\x0a * @return {?string} The path part of the URL.\x0a */\x0a\x0afunction getPath(url) {\x0a  var matches = /^[^\x5c/\x5cs:]+:(?:\x5c/\x5c/)?[^\x5c/\x5cs#?]+[\x5c/]([^\x5cs#?]+)[#?]{0,1}\x5cS*$/.exec(url);\x0a\x0a  if (matches) {\x0a    return matches[1];\x0a  }\x0a}\x0a/**\x0a * Checks for invalid characters within the provided path.\x0a *\x0a * @param {string} path The URL path.\x0a *\x0a * @example\x0a * ```js\x0a * const isValid = isValidPath( \x27test/path/\x27 ); // true\x0a * const isNotValid = isValidPath( \x27/invalid?test/path/\x27 ); // false\x0a * ```\x0a *\x0a * @return {boolean} True if the argument contains a valid path\x0a */\x0a\x0afunction isValidPath(path) {\x0a  if (!path) {\x0a    return false;\x0a  }\x0a\x0a  return /^[^\x5cs#?]+$/.test(path);\x0a}\x0a/**\x0a * Returns the query string part of the URL.\x0a *\x0a * @param {string} url The full URL.\x0a *\x0a * @example\x0a * ```js\x0a * const queryString1 = getQueryString( \x27http://localhost:8080/this/is/a/test?query=true#fragment\x27 ); // \x27query=true\x27\x0a * const queryString2 = getQueryString( \x27https://wordpress.org#fragment?query=false&search=hello\x27 ); // \x27query=false&search=hello\x27\x0a * ```\x0a *\x0a * @return {?string} The query string part of the URL.\x0a */\x0a\x0afunction getQueryString(url) {\x0a  var matches = /^\x5cS+?\x5c?([^\x5cs#]+)/.exec(url);\x0a\x0a  if (matches) {\x0a    return matches[1];\x0a  }\x0a}\x0a/**\x0a * Checks for invalid characters within the provided query string.\x0a *\x0a * @param {string} queryString The query string.\x0a *\x0a * @example\x0a * ```js\x0a * const isValid = isValidQueryString( \x27query=true&another=false\x27 ); // true\x0a * const isNotValid = isValidQueryString( \x27query=true?another=false\x27 ); // false\x0a * ```\x0a *\x0a * @return {boolean} True if the argument contains a valid query string.\x0a */\x0a\x0afunction isValidQueryString(queryString) {\x0a  if (!queryString) {\x0a    return false;\x0a  }\x0a\x0a  return /^[^\x5cs#?\x5c/]+$/.test(queryString);\x0a}\x0a/**\x0a * Returns the fragment part of the URL.\x0a *\x0a * @param {string} url The full URL\x0a *\x0a * @example\x0a * ```js\x0a * const fragment1 = getFragment( \x27http://localhost:8080/this/is/a/test?query=true#fragment\x27 ); // \x27#fragment\x27\x0a * const fragment2 = getFragment( \x27https://wordpress.org#another-fragment?query=true\x27 ); // \x27#another-fragment\x27\x0a * ```\x0a *\x0a * @return {?string} The fragment part of the URL.\x0a */\x0a\x0afunction getFragment(url) {\x0a  var matches = /^\x5cS+?(#[^\x5cs\x5c?]*)/.exec(url);\x0a\x0a  if (matches) {\x0a    return matches[1];\x0a  }\x0a}\x0a/**\x0a * Checks for invalid characters within the provided fragment.\x0a *\x0a * @param {string} fragment The url fragment.\x0a *\x0a * @example\x0a * ```js\x0a * const isValid = isValidFragment( \x27#valid-fragment\x27 ); // true\x0a * const isNotValid = isValidFragment( \x27#invalid-#fragment\x27 ); // false\x0a * ```\x0a *\x0a * @return {boolean} True if the argument contains a valid fragment.\x0a */\x0a\x0afunction isValidFragment(fragment) {\x0a  if (!fragment) {\x0a    return false;\x0a  }\x0a\x0a  return /^#[^\x5cs#?\x5c/]*$/.test(fragment);\x0a}\x0a/**\x0a * Appends arguments as querystring to the provided URL. If the URL already\x0a * includes query arguments, the arguments are merged with (and take precedent\x0a * over) the existing set.\x0a *\x0a * @param {?string} url  URL to which arguments should be appended. If omitted,\x0a *                       only the resulting querystring is returned.\x0a * @param {Object}  args Query arguments to apply to URL.\x0a *\x0a * @example\x0a * ```js\x0a * const newURL = addQueryArgs( \x27https://google.com\x27, { q: \x27test\x27 } ); // https://google.com/?q=test\x0a * ```\x0a *\x0a * @return {string} URL with arguments applied.\x0a */\x0a\x0afunction addQueryArgs() {\x0a  var url = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : \x27\x27;\x0a  var args = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  // If no arguments are to be appended, return original URL.\x0a  if (!args || !Object.keys(args).length) {\x0a    return url;\x0a  }\x0a\x0a  var baseUrl = url; // Determine whether URL already had query arguments.\x0a\x0a  var queryStringIndex = url.indexOf(\x27?\x27);\x0a\x0a  if (queryStringIndex !== -1) {\x0a    // Merge into existing query arguments.\x0a    args = Object.assign(Object(qs__WEBPACK_IMPORTED_MODULE_0__[\x22parse\x22])(url.substr(queryStringIndex + 1)), args); // Change working base URL to omit previous query arguments.\x0a\x0a    baseUrl = baseUrl.substr(0, queryStringIndex);\x0a  }\x0a\x0a  return baseUrl + \x27?\x27 + Object(qs__WEBPACK_IMPORTED_MODULE_0__[\x22stringify\x22])(args);\x0a}\x0a/**\x0a * Returns a single query argument of the url\x0a *\x0a * @param {string} url URL\x0a * @param {string} arg Query arg name\x0a *\x0a * @example\x0a * ```js\x0a * const foo = getQueryArg( \x27https://wordpress.org?foo=bar&bar=baz\x27, \x27foo\x27 ); // bar\x0a * ```\x0a *\x0a * @return {Array|string} Query arg value.\x0a */\x0a\x0afunction getQueryArg(url, arg) {\x0a  var queryStringIndex = url.indexOf(\x27?\x27);\x0a  var query = queryStringIndex !== -1 ? Object(qs__WEBPACK_IMPORTED_MODULE_0__[\x22parse\x22])(url.substr(queryStringIndex + 1)) : {};\x0a  return query[arg];\x0a}\x0a/**\x0a * Determines whether the URL contains a given query arg.\x0a *\x0a * @param {string} url URL\x0a * @param {string} arg Query arg name\x0a *\x0a * @example\x0a * ```js\x0a * const hasBar = hasQueryArg( \x27https://wordpress.org?foo=bar&bar=baz\x27, \x27bar\x27 ); // true\x0a * ```\x0a *\x0a * @return {boolean} Whether or not the URL contains the query arg.\x0a */\x0a\x0afunction hasQueryArg(url, arg) {\x0a  return getQueryArg(url, arg) !== undefined;\x0a}\x0a/**\x0a * Removes arguments from the query string of the url\x0a *\x0a * @param {string} url  URL\x0a * @param {...string} args Query Args\x0a *\x0a * @example\x0a * ```js\x0a * const newUrl = removeQueryArgs( \x27https://wordpress.org?foo=bar&bar=baz&baz=foobar\x27, \x27foo\x27, \x27bar\x27 ); // https://wordpress.org?baz=foobar\x0a * ```\x0a *\x0a * @return {string} Updated URL\x0a */\x0a\x0afunction removeQueryArgs(url) {\x0a  var queryStringIndex = url.indexOf(\x27?\x27);\x0a  var query = queryStringIndex !== -1 ? Object(qs__WEBPACK_IMPORTED_MODULE_0__[\x22parse\x22])(url.substr(queryStringIndex + 1)) : {};\x0a  var baseUrl = queryStringIndex !== -1 ? url.substr(0, queryStringIndex) : url;\x0a\x0a  for (var _len = arguments.length, args = new Array(_len \x3e 1 ? _len - 1 : 0), _key = 1; _key \x3c _len; _key++) {\x0a    args[_key - 1] = arguments[_key];\x0a  }\x0a\x0a  args.forEach(function (arg) {\x0a    return delete query[arg];\x0a  });\x0a  return baseUrl + \x27?\x27 + Object(qs__WEBPACK_IMPORTED_MODULE_0__[\x22stringify\x22])(query);\x0a}\x0a/**\x0a * Prepends \x22http://\x22 to a url, if it looks like something that is meant to be a TLD.\x0a *\x0a * @param  {string} url The URL to test\x0a *\x0a * @example\x0a * ```js\x0a * const actualURL = prependHTTP( \x27wordpress.org\x27 ); // http://wordpress.org\x0a * ```\x0a *\x0a * @return {string}     The updated URL\x0a */\x0a\x0afunction prependHTTP(url) {\x0a  if (!USABLE_HREF_REGEXP.test(url) && !EMAIL_REGEXP.test(url)) {\x0a    return \x27http://\x27 + url;\x0a  }\x0a\x0a  return url;\x0a}\x0a/**\x0a * Safely decodes a URI with `decodeURI`. Returns the URI unmodified if\x0a * `decodeURI` throws an error.\x0a *\x0a * @param {string} uri URI to decode.\x0a *\x0a * @example\x0a * ```js\x0a * const badUri = safeDecodeURI( \x27%z\x27 ); // does not throw an Error, simply returns \x27%z\x27\x0a * ```\x0a *\x0a * @return {string} Decoded URI if possible.\x0a */\x0a\x0afunction safeDecodeURI(uri) {\x0a  try {\x0a    return decodeURI(uri);\x0a  } catch (uriError) {\x0a    return uri;\x0a  }\x0a}\x0a/**\x0a * Returns a URL for display.\x0a *\x0a * @param {string} url Original URL.\x0a *\x0a * @example\x0a * ```js\x0a * const displayUrl = filterURLForDisplay( \x27https://www.wordpress.org/gutenberg/\x27 ); // wordpress.org/gutenberg\x0a * ```\x0a *\x0a * @return {string} Displayed URL.\x0a */\x0a\x0afunction filterURLForDisplay(url) {\x0a  // Remove protocol and www prefixes.\x0a  var filteredURL = url.replace(/^(?:https?:)\x5c/\x5c/(?:www\x5c.)?/, \x27\x27); // Ends with / and only has that single slash, strip it.\x0a\x0a  if (filteredURL.match(/^[^\x5c/]+\x5c/$/)) {\x0a    return filteredURL.replace(\x27/\x27, \x27\x27);\x0a  }\x0a\x0a  return filteredURL;\x0a}\x0a/**\x0a * Safely decodes a URI component with `decodeURIComponent`. Returns the URI component unmodified if\x0a * `decodeURIComponent` throws an error.\x0a *\x0a * @param {string} uriComponent URI component to decode.\x0a *\x0a * @return {string} Decoded URI component if possible.\x0a */\x0a\x0afunction safeDecodeURIComponent(uriComponent) {\x0a  try {\x0a    return decodeURIComponent(uriComponent);\x0a  } catch (uriComponentError) {\x0a    return uriComponent;\x0a  }\x0a}\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 355:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0avar utils = __webpack_require__(201);\x0avar formats = __webpack_require__(202);\x0a\x0avar arrayPrefixGenerators = {\x0a    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching\x0a        return prefix + \x27[]\x27;\x0a    },\x0a    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching\x0a        return prefix + \x27[\x27 + key + \x27]\x27;\x0a    },\x0a    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching\x0a        return prefix;\x0a    }\x0a};\x0a\x0avar isArray = Array.isArray;\x0avar push = Array.prototype.push;\x0avar pushToArray = function (arr, valueOrArray) {\x0a    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\x0a};\x0a\x0avar toISO = Date.prototype.toISOString;\x0a\x0avar defaults = {\x0a    addQueryPrefix: false,\x0a    allowDots: false,\x0a    charset: \x27utf-8\x27,\x0a    charsetSentinel: false,\x0a    delimiter: \x27&\x27,\x0a    encode: true,\x0a    encoder: utils.encode,\x0a    encodeValuesOnly: false,\x0a    // deprecated\x0a    indices: false,\x0a    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching\x0a        return toISO.call(date);\x0a    },\x0a    skipNulls: false,\x0a    strictNullHandling: false\x0a};\x0a\x0avar stringify = function stringify( // eslint-disable-line func-name-matching\x0a    object,\x0a    prefix,\x0a    generateArrayPrefix,\x0a    strictNullHandling,\x0a    skipNulls,\x0a    encoder,\x0a    filter,\x0a    sort,\x0a    allowDots,\x0a    serializeDate,\x0a    formatter,\x0a    encodeValuesOnly,\x0a    charset\x0a) {\x0a    var obj = object;\x0a    if (typeof filter === \x27function\x27) {\x0a        obj = filter(prefix, obj);\x0a    } else if (obj instanceof Date) {\x0a        obj = serializeDate(obj);\x0a    }\x0a\x0a    if (obj === null) {\x0a        if (strictNullHandling) {\x0a            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;\x0a        }\x0a\x0a        obj = \x27\x27;\x0a    }\x0a\x0a    if (typeof obj === \x27string\x27 || typeof obj === \x27number\x27 || typeof obj === \x27boolean\x27 || utils.isBuffer(obj)) {\x0a        if (encoder) {\x0a            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);\x0a            return [formatter(keyValue) + \x27=\x27 + formatter(encoder(obj, defaults.encoder, charset))];\x0a        }\x0a        return [formatter(prefix) + \x27=\x27 + formatter(String(obj))];\x0a    }\x0a\x0a    var values = [];\x0a\x0a    if (typeof obj === \x27undefined\x27) {\x0a        return values;\x0a    }\x0a\x0a    var objKeys;\x0a    if (Array.isArray(filter)) {\x0a        objKeys = filter;\x0a    } else {\x0a        var keys = Object.keys(obj);\x0a        objKeys = sort ? keys.sort(sort) : keys;\x0a    }\x0a\x0a    for (var i = 0; i \x3c objKeys.length; ++i) {\x0a        var key = objKeys[i];\x0a\x0a        if (skipNulls && obj[key] === null) {\x0a            continue;\x0a        }\x0a\x0a        if (Array.isArray(obj)) {\x0a            pushToArray(values, stringify(\x0a                obj[key],\x0a                generateArrayPrefix(prefix, key),\x0a                generateArrayPrefix,\x0a                strictNullHandling,\x0a                skipNulls,\x0a                encoder,\x0a                filter,\x0a                sort,\x0a                allowDots,\x0a                serializeDate,\x0a                formatter,\x0a                encodeValuesOnly,\x0a                charset\x0a            ));\x0a        } else {\x0a            pushToArray(values, stringify(\x0a                obj[key],\x0a                prefix + (allowDots ? \x27.\x27 + key : \x27[\x27 + key + \x27]\x27),\x0a                generateArrayPrefix,\x0a                strictNullHandling,\x0a                skipNulls,\x0a                encoder,\x0a                filter,\x0a                sort,\x0a                allowDots,\x0a                serializeDate,\x0a                formatter,\x0a                encodeValuesOnly,\x0a                charset\x0a            ));\x0a        }\x0a    }\x0a\x0a    return values;\x0a};\x0a\x0amodule.exports = function (object, opts) {\x0a    var obj = object;\x0a    var options = opts ? utils.assign({}, opts) : {};\x0a\x0a    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== \x27function\x27) {\x0a        throw new TypeError(\x27Encoder has to be a function.\x27);\x0a    }\x0a\x0a    var delimiter = typeof options.delimiter === \x27undefined\x27 ? defaults.delimiter : options.delimiter;\x0a    var strictNullHandling = typeof options.strictNullHandling === \x27boolean\x27 ? options.strictNullHandling : defaults.strictNullHandling;\x0a    var skipNulls = typeof options.skipNulls === \x27boolean\x27 ? options.skipNulls : defaults.skipNulls;\x0a    var encode = typeof options.encode === \x27boolean\x27 ? options.encode : defaults.encode;\x0a    var encoder = typeof options.encoder === \x27function\x27 ? options.encoder : defaults.encoder;\x0a    var sort = typeof options.sort === \x27function\x27 ? options.sort : null;\x0a    var allowDots = typeof options.allowDots === \x27undefined\x27 ? defaults.allowDots : !!options.allowDots;\x0a    var serializeDate = typeof options.serializeDate === \x27function\x27 ? options.serializeDate : defaults.serializeDate;\x0a    var encodeValuesOnly = typeof options.encodeValuesOnly === \x27boolean\x27 ? options.encodeValuesOnly : defaults.encodeValuesOnly;\x0a    var charset = options.charset || defaults.charset;\x0a    if (typeof options.charset !== \x27undefined\x27 && options.charset !== \x27utf-8\x27 && options.charset !== \x27iso-8859-1\x27) {\x0a        throw new Error(\x27The charset option must be either utf-8, iso-8859-1, or undefined\x27);\x0a    }\x0a\x0a    if (typeof options.format === \x27undefined\x27) {\x0a        options.format = formats[\x27default\x27];\x0a    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {\x0a        throw new TypeError(\x27Unknown format option provided.\x27);\x0a    }\x0a    var formatter = formats.formatters[options.format];\x0a    var objKeys;\x0a    var filter;\x0a\x0a    if (typeof options.filter === \x27function\x27) {\x0a        filter = options.filter;\x0a        obj = filter(\x27\x27, obj);\x0a    } else if (Array.isArray(options.filter)) {\x0a        filter = options.filter;\x0a        objKeys = filter;\x0a    }\x0a\x0a    var keys = [];\x0a\x0a    if (typeof obj !== \x27object\x27 || obj === null) {\x0a        return \x27\x27;\x0a    }\x0a\x0a    var arrayFormat;\x0a    if (options.arrayFormat in arrayPrefixGenerators) {\x0a        arrayFormat = options.arrayFormat;\x0a    } else if (\x27indices\x27 in options) {\x0a        arrayFormat = options.indices ? \x27indices\x27 : \x27repeat\x27;\x0a    } else {\x0a        arrayFormat = \x27indices\x27;\x0a    }\x0a\x0a    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\x0a\x0a    if (!objKeys) {\x0a        objKeys = Object.keys(obj);\x0a    }\x0a\x0a    if (sort) {\x0a        objKeys.sort(sort);\x0a    }\x0a\x0a    for (var i = 0; i \x3c objKeys.length; ++i) {\x0a        var key = objKeys[i];\x0a\x0a        if (skipNulls && obj[key] === null) {\x0a            continue;\x0a        }\x0a        pushToArray(keys, stringify(\x0a            obj[key],\x0a            key,\x0a            generateArrayPrefix,\x0a            strictNullHandling,\x0a            skipNulls,\x0a            encode ? encoder : null,\x0a            filter,\x0a            sort,\x0a            allowDots,\x0a            serializeDate,\x0a            formatter,\x0a            encodeValuesOnly,\x0a            charset\x0a        ));\x0a    }\x0a\x0a    var joined = keys.join(delimiter);\x0a    var prefix = options.addQueryPrefix === true ? \x27?\x27 : \x27\x27;\x0a\x0a    if (options.charsetSentinel) {\x0a        if (charset === \x27iso-8859-1\x27) {\x0a            // encodeURIComponent(\x27&#10003;\x27), the \x22numeric entity\x22 representation of a checkmark\x0a            prefix += \x27utf8=%26%2310003%3B&\x27;\x0a        } else {\x0a            // encodeURIComponent(\x27\xe2\x9c\x93\x27)\x0a            prefix += \x27utf8=%E2%9C%93&\x27;\x0a        }\x0a    }\x0a\x0a    return joined.length \x3e 0 ? prefix + joined : \x27\x27;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 356:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0avar utils = __webpack_require__(201);\x0a\x0avar has = Object.prototype.hasOwnProperty;\x0a\x0avar defaults = {\x0a    allowDots: false,\x0a    allowPrototypes: false,\x0a    arrayLimit: 20,\x0a    charset: \x27utf-8\x27,\x0a    charsetSentinel: false,\x0a    decoder: utils.decode,\x0a    delimiter: \x27&\x27,\x0a    depth: 5,\x0a    ignoreQueryPrefix: false,\x0a    interpretNumericEntities: false,\x0a    parameterLimit: 1000,\x0a    parseArrays: true,\x0a    plainObjects: false,\x0a    strictNullHandling: false\x0a};\x0a\x0avar interpretNumericEntities = function (str) {\x0a    return str.replace(/&#(\x5cd+);/g, function ($0, numberStr) {\x0a        return String.fromCharCode(parseInt(numberStr, 10));\x0a    });\x0a};\x0a\x0a// This is what browsers will submit when the \xe2\x9c\x93 character occurs in an\x0a// application/x-www-form-urlencoded body and the encoding of the page containing\x0a// the form is iso-8859-1, or when the submitted form has an accept-charset\x0a// attribute of iso-8859-1. Presumably also with other charsets that do not contain\x0a// the \xe2\x9c\x93 character, such as us-ascii.\x0avar isoSentinel = \x27utf8=%26%2310003%3B\x27; // encodeURIComponent(\x27&#10003;\x27)\x0a\x0a// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\x0avar charsetSentinel = \x27utf8=%E2%9C%93\x27; // encodeURIComponent(\x27\xe2\x9c\x93\x27)\x0a\x0avar parseValues = function parseQueryStringValues(str, options) {\x0a    var obj = {};\x0a    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\x5c?/, \x27\x27) : str;\x0a    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\x0a    var parts = cleanStr.split(options.delimiter, limit);\x0a    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\x0a    var i;\x0a\x0a    var charset = options.charset;\x0a    if (options.charsetSentinel) {\x0a        for (i = 0; i \x3c parts.length; ++i) {\x0a            if (parts[i].indexOf(\x27utf8=\x27) === 0) {\x0a                if (parts[i] === charsetSentinel) {\x0a                    charset = \x27utf-8\x27;\x0a                } else if (parts[i] === isoSentinel) {\x0a                    charset = \x27iso-8859-1\x27;\x0a                }\x0a                skipIndex = i;\x0a                i = parts.length; // The eslint settings do not allow break;\x0a            }\x0a        }\x0a    }\x0a\x0a    for (i = 0; i \x3c parts.length; ++i) {\x0a        if (i === skipIndex) {\x0a            continue;\x0a        }\x0a        var part = parts[i];\x0a\x0a        var bracketEqualsPos = part.indexOf(\x27]=\x27);\x0a        var pos = bracketEqualsPos === -1 ? part.indexOf(\x27=\x27) : bracketEqualsPos + 1;\x0a\x0a        var key, val;\x0a        if (pos === -1) {\x0a            key = options.decoder(part, defaults.decoder, charset);\x0a            val = options.strictNullHandling ? null : \x27\x27;\x0a        } else {\x0a            key = options.decoder(part.slice(0, pos), defaults.decoder, charset);\x0a            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);\x0a        }\x0a\x0a        if (val && options.interpretNumericEntities && charset === \x27iso-8859-1\x27) {\x0a            val = interpretNumericEntities(val);\x0a        }\x0a        if (has.call(obj, key)) {\x0a            obj[key] = utils.combine(obj[key], val);\x0a        } else {\x0a            obj[key] = val;\x0a        }\x0a    }\x0a\x0a    return obj;\x0a};\x0a\x0avar parseObject = function (chain, val, options) {\x0a    var leaf = val;\x0a\x0a    for (var i = chain.length - 1; i \x3e= 0; --i) {\x0a        var obj;\x0a        var root = chain[i];\x0a\x0a        if (root === \x27[]\x27 && options.parseArrays) {\x0a            obj = [].concat(leaf);\x0a        } else {\x0a            obj = options.plainObjects ? Object.create(null) : {};\x0a            var cleanRoot = root.charAt(0) === \x27[\x27 && root.charAt(root.length - 1) === \x27]\x27 ? root.slice(1, -1) : root;\x0a            var index = parseInt(cleanRoot, 10);\x0a            if (!options.parseArrays && cleanRoot === \x27\x27) {\x0a                obj = { 0: leaf };\x0a            } else if (\x0a                !isNaN(index)\x0a                && root !== cleanRoot\x0a                && String(index) === cleanRoot\x0a                && index \x3e= 0\x0a                && (options.parseArrays && index \x3c= options.arrayLimit)\x0a            ) {\x0a                obj = [];\x0a                obj[index] = leaf;\x0a            } else {\x0a                obj[cleanRoot] = leaf;\x0a            }\x0a        }\x0a\x0a        leaf = obj;\x0a    }\x0a\x0a    return leaf;\x0a};\x0a\x0avar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\x0a    if (!givenKey) {\x0a        return;\x0a    }\x0a\x0a    // Transform dot notation to bracket notation\x0a    var key = options.allowDots ? givenKey.replace(/\x5c.([^.[]+)/g, \x27[$1]\x27) : givenKey;\x0a\x0a    // The regex chunks\x0a\x0a    var brackets = /(\x5c[[^[\x5c]]*])/;\x0a    var child = /(\x5c[[^[\x5c]]*])/g;\x0a\x0a    // Get the parent\x0a\x0a    var segment = brackets.exec(key);\x0a    var parent = segment ? key.slice(0, segment.index) : key;\x0a\x0a    // Stash the parent if it exists\x0a\x0a    var keys = [];\x0a    if (parent) {\x0a        // If we aren\x27t using plain objects, optionally prefix keys that would overwrite object prototype properties\x0a        if (!options.plainObjects && has.call(Object.prototype, parent)) {\x0a            if (!options.allowPrototypes) {\x0a                return;\x0a            }\x0a        }\x0a\x0a        keys.push(parent);\x0a    }\x0a\x0a    // Loop through children appending to the array until we hit depth\x0a\x0a    var i = 0;\x0a    while ((segment = child.exec(key)) !== null && i \x3c options.depth) {\x0a        i += 1;\x0a        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\x0a            if (!options.allowPrototypes) {\x0a                return;\x0a            }\x0a        }\x0a        keys.push(segment[1]);\x0a    }\x0a\x0a    // If there\x27s a remainder, just add whatever is left\x0a\x0a    if (segment) {\x0a        keys.push(\x27[\x27 + key.slice(segment.index) + \x27]\x27);\x0a    }\x0a\x0a    return parseObject(keys, val, options);\x0a};\x0a\x0amodule.exports = function (str, opts) {\x0a    var options = opts ? utils.assign({}, opts) : {};\x0a\x0a    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== \x27function\x27) {\x0a        throw new TypeError(\x27Decoder has to be a function.\x27);\x0a    }\x0a\x0a    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;\x0a    options.delimiter = typeof options.delimiter === \x27string\x27 || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\x0a    options.depth = typeof options.depth === \x27number\x27 ? options.depth : defaults.depth;\x0a    options.arrayLimit = typeof options.arrayLimit === \x27number\x27 ? options.arrayLimit : defaults.arrayLimit;\x0a    options.parseArrays = options.parseArrays !== false;\x0a    options.decoder = typeof options.decoder === \x27function\x27 ? options.decoder : defaults.decoder;\x0a    options.allowDots = typeof options.allowDots === \x27undefined\x27 ? defaults.allowDots : !!options.allowDots;\x0a    options.plainObjects = typeof options.plainObjects === \x27boolean\x27 ? options.plainObjects : defaults.plainObjects;\x0a    options.allowPrototypes = typeof options.allowPrototypes === \x27boolean\x27 ? options.allowPrototypes : defaults.allowPrototypes;\x0a    options.parameterLimit = typeof options.parameterLimit === \x27number\x27 ? options.parameterLimit : defaults.parameterLimit;\x0a    options.strictNullHandling = typeof options.strictNullHandling === \x27boolean\x27 ? options.strictNullHandling : defaults.strictNullHandling;\x0a\x0a    if (typeof options.charset !== \x27undefined\x27 && options.charset !== \x27utf-8\x27 && options.charset !== \x27iso-8859-1\x27) {\x0a        throw new Error(\x27The charset option must be either utf-8, iso-8859-1, or undefined\x27);\x0a    }\x0a    if (typeof options.charset === \x27undefined\x27) {\x0a        options.charset = defaults.charset;\x0a    }\x0a\x0a    if (str === \x27\x27 || str === null || typeof str === \x27undefined\x27) {\x0a        return options.plainObjects ? Object.create(null) : {};\x0a    }\x0a\x0a    var tempObj = typeof str === \x27string\x27 ? parseValues(str, options) : str;\x0a    var obj = options.plainObjects ? Object.create(null) : {};\x0a\x0a    // Iterate over the keys and setup the new object\x0a\x0a    var keys = Object.keys(tempObj);\x0a    for (var i = 0; i \x3c keys.length; ++i) {\x0a        var key = keys[i];\x0a        var newObj = parseKeys(key, tempObj[key], options);\x0a        obj = utils.merge(obj, newObj, options);\x0a    }\x0a\x0a    return utils.compact(obj);\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 86:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0avar stringify = __webpack_require__(355);\x0avar parse = __webpack_require__(356);\x0avar formats = __webpack_require__(202);\x0a\x0amodule.exports = {\x0a    formats: formats,\x0a    parse: parse,\x0a    stringify: stringify\x0a};\x0a\x0a\x0a/***/ })\x0a\x0a/******/ });'}