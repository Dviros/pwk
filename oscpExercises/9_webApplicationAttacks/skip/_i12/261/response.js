var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:00:03 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Fri, 01 Sep 2017 12:28:46 GMT\x0aETag: \x22eb9a-5581fe6fb1b80-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-16729/16730\x0aContent-Length: 16730\x0aKeep-Alive: timeout=5, max=40\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/**\x0a * Plupload - multi-runtime File Uploader\x0a * v2.1.9\x0a *\x0a * Copyright 2013, Moxiecode Systems AB\x0a * Released under GPL License.\x0a *\x0a * License: http://www.plupload.com/license\x0a * Contributing: http://www.plupload.com/contributing\x0a *\x0a * Date: 2016-05-15\x0a */\x0a/**\x0a * Plupload.js\x0a *\x0a * Copyright 2013, Moxiecode Systems AB\x0a * Released under GPL License.\x0a *\x0a * License: http://www.plupload.com/license\x0a * Contributing: http://www.plupload.com/contributing\x0a */\x0a\x0a/**\x0a * Modified for WordPress, Silverlight and Flash runtimes support was removed.\x0a * See https://core.trac.wordpress.org/ticket/41755.\x0a */\x0a\x0a/*global mOxie:true */\x0a\x0a;(function(window, o, undef) {\x0a\x0avar delay = window.setTimeout\x0a, fileFilters = {}\x0a;\x0a\x0a// convert plupload features to caps acceptable by mOxie\x0afunction normalizeCaps(settings) {\x09\x09\x0a\x09var features = settings.required_features, caps = {};\x0a\x0a\x09function resolve(feature, value, strict) {\x0a\x09\x09// Feature notation is deprecated, use caps (this thing here is required for backward compatibility)\x0a\x09\x09var map = { \x0a\x09\x09\x09chunks: \x27slice_blob\x27,\x0a\x09\x09\x09jpgresize: \x27send_binary_string\x27,\x0a\x09\x09\x09pngresize: \x27send_binary_string\x27,\x0a\x09\x09\x09progress: \x27report_upload_progress\x27,\x0a\x09\x09\x09multi_selection: \x27select_multiple\x27,\x0a\x09\x09\x09dragdrop: \x27drag_and_drop\x27,\x0a\x09\x09\x09drop_element: \x27drag_and_drop\x27,\x0a\x09\x09\x09headers: \x27send_custom_headers\x27,\x0a\x09\x09\x09urlstream_upload: \x27send_binary_string\x27,\x0a\x09\x09\x09canSendBinary: \x27send_binary\x27,\x0a\x09\x09\x09triggerDialog: \x27summon_file_dialog\x27\x0a\x09\x09};\x0a\x0a\x09\x09if (map[feature]) {\x0a\x09\x09\x09caps[map[feature]] = value;\x0a\x09\x09} else if (!strict) {\x0a\x09\x09\x09caps[feature] = value;\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09if (typeof(features) === \x27string\x27) {\x0a\x09\x09plupload.each(features.split(/\x5cs*,\x5cs*/), function(feature) {\x0a\x09\x09\x09resolve(feature, true);\x0a\x09\x09});\x0a\x09} else if (typeof(features) === \x27object\x27) {\x0a\x09\x09plupload.each(features, function(value, feature) {\x0a\x09\x09\x09resolve(feature, value);\x0a\x09\x09});\x0a\x09} else if (features === true) {\x0a\x09\x09// check settings for required features\x0a\x09\x09if (settings.chunk_size \x3e 0) {\x0a\x09\x09\x09caps.slice_blob = true;\x0a\x09\x09}\x0a\x0a\x09\x09if (settings.resize.enabled || !settings.multipart) {\x0a\x09\x09\x09caps.send_binary_string = true;\x0a\x09\x09}\x0a\x09\x09\x0a\x09\x09plupload.each(settings, function(value, feature) {\x0a\x09\x09\x09resolve(feature, !!value, true); // strict check\x0a\x09\x09});\x0a\x09}\x0a\x0a\x09// WP: only html runtimes.\x0a\x09settings.runtimes = \x27html5,html4\x27;\x0a\x0a\x09return caps;\x0a}\x0a\x0a/** \x0a * @module plupload\x09\x0a * @static\x0a */\x0avar plupload = {\x0a\x09/**\x0a\x09 * Plupload version will be replaced on build.\x0a\x09 *\x0a\x09 * @property VERSION\x0a\x09 * @for Plupload\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09VERSION : \x272.1.9\x27,\x0a\x0a\x09/**\x0a\x09 * The state of the queue before it has started and after it has finished\x0a\x09 *\x0a\x09 * @property STOPPED\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09STOPPED : 1,\x0a\x0a\x09/**\x0a\x09 * Upload process is running\x0a\x09 *\x0a\x09 * @property STARTED\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09STARTED : 2,\x0a\x0a\x09/**\x0a\x09 * File is queued for upload\x0a\x09 *\x0a\x09 * @property QUEUED\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09QUEUED : 1,\x0a\x0a\x09/**\x0a\x09 * File is being uploaded\x0a\x09 *\x0a\x09 * @property UPLOADING\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09UPLOADING : 2,\x0a\x0a\x09/**\x0a\x09 * File has failed to be uploaded\x0a\x09 *\x0a\x09 * @property FAILED\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09FAILED : 4,\x0a\x0a\x09/**\x0a\x09 * File has been uploaded successfully\x0a\x09 *\x0a\x09 * @property DONE\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09DONE : 5,\x0a\x0a\x09// Error constants used by the Error event\x0a\x0a\x09/**\x0a\x09 * Generic error for example if an exception is thrown inside Silverlight.\x0a\x09 *\x0a\x09 * @property GENERIC_ERROR\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09GENERIC_ERROR : -100,\x0a\x0a\x09/**\x0a\x09 * HTTP transport error. For example if the server produces a HTTP status other than 200.\x0a\x09 *\x0a\x09 * @property HTTP_ERROR\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09HTTP_ERROR : -200,\x0a\x0a\x09/**\x0a\x09 * Generic I/O error. For example if it wasn\x27t possible to open the file stream on local machine.\x0a\x09 *\x0a\x09 * @property IO_ERROR\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09IO_ERROR : -300,\x0a\x0a\x09/**\x0a\x09 * @property SECURITY_ERROR\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09SECURITY_ERROR : -400,\x0a\x0a\x09/**\x0a\x09 * Initialization error. Will be triggered if no runtime was initialized.\x0a\x09 *\x0a\x09 * @property INIT_ERROR\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09INIT_ERROR : -500,\x0a\x0a\x09/**\x0a\x09 * File size error. If the user selects a file that is too large it will be blocked and an error of this type will be triggered.\x0a\x09 *\x0a\x09 * @property FILE_SIZE_ERROR\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09FILE_SIZE_ERROR : -600,\x0a\x0a\x09/**\x0a\x09 * File extension error. If the user selects a file that isn\x27t valid according to the filters setting.\x0a\x09 *\x0a\x09 * @property FILE_EXTENSION_ERROR\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09FILE_EXTENSION_ERROR : -601,\x0a\x0a\x09/**\x0a\x09 * Duplicate file error. If prevent_duplicates is set to true and user selects the same file again.\x0a\x09 *\x0a\x09 * @property FILE_DUPLICATE_ERROR\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09FILE_DUPLICATE_ERROR : -602,\x0a\x0a\x09/**\x0a\x09 * Runtime will try to detect if image is proper one. Otherwise will throw this error.\x0a\x09 *\x0a\x09 * @property IMAGE_FORMAT_ERROR\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09IMAGE_FORMAT_ERROR : -700,\x0a\x0a\x09/**\x0a\x09 * While working on files runtime may run out of memory and will throw this error.\x0a\x09 *\x0a\x09 * @since 2.1.2\x0a\x09 * @property MEMORY_ERROR\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09MEMORY_ERROR : -701,\x0a\x0a\x09/**\x0a\x09 * Each runtime has an upper limit on a dimension of the image it can handle. If bigger, will throw this error.\x0a\x09 *\x0a\x09 * @property IMAGE_DIMENSIONS_ERROR\x0a\x09 * @static\x0a\x09 * @final\x0a\x09 */\x0a\x09IMAGE_DIMENSIONS_ERROR : -702,\x0a\x0a\x09/**\x0a\x09 * Mime type lookup table.\x0a\x09 *\x0a\x09 * @property mimeTypes\x0a\x09 * @type Object\x0a\x09 * @final\x0a\x09 */\x0a\x09mimeTypes : o.mimes,\x0a\x0a\x09/**\x0a\x09 * In some cases sniffing is the only way around :(\x0a\x09 */\x0a\x09ua: o.ua,\x0a\x0a\x09/**\x0a\x09 * Gets the true type of the built-in object (better version of typeof).\x0a\x09 * @credits Angus Croll (http://javascriptweblog.wordpress.com/)\x0a\x09 *\x0a\x09 * @method typeOf\x0a\x09 * @static\x0a\x09 * @param {Object} o Object to check.\x0a\x09 * @return {String} Object [[Class]]\x0a\x09 */\x0a\x09typeOf: o.typeOf,\x0a\x0a\x09/**\x0a\x09 * Extends the specified object with another object.\x0a\x09 *\x0a\x09 * @method extend\x0a\x09 * @static\x0a\x09 * @param {Object} target Object to extend.\x0a\x09 * @param {Object..} obj Multiple objects to extend with.\x0a\x09 * @return {Object} Same as target, the extended object.\x0a\x09 */\x0a\x09extend : o.extend,\x0a\x0a\x09/**\x0a\x09 * Generates an unique ID. This is 99.99% unique since it takes the current time and 5 random numbers.\x0a\x09 * The only way a user would be able to get the same ID is if the two persons at the same exact millisecond manages\x0a\x09 * to get 5 the same random numbers between 0-65535 it also uses a counter so each call will be guaranteed to be page unique.\x0a\x09 * It\x27s more probable for the earth to be hit with an asteriod. You can also if you want to be 100% sure set the plupload.guidPrefix property\x0a\x09 * to an user unique key.\x0a\x09 *\x0a\x09 * @method guid\x0a\x09 * @static\x0a\x09 * @return {String} Virtually unique id.\x0a\x09 */\x0a\x09guid : o.guid,\x0a\x0a\x09/**\x0a\x09 * Get array of DOM Elements by their ids.\x0a\x09 * \x0a\x09 * @method get\x0a\x09 * @param {String} id Identifier of the DOM Element\x0a\x09 * @return {Array}\x0a\x09*/\x0a\x09getAll : function get(ids) {\x0a\x09\x09var els = [], el;\x0a\x0a\x09\x09if (plupload.typeOf(ids) !== \x27array\x27) {\x0a\x09\x09\x09ids = [ids];\x0a\x09\x09}\x0a\x0a\x09\x09var i = ids.length;\x0a\x09\x09while (i--) {\x0a\x09\x09\x09el = plupload.get(ids[i]);\x0a\x09\x09\x09if (el) {\x0a\x09\x09\x09\x09els.push(el);\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09return els.length ? els : null;\x0a\x09},\x0a\x0a\x09/**\x0a\x09Get DOM element by id\x0a\x0a\x09@method get\x0a\x09@param {String} id Identifier of the DOM Element\x0a\x09@return {Node}\x0a\x09*/\x0a\x09get: o.get,\x0a\x0a\x09/**\x0a\x09 * Executes the callback function for each item in array/object. If you return false in the\x0a\x09 * callback it will break the loop.\x0a\x09 *\x0a\x09 * @method each\x0a\x09 * @static\x0a\x09 * @param {Object} obj Object to iterate.\x0a\x09 * @param {function} callback Callback function to execute for each item.\x0a\x09 */\x0a\x09each : o.each,\x0a\x0a\x09/**\x0a\x09 * Returns the absolute x, y position of an Element. The position will be returned in a object with x, y fields.\x0a\x09 *\x0a\x09 * @method getPos\x0a\x09 * @static\x0a\x09 * @param {Element} node HTML element or element id to get x, y position from.\x0a\x09 * @param {Element} root Optional root element to stop calculations at.\x0a\x09 * @return {object} Absolute position of the specified element object with x, y fields.\x0a\x09 */\x0a\x09getPos : o.getPos,\x0a\x0a\x09/**\x0a\x09 * Returns the size of the specified node in pixels.\x0a\x09 *\x0a\x09 * @method getSize\x0a\x09 * @static\x0a\x09 * @param {Node} node Node to get the size of.\x0a\x09 * @return {Object} Object with a w and h property.\x0a\x09 */\x0a\x09getSize : o.getSize,\x0a\x0a\x09/**\x0a\x09 * Encodes the specified string.\x0a\x09 *\x0a\x09 * @method xmlEncode\x0a\x09 * @static\x0a\x09 * @param {String} s String to encode.\x0a\x09 * @return {String} Encoded string.\x0a\x09 */\x0a\x09xmlEncode : function(str) {\x0a\x09\x09var xmlEncodeChars = {\x27\x3c\x27 : \x27lt\x27, \x27\x3e\x27 : \x27gt\x27, \x27&\x27 : \x27amp\x27, \x27\x22\x27 : \x27quot\x27, \x27\x5c\x27\x27 : \x27#39\x27}, xmlEncodeRegExp = /[\x3c\x3e&\x5c\x22\x5c\x27]/g;\x0a\x0a\x09\x09return str ? (\x27\x27 + str).replace(xmlEncodeRegExp, function(chr) {\x0a\x09\x09\x09return xmlEncodeChars[chr] ? \x27&\x27 + xmlEncodeChars[chr] + \x27;\x27 : chr;\x0a\x09\x09}) : str;\x0a\x09},\x0a\x0a\x09/**\x0a\x09 * Forces anything into an array.\x0a\x09 *\x0a\x09 * @method toArray\x0a\x09 * @static\x0a\x09 * @param {Object} obj Object with length field.\x0a\x09 * @return {Array} Array object containing all items.\x0a\x09 */\x0a\x09toArray : o.toArray,\x0a\x0a\x09/**\x0a\x09 * Find an element in array and return its index if present, otherwise return -1.\x0a\x09 *\x0a\x09 * @method inArray\x0a\x09 * @static\x0a\x09 * @param {mixed} needle Element to find\x0a\x09 * @param {Array} array\x0a\x09 * @return {Int} Index of the element, or -1 if not found\x0a\x09 */\x0a\x09inArray : o.inArray,\x0a\x0a\x09/**\x0a\x09 * Extends the language pack object with new items.\x0a\x09 *\x0a\x09 * @method addI18n\x0a\x09 * @static\x0a\x09 * @param {Object} pack Language pack items to add.\x0a\x09 * @return {Object} Extended language pack object.\x0a\x09 */\x0a\x09addI18n : o.addI18n,\x0a\x0a\x09/**\x0a\x09 * Translates the specified string by checking for the english string in the language pack lookup.\x0a\x09 *\x0a\x09 * @method translate\x0a\x09 * @static\x0a\x09 * @param {String} str String to look for.\x0a\x09 * @return {String} Translated string or the input string if it wasn\x27t found.\x0a\x09 */\x0a\x09translate : o.translate,\x0a\x0a\x09/**\x0a\x09 * Checks if object is empty.\x0a\x09 *\x0a\x09 * @method isEmptyObj\x0a\x09 * @static\x0a\x09 * @param {Object} obj Object to check.\x0a\x09 * @return {Boolean}\x0a\x09 */\x0a\x09isEmptyObj : o.isEmptyObj,\x0a\x0a\x09/**\x0a\x09 * Checks if specified DOM element has specified class.\x0a\x09 *\x0a\x09 * @method hasClass\x0a\x09 * @static\x0a\x09 * @param {Object} obj DOM element like object to add handler to.\x0a\x09 * @param {String} name Class name\x0a\x09 */\x0a\x09hasClass : o.hasClass,\x0a\x0a\x09/**\x0a\x09 * Adds specified className to specified DOM element.\x0a\x09 *\x0a\x09 * @method addClass\x0a\x09 * @static\x0a\x09 * @param {Object} obj DOM element like object to add handler to.\x0a\x09 * @param {String} name Class name\x0a\x09 */\x0a\x09addClass : o.addClass,\x0a\x0a\x09/**\x0a\x09 * Removes specified className from specified DOM element.\x0a\x09 *\x0a\x09 * @method removeClass\x0a\x09 * @static\x0a\x09 * @param {Object} obj DOM element like object to add handler to.\x0a\x09 * @param {String} name Class name\x0a\x09 */\x0a\x09removeClass : o.removeClass,\x0a\x0a\x09/**\x0a\x09 * Returns a given computed style of a DOM element.\x0a\x09 *\x0a\x09 * @method getStyle\x0a\x09 * @static\x0a\x09 * @param {Object} obj DOM element like object.\x0a\x09 * @param {String} name Style you want to get from the DOM element\x0a\x09 */\x0a\x09getStyle : o.getStyle,\x0a\x0a\x09/**\x0a\x09 * Adds an event handler to the specified object and store reference to the handler\x0a\x09 * in objects internal Plupload registry (@see removeEvent).\x0a\x09 *\x0a\x09 * @method addEvent\x0a\x09 * @static\x0a\x09 * @param {Object} obj DOM element like object to add handler to.\x0a\x09 * @param {String} name Name to add event listener to.\x0a\x09 * @param {Function} callback Function to call when event occurs.\x0a\x09 * @param {String} (optional) key that might be used to add specifity to the event record.\x0a\x09 */\x0a\x09addEvent : o.addEvent,\x0a\x0a\x09/**\x0a\x09 * Remove event handler from the specified object. If third argument (callback)\x0a\x09 * is not specified remove all events with the specified name.\x0a\x09 *\x0a\x09 * @method removeEvent\x0a\x09 * @static\x0a\x09 * @param {Object} obj DOM element to remove event listener(s) from.\x0a\x09 * @param {String} name Name of event listener to remove.\x0a\x09 * @param {Function|String} (optional) might be a callback or unique key to match.\x0a\x09 */\x0a\x09removeEvent: o.removeEvent,\x0a\x0a\x09/**\x0a\x09 * Remove all kind of events from the specified object\x0a\x09 *\x0a\x09 * @method removeAllEvents\x0a\x09 * @static\x0a\x09 * @param {Object} obj DOM element to remove event listeners from.\x0a\x09 * @param {String} (optional) unique key to match, when removing events.\x0a\x09 */\x0a\x09removeAllEvents: o.removeAllEvents,\x0a\x0a\x09/**\x0a\x09 * Cleans the specified name from national characters (diacritics). The result will be a name with only a-z, 0-9 and _.\x0a\x09 *\x0a\x09 * @method cleanName\x0a\x09 * @static\x0a\x09 * @param {String} s String to clean up.\x0a\x09 * @return {String} Cleaned string.\x0a\x09 */\x0a\x09cleanName : function(name) {\x0a\x09\x09var i, lookup;\x0a\x0a\x09\x09// Replace diacritics\x0a\x09\x09lookup = [\x0a\x09\x09\x09/[\x5c300-\x5c306]/g, \x27A\x27, /[\x5c340-\x5c346]/g, \x27a\x27,\x0a\x09\x09\x09/\x5c307/g, \x27C\x27, /\x5c347/g, \x27c\x27,\x0a\x09\x09\x09/[\x5c310-\x5c313]/g, \x27E\x27, /[\x5c350-\x5c353]/g, \x27e\x27,\x0a\x09\x09\x09/[\x5c314-\x5c317]/g, \x27I\x27, /[\x5c354-\x5c357]/g, \x27i\x27,\x0a\x09\x09\x09/\x5c321/g, \x27N\x27, /\x5c361/g, \x27n\x27,\x0a\x09\x09\x09/[\x5c322-\x5c330]/g, \x27O\x27, /[\x5c362-\x5c370]/g, \x27o\x27,\x0a\x09\x09\x09/[\x5c331-\x5c334]/g, \x27U\x27, /[\x5c371-\x5c374]/g, \x27u\x27\x0a\x09\x09];\x0a\x0a\x09\x09for (i = 0; i \x3c lookup.length; i += 2) {\x0a\x09\x09\x09name = name.replace(lookup[i], lookup[i + 1]);\x0a\x09\x09}\x0a\x0a\x09\x09// Replace whitespace\x0a\x09\x09name = name.replace(/\x5cs+/g, \x27_\x27);\x0a\x0a\x09\x09// Remove anything else\x0a\x09\x09name = name.replace(/[^a-z0-9_\x5c-\x5c.]+/gi, \x27\x27);\x0a\x0a\x09\x09return name;\x0a\x09},\x0a\x0a\x09/**\x0a\x09 * Builds a full url out of a base URL and an object with items to append as query string items.\x0a\x09 *\x0a\x09 * @method buildUrl\x0a\x09 * @static\x0a\x09 * @param {String} url Base URL to append query string items to.\x0a\x09 * @param {Object} items Name/value object to serialize as a querystring.\x0a\x09 * @return {String} String with url + serialized query string items.\x0a\x09 */\x0a\x09buildUrl : function(url, items) {\x0a\x09\x09var query = \x27\x27;\x0a\x0a\x09\x09plupload.each(items, function(value, name) {\x0a\x09\x09\x09query += (query ? \x27&\x27 : \x27\x27) + encodeURIComponent(name) + \x27=\x27 + encodeURIComponent(value);\x0a\x09\x09});\x0a\x0a\x09\x09if (query) {\x0a\x09\x09\x09url += (url.indexOf(\x27?\x27) \x3e 0 ? \x27&\x27 : \x27?\x27) + query;\x0a\x09\x09}\x0a\x0a\x09\x09return url;\x0a\x09},\x0a\x0a\x09/**\x0a\x09 * Formats the specified number as a size string for example 1024 becomes 1 KB.\x0a\x09 *\x0a\x09 * @method formatSize\x0a\x09 * @static\x0a\x09 * @param {Number} size Size to format as string.\x0a\x09 * @return {String} Formatted size string.\x0a\x09 */\x0a\x09formatSize : function(size) {\x0a\x0a\x09\x09if (size === undef || /\x5cD/.test(size)) {\x0a\x09\x09\x09return plupload.translate(\x27N/A\x27);\x0a\x09\x09}\x0a\x0a\x09\x09function round(num, precision) {\x0a\x09\x09\x09return Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision);\x0a\x09\x09}\x0a\x0a\x09\x09var boundary = Math.pow(1024, 4);\x0a\x0a\x09\x09// TB\x0a\x09\x09if (size \x3e boundary) {\x0a\x09\x09\x09return round(size / boundary, 1) + \x22 \x22 + plupload.translate(\x27tb\x27);\x0a\x09\x09}\x0a\x0a\x09\x09// GB\x0a\x09\x09if (size \x3e (boundary/=1024)) {\x0a\x09\x09\x09return round(size / boundary, 1) + \x22 \x22 + plupload.translate(\x27gb\x27);\x0a\x09\x09}\x0a\x0a\x09\x09// MB\x0a\x09\x09if (size \x3e (boundary/=1024)) {\x0a\x09\x09\x09return round(size / boundary, 1) + \x22 \x22 + plupload.translate(\x27mb\x27);\x0a\x09\x09}\x0a\x0a\x09\x09// KB\x0a\x09\x09if (size \x3e 1024) {\x0a\x09\x09\x09return Math.round(size / 1024) + \x22 \x22 + plupload.translate(\x27kb\x27);\x0a\x09\x09}\x0a\x0a\x09\x09return size + \x22 \x22 + plupload.translate(\x27b\x27);\x0a\x09},\x0a\x0a\x0a\x09/**\x0a\x09 * Parses the specified size string into a byte value. For example 10kb becomes 10240.\x0a\x09 *\x0a\x09 * @method parseSize\x0a\x09 * @static\x0a\x09 * @param {String|Number} size String to parse or number to just pass through.\x0a\x09 * @return {Number} Size in bytes.\x0a\x09 */\x0a\x09parseSize : o.parseSizeStr,\x0a\x0a\x0a\x09/**\x0a\x09 * A way to predict what runtime will be choosen in the current environment with the\x0a\x09 * specified settings.\x0a\x09 *\x0a\x09 * @method predictRuntime\x0a\x09 * @static\x0a\x09 * @param {Object|String} config Plupload settings to check\x0a\x09 * @param {String} [runtimes] Comma-separated list of runtimes to check against\x0a\x09 * @return {String} Type of compatible runtime\x0a\x09 */\x0a\x09predictRuntime : function(config, runtimes) {\x0a\x09\x09var up, runtime;\x0a\x0a\x09\x09up = new plupload.Uploader(config);\x0a\x09\x09runtime = o.Runtime.thatCan(up.getOption().required_features, runtimes || config.runtimes);\x0a\x09\x09up.destroy();\x0a\x09\x09return runtime;\x0a\x09},\x0a\x0a\x09/**\x0a\x09 * Registers a filter that will be executed for each file added to the queue.\x0a\x09 * If callback returns false, file will not be added.\x0a\x09 *\x0a\x09 * Callback receives two arguments: a value for the filter as it was specified in settings.filters\x0a\x09 * and a file to be filtered. Callback is executed in the context of uploader instance.\x0a\x09 *\x0a\x09 * @method addFileFilter\x0a\x09 * @static\x0a\x09 * @param {String} name Name of the filter by which it can be referenced in settings.filters\x0a\x09 * @param {String} cb Callback - the actual routine that every added file must pass\x0a\x09 */\x0a\x09addFileFilter: function(name, cb) {\x0a\x09\x09fileFilters[name] = cb;\x0a\x09}\x0a};\x0a\x0a\x0aplupload.addFileFilter(\x27mime_types\x27, function(filters, file, cb) {\x0a\x09if (filters.length && !filters.regexp.test(file.name)) {\x0a\x09\x09this.trigger(\x27Error\x27, {\x0a\x09\x09\x09code : plupload.FILE_EXTENSION_ERROR,\x0a\x09\x09\x09message : plupload.translate(\x27File extension error.\x27),\x0a\x09\x09\x09file : file\x0a\x09\x09});\x0a\x09\x09cb(false);\x0a\x09} else {\x0a\x09\x09cb(true);\x0a\x09}\x0a});\x0a\x0a\x0aplupload.addFileFilter(\x27max_file_size\x27, function(maxSize, file, cb) {\x0a\x09var undef;\x0a\x0a\x09maxSize = plupload.parseSize(maxSize);\x0a\x0a\x09// Invalid file size\x0a\x09if (file.size !== undef && maxSize && file.size \x3e maxSize) {\x0a\x09\x09this.trigger(\x27Error\x27, {\x0a\x09\x09\x09code : plupload.FILE_SIZE_ERROR,\x0a\x09\x09\x09message : plupload.translate(\x27File size error.\x27),\x0a\x09\x09\x09file : file\x0a\x09\x09});\x0a\x09\x09cb(false);\x0a\x09} else {\x0a\x09\x09cb(true);\x0a\x09}\x0a});\x0a\x0a\x0aplupload.addFileFilter(\x27prevent_duplicates\x27, function(value, file, cb) {\x0a\x09if (value) {\x0a\x09\x09var ii = this.files.length;\x0a\x09\x09while (ii--) {\x0a\x09\x09\x09// Compare by name and size (size might be 0 or undefined, but still equivalent for both)\x0a\x09\x09\x09if (file.name === this.files[ii].name && file.size === this.files[ii].size) {\x0a\x09\x09\x09\x09this.trigger(\x27Error\x27, {\x0a\x09\x09\x09\x09\x09code : plupload.FILE_DUPLICATE_ERROR,\x0a\x09\x09\x09\x09\x09message : plupload.translate(\x27Duplicate file error.\x27),\x0a\x09\x09\x09\x09\x09file : file\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09\x09cb(false);\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09}\x0a\x09cb(true);\x0a});\x0a\x0a\x0a/**\x0a@class Uploader\x0a@constructor\x0a\x0a@param {Object} settings For detailed information about each option check documentation.\x0a\x09@param {String|DOMElement} settings.browse_button id of the DOM element or DOM element itself to use as file dialog trigger.\x0a\x09@param {String} settings.url URL of the server-side upload handler.\x0a\x09@param {Number|String} [settings.chunk_size=0] Chunk size in bytes to slice the file into. Shorcuts with b, kb, mb, gb, tb suffixes also supported. `e.g. 204800 or \x22204800b\x22 or \x22200kb\x22`. By default - disabled.\x0a\x09@param {Boolean} [settings.send_chunk_number=true] Whether to send chunks and chunk numbers, or total and offset bytes.\x0a\x09@param {String|DOMElement} [settings.container] id of the DOM element or DOM element itself that will be used to wrap uploader structures. Defaults to immediate parent of the `browse_button` element.\x0a\x09@param {String|DOMElement} [settings.drop_element] id of the DOM element or DOM element itself to use as a drop zone for Drag-n-Drop.\x0a\x09@param {String} [settings.file_data_name=\x22file\x22] Name for the file field in Multipart formated message.\x0a\x09@param {Object} [settings.filters={}] Set of file type filters.\x0a\x09\x09@param {Array} [settings.filters.mime_types=[]] List of file types to accept, each one defined by title and list of extensions. `e.g. {title : \x22Image files\x22, extensions : \x22jpg,jpeg,gif,png\x22}`. Dispatches `plupload.FILE_EXTENSION_ERROR`\x0a\x09\x09@param {String|Number} [settings.filters.max_file_size=0] Maximum file size that the user can pick, in bytes. Optionally supports b, kb, mb, gb, tb suffixes. `e.g. \x2210mb\x22 or \x221gb\x22`. By default - not set. Dispatches `plupload.FILE_SIZE_ERROR`.\x0a\x09\x09@param {Boolean} [settings.filters.prevent_duplicates=false] Do not let duplicates into the queue. Dispatches `plupload.FILE_DUPLICATE_ERROR`.\x0a\x09@param {String} [settings.flash_swf_url] URL of the Flash swf. (Not used in WordPress)\x0a\x09@param {Object} [settings.headers] Custom headers to send with the upload. Hash of name/value pairs.\x0a\x09@param {Number} [settings.max_retries=0] How many times to retry the chunk or file, before triggering Error event.\x0a\x09@param {Boolean} [settings.multipart=true] Whether to send file and additional parameters as Multipart formated message.\x0a\x09@param {Object} [settings.multipart_params] Hash of key/value pairs to send with every file upload.\x0a\x09@param {Boolean} [settings.multi_selection=true] Enable ability to select multiple files at once in file dialog.\x0a\x09@param {String|Object} [settings.required_features] Either comma-separated list or hash of required features that chosen runtime should absolutely possess.\x0a\x09@param {Object} [settings.resize] Enable resizng of images on client-side. Applies to `image/jpeg` and `image/png` only. `e.g. {width : 200, height : 200, quality : 90, crop: true}`\x0a\x09\x09@param {Number} [settings.resize.width] If image is bigger, it will be resized.\x0a\x09\x09@param {Number} [settings.resize.height] If image is bigger, it will be resized.\x0a\x09\x09@param {Number} [settings.resize.quality=90] Compression quality for jpegs (1-100).\x0a\x09\x09@param {Boolean} [settings.resize.crop=false] Whether to crop images to exact dimensions. By default they will be resized proportionally.\x0a\x09@param {String} [settings.runtimes=\x22html5,html4\x22] Comma separated list of runtimes, that Plupload will try in turn, moving to the next if previous fails.\x0a\x09@param {String} [settings.silverlight_xap_url] URL of the Silverlight xap. (Not used in WordPress)\x0a\x09@param {Boolean} [settings.unique_names=false] If true will generate unique filenames for uploaded files.\x0a\x09@param {Boolean} [settings.send_file_name=true] Whether to send file name as additional argument - \x27name\x27 (required for chunked uploads and some other cases where file name cannot be sent via normal ways).\x0a*/\x0aplupload.Uploader = function(options) {\x0a\x09/**\x0a\x09Fires when the current RunTime has been initialized.\x0a\x09\x0a\x09@event Init\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires after the init event incase you need to perform actions there.\x0a\x09\x0a\x09@event PostInit\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires when the option is changed in via uploader.setOption().\x0a\x09\x0a\x09@event OptionChanged\x0a\x09@since 2.1\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09@param {String} name Name of the option that was changed\x0a\x09@param {Mixed} value New value for the specified option\x0a\x09@param {Mixed} oldValue Previous value of the option\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires when the silverlight/flash or other shim needs to move.\x0a\x09\x0a\x09@event Refresh\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires when the overall state is being changed for the upload queue.\x0a\x09\x0a\x09@event StateChanged\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires when browse_button is clicked and browse dialog shows.\x0a\x09\x0a\x09@event Browse\x0a\x09@since 2.1.2\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09 */\x09\x0a\x0a\x09/**\x0a\x09Fires for every filtered file before it is added to the queue.\x0a\x09\x0a\x09@event FileFiltered\x0a\x09@since 2.1\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09@param {plupload.File} file Another file that has to be added to the queue.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires when the file queue is changed. In other words when files are added/removed to the files array of the uploader instance.\x0a\x09\x0a\x09@event QueueChanged\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09 */ \x0a\x0a\x09/**\x0a\x09Fires after files were filtered and added to the queue.\x0a\x09\x0a\x09@event FilesAdded\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09@param {Array} files Array of file objects that were added to queue by the user.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires when file is removed from the queue.\x0a\x09\x0a\x09@event FilesRemoved\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09@param {Array} files Array of files that got removed.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires just before a file is uploaded. Can be used to cancel the upload for the specified file\x0a\x09by returning false from the handler.\x0a\x09\x0a\x09@event BeforeUpload\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09@param {plupload.File} file File to be uploaded.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires when a file is to be uploaded by the runtime.\x0a\x09\x0a\x09@event UploadFile\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09@param {plupload.File} file File to be uploaded.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires while a file is being uploaded. Use this event to update the current file upload progress.\x0a\x09\x0a\x09@event UploadProgress\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09@param {plupload.File} file File that is currently being uploaded.\x0a\x09 */\x09\x0a\x0a\x09/**\x0a\x09Fires when file chunk is uploaded.\x0a\x09\x0a\x09@event ChunkUploaded\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09@param {plupload.File} file File that the chunk was uploaded for.\x0a\x09@param {Object} result Object with response properties.\x0a\x09\x09@param {Number} result.offset The amount of bytes the server has received so far, including this chunk.\x0a\x09\x09@param {Number} result.total The size of the file.\x0a\x09\x09@param {String} result.response The response body sent by the server.\x0a\x09\x09@param {Number} result.status The HTTP status code sent by the server.\x0a\x09\x09@param {String} result.responseHeaders All the response headers as a single string.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires when a file is successfully uploaded.\x0a\x09\x0a\x09@event FileUploaded\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09@param {plupload.File} file File that was uploaded.\x0a\x09@param {Object} result Object with response properties.\x0a\x09\x09@param {String} result.response The response body sent by the server.\x0a\x09\x09@param {Number} result.status The HTTP status code sent by the server.\x0a\x09\x09@param {String} result.responseHeaders All the response headers as a single string.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires when all files in a queue are uploaded.\x0a\x09\x0a\x09@event UploadComplete\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09@param {Array} files Array of file objects that was added to queue/selected by the user.\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires when a error occurs.\x0a\x09\x0a\x09@event Error\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09@param {Object} error Contains code, message and sometimes file and other details.\x0a\x09\x09@param {Number} error.code The plupload error code.\x0a\x09\x09@param {String} error.message Description of the error (uses i18n).\x0a\x09 */\x0a\x0a\x09/**\x0a\x09Fires when destroy method is called.\x0a\x09\x0a\x09@event Destroy\x0a\x09@param {plupload.Uploader} uploader Uploader instance sending the event.\x0a\x09 */\x0a\x09var uid = plupload.guid()\x0a\x09, settings\x0a\x09, files = []\x0a\x09, preferred_caps = {}\x0a\x09, fileInputs = []\x0a\x09, fileDrops = []\x0a\x09, startTime\x0a\x09, total\x0a\x09, disabled = false\x0a\x09, xhr\x0a\x09;\x0a\x0a\x0a\x09// Private methods\x0a\x09function uploadNext() {\x0a\x09\x09var file, count = 0, i;\x0a\x0a\x09\x09if (this.state == plupload.STARTED) {\x0a\x09\x09\x09// Find first QUEUED file\x0a\x09\x09\x09for (i = 0; i \x3c files.length; i++) {\x0a\x09\x09\x09\x09if (!file && files[i].status == plupload.QUEUED) {\x0a\x09\x09\x09\x09\x09file = files[i];\x0a\x09\x09\x09\x09\x09if (this.trigger(\x22BeforeUpload\x22, file)) {\x0a\x09\x09\x09\x09\x09\x09file.status = plupload.UPLOADING;\x0a\x09\x09\x09\x09\x09\x09this.trigger(\x22UploadFile\x22, file);\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09count++;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// All files are DONE or FAILED\x0a\x09\x09\x09if (count == files.length) {\x0a\x09\x09\x09\x09if (this.state !== plupload.STOPPED) {\x0a\x09\x09\x09\x09\x09this.state = plupload.STOPPED;\x0a\x09\x09\x09\x09\x09this.trigger(\x22StateChanged\x22);\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09this.trigger(\x22UploadComplete\x22, files);\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09}\x0a\x0a\x0a\x09function calcFile(file) {\x0a\x09\x09file.percent = file.size \x3e 0 ? Math.ceil(file.loaded / file.size * 100) : 100;\x0a\x09\x09calc();\x0a\x09}\x0a\x0a\x0a\x09function calc() {\x0a\x09\x09var i, file;\x0a\x0a\x09\x09// Reset stats\x0a\x09\x09total.reset();\x0a\x0a\x09\x09// Check status, size, loaded etc on all files\x0a\x09\x09for (i = 0; i \x3c files.length; i++) {\x0a\x09\x09\x09file = files[i];\x0a\x0a\x09\x09\x09if (file.size !== undef) {\x0a\x09\x09\x09\x09// We calculate totals based on original file size\x0a\x09\x09\x09\x09total.size += file.origSize;\x0a\x0a\x09\x09\x09\x09// Since we cannot predict file size after resize, we do opposite and\x0a\x09\x09\x09\x09// interpolate loaded amount to match magnitude of total\x0a\x09\x09\x09\x09total.loaded += file.loaded * file.origSize / file.size;\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09total.size = undef;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if (file.status == plupload.DONE) {\x0a\x09\x09\x09\x09total.uploaded++;\x0a\x09\x09\x09} else if (file.status == plupload.FAILED) {\x0a\x09\x09\x09\x09total.failed++;\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09total.queued++;\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09// If we couldn\x27t calculate a total file size then use the number of files to calc percent\x0a\x09\x09if (total.size === undef) {\x0a\x09\x09\x09total.percent = files.length \x3e 0 ? Math.ceil(total.uploaded / files.length * 100) : 0;\x0a\x09\x09} else {\x0a\x09\x09\x09total.bytesPerSec = Math.ceil(total.loaded / ((+new Date() - startTime || 1) / 1000.0));\x0a\x09\x09\x09total.percent = total.size \x3e 0 ? Math.ceil(total.loaded / total.size * 100) : 0;\x0a\x09\x09}\x0a\x09}\x0a\x0a\x0a\x09function getRUID() {\x0a\x09\x09var ctrl = fileInputs[0] || fileDrops[0];\x0a\x09\x09if (ctrl) {\x0a\x09\x09\x09return ctrl.getRuntime().uid;\x0a\x09\x09}\x0a\x09\x09return false;\x0a\x09}\x0a\x0a\x0a\x09function runtimeCan(file, cap) {\x0a\x09\x09if (file.ruid) {\x0a\x09\x09\x09var info = o.Runtime.getInfo(file.ruid);\x0a\x09\x09\x09if (info) {\x0a\x09\x09\x09\x09return info.can(cap);\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09\x09return false;\x0a\x09}\x0a\x0a\x0a\x09function bindEventListeners() {\x0a\x09\x09this.bind(\x27FilesAdded FilesRemoved\x27, function(up) {\x0a\x09\x09\x09up.trigger(\x27QueueChanged\x27);\x0a\x09\x09\x09up.refresh();\x0a\x09\x09});\x0a\x0a\x09\x09this.bind(\x27CancelUpload\x27, onCancelUpload);\x0a\x09\x09\x0a\x09\x09this.bind(\x27BeforeUpload\x27, onBeforeUpload);\x0a\x0a\x09\x09this.bind(\x27UploadFile\x27, onUploadFile);\x0a\x0a\x09\x09this.bind(\x27UploadProgress\x27, onUploadProgress);\x0a\x0a\x09\x09this.bind(\x27StateChanged\x27, onStateChanged);\x0a\x0a\x09\x09this.bind(\x27QueueChanged\x27, calc);\x0a\x0a\x09\x09this.bind(\x27Error\x27, onError);\x0a\x0a\x09\x09this.bind(\x27FileUploaded\x27, onFileUploaded);\x0a\x0a\x09\x09this.bind(\x27Destroy\x27, onDestroy);\x0a\x09}\x0a\x0a\x0a\x09function initControls(settings, cb) {\x0a\x09\x09var self = this, inited = 0, queue = [];\x0a\x0a\x09\x09// common settings\x0a\x09\x09var options = {\x0a\x09\x09\x09runtime_order: settings.runtimes,\x0a\x09\x09\x09required_caps: settings.required_features,\x0a\x09\x09\x09preferred_caps: preferred_caps\x0a\x09\x09};\x0a\x0a\x09\x09// add runtime specific options if any\x0a\x09\x09plupload.each(settings.runtimes.split(/\x5cs*,\x5cs*/), function(runtime) {\x0a\x09\x09\x09if (settings[runtime]) {\x0a\x09\x09\x09\x09options[runtime] = settings[runtime];\x0a\x09\x09\x09}\x0a\x09\x09});\x0a\x0a\x09\x09// initialize file pickers - there can be many\x0a\x09\x09if (settings.browse_button) {\x0a\x09\x09\x09plupload.each(settings.browse_button, function(el) {\x0a\x09\x09\x09\x09queue.push(function(cb) {\x0a\x09\x09\x09\x09\x09var fileInput = new o.FileInput(plupload.extend({}, options, {\x0a\x09\x09\x09\x09\x09\x09accept: settings.filters.mime_types,\x0a\x09\x09\x09\x09\x09\x09name: settings.file_data_name,\x0a\x09\x09\x09\x09\x09\x09multiple: settings.multi_selection,\x0a\x09\x09\x09\x09\x09\x09container: settings.container,\x0a\x09\x09\x09\x09\x09\x09browse_button: el\x0a\x09\x09\x09\x09\x09}));\x0a\x0a\x09\x09\x09\x09\x09fileInput.onready = function() {\x0a\x09\x09\x09\x09\x09\x09var info = o.Runtime.getInfo(this.ruid);\x0a\x0a\x09\x09\x09\x09\x09\x09// for backward compatibility\x0a\x09\x09\x09\x09\x09\x09o.extend(self.features, {\x0a\x09\x09\x09\x09\x09\x09\x09chunks: info.can(\x27slice_blob\x27),\x0a\x09\x09\x09\x09\x09\x09\x09multipart: info.can(\x27send_multipart\x27),\x0a\x09\x09\x09\x09\x09\x09\x09multi_selection: info.can(\x27select_multiple\x27)\x0a\x09\x09\x09\x09\x09\x09});\x0a\x0a\x09\x09\x09\x09\x09\x09inited++;\x0a\x09\x09\x09\x09\x09\x09fileInputs.push(this);\x0a\x09\x09\x09\x09\x09\x09cb();\x0a\x09\x09\x09\x09\x09};\x0a\x0a\x09\x09\x09\x09\x09fileInput.onchange = function() {\x0a\x09\x09\x09\x09\x09\x09self.addFile(this.files);\x0a\x09\x09\x09\x09\x09};\x0a\x0a\x09\x09\x09\x09\x09fileInput.bind(\x27mouseenter mouseleave mousedown mouseup\x27, function(e) {\x0a\x09\x09\x09\x09\x09\x09if (!disabled) {\x0a\x09\x09\x09\x09\x09\x09\x09if (settings.browse_button_hover) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09if (\x27mouseenter\x27 === e.type) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09o.addClass(el, settings.browse_button_hover);\x0a\x09\x09\x09\x09\x09\x09\x09\x09} else if (\x27mouseleave\x27 === e.type) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09o.removeClass(el, settings.browse_button_hover);\x0a\x09\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09\x09\x09if (settings.browse_button_active) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09if (\x27mousedown\x27 === e.type) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09o.addClass(el, settings.browse_button_active);\x0a\x09\x09\x09\x09\x09\x09\x09\x09} else if (\x27mouseup\x27 === e.type) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09o.removeClass(el, settings.browse_button_active);\x0a\x09\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09});\x0a\x0a\x09\x09\x09\x09\x09fileInput.bind(\x27mousedown\x27, function() {\x0a\x09\x09\x09\x09\x09\x09self.trigger(\x27Browse\x27);\x0a\x09\x09\x09\x09\x09});\x0a\x0a\x09\x09\x09\x09\x09fileInput.bind(\x27error runtimeerror\x27, function() {\x0a\x09\x09\x09\x09\x09\x09fileInput = null;\x0a\x09\x09\x09\x09\x09\x09cb();\x0a\x09\x09\x09\x09\x09});\x0a\x0a\x09\x09\x09\x09\x09fileInput.init();\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09});\x0a\x09\x09}\x0a\x0a\x09\x09// initialize drop zones\x0a\x09\x09if (settings.drop_element) {\x0a\x09\x09\x09plupload.each(settings.drop_element, function(el) {\x0a\x09\x09\x09\x09queue.push(function(cb) {\x0a\x09\x09\x09\x09\x09var fileDrop = new o.FileDrop(plupload.extend({}, options, {\x0a\x09\x09\x09\x09\x09\x09drop_zone: el\x0a\x09\x09\x09\x09\x09}));\x0a\x0a\x09\x09\x09\x09\x09fileDrop.onready = function() {\x0a\x09\x09\x09\x09\x09\x09var info = o.Runtime.getInfo(this.ruid);\x0a\x0a\x09\x09\x09\x09\x09\x09// for backward compatibility\x0a\x09\x09\x09\x09\x09\x09o.extend(self.features, {\x0a\x09\x09\x09\x09\x09\x09\x09chunks: info.can(\x27slice_blob\x27),\x0a\x09\x09\x09\x09\x09\x09\x09multipart: info.can(\x27send_multipart\x27),\x0a\x09\x09\x09\x09\x09\x09\x09dragdrop: info.can(\x27drag_and_drop\x27)\x0a\x09\x09\x09\x09\x09\x09});\x0a\x0a\x09\x09\x09\x09\x09\x09inited++;\x0a\x09\x09\x09\x09\x09\x09fileDrops.push(this);\x0a\x09\x09\x09\x09\x09\x09cb();\x0a\x09\x09\x09\x09\x09};\x0a\x0a\x09\x09\x09\x09\x09fileDrop.ondrop = function() {\x0a\x09\x09\x09\x09\x09\x09self.addFile(this.files);\x0a\x09\x09\x09\x09\x09};\x0a\x0a\x09\x09\x09\x09\x09fileDrop.bind(\x27error runtimeerror\x27, function() {\x0a\x09\x09\x09\x09\x09\x09fileDrop = null;\x0a\x09\x09\x09\x09\x09\x09cb();\x0a\x09\x09\x09\x09\x09});\x0a\x0a\x09\x09\x09\x09\x09fileDrop.init();\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09});\x0a\x09\x09}\x0a\x0a\x0a\x09\x09o.inSeries(queue, function() {\x0a\x09\x09\x09if (typeof(cb) === \x27function\x27) {\x0a\x09\x09\x09\x09cb(inited);\x0a\x09\x09\x09}\x0a\x09\x09});\x0a\x09}\x0a\x0a\x0a\x09function resizeImage(blob, params, cb) {\x0a\x09\x09var img = new o.Image();\x0a\x0a\x09\x09try {\x0a\x09\x09\x09img.onload = function() {\x0a\x09\x09\x09\x09// no manipulation required if...\x0a\x09\x09\x09\x09if (params.width \x3e this.width &&\x0a\x09\x09\x09\x09\x09params.height \x3e this.height &&\x0a\x09\x09\x09\x09\x09params.quality === undef &&\x0a\x09\x09\x09\x09\x09params.preserve_headers &&\x0a\x09\x09\x09\x09\x09!params.crop\x0a\x09\x09\x09\x09) {\x0a\x09\x09\x09\x09\x09this.destroy();\x0a\x09\x09\x09\x09\x09return cb(blob);\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09// otherwise downsize\x0a\x09\x09\x09\x09img.downsize(params.width, params.height, params.crop, params.preserve_headers);\x0a\x09\x09\x09};\x0a\x0a\x09\x09\x09img.onresize = function() {\x0a\x09\x09\x09\x09cb(this.getAsBlob(blob.type, params.quality));\x0a\x09\x09\x09\x09this.destroy();\x0a\x09\x09\x09};\x0a\x0a\x09\x09\x09img.onerror = function() {\x0a\x09\x09\x09\x09cb(blob);\x0a\x09\x09\x09};\x0a\x0a\x09\x09\x09img.load(blob);\x0a\x09\x09} catch(ex) {\x0a\x09\x09\x09cb(blob);\x0a\x09\x09}\x0a\x09}\x0a\x0a\x0a\x09function setOption(option, value, init) {\x0a\x09\x09var self = this, reinitRequired = false;\x0a\x0a\x09\x09function _setOption(option, value, init) {\x0a\x09\x09\x09var oldValue = settings[option];\x0a\x0a\x09\x09\x09switch (option) {\x0a\x09\x09\x09\x09case \x27max_file_size\x27:\x0a\x09\x09\x09\x09\x09if (option === \x27max_file_size\x27) {\x0a\x09\x09\x09\x09\x09\x09settings.max_file_size = settings.filters.max_file_size = value;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09break;\x0a\x0a\x09\x09\x09\x09case \x27chunk_size\x27:\x0a\x09\x09\x09\x09\x09if (value = plupload.parseSize(value)) {\x0a\x09\x09\x09\x09\x09\x09settings[option] = value;\x0a\x09\x09\x09\x09\x09\x09settings.send_file_name = true;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09break;\x0a\x0a\x09\x09\x09\x09case \x27multipart\x27:\x0a\x09\x09\x09\x09\x09settings[option] = value;\x0a\x09\x09\x09\x09\x09if (!value) {\x0a\x09\x09\x09\x09\x09\x09settings.send_file_name = true;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09break;\x0a\x0a\x09\x09\x09\x09case \x27unique_names\x27:\x0a\x09\x09\x09\x09\x09settings[option] = value;\x0a\x09\x09\x09\x09\x09if (value) {\x0a\x09\x09\x09\x09\x09\x09settings.send_file_name = true;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09break;\x0a\x0a\x09\x09\x09\x09case \x27filters\x27:\x0a\x09\x09\x09\x09\x09// for sake of backward compatibility\x0a\x09\x09\x09\x09\x09if (plupload.typeOf(value) === \x27array\x27) {\x0a\x09\x09\x09\x09\x09\x09value = {\x0a\x09\x09\x09\x09\x09\x09\x09mime_types: value\x0a\x09\x09\x09\x09\x09\x09};\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09if (init) {\x0a\x09\x09\x09\x09\x09\x09plupload.extend(settings.filters, value);\x0a\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09settings.filters = value;\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09// if file format filters are being updated, regenerate the matching expressions\x0a\x09\x09\x09\x09\x09if (value.mime_types) {\x0a\x09\x09\x09\x09\x09\x09settings.filters.mime_types.regexp = (function(filters) {\x0a\x09\x09\x09\x09\x09\x09\x09var extensionsRegExp = [];\x0a\x0a\x09\x09\x09\x09\x09\x09\x09plupload.each(filters, function(filter) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09plupload.each(filter.extensions.split(/,/), function(ext) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09if (/^\x5cs*\x5c*\x5cs*$/.test(ext)) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09\x09extensionsRegExp.push(\x27\x5c\x5c.*\x27);\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09\x09extensionsRegExp.push(\x27\x5c\x5c.\x27 + ext.replace(new RegExp(\x27[\x27 + (\x27/^$.*+?|()[]{}\x5c\x5c\x27.replace(/./g, \x27\x5c\x5c$&\x27)) + \x27]\x27, \x27g\x27), \x27\x5c\x5c$&\x27));\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09\x09\x09});\x0a\x09\x09\x09\x09\x09\x09\x09});\x0a\x0a\x09\x09\x09\x09\x09\x09\x09return new RegExp(\x27(\x27 + extensionsRegExp.join(\x27|\x27) + \x27)$\x27, \x27i\x27);\x0a\x09\x09\x09\x09\x09\x09}(settings.filters.mime_types));\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09break;\x0a\x09\x0a\x09\x09\x09\x09case \x27resize\x27:\x0a\x09\x09\x09\x09\x09if (init) {\x0a\x09\x09\x09\x09\x09\x09plupload.extend(settings.resize, value, {\x0a\x09\x09\x09\x09\x09\x09\x09enabled: true\x0a\x09\x09\x09\x09\x09\x09});\x0a\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09settings.resize = value;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09break;\x0a\x0a\x09\x09\x09\x09case \x27prevent_duplicates\x27:\x0a\x09\x09\x09\x09\x09settings.prevent_duplicates = settings.filters.prevent_duplicates = !!value;\x0a\x09\x09\x09\x09\x09break;\x0a\x0a\x09\x09\x09\x09// options that require reinitialisation\x0a\x09\x09\x09\x09case \x27container\x27:\x0a\x09\x09\x09\x09case \x27browse_button\x27:\x0a\x09\x09\x09\x09case \x27drop_element\x27:\x0a\x09\x09\x09\x09\x09\x09value = \x27container\x27 === option\x0a\x09\x09\x09\x09\x09\x09\x09? plupload.get(value)\x0a\x09\x09\x09\x09\x09\x09\x09: plupload.getAll(value)\x0a\x09\x09\x09\x09\x09\x09\x09; \x0a\x09\x09\x09\x09\x0a\x09\x09\x09\x09case \x27runtimes\x27:\x0a\x09\x09\x09\x09case \x27multi_selection\x27:\x0a\x09\x09\x09\x09\x09settings[option] = value;\x0a\x09\x09\x09\x09\x09if (!init) {\x0a\x09\x09\x09\x09\x09\x09reinitRequired = true;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09break;\x0a\x0a\x09\x09\x09\x09default:\x0a\x09\x09\x09\x09\x09settings[option] = value;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if (!init) {\x0a\x09\x09\x09\x09self.trigger(\x27OptionChanged\x27, option, value, oldValue);\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09if (typeof(option) === \x27object\x27) {\x0a\x09\x09\x09plupload.each(option, function(value, option) {\x0a\x09\x09\x09\x09_setOption(option, value, init);\x0a\x09\x09\x09});\x0a\x09\x09} else {\x0a\x09\x09\x09_setOption(option, value, init);\x0a\x09\x09}\x0a\x0a\x09\x09if (init) {\x0a\x09\x09\x09// Normalize the list of required capabilities\x0a\x09\x09\x09settings.required_features = normalizeCaps(plupload.extend({}, settings));\x0a\x0a\x09\x09\x09// Come up with the list of capabilities that can affect default mode in a multi-mode runtimes\x0a\x09\x09\x09preferred_caps = normalizeCaps(plupload.extend({}, settings, {\x0a\x09\x09\x09\x09required_features: true\x0a\x09\x09\x09}));\x0a\x09\x09} else if (reinitRequired) {\x0a\x09\x09\x09self.trigger(\x27Destroy\x27);\x0a\x09\x09\x09\x0a\x09\x09\x09initControls.call(self, settings, function(inited) {\x0a\x09\x09\x09\x09if (inited) {\x0a\x09\x09\x09\x09\x09self.runtime = o.Runtime.getInfo(getRUID()).type;\x0a\x09\x09\x09\x09\x09self.trigger(\x27Init\x27, { runtime: self.runtime });\x0a\x09\x09\x09\x09\x09self.trigger(\x27PostInit\x27);\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09self.trigger(\x27Error\x27, {\x0a\x09\x09\x09\x09\x09\x09code : plupload.INIT_ERROR,\x0a\x09\x09\x09\x09\x09\x09message : plupload.translate(\x27Init error.\x27)\x0a\x09\x09\x09\x09\x09});\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09});\x0a\x09\x09}\x0a\x09}\x0a\x0a\x0a\x09// Internal event handlers\x0a\x09function onBeforeUpload(up, file) {\x0a\x09\x09// Generate unique target filenames\x0a\x09\x09if (up.settings.unique_names) {\x0a\x09\x09\x09var matches = file.name.match(/\x5c.([^.]+)$/), ext = \x22part\x22;\x0a\x09\x09\x09if (matches) {\x0a\x09\x09\x09\x09ext = matches[1];\x0a\x09\x09\x09}\x0a\x09\x09\x09file.target_name = file.id + \x27.\x27 + ext;\x0a\x09\x09}\x0a\x09}\x0a\x0a\x0a\x09function onUploadFile(up, file) {\x0a\x09\x09var url = up.settings.url\x0a\x09\x09, chunkSize = up.settings.chunk_size\x0a\x09\x09, retries = up.settings.max_retries\x0a\x09\x09, features = up.features\x0a\x09\x09, offset = 0\x0a\x09\x09, blob\x0a\x09\x09;\x0a\x0a\x09\x09// make sure we start at a predictable offset\x0a\x09\x09if (file.loaded) {\x0a\x09\x09\x09offset = file.loaded = chunkSize ? chunkSize * Math.floor(file.loaded / chunkSize) : 0;\x0a\x09\x09}\x0a\x0a\x09\x09function handleError() {\x0a\x09\x09\x09if (retries-- \x3e 0) {\x0a\x09\x09\x09\x09delay(uploadNextChunk, 1000);\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09file.loaded = offset; // reset all progress\x0a\x0a\x09\x09\x09\x09up.trigger(\x27Error\x27, {\x0a\x09\x09\x09\x09\x09code : plupload.HTTP_ERROR,\x0a\x09\x09\x09\x09\x09message : plupload.translate(\x27HTTP Error.\x27),\x0a\x09\x09\x09\x09\x09file : file,\x0a\x09\x09\x09\x09\x09response : xhr.responseText,\x0a\x09\x09\x09\x09\x09status : xhr.status,\x0a\x09\x09\x09\x09\x09responseHeaders: xhr.getAllResponseHeaders()\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09function uploadNextChunk() {\x0a\x09\x09\x09var chunkBlob, formData, args = {}, curChunkSize;\x0a\x0a\x09\x09\x09// make sure that file wasn\x27t cancelled and upload is not stopped in general\x0a\x09\x09\x09if (file.status !== plupload.UPLOADING || up.state === plupload.STOPPED) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// send additional \x27name\x27 parameter only if required\x0a\x09\x09\x09if (up.settings.send_file_name) {\x0a\x09\x09\x09\x09args.name = file.target_name || file.name;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if (chunkSize && features.chunks && blob.size \x3e chunkSize) { // blob will be of type string if it was loaded in memory \x0a\x09\x09\x09\x09curChunkSize = Math.min(chunkSize, blob.size - offset);\x0a\x09\x09\x09\x09chunkBlob = blob.slice(offset, offset + curChunkSize);\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09curChunkSize = blob.size;\x0a\x09\x09\x09\x09chunkBlob = blob;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// If chunking is enabled add corresponding args, no matter if file is bigger than chunk or smaller\x0a\x09\x09\x09if (chunkSize && features.chunks) {\x0a\x09\x09\x09\x09// Setup query string arguments\x0a\x09\x09\x09\x09if (up.settings.send_chunk_number) {\x0a\x09\x09\x09\x09\x09args.chunk = Math.ceil(offset / chunkSize);\x0a\x09\x09\x09\x09\x09args.chunks = Math.ceil(blob.size / chunkSize);\x0a\x09\x09\x09\x09} else { // keep support for experimental chunk format, just in case\x0a\x09\x09\x09\x09\x09args.offset = offset;\x0a\x09\x09\x09\x09\x09args.total = blob.size;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09xhr = new o.XMLHttpRequest();\x0a\x0a\x09\x09\x09// Do we have upload progress support\x0a\x09\x09\x09if (xhr.upload) {\x0a\x09\x09\x09\x09xhr.upload.onprogress = function(e) {\x0a\x09\x09\x09\x09\x09file.loaded = Math.min(file.size, offset + e.loaded);\x0a\x09\x09\x09\x09\x09up.trigger(\x27UploadProgress\x27, file);\x0a\x09\x09\x09\x09};\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09xhr.onload = function() {\x0a\x09\x09\x09\x09// check if upload made itself through\x0a\x09\x09\x09\x09if (xhr.status \x3e= 400) {\x0a\x09\x09\x09\x09\x09handleError();\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09retries = up.settings.max_retries; // reset the counter\x0a\x0a\x09\x09\x09\x09// Handle chunk response\x0a\x09\x09\x09\x09if (curChunkSize \x3c blob.size) {\x0a\x09\x09\x09\x09\x09chunkBlob.destroy();\x0a\x0a\x09\x09\x09\x09\x09offset += curChunkSize;\x0a\x09\x09\x09\x09\x09file.loaded = Math.min(offset, blob.size);\x0a\x0a\x09\x09\x09\x09\x09up.trigger(\x27ChunkUploaded\x27, file, {\x0a\x09\x09\x09\x09\x09\x09offset : file.loaded,\x0a\x09\x09\x09\x09\x09\x09total : blob.size,\x0a\x09\x09\x09\x09\x09\x09response : xhr.responseText,\x0a\x09\x09\x09\x09\x09\x09status : xhr.status,\x0a\x09\x09\x09\x09\x09\x09responseHeaders: xhr.getAllResponseHeaders()\x0a\x09\x09\x09\x09\x09});\x0a\x0a\x09\x09\x09\x09\x09// stock Android browser doesn\x27t fire upload progress events, but in chunking mode we can fake them\x0a\x09\x09\x09\x09\x09if (o.Env.browser === \x27Android Browser\x27) {\x0a\x09\x09\x09\x09\x09\x09// doesn\x27t harm in general, but is not required anywhere else\x0a\x09\x09\x09\x09\x09\x09up.trigger(\x27UploadProgress\x27, file);\x0a\x09\x09\x09\x09\x09} \x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09file.loaded = file.size;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09chunkBlob = formData = null; // Free memory\x0a\x0a\x09\x09\x09\x09// Check if file is uploaded\x0a\x09\x09\x09\x09if (!offset || offset \x3e= blob.size) {\x0a\x09\x09\x09\x09\x09// If file was modified, destory the copy\x0a\x09\x09\x09\x09\x09if (file.size != file.origSize) {\x0a\x09\x09\x09\x09\x09\x09blob.destroy();\x0a\x09\x09\x09\x09\x09\x09blob = null;\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09up.trigger(\x27UploadProgress\x27, file);\x0a\x0a\x09\x09\x09\x09\x09file.status = plupload.DONE;\x0a\x0a\x09\x09\x09\x09\x09up.trigger(\x27FileUploaded\x27, file, {\x0a\x09\x09\x09\x09\x09\x09response : xhr.responseText,\x0a\x09\x09\x09\x09\x09\x09status : xhr.status,\x0a\x09\x09\x09\x09\x09\x09responseHeaders: xhr.getAllResponseHeaders()\x0a\x09\x09\x09\x09\x09});\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09// Still chunks left\x0a\x09\x09\x09\x09\x09delay(uploadNextChunk, 1); // run detached, otherwise event handlers interfere\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09};\x0a\x0a\x09\x09\x09xhr.onerror = function() {\x0a\x09\x09\x09\x09handleError();\x0a\x09\x09\x09};\x0a\x0a\x09\x09\x09xhr.onloadend = function() {\x0a\x09\x09\x09\x09this.destroy();\x0a\x09\x09\x09\x09xhr = null;\x0a\x09\x09\x09};\x0a\x0a\x09\x09\x09// Build multipart request\x0a\x09\x09\x09if (up.settings.multipart && features.multipart) {\x0a\x09\x09\x09\x09xhr.open(\x22post\x22, url, true);\x0a\x0a\x09\x09\x09\x09// Set custom headers\x0a\x09\x09\x09\x09plupload.each(up.settings.headers, function(value, name) {\x0a\x09\x09\x09\x09\x09xhr.setRequestHeader(name, value);\x0a\x09\x09\x09\x09});\x0a\x0a\x09\x09\x09\x09formData = new o.FormData();\x0a\x0a\x09\x09\x09\x09// Add multipart params\x0a\x09\x09\x09\x09plupload.each(plupload.extend(args, up.settings.multipart_params), function(value, name) {\x0a\x09\x09\x09\x09\x09formData.append(name, value);\x0a\x09\x09\x09\x09});\x0a\x0a\x09\x09\x09\x09// Add file and send it\x0a\x09\x09\x09\x09formData.append(up.settings.file_data_name, chunkBlob);\x0a\x09\x09\x09\x09xhr.send(formData, {\x0a\x09\x09\x09\x09\x09runtime_order: up.settings.runtimes,\x0a\x09\x09\x09\x09\x09required_caps: up.settings.required_features,\x0a\x09\x09\x09\x09\x09preferred_caps: preferred_caps\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09// if no multipart, send as binary stream\x0a\x09\x09\x09\x09url = plupload.buildUrl(up.settings.url, plupload.extend(args, up.settings.multipart_params));\x0a\x0a\x09\x09\x09\x09xhr.open(\x22post\x22, url, true);\x0a\x0a\x09\x09\x09\x09xhr.setRequestHeader(\x27Content-Type\x27, \x27application/octet-stream\x27); // Binary stream header\x0a\x0a\x09\x09\x09\x09// Set custom headers\x0a\x09\x09\x09\x09plupload.each(up.settings.headers, function(value, name) {\x0a\x09\x09\x09\x09\x09xhr.setRequestHeader(name, value);\x0a\x09\x09\x09\x09});\x0a\x0a\x09\x09\x09\x09xhr.send(chunkBlob, {\x0a\x09\x09\x09\x09\x09runtime_order: up.settings.runtimes,\x0a\x09\x09\x09\x09\x09required_caps: up.settings.required_features,\x0a\x09\x09\x09\x09\x09preferred_caps: preferred_caps\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09blob = file.getSource();\x0a\x0a\x09\x09// Start uploading chunks\x0a\x09\x09if (up.settings.resize.enabled && runtimeCan(blob, \x27send_binary_string\x27) && !!~o.inArray(blob.type, [\x27image/jpeg\x27, \x27image/png\x27])) {\x0a\x09\x09\x09// Resize if required\x0a\x09\x09\x09resizeImage.call(this, blob, up.settings.resize, function(resizedBlob) {\x0a\x09\x09\x09\x09blob = resizedBlob;\x0a\x09\x09\x09\x09file.size = resizedBlob.size;\x0a\x09\x09\x09\x09uploadNextChunk();\x0a\x09\x09\x09});\x0a\x09\x09} else {\x0a\x09\x09\x09uploadNextChunk();\x0a\x09\x09}\x0a\x09}\x0a\x0a\x0a\x09function onUploadProgress(up, file) {\x0a\x09\x09calcFile(file);\x0a\x09}\x0a\x0a\x0a\x09function onStateChanged(up) {\x0a\x09\x09if (up.state == plupload.STARTED) {\x0a\x09\x09\x09// Get start time to calculate bps\x0a\x09\x09\x09startTime = (+new Date());\x0a\x09\x09} else if (up.state == plupload.STOPPED) {\x0a\x09\x09\x09// Reset currently uploading files\x0a\x09\x09\x09for (var i = up.files.length - 1; i \x3e= 0; i--) {\x0a\x09\x09\x09\x09if (up.files[i].status == plupload.UPLOADING) {\x0a\x09\x09\x09\x09\x09up.files[i].status = plupload.QUEUED;\x0a\x09\x09\x09\x09\x09calc();\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09}\x0a\x0a\x0a\x09function onCancelUpload() {\x0a\x09\x09if (xhr) {\x0a\x09\x09\x09xhr.abort();\x0a\x09\x09}\x0a\x09}\x0a\x0a\x0a\x09function onFileUploaded(up) {\x0a\x09\x09calc();\x0a\x0a\x09\x09// Upload next file but detach it from the error event\x0a\x09\x09// since other custom listeners might want to stop the queue\x0a\x09\x09delay(function() {\x0a\x09\x09\x09uploadNext.call(up);\x0a\x09\x09}, 1);\x0a\x09}\x0a\x0a\x0a\x09function onError(up, err) {\x0a\x09\x09if (err.code === plupload.INIT_ERROR) {\x0a\x09\x09\x09up.destroy();\x0a\x09\x09}\x0a\x09\x09// Set failed status if an error occured on a file\x0a\x09\x09else if (err.code === plupload.HTTP_ERROR) {\x0a\x09\x09\x09err.file.status = plupload.FAILED;\x0a\x09\x09\x09calcFile(err.file);\x0a\x0a\x09\x09\x09// Upload next file but detach it from the error event\x0a\x09\x09\x09// since other custom listeners might want to stop the queue\x0a\x09\x09\x09if (up.state == plupload.STARTED) { // upload in progress\x0a\x09\x09\x09\x09up.trigger(\x27CancelUpload\x27);\x0a\x09\x09\x09\x09delay(function() {\x0a\x09\x09\x09\x09\x09uploadNext.call(up);\x0a\x09\x09\x09\x09}, 1);\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09}\x0a\x0a\x0a\x09function onDestroy(up) {\x0a\x09\x09up.stop();\x0a\x0a\x09\x09// Purge the queue\x0a\x09\x09plupload.each(files, function(file) {\x0a\x09\x09\x09file.destroy();\x0a\x09\x09});\x0a\x09\x09files = [];\x0a\x0a\x09\x09if (fileInputs.length) {\x0a\x09\x09\x09plupload.each(fileInputs, function(fileInput) {\x0a\x09\x09\x09\x09fileInput.destroy();\x0a\x09\x09\x09});\x0a\x09\x09\x09fileInputs = [];\x0a\x09\x09}\x0a\x0a\x09\x09if (fileDrops.length) {\x0a\x09\x09\x09plupload.each(fileDrops, function(fileDrop) {\x0a\x09\x09\x09\x09fileDrop.destroy();\x0a\x09\x09\x09});\x0a\x09\x09\x09fileDrops = [];\x0a\x09\x09}\x0a\x0a\x09\x09preferred_caps = {};\x0a\x09\x09disabled = false;\x0a\x09\x09startTime = xhr = null;\x0a\x09\x09total.reset();\x0a\x09}\x0a\x0a\x0a\x09// Default settings\x0a\x09settings = {\x0a\x09\x09runtimes: o.Runtime.order,\x0a\x09\x09max_retries: 0,\x0a\x09\x09chunk_size: 0,\x0a\x09\x09multipart: true,\x0a\x09\x09multi_selection: true,\x0a\x09\x09file_data_name: \x27file\x27,\x0a\x09\x09filters: {\x0a\x09\x09\x09mime_types: [],\x0a\x09\x09\x09prevent_duplicates: false,\x0a\x09\x09\x09max_file_size: 0\x0a\x09\x09},\x0a\x09\x09resize: {\x0a\x09\x09\x09enabled: false,\x0a\x09\x09\x09preserve_headers: true,\x0a\x09\x09\x09crop: false\x0a\x09\x09},\x0a\x09\x09send_file_name: true,\x0a\x09\x09send_chunk_number: true\x0a\x09};\x0a\x0a\x09\x0a\x09setOption.call(this, options, null, true);\x0a\x0a\x09// Inital total state\x0a\x09total = new plupload.QueueProgress(); \x0a\x0a\x09// Add public methods\x0a\x09plupload.extend(this, {\x0a\x0a\x09\x09/**\x0a\x09\x09 * Unique id for the Uploader instance.\x0a\x09\x09 *\x0a\x09\x09 * @property id\x0a\x09\x09 * @type String\x0a\x09\x09 */\x0a\x09\x09id : uid,\x0a\x09\x09uid : uid, // mOxie uses this to differentiate between event targets\x0a\x0a\x09\x09/**\x0a\x09\x09 * Current state of the total uploading progress. This one can either be plupload.STARTED or plupload.STOPPED.\x0a\x09\x09 * These states are controlled by the stop/start methods. The default value is STOPPED.\x0a\x09\x09 *\x0a\x09\x09 * @property state\x0a\x09\x09 * @type Number\x0a\x09\x09 */\x0a\x09\x09state : plupload.STOPPED,\x0a\x0a\x09\x09/**\x0a\x09\x09 * Map of features that are available for the uploader runtime. Features will be filled\x0a\x09\x09 * before the init event is called, these features can then be used to alter the UI for the end user.\x0a\x09\x09 * Some of the current features that might be in this map is: dragdrop, chunks, jpgresize, pngresize.\x0a\x09\x09 *\x0a\x09\x09 * @property features\x0a\x09\x09 * @type Object\x0a\x09\x09 */\x0a\x09\x09features : {},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Current runtime name.\x0a\x09\x09 *\x0a\x09\x09 * @property runtime\x0a\x09\x09 * @type String\x0a\x09\x09 */\x0a\x09\x09runtime : null,\x0a\x0a\x09\x09/**\x0a\x09\x09 * Current upload queue, an array of File instances.\x0a\x09\x09 *\x0a\x09\x09 * @property files\x0a\x09\x09 * @type Array\x0a\x09\x09 * @see plupload.File\x0a\x09\x09 */\x0a\x09\x09files : files,\x0a\x0a\x09\x09/**\x0a\x09\x09 * Object with name/value settings.\x0a\x09\x09 *\x0a\x09\x09 * @property settings\x0a\x09\x09 * @type Object\x0a\x09\x09 */\x0a\x09\x09settings : settings,\x0a\x0a\x09\x09/**\x0a\x09\x09 * Total progess information. How many files has been uploaded, total percent etc.\x0a\x09\x09 *\x0a\x09\x09 * @property total\x0a\x09\x09 * @type plupload.QueueProgress\x0a\x09\x09 */\x0a\x09\x09total : total,\x0a\x0a\x0a\x09\x09/**\x0a\x09\x09 * Initializes the Uploader instance and adds internal event listeners.\x0a\x09\x09 *\x0a\x09\x09 * @method init\x0a\x09\x09 */\x0a\x09\x09init : function() {\x0a\x09\x09\x09var self = this, opt, preinitOpt, err;\x0a\x09\x09\x09\x0a\x09\x09\x09preinitOpt = self.getOption(\x27preinit\x27);\x0a\x09\x09\x09if (typeof(preinitOpt) == \x22function\x22) {\x0a\x09\x09\x09\x09preinitOpt(self);\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09plupload.each(preinitOpt, function(func, name) {\x0a\x09\x09\x09\x09\x09self.bind(name, func);\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09bindEventListeners.call(self);\x0a\x0a\x09\x09\x09// Check for required options\x0a\x09\x09\x09plupload.each([\x27container\x27, \x27browse_button\x27, \x27drop_element\x27], function(el) {\x0a\x09\x09\x09\x09if (self.getOption(el) === null) {\x0a\x09\x09\x09\x09\x09err = {\x0a\x09\x09\x09\x09\x09\x09code : plupload.INIT_ERROR,\x0a\x09\x09\x09\x09\x09\x09message : plupload.translate(\x22\x27%\x27 specified, but cannot be found.\x22)\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09return false;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09});\x0a\x0a\x09\x09\x09if (err) {\x0a\x09\x09\x09\x09return self.trigger(\x27Error\x27, err);\x0a\x09\x09\x09}\x0a\x0a\x0a\x09\x09\x09if (!settings.browse_button && !settings.drop_element) {\x0a\x09\x09\x09\x09return self.trigger(\x27Error\x27, {\x0a\x09\x09\x09\x09\x09code : plupload.INIT_ERROR,\x0a\x09\x09\x09\x09\x09message : plupload.translate(\x22You must specify either \x27browse_button\x27 or \x27drop_element\x27.\x22)\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09}\x0a\x0a\x0a\x09\x09\x09initControls.call(self, settings, function(inited) {\x0a\x09\x09\x09\x09var initOpt = self.getOption(\x27init\x27);\x0a\x09\x09\x09\x09if (typeof(initOpt) == \x22function\x22) {\x0a\x09\x09\x09\x09\x09initOpt(self);\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09plupload.each(initOpt, function(func, name) {\x0a\x09\x09\x09\x09\x09\x09self.bind(name, func);\x0a\x09\x09\x09\x09\x09});\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09if (inited) {\x0a\x09\x09\x09\x09\x09self.runtime = o.Runtime.getInfo(getRUID()).type;\x0a\x09\x09\x09\x09\x09self.trigger(\x27Init\x27, { runtime: self.runtime });\x0a\x09\x09\x09\x09\x09self.trigger(\x27PostInit\x27);\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09self.trigger(\x27Error\x27, {\x0a\x09\x09\x09\x09\x09\x09code : plupload.INIT_ERROR,\x0a\x09\x09\x09\x09\x09\x09message : plupload.translate(\x27Init error.\x27)\x0a\x09\x09\x09\x09\x09});\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09});\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Set the value for the specified option(s).\x0a\x09\x09 *\x0a\x09\x09 * @method setOption\x0a\x09\x09 * @since 2.1\x0a\x09\x09 * @param {String|Object} option Name of the option to change or the set of key/value pairs\x0a\x09\x09 * @param {Mixed} [value] Value for the option (is ignored, if first argument is object)\x0a\x09\x09 */\x0a\x09\x09setOption: function(option, value) {\x0a\x09\x09\x09setOption.call(this, option, value, !this.runtime); // until runtime not set we do not need to reinitialize\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Get the value for the specified option or the whole configuration, if not specified.\x0a\x09\x09 * \x0a\x09\x09 * @method getOption\x0a\x09\x09 * @since 2.1\x0a\x09\x09 * @param {String} [option] Name of the option to get\x0a\x09\x09 * @return {Mixed} Value for the option or the whole set\x0a\x09\x09 */\x0a\x09\x09getOption: function(option) {\x0a\x09\x09\x09if (!option) {\x0a\x09\x09\x09\x09return settings;\x0a\x09\x09\x09}\x0a\x09\x09\x09return settings[option];\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Refreshes the upload instance by dispatching out a refresh event to all runtimes.\x0a\x09\x09 * This would for example reposition flash/silverlight shims on the page.\x0a\x09\x09 *\x0a\x09\x09 * @method refresh\x0a\x09\x09 */\x0a\x09\x09refresh : function() {\x0a\x09\x09\x09if (fileInputs.length) {\x0a\x09\x09\x09\x09plupload.each(fileInputs, function(fileInput) {\x0a\x09\x09\x09\x09\x09fileInput.trigger(\x27Refresh\x27);\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09}\x0a\x09\x09\x09this.trigger(\x27Refresh\x27);\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Starts uploading the queued files.\x0a\x09\x09 *\x0a\x09\x09 * @method start\x0a\x09\x09 */\x0a\x09\x09start : function() {\x0a\x09\x09\x09if (this.state != plupload.STARTED) {\x0a\x09\x09\x09\x09this.state = plupload.STARTED;\x0a\x09\x09\x09\x09this.trigger(\x27StateChanged\x27);\x0a\x0a\x09\x09\x09\x09uploadNext.call(this);\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Stops the upload of the queued files.\x0a\x09\x09 *\x0a\x09\x09 * @method stop\x0a\x09\x09 */\x0a\x09\x09stop : function() {\x0a\x09\x09\x09if (this.state != plupload.STOPPED) {\x0a\x09\x09\x09\x09this.state = plupload.STOPPED;\x0a\x09\x09\x09\x09this.trigger(\x27StateChanged\x27);\x0a\x09\x09\x09\x09this.trigger(\x27CancelUpload\x27);\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x0a\x09\x09/**\x0a\x09\x09 * Disables/enables browse button on request.\x0a\x09\x09 *\x0a\x09\x09 * @method disableBrowse\x0a\x09\x09 * @param {Boolean} disable Whether to disable or enable (default: true)\x0a\x09\x09 */\x0a\x09\x09disableBrowse : function() {\x0a\x09\x09\x09disabled = arguments[0] !== undef ? arguments[0] : true;\x0a\x0a\x09\x09\x09if (fileInputs.length) {\x0a\x09\x09\x09\x09plupload.each(fileInputs, function(fileInput) {\x0a\x09\x09\x09\x09\x09fileInput.disable(disabled);\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09this.trigger(\x27DisableBrowse\x27, disabled);\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Returns the specified file object by id.\x0a\x09\x09 *\x0a\x09\x09 * @method getFile\x0a\x09\x09 * @param {String} id File id to look for.\x0a\x09\x09 * @return {plupload.File} File object or undefined if it wasn\x27t found;\x0a\x09\x09 */\x0a\x09\x09getFile : function(id) {\x0a\x09\x09\x09var i;\x0a\x09\x09\x09for (i = files.length - 1; i \x3e= 0; i--) {\x0a\x09\x09\x09\x09if (files[i].id === id) {\x0a\x09\x09\x09\x09\x09return files[i];\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Adds file to the queue programmatically. Can be native file, instance of Plupload.File,\x0a\x09\x09 * instance of mOxie.File, input[type=\x22file\x22] element, or array of these. Fires FilesAdded, \x0a\x09\x09 * if any files were added to the queue. Otherwise nothing happens.\x0a\x09\x09 *\x0a\x09\x09 * @method addFile\x0a\x09\x09 * @since 2.0\x0a\x09\x09 * @param {plupload.File|mOxie.File|File|Node|Array} file File or files to add to the queue.\x0a\x09\x09 * @param {String} [fileName] If specified, will be used as a name for the file\x0a\x09\x09 */\x0a\x09\x09addFile : function(file, fileName) {\x0a\x09\x09\x09var self = this\x0a\x09\x09\x09, queue = [] \x0a\x09\x09\x09, filesAdded = []\x0a\x09\x09\x09, ruid\x0a\x09\x09\x09;\x0a\x0a\x09\x09\x09function filterFile(file, cb) {\x0a\x09\x09\x09\x09var queue = [];\x0a\x09\x09\x09\x09o.each(self.settings.filters, function(rule, name) {\x0a\x09\x09\x09\x09\x09if (fileFilters[name]) {\x0a\x09\x09\x09\x09\x09\x09queue.push(function(cb) {\x0a\x09\x09\x09\x09\x09\x09\x09fileFilters[name].call(self, rule, file, function(res) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09cb(!res);\x0a\x09\x09\x09\x09\x09\x09\x09});\x0a\x09\x09\x09\x09\x09\x09});\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09\x09o.inSeries(queue, cb);\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * @method resolveFile\x0a\x09\x09\x09 * @private\x0a\x09\x09\x09 * @param {o.File|o.Blob|plupload.File|File|Blob|input[type=\x22file\x22]} file\x0a\x09\x09\x09 */\x0a\x09\x09\x09function resolveFile(file) {\x0a\x09\x09\x09\x09var type = o.typeOf(file);\x0a\x0a\x09\x09\x09\x09// o.File\x0a\x09\x09\x09\x09if (file instanceof o.File) { \x0a\x09\x09\x09\x09\x09if (!file.ruid && !file.isDetached()) {\x0a\x09\x09\x09\x09\x09\x09if (!ruid) { // weird case\x0a\x09\x09\x09\x09\x09\x09\x09return false;\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09file.ruid = ruid;\x0a\x09\x09\x09\x09\x09\x09file.connectRuntime(ruid);\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09resolveFile(new plupload.File(file));\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09// o.Blob \x0a\x09\x09\x09\x09else if (file instanceof o.Blob) {\x0a\x09\x09\x09\x09\x09resolveFile(file.getSource());\x0a\x09\x09\x09\x09\x09file.destroy();\x0a\x09\x09\x09\x09} \x0a\x09\x09\x09\x09// plupload.File - final step for other branches\x0a\x09\x09\x09\x09else if (file instanceof plupload.File) {\x0a\x09\x09\x09\x09\x09if (fileName) {\x0a\x09\x09\x09\x09\x09\x09file.name = fileName;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x0a\x09\x09\x09\x09\x09queue.push(function(cb) {\x0a\x09\x09\x09\x09\x09\x09// run through the internal and user-defined filters, if any\x0a\x09\x09\x09\x09\x09\x09filterFile(file, function(err) {\x0a\x09\x09\x09\x09\x09\x09\x09if (!err) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09// make files available for the filters by updating the main queue directly\x0a\x09\x09\x09\x09\x09\x09\x09\x09files.push(file);\x0a\x09\x09\x09\x09\x09\x09\x09\x09// collect the files that will be passed to FilesAdded event\x0a\x09\x09\x09\x09\x09\x09\x09\x09filesAdded.push(file); \x0a\x0a\x09\x09\x09\x09\x09\x09\x09\x09self.trigger(\x22FileFiltered\x22, file);\x0a\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09\x09delay(cb, 1); // do not build up recursions or eventually we might hit the limits\x0a\x09\x09\x09\x09\x09\x09});\x0a\x09\x09\x09\x09\x09});\x0a\x09\x09\x09\x09} \x0a\x09\x09\x09\x09// native File or blob\x0a\x09\x09\x09\x09else if (o.inArray(type, [\x27file\x27, \x27blob\x27]) !== -1) {\x0a\x09\x09\x09\x09\x09resolveFile(new o.File(null, file));\x0a\x09\x09\x09\x09} \x0a\x09\x09\x09\x09// input[type=\x22file\x22]\x0a\x09\x09\x09\x09else if (type === \x27node\x27 && o.typeOf(file.files) === \x27filelist\x27) {\x0a\x09\x09\x09\x09\x09// if we are dealing with input[type=\x22file\x22]\x0a\x09\x09\x09\x09\x09o.each(file.files, resolveFile);\x0a\x09\x09\x09\x09} \x0a\x09\x09\x09\x09// mixed array of any supported types (see above)\x0a\x09\x09\x09\x09else if (type === \x27array\x27) {\x0a\x09\x09\x09\x09\x09fileName = null; // should never happen, but unset anyway to avoid funny situations\x0a\x09\x09\x09\x09\x09o.each(file, resolveFile);\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09ruid = getRUID();\x0a\x09\x09\x09\x0a\x09\x09\x09resolveFile(file);\x0a\x0a\x09\x09\x09if (queue.length) {\x0a\x09\x09\x09\x09o.inSeries(queue, function() {\x0a\x09\x09\x09\x09\x09// if any files left after filtration, trigger FilesAdded\x0a\x09\x09\x09\x09\x09if (filesAdded.length) {\x0a\x09\x09\x09\x09\x09\x09self.trigger(\x22FilesAdded\x22, filesAdded);\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Removes a specific file.\x0a\x09\x09 *\x0a\x09\x09 * @method removeFile\x0a\x09\x09 * @param {plupload.File|String} file File to remove from queue.\x0a\x09\x09 */\x0a\x09\x09removeFile : function(file) {\x0a\x09\x09\x09var id = typeof(file) === \x27string\x27 ? file : file.id;\x0a\x0a\x09\x09\x09for (var i = files.length - 1; i \x3e= 0; i--) {\x0a\x09\x09\x09\x09if (files[i].id === id) {\x0a\x09\x09\x09\x09\x09return this.splice(i, 1)[0];\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Removes part of the queue and returns the files removed. This will also trigger the FilesRemoved and QueueChanged events.\x0a\x09\x09 *\x0a\x09\x09 * @method splice\x0a\x09\x09 * @param {Number} start (Optional) Start index to remove from.\x0a\x09\x09 * @param {Number} length (Optional) Lengh of items to remove.\x0a\x09\x09 * @return {Array} Array of files that was removed.\x0a\x09\x09 */\x0a\x09\x09splice : function(start, length) {\x0a\x09\x09\x09// Splice and trigger events\x0a\x09\x09\x09var removed = files.splice(start === undef ? 0 : start, length === undef ? files.length : length);\x0a\x0a\x09\x09\x09// if upload is in progress we need to stop it and restart after files are removed\x0a\x09\x09\x09var restartRequired = false;\x0a\x09\x09\x09if (this.state == plupload.STARTED) { // upload in progress\x0a\x09\x09\x09\x09plupload.each(removed, function(file) {\x0a\x09\x09\x09\x09\x09if (file.status === plupload.UPLOADING) {\x0a\x09\x09\x09\x09\x09\x09restartRequired = true; // do not restart, unless file that is being removed is uploading\x0a\x09\x09\x09\x09\x09\x09return false;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09\x09\x0a\x09\x09\x09\x09if (restartRequired) {\x0a\x09\x09\x09\x09\x09this.stop();\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09this.trigger(\x22FilesRemoved\x22, removed);\x0a\x0a\x09\x09\x09// Dispose any resources allocated by those files\x0a\x09\x09\x09plupload.each(removed, function(file) {\x0a\x09\x09\x09\x09file.destroy();\x0a\x09\x09\x09});\x0a\x09\x09\x09\x0a\x09\x09\x09if (restartRequired) {\x0a\x09\x09\x09\x09this.start();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09return removed;\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09Dispatches the specified event name and its arguments to all listeners.\x0a\x0a\x09\x09@method trigger\x0a\x09\x09@param {String} name Event name to fire.\x0a\x09\x09@param {Object..} Multiple arguments to pass along to the listener functions.\x0a\x09\x09*/\x0a\x0a\x09\x09// override the parent method to match Plupload-like event logic\x0a\x09\x09dispatchEvent: function(type) {\x0a\x09\x09\x09var list, args, result;\x0a\x09\x09\x09\x09\x09\x09\x0a\x09\x09\x09type = type.toLowerCase();\x0a\x09\x09\x09\x09\x09\x09\x09\x0a\x09\x09\x09list = this.hasEventListener(type);\x0a\x0a\x09\x09\x09if (list) {\x0a\x09\x09\x09\x09// sort event list by priority\x0a\x09\x09\x09\x09list.sort(function(a, b) { return b.priority - a.priority; });\x0a\x09\x09\x09\x09\x0a\x09\x09\x09\x09// first argument should be current plupload.Uploader instance\x0a\x09\x09\x09\x09args = [].slice.call(arguments);\x0a\x09\x09\x09\x09args.shift();\x0a\x09\x09\x09\x09args.unshift(this);\x0a\x0a\x09\x09\x09\x09for (var i = 0; i \x3c list.length; i++) {\x0a\x09\x09\x09\x09\x09// Fire event, break chain if false is returned\x0a\x09\x09\x09\x09\x09if (list[i].fn.apply(list[i].scope, args) === false) {\x0a\x09\x09\x09\x09\x09\x09return false;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x09\x09\x09return true;\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09Check whether uploader has any listeners to the specified event.\x0a\x0a\x09\x09@method hasEventListener\x0a\x09\x09@param {String} name Event name to check for.\x0a\x09\x09*/\x0a\x0a\x0a\x09\x09/**\x0a\x09\x09Adds an event listener by name.\x0a\x0a\x09\x09@method bind\x0a\x09\x09@param {String} name Event name to listen for.\x0a\x09\x09@param {function} fn Function to call ones the event gets fired.\x0a\x09\x09@param {Object} [scope] Optional scope to execute the specified function in.\x0a\x09\x09@param {Number} [priority=0] Priority of the event handler - handlers with higher priorities will be called first\x0a\x09\x09*/\x0a\x09\x09bind: function(name, fn, scope, priority) {\x0a\x09\x09\x09// adapt moxie EventTarget style to Plupload-like\x0a\x09\x09\x09plupload.Uploader.prototype.bind.call(this, name, fn, priority, scope);\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09Removes the specified event listener.\x0a\x0a\x09\x09@method unbind\x0a\x09\x09@param {String} name Name of event to remove.\x0a\x09\x09@param {function} fn Function to remove from listener.\x0a\x09\x09*/\x0a\x0a\x09\x09/**\x0a\x09\x09Removes all event listeners.\x0a\x0a\x09\x09@method unbindAll\x0a\x09\x09*/\x0a\x0a\x0a\x09\x09/**\x0a\x09\x09 * Destroys Plupload instance and cleans after itself.\x0a\x09\x09 *\x0a\x09\x09 * @method destroy\x0a\x09\x09 */\x0a\x09\x09destroy : function() {\x0a\x09\x09\x09this.trigger(\x27Destroy\x27);\x0a\x09\x09\x09settings = total = null; // purge these exclusively\x0a\x09\x09\x09this.unbindAll();\x0a\x09\x09}\x0a\x09});\x0a};\x0a\x0aplupload.Uploader.prototype = o.EventTarget.instance;\x0a\x0a/**\x0a * Constructs a new file instance.\x0a *\x0a * @class File\x0a * @constructor\x0a * \x0a * @param {Object} file Object containing file properties\x0a * @param {String} file.name Name of the file.\x0a * @param {Number} file.size File size.\x0a */\x0aplupload.File = (function() {\x0a\x09var filepool = {};\x0a\x0a\x09function PluploadFile(file) {\x0a\x0a\x09\x09plupload.extend(this, {\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * File id this is a globally unique id for the specific file.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @property id\x0a\x09\x09\x09 * @type String\x0a\x09\x09\x09 */\x0a\x09\x09\x09id: plupload.guid(),\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * File name for example \x22myfile.gif\x22.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @property name\x0a\x09\x09\x09 * @type String\x0a\x09\x09\x09 */\x0a\x09\x09\x09name: file.name || file.fileName,\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * File type, `e.g image/jpeg`\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @property type\x0a\x09\x09\x09 * @type String\x0a\x09\x09\x09 */\x0a\x09\x09\x09type: file.type || \x27\x27,\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * File size in bytes (may change after client-side manupilation).\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @property size\x0a\x09\x09\x09 * @type Number\x0a\x09\x09\x09 */\x0a\x09\x09\x09size: file.size || file.fileSize,\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Original file size in bytes.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @property origSize\x0a\x09\x09\x09 * @type Number\x0a\x09\x09\x09 */\x0a\x09\x09\x09origSize: file.size || file.fileSize,\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Number of bytes uploaded of the files total size.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @property loaded\x0a\x09\x09\x09 * @type Number\x0a\x09\x09\x09 */\x0a\x09\x09\x09loaded: 0,\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Number of percentage uploaded of the file.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @property percent\x0a\x09\x09\x09 * @type Number\x0a\x09\x09\x09 */\x0a\x09\x09\x09percent: 0,\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Status constant matching the plupload states QUEUED, UPLOADING, FAILED, DONE.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @property status\x0a\x09\x09\x09 * @type Number\x0a\x09\x09\x09 * @see plupload\x0a\x09\x09\x09 */\x0a\x09\x09\x09status: plupload.QUEUED,\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Date of last modification.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @property lastModifiedDate\x0a\x09\x09\x09 * @type {String}\x0a\x09\x09\x09 */\x0a\x09\x09\x09lastModifiedDate: file.lastModifiedDate || (new Date()).toLocaleString(), // Thu Aug 23 2012 19:40:00 GMT+0400 (GET)\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Returns native window.File object, when it\x27s available.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @method getNative\x0a\x09\x09\x09 * @return {window.File} or null, if plupload.File is of different origin\x0a\x09\x09\x09 */\x0a\x09\x09\x09getNative: function() {\x0a\x09\x09\x09\x09var file = this.getSource().getSource();\x0a\x09\x09\x09\x09return o.inArray(o.typeOf(file), [\x27blob\x27, \x27file\x27]) !== -1 ? file : null;\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Returns mOxie.File - unified wrapper object that can be used across runtimes.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @method getSource\x0a\x09\x09\x09 * @return {mOxie.File} or null\x0a\x09\x09\x09 */\x0a\x09\x09\x09getSource: function() {\x0a\x09\x09\x09\x09if (!filepool[this.id]) {\x0a\x09\x09\x09\x09\x09return null;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09return filepool[this.id];\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Destroys plupload.File object.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @method destroy\x0a\x09\x09\x09 */\x0a\x09\x09\x09destroy: function() {\x0a\x09\x09\x09\x09var src = this.getSource();\x0a\x09\x09\x09\x09if (src) {\x0a\x09\x09\x09\x09\x09src.destroy();\x0a\x09\x09\x09\x09\x09delete filepool[this.id];\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x09\x09});\x0a\x0a\x09\x09filepool[this.id] = file;\x0a\x09}\x0a\x0a\x09return PluploadFile;\x0a}());\x0a\x0a\x0a/**\x0a * Constructs a queue progress.\x0a *\x0a * @class QueueProgress\x0a * @constructor\x0a */\x0a plupload.QueueProgress = function() {\x0a\x09var self = this; // Setup alias for self to reduce code size when it\x27s compressed\x0a\x0a\x09/**\x0a\x09 * Total queue file size.\x0a\x09 *\x0a\x09 * @property size\x0a\x09 * @type Number\x0a\x09 */\x0a\x09self.size = 0;\x0a\x0a\x09/**\x0a\x09 * Total bytes uploaded.\x0a\x09 *\x0a\x09 * @property loaded\x0a\x09 * @type Number\x0a\x09 */\x0a\x09self.loaded = 0;\x0a\x0a\x09/**\x0a\x09 * Number of files uploaded.\x0a\x09 *\x0a\x09 * @property uploaded\x0a\x09 * @type Number\x0a\x09 */\x0a\x09self.uploaded = 0;\x0a\x0a\x09/**\x0a\x09 * Number of files failed to upload.\x0a\x09 *\x0a\x09 * @property failed\x0a\x09 * @type Number\x0a\x09 */\x0a\x09self.failed = 0;\x0a\x0a\x09/**\x0a\x09 * Number of files yet to be uploaded.\x0a\x09 *\x0a\x09 * @property queued\x0a\x09 * @type Number\x0a\x09 */\x0a\x09self.queued = 0;\x0a\x0a\x09/**\x0a\x09 * Total percent of the uploaded bytes.\x0a\x09 *\x0a\x09 * @property percent\x0a\x09 * @type Number\x0a\x09 */\x0a\x09self.percent = 0;\x0a\x0a\x09/**\x0a\x09 * Bytes uploaded per second.\x0a\x09 *\x0a\x09 * @property bytesPerSec\x0a\x09 * @type Number\x0a\x09 */\x0a\x09self.bytesPerSec = 0;\x0a\x0a\x09/**\x0a\x09 * Resets the progress to its initial values.\x0a\x09 *\x0a\x09 * @method reset\x0a\x09 */\x0a\x09self.reset = function() {\x0a\x09\x09self.size = self.loaded = self.uploaded = self.failed = self.queued = self.percent = self.bytesPerSec = 0;\x0a\x09};\x0a};\x0a\x0awindow.plupload = plupload;\x0a\x0a}(window, mOxie));\x0a)}});a.e!'}