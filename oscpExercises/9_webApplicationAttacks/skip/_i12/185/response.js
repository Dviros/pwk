var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:04:16 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Fri, 09 Mar 2018 17:27:31 GMT\x0aETag: \x2294f4-566fe1b66c6c0-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-9430/9431\x0aContent-Length: 9431\x0aKeep-Alive: timeout=5, max=13\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/*\x0a * imgAreaSelect jQuery plugin\x0a * version 0.9.10-monkey\x0a *\x0a * Copyright (c) 2008-2013 Michal Wojciechowski (odyniec.net)\x0a *\x0a * Dual licensed under the MIT (MIT-LICENSE.txt)\x0a * and GPL (GPL-LICENSE.txt) licenses.\x0a *\x0a * http://odyniec.net/projects/imgareaselect/\x0a *\x0a */\x0a\x0a(function($) {\x0a\x0a/*\x0a * Math functions will be used extensively, so it\x27s convenient to make a few\x0a * shortcuts\x0a */\x0avar abs = Math.abs,\x0a    max = Math.max,\x0a    min = Math.min,\x0a    round = Math.round;\x0a\x0a/**\x0a * Create a new HTML div element\x0a *\x0a * @return A jQuery object representing the new element\x0a */\x0afunction div() {\x0a    return $(\x27\x3cdiv/\x3e\x27);\x0a}\x0a\x0a/**\x0a * imgAreaSelect initialization\x0a *\x0a * @param img\x0a *            A HTML image element to attach the plugin to\x0a * @param options\x0a *            An options object\x0a */\x0a$.imgAreaSelect = function (img, options) {\x0a    var\x0a        /* jQuery object representing the image */\x0a        $img = $(img),\x0a\x0a        /* Has the image finished loading? */\x0a        imgLoaded,\x0a\x0a        /* Plugin elements */\x0a\x0a        /* Container box */\x0a        $box = div(),\x0a        /* Selection area */\x0a        $area = div(),\x0a        /* Border (four divs) */\x0a        $border = div().add(div()).add(div()).add(div()),\x0a        /* Outer area (four divs) */\x0a        $outer = div().add(div()).add(div()).add(div()),\x0a        /* Handles (empty by default, initialized in setOptions()) */\x0a        $handles = $([]),\x0a\x0a        /*\x0a         * Additional element to work around a cursor problem in Opera\x0a         * (explained later)\x0a         */\x0a        $areaOpera,\x0a\x0a        /* Image position (relative to viewport) */\x0a        left, top,\x0a\x0a        /* Image offset (as returned by .offset()) */\x0a        imgOfs = { left: 0, top: 0 },\x0a\x0a        /* Image dimensions (as returned by .width() and .height()) */\x0a        imgWidth, imgHeight,\x0a\x0a        /*\x0a         * jQuery object representing the parent element that the plugin\x0a         * elements are appended to\x0a         */\x0a        $parent,\x0a\x0a        /* Parent element offset (as returned by .offset()) */\x0a        parOfs = { left: 0, top: 0 },\x0a\x0a        /* Base z-index for plugin elements */\x0a        zIndex = 0,\x0a\x0a        /* Plugin elements position */\x0a        position = \x27absolute\x27,\x0a\x0a        /* X/Y coordinates of the starting point for move/resize operations */\x0a        startX, startY,\x0a\x0a        /* Horizontal and vertical scaling factors */\x0a        scaleX, scaleY,\x0a\x0a        /* Current resize mode (\x22nw\x22, \x22se\x22, etc.) */\x0a        resize,\x0a\x0a        /* Selection area constraints */\x0a        minWidth, minHeight, maxWidth, maxHeight,\x0a\x0a        /* Aspect ratio to maintain (floating point number) */\x0a        aspectRatio,\x0a\x0a        /* Are the plugin elements currently displayed? */\x0a        shown,\x0a\x0a        /* Current selection (relative to parent element) */\x0a        x1, y1, x2, y2,\x0a\x0a        /* Current selection (relative to scaled image) */\x0a        selection = { x1: 0, y1: 0, x2: 0, y2: 0, width: 0, height: 0 },\x0a\x0a        /* Document element */\x0a        docElem = document.documentElement,\x0a\x0a        /* User agent */\x0a        ua = navigator.userAgent,\x0a\x0a        /* Various helper variables used throughout the code */\x0a        $p, d, i, o, w, h, adjusted;\x0a\x0a    /*\x0a     * Translate selection coordinates (relative to scaled image) to viewport\x0a     * coordinates (relative to parent element)\x0a     */\x0a\x0a    /**\x0a     * Translate selection X to viewport X\x0a     *\x0a     * @param x\x0a     *            Selection X\x0a     * @return Viewport X\x0a     */\x0a    function viewX(x) {\x0a        return x + imgOfs.left - parOfs.left;\x0a    }\x0a\x0a    /**\x0a     * Translate selection Y to viewport Y\x0a     *\x0a     * @param y\x0a     *            Selection Y\x0a     * @return Viewport Y\x0a     */\x0a    function viewY(y) {\x0a        return y + imgOfs.top - parOfs.top;\x0a    }\x0a\x0a    /*\x0a     * Translate viewport coordinates to selection coordinates\x0a     */\x0a\x0a    /**\x0a     * Translate viewport X to selection X\x0a     *\x0a     * @param x\x0a     *            Viewport X\x0a     * @return Selection X\x0a     */\x0a    function selX(x) {\x0a        return x - imgOfs.left + parOfs.left;\x0a    }\x0a\x0a    /**\x0a     * Translate viewport Y to selection Y\x0a     *\x0a     * @param y\x0a     *            Viewport Y\x0a     * @return Selection Y\x0a     */\x0a    function selY(y) {\x0a        return y - imgOfs.top + parOfs.top;\x0a    }\x0a\x0a    /*\x0a     * Translate event coordinates (relative to document) to viewport\x0a     * coordinates\x0a     */\x0a\x0a    /**\x0a     * Get event X and translate it to viewport X\x0a     *\x0a     * @param event\x0a     *            The event object\x0a     * @return Viewport X\x0a     */\x0a    function evX(event) {\x0a        return max(event.pageX || 0, touchCoords(event).x) - parOfs.left;\x0a    }\x0a\x0a    /**\x0a     * Get event Y and translate it to viewport Y\x0a     *\x0a     * @param event\x0a     *            The event object\x0a     * @return Viewport Y\x0a     */\x0a    function evY(event) {\x0a        return max(event.pageY || 0, touchCoords(event).y) - parOfs.top;\x0a    }\x0a\x0a    /**\x0a     * Get X and Y coordinates of a touch event\x0a     *\x0a     * @param event\x0a     *            The event object\x0a     * @return Coordinates object\x0a     */\x0a    function touchCoords(event) {\x0a        var oev = event.originalEvent || {};\x0a\x0a        if (oev.touches && oev.touches.length)\x0a            return { x: oev.touches[0].pageX, y: oev.touches[0].pageY };\x0a        else\x0a            return { x: 0, y: 0 };\x0a    }\x0a\x0a    /**\x0a     * Get the current selection\x0a     *\x0a     * @param noScale\x0a     *            If set to \x3ccode\x3etrue\x3c/code\x3e, scaling is not applied to the\x0a     *            returned selection\x0a     * @return Selection object\x0a     */\x0a    function getSelection(noScale) {\x0a        var sx = noScale || scaleX, sy = noScale || scaleY;\x0a\x0a        return { x1: round(selection.x1 * sx),\x0a            y1: round(selection.y1 * sy),\x0a            x2: round(selection.x2 * sx),\x0a            y2: round(selection.y2 * sy),\x0a            width: round(selection.x2 * sx) - round(selection.x1 * sx),\x0a            height: round(selection.y2 * sy) - round(selection.y1 * sy) };\x0a    }\x0a\x0a    /**\x0a     * Set the current selection\x0a     *\x0a     * @param x1\x0a     *            X coordinate of the upper left corner of the selection area\x0a     * @param y1\x0a     *            Y coordinate of the upper left corner of the selection area\x0a     * @param x2\x0a     *            X coordinate of the lower right corner of the selection area\x0a     * @param y2\x0a     *            Y coordinate of the lower right corner of the selection area\x0a     * @param noScale\x0a     *            If set to \x3ccode\x3etrue\x3c/code\x3e, scaling is not applied to the\x0a     *            new selection\x0a     */\x0a    function setSelection(x1, y1, x2, y2, noScale) {\x0a        var sx = noScale || scaleX, sy = noScale || scaleY;\x0a\x0a        selection = {\x0a            x1: round(x1 / sx || 0),\x0a            y1: round(y1 / sy || 0),\x0a            x2: round(x2 / sx || 0),\x0a            y2: round(y2 / sy || 0)\x0a        };\x0a\x0a        selection.width = selection.x2 - selection.x1;\x0a        selection.height = selection.y2 - selection.y1;\x0a    }\x0a\x0a    /**\x0a     * Recalculate image and parent offsets\x0a     */\x0a    function adjust() {\x0a        /*\x0a         * Do not adjust if image has not yet loaded or if width is not a\x0a         * positive number. The latter might happen when imgAreaSelect is put\x0a         * on a parent element which is then hidden.\x0a         */\x0a        if (!imgLoaded || !$img.width())\x0a            return;\x0a\x0a        /*\x0a         * Get image offset. The .offset() method returns float values, so they\x0a         * need to be rounded.\x0a         */\x0a        imgOfs = { left: round($img.offset().left), top: round($img.offset().top) };\x0a\x0a        /* Get image dimensions */\x0a        imgWidth = $img.innerWidth();\x0a        imgHeight = $img.innerHeight();\x0a\x0a        imgOfs.top += ($img.outerHeight() - imgHeight) \x3e\x3e 1;\x0a        imgOfs.left += ($img.outerWidth() - imgWidth) \x3e\x3e 1;\x0a\x0a        /* Set minimum and maximum selection area dimensions */\x0a        minWidth = round(options.minWidth / scaleX) || 0;\x0a        minHeight = round(options.minHeight / scaleY) || 0;\x0a        maxWidth = round(min(options.maxWidth / scaleX || 1\x3c\x3c24, imgWidth));\x0a        maxHeight = round(min(options.maxHeight / scaleY || 1\x3c\x3c24, imgHeight));\x0a\x0a        /*\x0a         * Workaround for jQuery 1.3.2 incorrect offset calculation, originally\x0a         * observed in Safari 3. Firefox 2 is also affected.\x0a         */\x0a        if ($().jquery == \x271.3.2\x27 && position == \x27fixed\x27 &&\x0a            !docElem[\x27getBoundingClientRect\x27])\x0a        {\x0a            imgOfs.top += max(document.body.scrollTop, docElem.scrollTop);\x0a            imgOfs.left += max(document.body.scrollLeft, docElem.scrollLeft);\x0a        }\x0a\x0a        /* Determine parent element offset */\x0a        parOfs = /absolute|relative/.test($parent.css(\x27position\x27)) ?\x0a            { left: round($parent.offset().left) - $parent.scrollLeft(),\x0a                top: round($parent.offset().top) - $parent.scrollTop() } :\x0a            position == \x27fixed\x27 ?\x0a                { left: $(document).scrollLeft(), top: $(document).scrollTop() } :\x0a                { left: 0, top: 0 };\x0a\x0a        left = viewX(0);\x0a        top = viewY(0);\x0a\x0a        /*\x0a         * Check if selection area is within image boundaries, adjust if\x0a         * necessary\x0a         */\x0a        if (selection.x2 \x3e imgWidth || selection.y2 \x3e imgHeight)\x0a            doResize();\x0a    }\x0a\x0a    /**\x0a     * Update plugin elements\x0a     *\x0a     * @param resetKeyPress\x0a     *            If set to \x3ccode\x3efalse\x3c/code\x3e, this instance\x27s keypress\x0a     *            event handler is not activated\x0a     */\x0a    function update(resetKeyPress) {\x0a        /* If plugin elements are hidden, do nothing */\x0a        if (!shown) return;\x0a\x0a        /*\x0a         * Set the position and size of the container box and the selection area\x0a         * inside it\x0a         */\x0a        $box.css({ left: viewX(selection.x1), top: viewY(selection.y1) })\x0a            .add($area).width(w = selection.width).height(h = selection.height);\x0a\x0a        /*\x0a         * Reset the position of selection area, borders, and handles (IE6/IE7\x0a         * position them incorrectly if we don\x27t do this)\x0a         */\x0a        $area.add($border).add($handles).css({ left: 0, top: 0 });\x0a\x0a        /* Set border dimensions */\x0a        $border\x0a            .width(max(w - $border.outerWidth() + $border.innerWidth(), 0))\x0a            .height(max(h - $border.outerHeight() + $border.innerHeight(), 0));\x0a\x0a        /* Arrange the outer area elements */\x0a        $($outer[0]).css({ left: left, top: top,\x0a            width: selection.x1, height: imgHeight });\x0a        $($outer[1]).css({ left: left + selection.x1, top: top,\x0a            width: w, height: selection.y1 });\x0a        $($outer[2]).css({ left: left + selection.x2, top: top,\x0a            width: imgWidth - selection.x2, height: imgHeight });\x0a        $($outer[3]).css({ left: left + selection.x1, top: top + selection.y2,\x0a            width: w, height: imgHeight - selection.y2 });\x0a\x0a        w -= $handles.outerWidth();\x0a        h -= $handles.outerHeight();\x0a\x0a        /* Arrange handles */\x0a        switch ($handles.length) {\x0a        case 8:\x0a            $($handles[4]).css({ left: w \x3e\x3e 1 });\x0a            $($handles[5]).css({ left: w, top: h \x3e\x3e 1 });\x0a            $($handles[6]).css({ left: w \x3e\x3e 1, top: h });\x0a            $($handles[7]).css({ top: h \x3e\x3e 1 });\x0a        case 4:\x0a            $handles.slice(1,3).css({ left: w });\x0a            $handles.slice(2,4).css({ top: h });\x0a        }\x0a\x0a        if (resetKeyPress !== false) {\x0a            /*\x0a             * Need to reset the document keypress event handler -- unbind the\x0a             * current handler\x0a             */\x0a            if ($.imgAreaSelect.onKeyPress != docKeyPress)\x0a                $(document).unbind($.imgAreaSelect.keyPress,\x0a                    $.imgAreaSelect.onKeyPress);\x0a\x0a            if (options.keys)\x0a                /*\x0a                 * Set the document keypress event handler to this instance\x27s\x0a                 * docKeyPress() function\x0a                 */\x0a                $(document)[$.imgAreaSelect.keyPress](\x0a                    $.imgAreaSelect.onKeyPress = docKeyPress);\x0a        }\x0a\x0a        /*\x0a         * Internet Explorer displays 1px-wide dashed borders incorrectly by\x0a         * filling the spaces between dashes with white. Toggling the margin\x0a         * property between 0 and \x22auto\x22 fixes this in IE6 and IE7 (IE8 is still\x0a         * broken). This workaround is not perfect, as it requires setTimeout()\x0a         * and thus causes the border to flicker a bit, but I haven\x27t found a\x0a         * better solution.\x0a         *\x0a         * Note: This only happens with CSS borders, set with the borderWidth,\x0a         * borderOpacity, borderColor1, and borderColor2 options (which are now\x0a         * deprecated). Borders created with GIF background images are fine.\x0a         */\x0a        if (msie && $border.outerWidth() - $border.innerWidth() == 2) {\x0a            $border.css(\x27margin\x27, 0);\x0a            setTimeout(function () { $border.css(\x27margin\x27, \x27auto\x27); }, 0);\x0a        }\x0a    }\x0a\x0a    /**\x0a     * Do the complete update sequence: recalculate offsets, update the\x0a     * elements, and set the correct values of x1, y1, x2, and y2.\x0a     *\x0a     * @param resetKeyPress\x0a     *            If set to \x3ccode\x3efalse\x3c/code\x3e, this instance\x27s keypress\x0a     *            event handler is not activated\x0a     */\x0a    function doUpdate(resetKeyPress) {\x0a        adjust();\x0a        update(resetKeyPress);\x0a        x1 = viewX(selection.x1); y1 = viewY(selection.y1);\x0a        x2 = viewX(selection.x2); y2 = viewY(selection.y2);\x0a    }\x0a\x0a    /**\x0a     * Hide or fade out an element (or multiple elements)\x0a     *\x0a     * @param $elem\x0a     *            A jQuery object containing the element(s) to hide/fade out\x0a     * @param fn\x0a     *            Callback function to be called when fadeOut() completes\x0a     */\x0a    function hide($elem, fn) {\x0a        options.fadeSpeed ? $elem.fadeOut(options.fadeSpeed, fn) : $elem.hide();\x0a    }\x0a\x0a    /**\x0a     * Selection area mousemove event handler\x0a     *\x0a     * @param event\x0a     *            The event object\x0a     */\x0a    function areaMouseMove(event) {\x0a        var x = selX(evX(event)) - selection.x1,\x0a            y = selY(evY(event)) - selection.y1;\x0a\x0a        if (!adjusted) {\x0a            adjust();\x0a            adjusted = true;\x0a\x0a            $box.one(\x27mouseout\x27, function () { adjusted = false; });\x0a        }\x0a\x0a        /* Clear the resize mode */\x0a        resize = \x27\x27;\x0a\x0a        if (options.resizable) {\x0a            /*\x0a             * Check if the mouse pointer is over the resize margin area and set\x0a             * the resize mode accordingly\x0a             */\x0a            if (y \x3c= options.resizeMargin)\x0a                resize = \x27n\x27;\x0a            else if (y \x3e= selection.height - options.resizeMargin)\x0a                resize = \x27s\x27;\x0a            if (x \x3c= options.resizeMargin)\x0a                resize += \x27w\x27;\x0a            else if (x \x3e= selection.width - options.resizeMargin)\x0a                resize += \x27e\x27;\x0a        }\x0a\x0a        $box.css(\x27cursor\x27, resize ? resize + \x27-resize\x27 :\x0a            options.movable ? \x27move\x27 : \x27\x27);\x0a        if ($areaOpera)\x0a            $areaOpera.toggle();\x0a    }\x0a\x0a    /**\x0a     * Document mouseup event handler\x0a     *\x0a     * @param event\x0a     *            The event object\x0a     */\x0a    function docMouseUp(event) {\x0a        /* Set back the default cursor */\x0a        $(\x27body\x27).css(\x27cursor\x27, \x27\x27);\x0a        /*\x0a         * If autoHide is enabled, or if the selection has zero width/height,\x0a         * hide the selection and the outer area\x0a         */\x0a        if (options.autoHide || selection.width * selection.height == 0)\x0a            hide($box.add($outer), function () { $(this).hide(); });\x0a\x0a        $(document).off(\x27mousemove touchmove\x27, selectingMouseMove);\x0a        $box.on(\x27mousemove touchmove\x27, areaMouseMove);\x0a\x0a        options.onSelectEnd(img, getSelection());\x0a    }\x0a\x0a    /**\x0a     * Selection area mousedown event handler\x0a     *\x0a     * @param event\x0a     *            The event object\x0a     * @return false\x0a     */\x0a    function areaMouseDown(event) {\x0a        if (event.type == \x27mousedown\x27 && event.which != 1) return false;\x0a\x0a    \x09/*\x0a    \x09 * With mobile browsers, there is no \x22moving the pointer over\x22 action,\x0a    \x09 * so we need to simulate one mousemove event happening prior to\x0a    \x09 * mousedown/touchstart.\x0a    \x09 */\x0a    \x09areaMouseMove(event);\x0a\x0a        adjust();\x0a\x0a        if (resize) {\x0a            /* Resize mode is in effect */\x0a            $(\x27body\x27).css(\x27cursor\x27, resize + \x27-resize\x27);\x0a\x0a            x1 = viewX(selection[/w/.test(resize) ? \x27x2\x27 : \x27x1\x27]);\x0a            y1 = viewY(selection[/n/.test(resize) ? \x27y2\x27 : \x27y1\x27]);\x0a\x0a            $(document).on(\x27mousemove touchmove\x27, selectingMouseMove)\x0a                .one(\x27mouseup touchend\x27, docMouseUp);\x0a            $box.off(\x27mousemove touchmove\x27, areaMouseMove);\x0a        }\x0a        else if (options.movable) {\x0a            startX = left + selection.x1 - evX(event);\x0a            startY = top + selection.y1 - evY(event);\x0a\x0a            $box.off(\x27mousemove touchmove\x27, areaMouseMove);\x0a\x0a            $(document).on(\x27mousemove touchmove\x27, movingMouseMove)\x0a                .one(\x27mouseup touchend\x27, function () {\x0a                    options.onSelectEnd(img, getSelection());\x0a\x0a                    $(document).off(\x27mousemove touchmove\x27, movingMouseMove);\x0a                    $box.on(\x27mousemove touchmove\x27, areaMouseMove);\x0a                });\x0a        }\x0a        else\x0a            $img.mousedown(event);\x0a\x0a        return false;\x0a    }\x0a\x0a    /**\x0a     * Adjust the x2/y2 coordinates to maintain aspect ratio (if defined)\x0a     *\x0a     * @param xFirst\x0a     *            If set to \x3ccode\x3etrue\x3c/code\x3e, calculate x2 first. Otherwise,\x0a     *            calculate y2 first.\x0a     */\x0a    function fixAspectRatio(xFirst) {\x0a        if (aspectRatio)\x0a            if (xFirst) {\x0a                x2 = max(left, min(left + imgWidth,\x0a                    x1 + abs(y2 - y1) * aspectRatio * (x2 \x3e x1 || -1)));\x0a                y2 = round(max(top, min(top + imgHeight,\x0a                    y1 + abs(x2 - x1) / aspectRatio * (y2 \x3e y1 || -1))));\x0a                x2 = round(x2);\x0a            }\x0a            else {\x0a                y2 = max(top, min(top + imgHeight,\x0a                    y1 + abs(x2 - x1) / aspectRatio * (y2 \x3e y1 || -1)));\x0a                x2 = round(max(left, min(left + imgWidth,\x0a                    x1 + abs(y2 - y1) * aspectRatio * (x2 \x3e x1 || -1))));\x0a                y2 = round(y2);\x0a            }\x0a    }\x0a\x0a    /**\x0a     * Resize the selection area respecting the minimum/maximum dimensions and\x0a     * aspect ratio\x0a     */\x0a    function doResize() {\x0a        /*\x0a         * Make sure the top left corner of the selection area stays within\x0a         * image boundaries (it might not if the image source was dynamically\x0a         * changed).\x0a         */\x0a        x1 = min(x1, left + imgWidth);\x0a        y1 = min(y1, top + imgHeight);\x0a\x0a        if (abs(x2 - x1) \x3c minWidth) {\x0a            /* Selection width is smaller than minWidth */\x0a            x2 = x1 - minWidth * (x2 \x3c x1 || -1);\x0a\x0a            if (x2 \x3c left)\x0a                x1 = left + minWidth;\x0a            else if (x2 \x3e left + imgWidth)\x0a                x1 = left + imgWidth - minWidth;\x0a        }\x0a\x0a        if (abs(y2 - y1) \x3c minHeight) {\x0a            /* Selection height is smaller than minHeight */\x0a            y2 = y1 - minHeight * (y2 \x3c y1 || -1);\x0a\x0a            if (y2 \x3c top)\x0a                y1 = top + minHeight;\x0a            else if (y2 \x3e top + imgHeight)\x0a                y1 = top + imgHeight - minHeight;\x0a        }\x0a\x0a        x2 = max(left, min(x2, left + imgWidth));\x0a        y2 = max(top, min(y2, top + imgHeight));\x0a\x0a        fixAspectRatio(abs(x2 - x1) \x3c abs(y2 - y1) * aspectRatio);\x0a\x0a        if (abs(x2 - x1) \x3e maxWidth) {\x0a            /* Selection width is greater than maxWidth */\x0a            x2 = x1 - maxWidth * (x2 \x3c x1 || -1);\x0a            fixAspectRatio();\x0a        }\x0a\x0a        if (abs(y2 - y1) \x3e maxHeight) {\x0a            /* Selection height is greater than maxHeight */\x0a            y2 = y1 - maxHeight * (y2 \x3c y1 || -1);\x0a            fixAspectRatio(true);\x0a        }\x0a\x0a        selection = { x1: selX(min(x1, x2)), x2: selX(max(x1, x2)),\x0a            y1: selY(min(y1, y2)), y2: selY(max(y1, y2)),\x0a            width: abs(x2 - x1), height: abs(y2 - y1) };\x0a\x0a        update();\x0a\x0a        options.onSelectChange(img, getSelection());\x0a    }\x0a\x0a    /**\x0a     * Mousemove event handler triggered when the user is selecting an area\x0a     *\x0a     * @param event\x0a     *            The event object\x0a     * @return false\x0a     */\x0a    function selectingMouseMove(event) {\x0a        x2 = /w|e|^$/.test(resize) || aspectRatio ? evX(event) : viewX(selection.x2);\x0a        y2 = /n|s|^$/.test(resize) || aspectRatio ? evY(event) : viewY(selection.y2);\x0a\x0a        doResize();\x0a\x0a        return false;\x0a    }\x0a\x0a    /**\x0a     * Move the selection area\x0a     *\x0a     * @param newX1\x0a     *            New viewport X1\x0a     * @param newY1\x0a     *            New viewport Y1\x0a     */\x0a    function doMove(newX1, newY1) {\x0a        x2 = (x1 = newX1) + selection.width;\x0a        y2 = (y1 = newY1) + selection.height;\x0a\x0a        $.extend(selection, { x1: selX(x1), y1: selY(y1), x2: selX(x2),\x0a            y2: selY(y2) });\x0a\x0a        update();\x0a\x0a        options.onSelectChange(img, getSelection());\x0a    }\x0a\x0a    /**\x0a     * Mousemove event handler triggered when the selection area is being moved\x0a     *\x0a     * @param event\x0a     *            The event object\x0a     * @return false\x0a     */\x0a    function movingMouseMove(event) {\x0a        x1 = max(left, min(startX + evX(event), left + imgWidth - selection.width));\x0a        y1 = max(top, min(startY + evY(event), top + imgHeight - selection.height));\x0a\x0a        doMove(x1, y1);\x0a\x0a        event.preventDefault();\x0a        return false;\x0a    }\x0a\x0a    /**\x0a     * Start selection\x0a     */\x0a    function startSelection() {\x0a        $(document).off(\x27mousemove touchmove\x27, startSelection);\x0a        adjust();\x0a\x0a        x2 = x1;\x0a        y2 = y1;\x0a        doResize();\x0a\x0a        resize = \x27\x27;\x0a\x0a        if (!$outer.is(\x27:visible\x27))\x0a            /* Show the plugin elements */\x0a            $box.add($outer).hide().fadeIn(options.fadeSpeed||0);\x0a\x0a        shown = true;\x0a\x0a        $(document).off(\x27mouseup touchend\x27, cancelSelection)\x0a            .on(\x27mousemove touchmove\x27, selectingMouseMove)\x0a            .one(\x27mouseup touchend\x27, docMouseUp);\x0a        $box.off(\x27mousemove touchmove\x27, areaMouseMove);\x0a\x0a        options.onSelectStart(img, getSelection());\x0a    }\x0a\x0a    /**\x0a     * Cancel selection\x0a     */\x0a    function cancelSelection() {\x0a        $(document).off(\x27mousemove touchmove\x27, startSelection)\x0a            .off(\x27mouseup touchend\x27, cancelSelection);\x0a        hide($box.add($outer));\x0a\x0a        setSelection(selX(x1), selY(y1), selX(x1), selY(y1));\x0a\x0a        /* If this is an API call, callback functions should not be triggered */\x0a        if (!(this instanceof $.imgAreaSelect)) {\x0a            options.onSelectChange(img, getSelection());\x0a            options.onSelectEnd(img, getSelection());\x0a        }\x0a    }\x0a\x0a    /**\x0a     * Image mousedown event handler\x0a     *\x0a     * @param event\x0a     *            The event object\x0a     * @return false\x0a     */\x0a    function imgMouseDown(event) {\x0a        /* Ignore the event if animation is in progress */\x0a        if (event.which \x3e 1 || $outer.is(\x27:animated\x27)) return false;\x0a\x0a        adjust();\x0a        startX = x1 = evX(event);\x0a        startY = y1 = evY(event);\x0a\x0a        /* Selection will start when the mouse is moved */\x0a        $(document).on({ \x27mousemove touchmove\x27: startSelection,\x0a            \x27mouseup touchend\x27: cancelSelection });\x0a\x0a        return false;\x0a    }\x0a\x0a    /**\x0a     * Window resize event handler\x0a     */\x0a    function windowResize() {\x0a        doUpdate(false);\x0a    }\x0a\x0a    /**\x0a     * Image load event handler. This is the final part of the initialization\x0a     * process.\x0a     */\x0a    function imgLoad() {\x0a        imgLoaded = true;\x0a\x0a        /* Set options */\x0a        setOptions(options = $.extend({\x0a            classPrefix: \x27imgareaselect\x27,\x0a            movable: true,\x0a            parent: \x27body\x27,\x0a            resizable: true,\x0a            resizeMargin: 10,\x0a            onInit: function () {},\x0a            onSelectStart: function () {},\x0a            onSelectChange: function () {},\x0a            onSelectEnd: function () {}\x0a        }, options));\x0a\x0a        $box.add($outer).css({ visibility: \x27\x27 });\x0a\x0a        if (options.show) {\x0a            shown = true;\x0a            adjust();\x0a            update();\x0a            $box.add($outer).hide().fadeIn(options.fadeSpeed||0);\x0a        }\x0a\x0a        /*\x0a         * Call the onInit callback. The setTimeout() call is used to ensure\x0a         * that the plugin has been fully initialized and the object instance is\x0a         * available (so that it can be obtained in the callback).\x0a         */\x0a        setTimeout(function () { options.onInit(img, getSelection()); }, 0);\x0a    }\x0a\x0a    /**\x0a     * Document keypress event handler\x0a     *\x0a     * @param event\x0a     *            The event object\x0a     * @return false\x0a     */\x0a    var docKeyPress = function(event) {\x0a        var k = options.keys, d, t, key = event.keyCode;\x0a\x0a        d = !isNaN(k.alt) && (event.altKey || event.originalEvent.altKey) ? k.alt :\x0a            !isNaN(k.ctrl) && event.ctrlKey ? k.ctrl :\x0a            !isNaN(k.shift) && event.shiftKey ? k.shift :\x0a            !isNaN(k.arrows) ? k.arrows : 10;\x0a\x0a        if (k.arrows == \x27resize\x27 || (k.shift == \x27resize\x27 && event.shiftKey) ||\x0a            (k.ctrl == \x27resize\x27 && event.ctrlKey) ||\x0a            (k.alt == \x27resize\x27 && (event.altKey || event.originalEvent.altKey)))\x0a        {\x0a            /* Resize selection */\x0a\x0a            switch (key) {\x0a            case 37:\x0a                /* Left */\x0a                d = -d;\x0a            case 39:\x0a                /* Right */\x0a                t = max(x1, x2);\x0a                x1 = min(x1, x2);\x0a                x2 = max(t + d, x1);\x0a                fixAspectRatio();\x0a                break;\x0a            case 38:\x0a                /* Up */\x0a                d = -d;\x0a            case 40:\x0a                /* Down */\x0a                t = max(y1, y2);\x0a                y1 = min(y1, y2);\x0a                y2 = max(t + d, y1);\x0a                fixAspectRatio(true);\x0a                break;\x0a            default:\x0a                return;\x0a            }\x0a\x0a            doResize();\x0a        }\x0a        else {\x0a            /* Move selection */\x0a\x0a            x1 = min(x1, x2);\x0a            y1 = min(y1, y2);\x0a\x0a            switch (key) {\x0a            case 37:\x0a                /* Left */\x0a                doMove(max(x1 - d, left), y1);\x0a                break;\x0a            case 38:\x0a                /* Up */\x0a                doMove(x1, max(y1 - d, top));\x0a                break;\x0a            case 39:\x0a                /* Right */\x0a                doMove(x1 + min(d, imgWidth - selX(x2)), y1);\x0a                break;\x0a            case 40:\x0a                /* Down */\x0a                doMove(x1, y1 + min(d, imgHeight - selY(y2)));\x0a                break;\x0a            default:\x0a                return;\x0a            }\x0a        }\x0a\x0a        return false;\x0a    };\x0a\x0a    /**\x0a     * Apply style options to plugin element (or multiple elements)\x0a     *\x0a     * @param $elem\x0a     *            A jQuery object representing the element(s) to style\x0a     * @param props\x0a     *            An object that maps option names to corresponding CSS\x0a     *            properties\x0a     */\x0a    function styleOptions($elem, props) {\x0a        for (var option in props)\x0a            if (options[option] !== undefined)\x0a                $elem.css(props[option], options[option]);\x0a    }\x0a\x0a    /**\x0a     * Set plugin options\x0a     *\x0a     * @param newOptions\x0a     *            The new options object\x0a     */\x0a    function setOptions(newOptions) {\x0a        if (newOptions.parent)\x0a            ($parent = $(newOptions.parent)).append($box.add($outer));\x0a\x0a        /* Merge the new options with the existing ones */\x0a        $.extend(options, newOptions);\x0a\x0a        adjust();\x0a\x0a        if (newOptions.handles != null) {\x0a            /* Recreate selection area handles */\x0a            $handles.remove();\x0a            $handles = $([]);\x0a\x0a            i = newOptions.handles ? newOptions.handles == \x27corners\x27 ? 4 : 8 : 0;\x0a\x0a            while (i--)\x0a                $handles = $handles.add(div());\x0a\x0a            /* Add a class to handles and set the CSS properties */\x0a            $handles.addClass(options.classPrefix + \x27-handle\x27).css({\x0a                position: \x27absolute\x27,\x0a                /*\x0a                 * The font-size property needs to be set to zero, otherwise\x0a                 * Internet Explorer makes the handles too large\x0a                 */\x0a                fontSize: 0,\x0a                zIndex: zIndex + 1 || 1\x0a            });\x0a\x0a            /*\x0a             * If handle width/height has not been set with CSS rules, set the\x0a             * default 5px\x0a             */\x0a            if (!parseInt($handles.css(\x27width\x27)) \x3e= 0)\x0a                $handles.width(5).height(5);\x0a\x0a            /*\x0a             * If the borderWidth option is in use, add a solid border to\x0a             * handles\x0a             */\x0a            if (o = options.borderWidth)\x0a                $handles.css({ borderWidth: o, borderStyle: \x27solid\x27 });\x0a\x0a            /* Apply other style options */\x0a            styleOptions($handles, { borderColor1: \x27border-color\x27,\x0a                borderColor2: \x27background-color\x27,\x0a                borderOpacity: \x27opacity\x27 });\x0a        }\x0a\x0a        /* Calculate scale factors */\x0a        scaleX = options.imageWidth / imgWidth || 1;\x0a        scaleY = options.imageHeight / imgHeight || 1;\x0a\x0a        /* Set selection */\x0a        if (newOptions.x1 != null) {\x0a            setSelection(newOptions.x1, newOptions.y1, newOptions.x2,\x0a                newOptions.y2);\x0a            newOptions.show = !newOptions.hide;\x0a        }\x0a\x0a        if (newOptions.keys)\x0a            /* Enable keyboard support */\x0a            options.keys = $.extend({ shift: 1, ctrl: \x27resize\x27 },\x0a                newOptions.keys);\x0a\x0a        /* Add classes to plugin elements */\x0a        $outer.addClass(options.classPrefix + \x27-outer\x27);\x0a        $area.addClass(options.classPrefix + \x27-selection\x27);\x0a        for (i = 0; i++ \x3c 4;)\x0a            $($border[i-1]).addClass(options.classPrefix + \x27-border\x27 + i);\x0a\x0a        /* Apply style options */\x0a        styleOptions($area, { selectionColor: \x27background-color\x27,\x0a            selectionOpacity: \x27opacity\x27 });\x0a        styleOptions($border, { borderOpacity: \x27opacity\x27,\x0a            borderWidth: \x27border-width\x27 });\x0a        styleOptions($outer, { outerColor: \x27background-color\x27,\x0a            outerOpacity: \x27opacity\x27 });\x0a        if (o = options.borderColor1)\x0a            $($border[0]).css({ borderStyle: \x27solid\x27, borderColor: o });\x0a        if (o = options.borderColor2)\x0a            $($border[1]).css({ borderStyle: \x27dashed\x27, borderColor: o });\x0a\x0a        /* Append all the selection area elements to the container box */\x0a        $box.append($area.add($border).add($areaOpera)).append($handles);\x0a\x0a        if (msie) {\x0a            if (o = ($outer.css(\x27filter\x27)||\x27\x27).match(/opacity=(\x5cd+)/))\x0a                $outer.css(\x27opacity\x27, o[1]/100);\x0a            if (o = ($border.css(\x27filter\x27)||\x27\x27).match(/opacity=(\x5cd+)/))\x0a                $border.css(\x27opacity\x27, o[1]/100);\x0a        }\x0a\x0a        if (newOptions.hide)\x0a            hide($box.add($outer));\x0a        else if (newOptions.show && imgLoaded) {\x0a            shown = true;\x0a            $box.add($outer).fadeIn(options.fadeSpeed||0);\x0a            doUpdate();\x0a        }\x0a\x0a        /* Calculate the aspect ratio factor */\x0a        aspectRatio = (d = (options.aspectRatio || \x27\x27).split(/:/))[0] / d[1];\x0a\x0a        $img.add($outer).unbind(\x27mousedown\x27, imgMouseDown);\x0a\x0a        if (options.disable || options.enable === false) {\x0a            /* Disable the plugin */\x0a            $box.off({ \x27mousemove touchmove\x27: areaMouseMove,\x0a                \x27mousedown touchstart\x27: areaMouseDown });\x0a            $(window).off(\x27resize\x27, windowResize);\x0a        }\x0a        else {\x0a            if (options.enable || options.disable === false) {\x0a                /* Enable the plugin */\x0a                if (options.resizable || options.movable)\x0a                    $box.on({ \x27mousemove touchmove\x27: areaMouseMove,\x0a                        \x27mousedown touchstart\x27: areaMouseDown });\x0a\x0a                $(window).resize(windowResize);\x0a            }\x0a\x0a            if (!options.persistent)\x0a                $img.add($outer).on(\x27mousedown touchstart\x27, imgMouseDown);\x0a        }\x0a\x0a        options.enable = options.disable = undefined;\x0a    }\x0a\x0a    /**\x0a     * Remove plugin completely\x0a     */\x0a    this.remove = function () {\x0a        /*\x0a         * Call setOptions with { disable: true } to unbind the event handlers\x0a         */\x0a        setOptions({ disable: true });\x0a        $box.add($outer).remove();\x0a    };\x0a\x0a    /*\x0a     * Public API\x0a     */\x0a\x0a    /**\x0a     * Get current options\x0a     *\x0a     * @return An object containing the set of options currently in use\x0a     */\x0a    this.getOptions = function () { return options; };\x0a\x0a    /**\x0a     * Set plugin options\x0a     *\x0a     * @param newOptions\x0a     *            The new options object\x0a     */\x0a    this.setOptions = setOptions;\x0a\x0a    /**\x0a     * Get the current selection\x0a     *\x0a     * @param noScale\x0a     *            If set to \x3ccode\x3etrue\x3c/code\x3e, scaling is not applied to the\x0a     *            returned selection\x0a     * @return Selection object\x0a     */\x0a    this.getSelection = getSelection;\x0a\x0a    /**\x0a     * Set the current selection\x0a     *\x0a     * @param x1\x0a     *            X coordinate of the upper left corner of the selection area\x0a     * @param y1\x0a     *            Y coordinate of the upper left corner of the selection area\x0a     * @param x2\x0a     *            X coordinate of the lower right corner of the selection area\x0a     * @param y2\x0a     *            Y coordinate of the lower right corner of the selection area\x0a     * @param noScale\x0a     *            If set to \x3ccode\x3etrue\x3c/code\x3e, scaling is not applied to the\x0a     *            new selection\x0a     */\x0a    this.setSelection = setSelection;\x0a\x0a    /**\x0a     * Cancel selection\x0a     */\x0a    this.cancelSelection = cancelSelection;\x0a\x0a    /**\x0a     * Update plugin elements\x0a     *\x0a     * @param resetKeyPress\x0a     *            If set to \x3ccode\x3efalse\x3c/code\x3e, this instance\x27s keypress\x0a     *            event handler is not activated\x0a     */\x0a    this.update = doUpdate;\x0a\x0a    /* Do the dreaded browser detection */\x0a    var msie = (/msie ([\x5cw.]+)/i.exec(ua)||[])[1],\x0a        opera = /opera/i.test(ua),\x0a        safari = /webkit/i.test(ua) && !/chrome/i.test(ua);\x0a\x0a    /*\x0a     * Traverse the image\x27s parent elements (up to \x3cbody\x3e) and find the\x0a     * highest z-index\x0a     */\x0a    $p = $img;\x0a\x0a    while ($p.length) {\x0a        zIndex = max(zIndex,\x0a            !isNaN($p.css(\x27z-index\x27)) ? $p.css(\x27z-index\x27) : zIndex);\x0a        /* Also check if any of the ancestor elements has fixed position */\x0a        if ($p.css(\x27position\x27) == \x27fixed\x27)\x0a            position = \x27fixed\x27;\x0a\x0a        $p = $p.parent(\x27:not(body)\x27);\x0a    }\x0a\x0a    /*\x0a     * If z-index is given as an option, it overrides the one found by the\x0a     * above loop\x0a     */\x0a    zIndex = options.zIndex || zIndex;\x0a\x0a    if (msie)\x0a        $img.attr(\x27unselectable\x27, \x27on\x27);\x0a\x0a    /*\x0a     * In MSIE and WebKit, we need to use the keydown event instead of keypress\x0a     */\x0a    $.imgAreaSelect.keyPress = msie || safari ? \x27keydown\x27 : \x27keypress\x27;\x0a\x0a    /*\x0a     * There is a bug affecting the CSS cursor property in Opera (observed in\x0a     * versions up to 10.00) that prevents the cursor from being updated unless\x0a     * the mouse leaves and enters the element again. To trigger the mouseover\x0a     * event, we\x27re adding an additional div to $box and we\x27re going to toggle\x0a     * it when mouse moves inside the selection area.\x0a     */\x0a    if (opera)\x0a        $areaOpera = div().css({ width: \x27100%\x27, height: \x27100%\x27,\x0a            position: \x27absolute\x27, zIndex: zIndex + 2 || 2 });\x0a\x0a    /*\x0a     * We initially set visibility to \x22hidden\x22 as a workaround for a weird\x0a     * behaviour observed in Google Chrome 1.0.154.53 (on Windows XP). Normally\x0a     * we would just set display to \x22none\x22, but, for some reason, if we do so\x0a     * then Chrome refuses to later display the element with .show() or\x0a     * .fadeIn().\x0a     */\x0a    $box.add($outer).css({ visibility: \x27hidden\x27, position: position,\x0a        overflow: \x27hidden\x27, zIndex: zIndex || \x270\x27 });\x0a    $box.css({ zIndex: zIndex + 2 || 2 });\x0a    $area.add($border).css({ position: \x27absolute\x27, fontSize: 0 });\x0a\x0a    /*\x0a     * If the image has been fully loaded, or if it is not really an image (eg.\x0a     * a div), call imgLoad() immediately; otherwise, bind it to be called once\x0a     * on image load event.\x0a     */\x0a    img.complete || img.readyState == \x27complete\x27 || !$img.is(\x27img\x27) ?\x0a        imgLoad() : $img.one(\x27load\x27, imgLoad);\x0a\x0a    /*\x0a     * MSIE 9.0 doesn\x27t always fire the image load event -- resetting the src\x0a     * attribute seems to trigger it. The check is for version 7 and above to\x0a     * accommodate for MSIE 9 running in compatibility mode.\x0a     */\x0a    if (!imgLoaded && msie && msie \x3e= 7)\x0a        img.src = img.src;\x0a};\x0a\x0a/**\x0a * Invoke imgAreaSelect on a jQuery object containing the image(s)\x0a *\x0a * @param options\x0a *            Options object\x0a * @return The jQuery object or a reference to imgAreaSelect instance (if the\x0a *         \x3ccode\x3einstance\x3c/code\x3e option was specified)\x0a */\x0a$.fn.imgAreaSelect = function (options) {\x0a    options = options || {};\x0a\x0a    this.each(function () {\x0a        /* Is there already an imgAreaSelect instance bound to this element? */\x0a        if ($(this).data(\x27imgAreaSelect\x27)) {\x0a            /* Yes there is -- is it supposed to be removed? */\x0a            if (options.remove) {\x0a                /* Remove the plugin */\x0a                $(this).data(\x27imgAreaSelect\x27).remove();\x0a                $(this).removeData(\x27imgAreaSelect\x27);\x0a            }\x0a            else\x0a                /* Reset options */\x0a                $(this).data(\x27imgAreaSelect\x27).setOptions(options);\x0a        }\x0a        else if (!options.remove) {\x0a            /* No exising instance -- create a new one */\x0a\x0a            /*\x0a             * If neither the \x22enable\x22 nor the \x22disable\x22 option is present, add\x0a             * \x22enable\x22 as the default\x0a             */\x0a            if (options.enable === undefined && options.disable === undefined)\x0a                options.enable = true;\x0a\x0a            $(this).data(\x27imgAreaSelect\x27, new $.imgAreaSelect(this, options));\x0a        }\x0a    });\x0a\x0a    if (options.instance)\x0a        /*\x0a         * Return the imgAreaSelect instance bound to the first element in the\x0a         * set\x0a         */\x0a        return $(this).data(\x27imgAreaSelect\x27);\x0a\x0a    return this;\x0a};\x0a\x0a})(jQuery);\x0a\x0d\x0aReferer: htt\xe1'}