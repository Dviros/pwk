var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 14:59:46 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 28 Jun 2018 02:30:15 GMT\x0aETag: \x222949-56faa82e93bc0-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-3515/3516\x0aContent-Length: 3516\x0aKeep-Alive: timeout=5, max=37\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/**\x0a * Utility functions for parsing and handling shortcodes in JavaScript.\x0a *\x0a * @output wp-includes/js/shortcode.js\x0a */\x0a\x0a/**\x0a * Ensure the global `wp` object exists.\x0a *\x0a * @namespace wp\x0a */\x0awindow.wp = window.wp || {};\x0a\x0a(function(){\x0a\x09wp.shortcode = {\x0a\x09\x09// ### Find the next matching shortcode\x0a\x09\x09//\x0a\x09\x09// Given a shortcode `tag`, a block of `text`, and an optional starting\x0a\x09\x09// `index`, returns the next matching shortcode or `undefined`.\x0a\x09\x09//\x0a\x09\x09// Shortcodes are formatted as an object that contains the match\x0a\x09\x09// `content`, the matching `index`, and the parsed `shortcode` object.\x0a\x09\x09next: function( tag, text, index ) {\x0a\x09\x09\x09var re = wp.shortcode.regexp( tag ),\x0a\x09\x09\x09\x09match, result;\x0a\x0a\x09\x09\x09re.lastIndex = index || 0;\x0a\x09\x09\x09match = re.exec( text );\x0a\x0a\x09\x09\x09if ( ! match ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// If we matched an escaped shortcode, try again.\x0a\x09\x09\x09if ( \x27[\x27 === match[1] && \x27]\x27 === match[7] ) {\x0a\x09\x09\x09\x09return wp.shortcode.next( tag, text, re.lastIndex );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09result = {\x0a\x09\x09\x09\x09index:     match.index,\x0a\x09\x09\x09\x09content:   match[0],\x0a\x09\x09\x09\x09shortcode: wp.shortcode.fromMatch( match )\x0a\x09\x09\x09};\x0a\x0a\x09\x09\x09// If we matched a leading `[`, strip it from the match\x0a\x09\x09\x09// and increment the index accordingly.\x0a\x09\x09\x09if ( match[1] ) {\x0a\x09\x09\x09\x09result.content = result.content.slice( 1 );\x0a\x09\x09\x09\x09result.index++;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// If we matched a trailing `]`, strip it from the match.\x0a\x09\x09\x09if ( match[7] ) {\x0a\x09\x09\x09\x09result.content = result.content.slice( 0, -1 );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09return result;\x0a\x09\x09},\x0a\x0a\x09\x09// ### Replace matching shortcodes in a block of text\x0a\x09\x09//\x0a\x09\x09// Accepts a shortcode `tag`, content `text` to scan, and a `callback`\x0a\x09\x09// to process the shortcode matches and return a replacement string.\x0a\x09\x09// Returns the `text` with all shortcodes replaced.\x0a\x09\x09//\x0a\x09\x09// Shortcode matches are objects that contain the shortcode `tag`,\x0a\x09\x09// a shortcode `attrs` object, the `content` between shortcode tags,\x0a\x09\x09// and a boolean flag to indicate if the match was a `single` tag.\x0a\x09\x09replace: function( tag, text, callback ) {\x0a\x09\x09\x09return text.replace( wp.shortcode.regexp( tag ), function( match, left, tag, attrs, slash, content, closing, right ) {\x0a\x09\x09\x09\x09// If both extra brackets exist, the shortcode has been\x0a\x09\x09\x09\x09// properly escaped.\x0a\x09\x09\x09\x09if ( left === \x27[\x27 && right === \x27]\x27 ) {\x0a\x09\x09\x09\x09\x09return match;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Create the match object and pass it through the callback.\x0a\x09\x09\x09\x09var result = callback( wp.shortcode.fromMatch( arguments ) );\x0a\x0a\x09\x09\x09\x09// Make sure to return any of the extra brackets if they\x0a\x09\x09\x09\x09// weren\x27t used to escape the shortcode.\x0a\x09\x09\x09\x09return result ? left + result + right : match;\x0a\x09\x09\x09});\x0a\x09\x09},\x0a\x0a\x09\x09// ### Generate a string from shortcode parameters\x0a\x09\x09//\x0a\x09\x09// Creates a `wp.shortcode` instance and returns a string.\x0a\x09\x09//\x0a\x09\x09// Accepts the same `options` as the `wp.shortcode()` constructor,\x0a\x09\x09// containing a `tag` string, a string or object of `attrs`, a boolean\x0a\x09\x09// indicating whether to format the shortcode using a `single` tag, and a\x0a\x09\x09// `content` string.\x0a\x09\x09string: function( options ) {\x0a\x09\x09\x09return new wp.shortcode( options ).string();\x0a\x09\x09},\x0a\x0a\x09\x09// ### Generate a RegExp to identify a shortcode\x0a\x09\x09//\x0a\x09\x09// The base regex is functionally equivalent to the one found in\x0a\x09\x09// `get_shortcode_regex()` in `wp-includes/shortcodes.php`.\x0a\x09\x09//\x0a\x09\x09// Capture groups:\x0a\x09\x09//\x0a\x09\x09// 1. An extra `[` to allow for escaping shortcodes with double `[[]]`\x0a\x09\x09// 2. The shortcode name\x0a\x09\x09// 3. The shortcode argument list\x0a\x09\x09// 4. The self closing `/`\x0a\x09\x09// 5. The content of a shortcode when it wraps some content.\x0a\x09\x09// 6. The closing tag.\x0a\x09\x09// 7. An extra `]` to allow for escaping shortcodes with double `[[]]`\x0a\x09\x09regexp: _.memoize( function( tag ) {\x0a\x09\x09\x09return new RegExp( \x27\x5c\x5c[(\x5c\x5c[?)(\x27 + tag + \x27)(?![\x5c\x5cw-])([^\x5c\x5c]\x5c\x5c/]*(?:\x5c\x5c/(?!\x5c\x5c])[^\x5c\x5c]\x5c\x5c/]*)*?)(?:(\x5c\x5c/)\x5c\x5c]|\x5c\x5c](?:([^\x5c\x5c[]*(?:\x5c\x5c[(?!\x5c\x5c/\x5c\x5c2\x5c\x5c])[^\x5c\x5c[]*)*)(\x5c\x5c[\x5c\x5c/\x5c\x5c2\x5c\x5c]))?)(\x5c\x5c]?)\x27, \x27g\x27 );\x0a\x09\x09}),\x0a\x0a\x0a\x09\x09// ### Parse shortcode attributes\x0a\x09\x09//\x0a\x09\x09// Shortcodes accept many types of attributes. These can chiefly be\x0a\x09\x09// divided into named and numeric attributes:\x0a\x09\x09//\x0a\x09\x09// Named attributes are assigned on a key/value basis, while numeric\x0a\x09\x09// attributes are treated as an array.\x0a\x09\x09//\x0a\x09\x09// Named attributes can be formatted as either `name=\x22value\x22`,\x0a\x09\x09// `name=\x27value\x27`, or `name=value`. Numeric attributes can be formatted\x0a\x09\x09// as `\x22value\x22` or just `value`.\x0a\x09\x09attrs: _.memoize( function( text ) {\x0a\x09\x09\x09var named   = {},\x0a\x09\x09\x09\x09numeric = [],\x0a\x09\x09\x09\x09pattern, match;\x0a\x0a\x09\x09\x09// This regular expression is reused from `shortcode_parse_atts()`\x0a\x09\x09\x09// in `wp-includes/shortcodes.php`.\x0a\x09\x09\x09//\x0a\x09\x09\x09// Capture groups:\x0a\x09\x09\x09//\x0a\x09\x09\x09// 1. An attribute name, that corresponds to...\x0a\x09\x09\x09// 2. a value in double quotes.\x0a\x09\x09\x09// 3. An attribute name, that corresponds to...\x0a\x09\x09\x09// 4. a value in single quotes.\x0a\x09\x09\x09// 5. An attribute name, that corresponds to...\x0a\x09\x09\x09// 6. an unquoted value.\x0a\x09\x09\x09// 7. A numeric attribute in double quotes.\x0a\x09\x09\x09// 8. A numeric attribute in single quotes.\x0a\x09\x09\x09// 9. An unquoted numeric attribute.\x0a\x09\x09\x09pattern = /([\x5cw-]+)\x5cs*=\x5cs*\x22([^\x22]*)\x22(?:\x5cs|$)|([\x5cw-]+)\x5cs*=\x5cs*\x27([^\x27]*)\x27(?:\x5cs|$)|([\x5cw-]+)\x5cs*=\x5cs*([^\x5cs\x27\x22]+)(?:\x5cs|$)|\x22([^\x22]*)\x22(?:\x5cs|$)|\x27([^\x27]*)\x27(?:\x5cs|$)|(\x5cS+)(?:\x5cs|$)/g;\x0a\x0a\x09\x09\x09// Map zero-width spaces to actual spaces.\x0a\x09\x09\x09text = text.replace( /[\x5cu00a0\x5cu200b]/g, \x27 \x27 );\x0a\x0a\x09\x09\x09// Match and normalize attributes.\x0a\x09\x09\x09while ( (match = pattern.exec( text )) ) {\x0a\x09\x09\x09\x09if ( match[1] ) {\x0a\x09\x09\x09\x09\x09named[ match[1].toLowerCase() ] = match[2];\x0a\x09\x09\x09\x09} else if ( match[3] ) {\x0a\x09\x09\x09\x09\x09named[ match[3].toLowerCase() ] = match[4];\x0a\x09\x09\x09\x09} else if ( match[5] ) {\x0a\x09\x09\x09\x09\x09named[ match[5].toLowerCase() ] = match[6];\x0a\x09\x09\x09\x09} else if ( match[7] ) {\x0a\x09\x09\x09\x09\x09numeric.push( match[7] );\x0a\x09\x09\x09\x09} else if ( match[8] ) {\x0a\x09\x09\x09\x09\x09numeric.push( match[8] );\x0a\x09\x09\x09\x09} else if ( match[9] ) {\x0a\x09\x09\x09\x09\x09numeric.push( match[9] );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09return {\x0a\x09\x09\x09\x09named:   named,\x0a\x09\x09\x09\x09numeric: numeric\x0a\x09\x09\x09};\x0a\x09\x09}),\x0a\x0a\x09\x09// ### Generate a Shortcode Object from a RegExp match\x0a\x09\x09// Accepts a `match` object from calling `regexp.exec()` on a `RegExp`\x0a\x09\x09// generated by `wp.shortcode.regexp()`. `match` can also be set to the\x0a\x09\x09// `arguments` from a callback passed to `regexp.replace()`.\x0a\x09\x09fromMatch: function( match ) {\x0a\x09\x09\x09var type;\x0a\x0a\x09\x09\x09if ( match[4] ) {\x0a\x09\x09\x09\x09type = \x27self-closing\x27;\x0a\x09\x09\x09} else if ( match[6] ) {\x0a\x09\x09\x09\x09type = \x27closed\x27;\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09type = \x27single\x27;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09return new wp.shortcode({\x0a\x09\x09\x09\x09tag:     match[2],\x0a\x09\x09\x09\x09attrs:   match[3],\x0a\x09\x09\x09\x09type:    type,\x0a\x09\x09\x09\x09content: match[5]\x0a\x09\x09\x09});\x0a\x09\x09}\x0a\x09};\x0a\x0a\x0a\x09// Shortcode Objects\x0a\x09// -----------------\x0a\x09//\x0a\x09// Shortcode objects are generated automatically when using the main\x0a\x09// `wp.shortcode` methods: `next()`, `replace()`, and `string()`.\x0a\x09//\x0a\x09// To access a raw representation of a shortcode, pass an `options` object,\x0a\x09// containing a `tag` string, a string or object of `attrs`, a string\x0a\x09// indicating the `type` of the shortcode (\x27single\x27, \x27self-closing\x27, or\x0a\x09// \x27closed\x27), and a `content` string.\x0a\x09wp.shortcode = _.extend( function( options ) {\x0a\x09\x09_.extend( this, _.pick( options || {}, \x27tag\x27, \x27attrs\x27, \x27type\x27, \x27content\x27 ) );\x0a\x0a\x09\x09var attrs = this.attrs;\x0a\x0a\x09\x09// Ensure we have a correctly formatted `attrs` object.\x0a\x09\x09this.attrs = {\x0a\x09\x09\x09named:   {},\x0a\x09\x09\x09numeric: []\x0a\x09\x09};\x0a\x0a\x09\x09if ( ! attrs ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09// Parse a string of attributes.\x0a\x09\x09if ( _.isString( attrs ) ) {\x0a\x09\x09\x09this.attrs = wp.shortcode.attrs( attrs );\x0a\x0a\x09\x09// Identify a correctly formatted `attrs` object.\x0a\x09\x09} else if ( _.isEqual( _.keys( attrs ), [ \x27named\x27, \x27numeric\x27 ] ) ) {\x0a\x09\x09\x09this.attrs = attrs;\x0a\x0a\x09\x09// Handle a flat object of attributes.\x0a\x09\x09} else {\x0a\x09\x09\x09_.each( options.attrs, function( value, key ) {\x0a\x09\x09\x09\x09this.set( key, value );\x0a\x09\x09\x09}, this );\x0a\x09\x09}\x0a\x09}, wp.shortcode );\x0a\x0a\x09_.extend( wp.shortcode.prototype, {\x0a\x09\x09// ### Get a shortcode attribute\x0a\x09\x09//\x0a\x09\x09// Automatically detects whether `attr` is named or numeric and routes\x0a\x09\x09// it accordingly.\x0a\x09\x09get: function( attr ) {\x0a\x09\x09\x09return this.attrs[ _.isNumber( attr ) ? \x27numeric\x27 : \x27named\x27 ][ attr ];\x0a\x09\x09},\x0a\x0a\x09\x09// ### Set a shortcode attribute\x0a\x09\x09//\x0a\x09\x09// Automatically detects whether `attr` is named or numeric and routes\x0a\x09\x09// it accordingly.\x0a\x09\x09set: function( attr, value ) {\x0a\x09\x09\x09this.attrs[ _.isNumber( attr ) ? \x27numeric\x27 : \x27named\x27 ][ attr ] = value;\x0a\x09\x09\x09return this;\x0a\x09\x09},\x0a\x0a\x09\x09// ### Transform the shortcode match into a string\x0a\x09\x09string: function() {\x0a\x09\x09\x09var text    = \x27[\x27 + this.tag;\x0a\x0a\x09\x09\x09_.each( this.attrs.numeric, function( value ) {\x0a\x09\x09\x09\x09if ( /\x5cs/.test( value ) ) {\x0a\x09\x09\x09\x09\x09text += \x27 \x22\x27 + value + \x27\x22\x27;\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09text += \x27 \x27 + value;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09});\x0a\x0a\x09\x09\x09_.each( this.attrs.named, function( value, name ) {\x0a\x09\x09\x09\x09text += \x27 \x27 + name + \x27=\x22\x27 + value + \x27\x22\x27;\x0a\x09\x09\x09});\x0a\x0a\x09\x09\x09// If the tag is marked as `single` or `self-closing`, close the\x0a\x09\x09\x09// tag and ignore any additional content.\x0a\x09\x09\x09if ( \x27single\x27 === this.type ) {\x0a\x09\x09\x09\x09return text + \x27]\x27;\x0a\x09\x09\x09} else if ( \x27self-closing\x27 === this.type ) {\x0a\x09\x09\x09\x09return text + \x27 /]\x27;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Complete the opening tag.\x0a\x09\x09\x09text += \x27]\x27;\x0a\x0a\x09\x09\x09if ( this.content ) {\x0a\x09\x09\x09\x09text += this.content;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Add the closing tag.\x0a\x09\x09\x09return text + \x27[/\x27 + this.tag + \x27]\x27;\x0a\x09\x09}\x0a\x09});\x0a}());\x0a\x0a// HTML utility functions\x0a// ----------------------\x0a//\x0a// Experimental. These functions may change or be removed in the future.\x0a(function(){\x0a\x09wp.html = _.extend( wp.html || {}, {\x0a\x09\x09// ### Parse HTML attributes.\x0a\x09\x09//\x0a\x09\x09// Converts `content` to a set of parsed HTML attributes.\x0a\x09\x09// Utilizes `wp.shortcode.attrs( content )`, which is a valid superset of\x0a\x09\x09// the HTML attribute specification. Reformats the attributes into an\x0a\x09\x09// object that contains the `attrs` with `key:value` mapping, and a record\x0a\x09\x09// of the attributes that were entered using `empty` attribute syntax (i.e.\x0a\x09\x09// with no value).\x0a\x09\x09attrs: function( content ) {\x0a\x09\x09\x09var result, attrs;\x0a\x0a\x09\x09\x09// If `content` ends in a slash, strip it.\x0a\x09\x09\x09if ( \x27/\x27 === content[ content.length - 1 ] ) {\x0a\x09\x09\x09\x09content = content.slice( 0, -1 );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09result = wp.shortcode.attrs( content );\x0a\x09\x09\x09attrs  = result.named;\x0a\x0a\x09\x09\x09_.each( result.numeric, function( key ) {\x0a\x09\x09\x09\x09if ( /\x5cs/.test( key ) ) {\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09attrs[ key ] = \x27\x27;\x0a\x09\x09\x09});\x0a\x0a\x09\x09\x09return attrs;\x0a\x09\x09},\x0a\x0a\x09\x09// ### Convert an HTML-representation of an object to a string.\x0a\x09\x09string: function( options ) {\x0a\x09\x09\x09var text = \x27\x3c\x27 + options.tag,\x0a\x09\x09\x09\x09content = options.content || \x27\x27;\x0a\x0a\x09\x09\x09_.each( options.attrs, function( value, attr ) {\x0a\x09\x09\x09\x09text += \x27 \x27 + attr;\x0a\x0a\x09\x09\x09\x09// Convert boolean values to strings.\x0a\x09\x09\x09\x09if ( _.isBoolean( value ) ) {\x0a\x09\x09\x09\x09\x09value = value ? \x27true\x27 : \x27false\x27;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09text += \x27=\x22\x27 + value + \x27\x22\x27;\x0a\x09\x09\x09});\x0a\x0a\x09\x09\x09// Return the result if it is a self-closing tag.\x0a\x09\x09\x09if ( options.single ) {\x0a\x09\x09\x09\x09return text + \x27 /\x3e\x27;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Complete the opening tag.\x0a\x09\x09\x09text += \x27\x3e\x27;\x0a\x0a\x09\x09\x09// If `content` is an object, recursively call this function.\x0a\x09\x09\x09text += _.isObject( content ) ? wp.html.string( content ) : content;\x0a\x0a\x09\x09\x09return text + \x27\x3c/\x27 + options.tag + \x27\x3e\x27;\x0a\x09\x09}\x0a\x09});\x0a}());\x0a'}