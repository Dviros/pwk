var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 17:44:58 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Fri, 14 Dec 2018 02:33:41 GMT\x0aETag: \x2214eb-57cf2425eeb40-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-1721/1722\x0aContent-Length: 1722\x0aKeep-Alive: timeout=5, max=28\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a(function() {\x0a\x0a\x09/**\x0a\x09 * Debounce\x0a\x09 *\x0a\x09 * @param {Function} func\x0a\x09 * @param {number} wait\x0a\x09 * @param {boolean} immediate\x0a\x09 */\x0a\x09function debounce(func, wait, immediate) {\x0a\x09\x09\x27use strict\x27;\x0a\x0a\x09\x09var timeout;\x0a\x09\x09wait      = (typeof wait !== \x27undefined\x27) ? wait : 20;\x0a\x09\x09immediate = (typeof immediate !== \x27undefined\x27) ? immediate : true;\x0a\x0a\x09\x09return function() {\x0a\x0a\x09\x09\x09var context = this, args = arguments;\x0a\x09\x09\x09var later = function() {\x0a\x09\x09\x09\x09timeout = null;\x0a\x0a\x09\x09\x09\x09if (!immediate) {\x0a\x09\x09\x09\x09\x09func.apply(context, args);\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09};\x0a\x0a\x09\x09\x09var callNow = immediate && !timeout;\x0a\x0a\x09\x09\x09clearTimeout(timeout);\x0a\x09\x09\x09timeout = setTimeout(later, wait);\x0a\x0a\x09\x09\x09if (callNow) {\x0a\x09\x09\x09\x09func.apply(context, args);\x0a\x09\x09\x09}\x0a\x09\x09};\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Prepends an element to a container.\x0a\x09 *\x0a\x09 * @param {Element} container\x0a\x09 * @param {Element} element\x0a\x09 */\x0a\x09function prependElement(container, element) {\x0a\x09\x09if (container.firstChild.nextSibling) {\x0a\x09\x09\x09return container.insertBefore(element, container.firstChild.nextSibling);\x0a\x09\x09} else {\x0a\x09\x09\x09return container.appendChild(element);\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Shows an element by adding a hidden className.\x0a\x09 *\x0a\x09 * @param {Element} element\x0a\x09 */\x0a\x09function showButton(element) {\x0a\x09\x09// classList.remove is not supported in IE11\x0a\x09\x09element.className = element.className.replace(\x27is-empty\x27, \x27\x27);\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Hides an element by removing the hidden className.\x0a\x09 *\x0a\x09 * @param {Element} element\x0a\x09 */\x0a\x09function hideButton(element) {\x0a\x09\x09// classList.add is not supported in IE11\x0a\x09\x09if (!element.classList.contains(\x27is-empty\x27)) {\x0a\x09\x09\x09element.className += \x27 is-empty\x27;\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Returns the currently available space in the menu container.\x0a\x09 *\x0a\x09 * @returns {number} Available space\x0a\x09 */\x0a\x09function getAvailableSpace( button, container ) {\x0a\x09\x09return container.offsetWidth - button.offsetWidth - 22;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Returns whether the current menu is overflowing or not.\x0a\x09 *\x0a\x09 * @returns {boolean} Is overflowing\x0a\x09 */\x0a\x09function isOverflowingNavivation( list, button, container ) {\x0a\x09\x09return list.offsetWidth \x3e getAvailableSpace( button, container );\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Set menu container variable\x0a\x09 */\x0a\x09var navContainer = document.querySelector(\x27.main-navigation\x27);\x0a\x09var breaks       = [];\x0a\x0a\x09/**\x0a\x09 * Let\xe2\x80\x99s bail if we our menu doesn\x27t exist\x0a\x09 */\x0a\x09if ( ! navContainer ) {\x0a\x09\x09return;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Refreshes the list item from the menu depending on the menu size\x0a\x09 */\x0a\x09function updateNavigationMenu( container ) {\x0a\x0a\x09\x09/**\x0a\x09\x09 * Let\xe2\x80\x99s bail if our menu is empty\x0a\x09\x09 */\x0a\x09\x09if ( ! container.parentNode.querySelector(\x27.main-menu[id]\x27) ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09// Adds the necessary UI to operate the menu.\x0a\x09\x09var visibleList  = container.parentNode.querySelector(\x27.main-menu[id]\x27);\x0a\x09\x09var hiddenList   = visibleList.parentNode.nextElementSibling.querySelector(\x27.hidden-links\x27);\x0a\x09\x09var toggleButton = visibleList.parentNode.nextElementSibling.querySelector(\x27.main-menu-more-toggle\x27);\x0a\x0a\x09\x09if ( isOverflowingNavivation( visibleList, toggleButton, container ) ) {\x0a\x0a\x09\x09\x09// Record the width of the list\x0a\x09\x09\x09breaks.push( visibleList.offsetWidth );\x0a\x09\x09\x09// Move last item to the hidden list\x0a\x09\x09\x09prependElement( hiddenList, ! visibleList.lastChild || null === visibleList.lastChild ? visibleList.previousElementSibling : visibleList.lastChild );\x0a\x09\x09\x09// Show the toggle button\x0a\x09\x09\x09showButton( toggleButton );\x0a\x0a\x09\x09} else {\x0a\x0a\x09\x09\x09// There is space for another item in the nav\x0a\x09\x09\x09if ( getAvailableSpace( toggleButton, container ) \x3e breaks[breaks.length - 1] ) {\x0a\x09\x09\x09\x09// Move the item to the visible list\x0a\x09\x09\x09\x09visibleList.appendChild( hiddenList.firstChild.nextSibling );\x0a\x09\x09\x09\x09breaks.pop();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Hide the dropdown btn if hidden list is empty\x0a\x09\x09\x09if (breaks.length \x3c 2) {\x0a\x09\x09\x09\x09hideButton( toggleButton );\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09// Recur if the visible list is still overflowing the nav\x0a\x09\x09if ( isOverflowingNavivation( visibleList, toggleButton, container ) ) {\x0a\x09\x09\x09updateNavigationMenu( container );\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Run our priority+ function as soon as the document is `ready`\x0a\x09 */\x0a\x09document.addEventListener( \x27DOMContentLoaded\x27, function() {\x0a\x0a\x09\x09updateNavigationMenu( navContainer );\x0a\x0a\x09\x09// Also, run our priority+ function on selective refresh in the customizer\x0a\x09\x09var hasSelectiveRefresh = (\x0a\x09\x09\x09\x27undefined\x27 !== typeof wp &&\x0a\x09\x09\x09wp.customize &&\x0a\x09\x09\x09wp.customize.selectiveRefresh &&\x0a\x09\x09\x09wp.customize.navMenusPreview.NavMenuInstancePartial\x0a\x09\x09);\x0a\x0a\x09\x09if ( hasSelectiveRefresh ) {\x0a\x09\x09\x09// Re-run our priority+ function on Nav Menu partial refreshes\x0a\x09\x09\x09wp.customize.selectiveRefresh.bind( \x27partial-content-rendered\x27, function ( placement ) {\x0a\x0a\x09\x09\x09\x09var isNewNavMenu = (\x0a\x09\x09\x09\x09\x09placement &&\x0a\x09\x09\x09\x09\x09placement.partial.id.includes( \x27nav_menu_instance\x27 ) &&\x0a\x09\x09\x09\x09\x09\x27null\x27 !== placement.container[0].parentNode &&\x0a\x09\x09\x09\x09\x09placement.container[0].parentNode.classList.contains( \x27main-navigation\x27 )\x0a\x09\x09\x09\x09);\x0a\x0a\x09\x09\x09\x09if ( isNewNavMenu ) {\x0a\x09\x09\x09\x09\x09updateNavigationMenu( placement.container[0].parentNode );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09});\x0a        }\x0a\x09});\x0a\x0a\x09/**\x0a\x09 * Run our priority+ function on load\x0a\x09 */\x0a\x09window.addEventListener( \x27load\x27, function() {\x0a\x09\x09updateNavigationMenu( navContainer );\x0a\x09});\x0a\x0a\x09/**\x0a\x09 * Run our priority+ function every time the window resizes\x0a\x09 */\x0a\x09var isResizing = false;\x0a\x09window.addEventListener( \x27resize\x27,\x0a\x09\x09debounce( function() {\x0a\x09\x09\x09if ( isResizing ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09isResizing = true;\x0a\x09\x09\x09setTimeout( function() {\x0a\x09\x09\x09\x09updateNavigationMenu( navContainer );\x0a\x09\x09\x09\x09isResizing = false;\x0a\x09\x09\x09}, 150 );\x0a\x09\x09} )\x0a\x09);\x0a\x0a\x09/**\x0a\x09 * Run our priority+ function\x0a\x09 */\x0a\x09updateNavigationMenu( navContainer );\x0a\x0a})();\x0a'}