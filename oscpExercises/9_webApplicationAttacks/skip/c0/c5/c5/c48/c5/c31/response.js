var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:10:31 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Mon, 22 Apr 2019 12:40:04 GMT\x0aETag: \x2221a37-5871dc47ed100-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-32077/32078\x0aContent-Length: 32078\x0aKeep-Alive: timeout=5, max=90\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0athis[\x22wp\x22] = this[\x22wp\x22] || {}; this[\x22wp\x22][\x22data\x22] =\x0a/******/ (function(modules) { // webpackBootstrap\x0a/******/ \x09// The module cache\x0a/******/ \x09var installedModules = {};\x0a/******/\x0a/******/ \x09// The require function\x0a/******/ \x09function __webpack_require__(moduleId) {\x0a/******/\x0a/******/ \x09\x09// Check if module is in cache\x0a/******/ \x09\x09if(installedModules[moduleId]) {\x0a/******/ \x09\x09\x09return installedModules[moduleId].exports;\x0a/******/ \x09\x09}\x0a/******/ \x09\x09// Create a new module (and put it into the cache)\x0a/******/ \x09\x09var module = installedModules[moduleId] = {\x0a/******/ \x09\x09\x09i: moduleId,\x0a/******/ \x09\x09\x09l: false,\x0a/******/ \x09\x09\x09exports: {}\x0a/******/ \x09\x09};\x0a/******/\x0a/******/ \x09\x09// Execute the module function\x0a/******/ \x09\x09modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\x0a/******/\x0a/******/ \x09\x09// Flag the module as loaded\x0a/******/ \x09\x09module.l = true;\x0a/******/\x0a/******/ \x09\x09// Return the exports of the module\x0a/******/ \x09\x09return module.exports;\x0a/******/ \x09}\x0a/******/\x0a/******/\x0a/******/ \x09// expose the modules object (__webpack_modules__)\x0a/******/ \x09__webpack_require__.m = modules;\x0a/******/\x0a/******/ \x09// expose the module cache\x0a/******/ \x09__webpack_require__.c = installedModules;\x0a/******/\x0a/******/ \x09// define getter function for harmony exports\x0a/******/ \x09__webpack_require__.d = function(exports, name, getter) {\x0a/******/ \x09\x09if(!__webpack_require__.o(exports, name)) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, name, { enumerable: true, get: getter });\x0a/******/ \x09\x09}\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// define __esModule on exports\x0a/******/ \x09__webpack_require__.r = function(exports) {\x0a/******/ \x09\x09if(typeof Symbol !== \x27undefined\x27 && Symbol.toStringTag) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, Symbol.toStringTag, { value: \x27Module\x27 });\x0a/******/ \x09\x09}\x0a/******/ \x09\x09Object.defineProperty(exports, \x27__esModule\x27, { value: true });\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// create a fake namespace object\x0a/******/ \x09// mode & 1: value is a module id, require it\x0a/******/ \x09// mode & 2: merge all properties of value into the ns\x0a/******/ \x09// mode & 4: return value when already ns object\x0a/******/ \x09// mode & 8|1: behave like require\x0a/******/ \x09__webpack_require__.t = function(value, mode) {\x0a/******/ \x09\x09if(mode & 1) value = __webpack_require__(value);\x0a/******/ \x09\x09if(mode & 8) return value;\x0a/******/ \x09\x09if((mode & 4) && typeof value === \x27object\x27 && value && value.__esModule) return value;\x0a/******/ \x09\x09var ns = Object.create(null);\x0a/******/ \x09\x09__webpack_require__.r(ns);\x0a/******/ \x09\x09Object.defineProperty(ns, \x27default\x27, { enumerable: true, value: value });\x0a/******/ \x09\x09if(mode & 2 && typeof value != \x27string\x27) for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\x0a/******/ \x09\x09return ns;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// getDefaultExport function for compatibility with non-harmony modules\x0a/******/ \x09__webpack_require__.n = function(module) {\x0a/******/ \x09\x09var getter = module && module.__esModule ?\x0a/******/ \x09\x09\x09function getDefault() { return module[\x27default\x27]; } :\x0a/******/ \x09\x09\x09function getModuleExports() { return module; };\x0a/******/ \x09\x09__webpack_require__.d(getter, \x27a\x27, getter);\x0a/******/ \x09\x09return getter;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// Object.prototype.hasOwnProperty.call\x0a/******/ \x09__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\x0a/******/\x0a/******/ \x09// __webpack_public_path__\x0a/******/ \x09__webpack_require__.p = \x22\x22;\x0a/******/\x0a/******/\x0a/******/ \x09// Load entry module and return exports\x0a/******/ \x09return __webpack_require__(__webpack_require__.s = 363);\x0a/******/ })\x0a/************************************************************************/\x0a/******/ ({\x0a\x0a/***/ 0:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22element\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 10:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _classCallCheck; });\x0afunction _classCallCheck(instance, Constructor) {\x0a  if (!(instance instanceof Constructor)) {\x0a    throw new TypeError(\x22Cannot call a class as a function\x22);\x0a  }\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 100:\x0a/***/ (function(module, exports) {\x0a\x0amodule.exports = isPromise;\x0a\x0afunction isPromise(obj) {\x0a  return !!obj && (typeof obj === \x27object\x27 || typeof obj === \x27function\x27) && typeof obj.then === \x27function\x27;\x0a}\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 11:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _possibleConstructorReturn; });\x0a/* harmony import */ var _helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32);\x0a/* harmony import */ var _assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\x0a\x0a\x0afunction _possibleConstructorReturn(self, call) {\x0a  if (call && (Object(_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22])(call) === \x22object\x22 || typeof call === \x22function\x22)) {\x0a    return call;\x0a  }\x0a\x0a  return Object(_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[/* default */ \x22a\x22])(self);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 12:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _getPrototypeOf; });\x0afunction _getPrototypeOf(o) {\x0a  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\x0a    return o.__proto__ || Object.getPrototypeOf(o);\x0a  };\x0a  return _getPrototypeOf(o);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 13:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\x0afunction _setPrototypeOf(o, p) {\x0a  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\x0a    o.__proto__ = p;\x0a    return o;\x0a  };\x0a\x0a  return _setPrototypeOf(o, p);\x0a}\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _inherits; });\x0a\x0afunction _inherits(subClass, superClass) {\x0a  if (typeof superClass !== \x22function\x22 && superClass !== null) {\x0a    throw new TypeError(\x22Super expression must either be null or a function\x22);\x0a  }\x0a\x0a  subClass.prototype = Object.create(superClass && superClass.prototype, {\x0a    constructor: {\x0a      value: subClass,\x0a      writable: true,\x0a      configurable: true\x0a    }\x0a  });\x0a  if (superClass) _setPrototypeOf(subClass, superClass);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 132:\x0a/***/ (function(module, exports) {\x0a\x0amodule.exports = function(originalModule) {\x0a\x09if (!originalModule.webpackPolyfill) {\x0a\x09\x09var module = Object.create(originalModule);\x0a\x09\x09// module.parent = undefined by default\x0a\x09\x09if (!module.children) module.children = [];\x0a\x09\x09Object.defineProperty(module, \x22loaded\x22, {\x0a\x09\x09\x09enumerable: true,\x0a\x09\x09\x09get: function() {\x0a\x09\x09\x09\x09return module.l;\x0a\x09\x09\x09}\x0a\x09\x09});\x0a\x09\x09Object.defineProperty(module, \x22id\x22, {\x0a\x09\x09\x09enumerable: true,\x0a\x09\x09\x09get: function() {\x0a\x09\x09\x09\x09return module.i;\x0a\x09\x09\x09}\x0a\x09\x09});\x0a\x09\x09Object.defineProperty(module, \x22exports\x22, {\x0a\x09\x09\x09enumerable: true\x0a\x09\x09});\x0a\x09\x09module.webpackPolyfill = 1;\x0a\x09}\x0a\x09return module;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 15:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _defineProperty; });\x0afunction _defineProperty(obj, key, value) {\x0a  if (key in obj) {\x0a    Object.defineProperty(obj, key, {\x0a      value: value,\x0a      enumerable: true,\x0a      configurable: true,\x0a      writable: true\x0a    });\x0a  } else {\x0a    obj[key] = value;\x0a  }\x0a\x0a  return obj;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 17:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\x0afunction _arrayWithoutHoles(arr) {\x0a  if (Array.isArray(arr)) {\x0a    for (var i = 0, arr2 = new Array(arr.length); i \x3c arr.length; i++) {\x0a      arr2[i] = arr[i];\x0a    }\x0a\x0a    return arr2;\x0a  }\x0a}\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js\x0avar iterableToArray = __webpack_require__(34);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\x0afunction _nonIterableSpread() {\x0a  throw new TypeError(\x22Invalid attempt to spread non-iterable instance\x22);\x0a}\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _toConsumableArray; });\x0a\x0a\x0a\x0afunction _toConsumableArray(arr) {\x0a  return _arrayWithoutHoles(arr) || Object(iterableToArray[\x22a\x22 /* default */])(arr) || _nonIterableSpread();\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 19:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _extends; });\x0afunction _extends() {\x0a  _extends = Object.assign || function (target) {\x0a    for (var i = 1; i \x3c arguments.length; i++) {\x0a      var source = arguments[i];\x0a\x0a      for (var key in source) {\x0a        if (Object.prototype.hasOwnProperty.call(source, key)) {\x0a          target[key] = source[key];\x0a        }\x0a      }\x0a    }\x0a\x0a    return target;\x0a  };\x0a\x0a  return _extends.apply(this, arguments);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 197:\x0a/***/ (function(module, exports) {\x0a\x0afunction combineReducers( reducers ) {\x0a\x09var keys = Object.keys( reducers ),\x0a\x09\x09getNextState;\x0a\x0a\x09getNextState = ( function() {\x0a\x09\x09var fn, i, key;\x0a\x0a\x09\x09fn = \x27return {\x27;\x0a\x09\x09for ( i = 0; i \x3c keys.length; i++ ) {\x0a\x09\x09\x09// Rely on Quoted escaping of JSON.stringify with guarantee that\x0a\x09\x09\x09// each member of Object.keys is a string.\x0a\x09\x09\x09//\x0a\x09\x09\x09// \x22If Type(value) is String, then return the result of calling the\x0a\x09\x09\x09// abstract operation Quote with argument value. [...] The abstract\x0a\x09\x09\x09// operation Quote(value) wraps a String value in double quotes and\x0a\x09\x09\x09// escapes characters within it.\x22\x0a\x09\x09\x09//\x0a\x09\x09\x09// https://www.ecma-international.org/ecma-262/5.1/#sec-15.12.3\x0a\x09\x09\x09key = JSON.stringify( keys[ i ] );\x0a\x0a\x09\x09\x09fn += key + \x27:r[\x27 + key + \x27](s[\x27 + key + \x27],a),\x27;\x0a\x09\x09}\x0a\x09\x09fn += \x27}\x27;\x0a\x0a\x09\x09return new Function( \x27r,s,a\x27, fn );\x0a\x09} )();\x0a\x0a\x09return function combinedReducer( state, action ) {\x0a\x09\x09var nextState, i, key;\x0a\x0a\x09\x09// Assumed changed if initial state.\x0a\x09\x09if ( state === undefined ) {\x0a\x09\x09\x09return getNextState( reducers, {}, action );\x0a\x09\x09}\x0a\x0a\x09\x09nextState = getNextState( reducers, state, action );\x0a\x0a\x09\x09// Determine whether state has changed.\x0a\x09\x09i = keys.length;\x0a\x09\x09while ( i-- ) {\x0a\x09\x09\x09key = keys[ i ];\x0a\x09\x09\x09if ( state[ key ] !== nextState[ key ] ) {\x0a\x09\x09\x09\x09// Return immediately if a changed value is encountered.\x0a\x09\x09\x09\x09return nextState;\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09return state;\x0a\x09};\x0a}\x0a\x0amodule.exports = combineReducers;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 2:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22lodash\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 224:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22reduxRoutine\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 225:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22priorityQueue\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 23:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0amodule.exports = __webpack_require__(54);\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 28:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\x0avar arrayWithHoles = __webpack_require__(37);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\x0afunction _iterableToArrayLimit(arr, i) {\x0a  var _arr = [];\x0a  var _n = true;\x0a  var _d = false;\x0a  var _e = undefined;\x0a\x0a  try {\x0a    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\x0a      _arr.push(_s.value);\x0a\x0a      if (i && _arr.length === i) break;\x0a    }\x0a  } catch (err) {\x0a    _d = true;\x0a    _e = err;\x0a  } finally {\x0a    try {\x0a      if (!_n && _i[\x22return\x22] != null) _i[\x22return\x22]();\x0a    } finally {\x0a      if (_d) throw _e;\x0a    }\x0a  }\x0a\x0a  return _arr;\x0a}\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\x0avar nonIterableRest = __webpack_require__(38);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _slicedToArray; });\x0a\x0a\x0a\x0afunction _slicedToArray(arr, i) {\x0a  return Object(arrayWithHoles[\x22a\x22 /* default */])(arr) || _iterableToArrayLimit(arr, i) || Object(nonIterableRest[\x22a\x22 /* default */])();\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 3:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _assertThisInitialized; });\x0afunction _assertThisInitialized(self) {\x0a  if (self === void 0) {\x0a    throw new ReferenceError(\x22this hasn\x27t been initialised - super() hasn\x27t been called\x22);\x0a  }\x0a\x0a  return self;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 32:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _typeof; });\x0afunction _typeof2(obj) { if (typeof Symbol === \x22function\x22 && typeof Symbol.iterator === \x22symbol\x22) { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \x22function\x22 && obj.constructor === Symbol && obj !== Symbol.prototype ? \x22symbol\x22 : typeof obj; }; } return _typeof2(obj); }\x0a\x0afunction _typeof(obj) {\x0a  if (typeof Symbol === \x22function\x22 && _typeof2(Symbol.iterator) === \x22symbol\x22) {\x0a    _typeof = function _typeof(obj) {\x0a      return _typeof2(obj);\x0a    };\x0a  } else {\x0a    _typeof = function _typeof(obj) {\x0a      return obj && typeof Symbol === \x22function\x22 && obj.constructor === Symbol && obj !== Symbol.prototype ? \x22symbol\x22 : _typeof2(obj);\x0a    };\x0a  }\x0a\x0a  return _typeof(obj);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 34:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _iterableToArray; });\x0afunction _iterableToArray(iter) {\x0a  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \x22[object Arguments]\x22) return Array.from(iter);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 363:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0avar selectors_namespaceObject = {};\x0a__webpack_require__.r(selectors_namespaceObject);\x0a__webpack_require__.d(selectors_namespaceObject, \x22getIsResolving\x22, function() { return getIsResolving; });\x0a__webpack_require__.d(selectors_namespaceObject, \x22hasStartedResolution\x22, function() { return hasStartedResolution; });\x0a__webpack_require__.d(selectors_namespaceObject, \x22hasFinishedResolution\x22, function() { return hasFinishedResolution; });\x0a__webpack_require__.d(selectors_namespaceObject, \x22isResolving\x22, function() { return isResolving; });\x0a__webpack_require__.d(selectors_namespaceObject, \x22getCachedResolvers\x22, function() { return getCachedResolvers; });\x0avar actions_namespaceObject = {};\x0a__webpack_require__.r(actions_namespaceObject);\x0a__webpack_require__.d(actions_namespaceObject, \x22startResolution\x22, function() { return startResolution; });\x0a__webpack_require__.d(actions_namespaceObject, \x22finishResolution\x22, function() { return finishResolution; });\x0a__webpack_require__.d(actions_namespaceObject, \x22invalidateResolution\x22, function() { return invalidateResolution; });\x0a__webpack_require__.d(actions_namespaceObject, \x22invalidateResolutionForStore\x22, function() { return invalidateResolutionForStore; });\x0a__webpack_require__.d(actions_namespaceObject, \x22invalidateResolutionForStoreSelector\x22, function() { return invalidateResolutionForStoreSelector; });\x0avar plugins_namespaceObject = {};\x0a__webpack_require__.r(plugins_namespaceObject);\x0a__webpack_require__.d(plugins_namespaceObject, \x22controls\x22, function() { return controls; });\x0a__webpack_require__.d(plugins_namespaceObject, \x22persistence\x22, function() { return plugins_persistence; });\x0a\x0a// EXTERNAL MODULE: ./node_modules/turbo-combine-reducers/index.js\x0avar turbo_combine_reducers = __webpack_require__(197);\x0avar turbo_combine_reducers_default = /*#__PURE__*/__webpack_require__.n(turbo_combine_reducers);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 1 modules\x0avar slicedToArray = __webpack_require__(28);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread.js\x0avar objectSpread = __webpack_require__(7);\x0a\x0a// EXTERNAL MODULE: external \x22lodash\x22\x0avar external_lodash_ = __webpack_require__(2);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\x0avar regenerator = __webpack_require__(23);\x0avar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\x0avar asyncToGenerator = __webpack_require__(44);\x0a\x0a// EXTERNAL MODULE: ./node_modules/redux/es/redux.js\x0avar redux = __webpack_require__(71);\x0a\x0a// EXTERNAL MODULE: ./node_modules/is-promise/index.js\x0avar is_promise = __webpack_require__(100);\x0avar is_promise_default = /*#__PURE__*/__webpack_require__.n(is_promise);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/promise-middleware.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Simplest possible promise redux middleware.\x0a *\x0a * @return {function} middleware.\x0a */\x0a\x0avar promise_middleware_promiseMiddleware = function promiseMiddleware() {\x0a  return function (next) {\x0a    return function (action) {\x0a      if (is_promise_default()(action)) {\x0a        return action.then(function (resolvedAction) {\x0a          if (resolvedAction) {\x0a            return next(resolvedAction);\x0a          }\x0a        });\x0a      }\x0a\x0a      return next(action);\x0a    };\x0a  };\x0a};\x0a\x0a/* harmony default export */ var promise_middleware = (promise_middleware_promiseMiddleware);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules\x0avar toConsumableArray = __webpack_require__(17);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/resolvers-cache-middleware.js\x0a\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * creates a middleware handling resolvers cache invalidation.\x0a *\x0a * @param {Object} registry\x0a * @param {string} reducerKey\x0a *\x0a * @return {function} middleware\x0a */\x0a\x0avar resolvers_cache_middleware_createResolversCacheMiddleware = function createResolversCacheMiddleware(registry, reducerKey) {\x0a  return function () {\x0a    return function (next) {\x0a      return function (action) {\x0a        var resolvers = registry.select(\x27core/data\x27).getCachedResolvers(reducerKey);\x0a        Object.entries(resolvers).forEach(function (_ref) {\x0a          var _ref2 = Object(slicedToArray[\x22a\x22 /* default */])(_ref, 2),\x0a              selectorName = _ref2[0],\x0a              resolversByArgs = _ref2[1];\x0a\x0a          var resolver = Object(external_lodash_[\x22get\x22])(registry.namespaces, [reducerKey, \x27resolvers\x27, selectorName]);\x0a\x0a          if (!resolver || !resolver.shouldInvalidate) {\x0a            return;\x0a          }\x0a\x0a          resolversByArgs.forEach(function (value, args) {\x0a            // resolversByArgs is the map Map([ args ] =\x3e boolean) storing the cache resolution status for a given selector.\x0a            // If the value is false it means this resolver has finished its resolution which means we need to invalidate it,\x0a            // if it\x27s true it means it\x27s inflight and the invalidation is not necessary.\x0a            if (value !== false || !resolver.shouldInvalidate.apply(resolver, [action].concat(Object(toConsumableArray[\x22a\x22 /* default */])(args)))) {\x0a              return;\x0a            } // Trigger cache invalidation\x0a\x0a\x0a            registry.dispatch(\x27core/data\x27).invalidateResolution(reducerKey, selectorName, args);\x0a          });\x0a        });\x0a        next(action);\x0a      };\x0a    };\x0a  };\x0a};\x0a\x0a/* harmony default export */ var resolvers_cache_middleware = (resolvers_cache_middleware_createResolversCacheMiddleware);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/namespace-store.js\x0a\x0a\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * Creates a namespace object with a store derived from the reducer given.\x0a *\x0a * @param {string} key              Identifying string used for namespace and redex dev tools.\x0a * @param {Object} options          Contains reducer, actions, selectors, and resolvers.\x0a * @param {Object} registry         Registry reference.\x0a *\x0a * @return {Object} Store Object.\x0a */\x0a\x0afunction createNamespace(key, options, registry) {\x0a  var reducer = options.reducer;\x0a  var store = createReduxStore(key, options, registry);\x0a  var selectors, actions, resolvers;\x0a\x0a  if (options.actions) {\x0a    actions = mapActions(options.actions, store);\x0a  }\x0a\x0a  if (options.selectors) {\x0a    selectors = mapSelectors(options.selectors, store, registry);\x0a  }\x0a\x0a  if (options.resolvers) {\x0a    var fulfillment = getCoreDataFulfillment(registry, key);\x0a    var result = mapResolvers(options.resolvers, selectors, fulfillment, store);\x0a    resolvers = result.resolvers;\x0a    selectors = result.selectors;\x0a  }\x0a\x0a  var getSelectors = function getSelectors() {\x0a    return selectors;\x0a  };\x0a\x0a  var getActions = function getActions() {\x0a    return actions;\x0a  }; // Customize subscribe behavior to call listeners only on effective change,\x0a  // not on every dispatch.\x0a\x0a\x0a  var subscribe = store && function (listener) {\x0a    var lastState = store.getState();\x0a    store.subscribe(function () {\x0a      var state = store.getState();\x0a      var hasChanged = state !== lastState;\x0a      lastState = state;\x0a\x0a      if (hasChanged) {\x0a        listener();\x0a      }\x0a    });\x0a  }; // This can be simplified to just { subscribe, getSelectors, getActions }\x0a  // Once we remove the use function.\x0a\x0a\x0a  return {\x0a    reducer: reducer,\x0a    store: store,\x0a    actions: actions,\x0a    selectors: selectors,\x0a    resolvers: resolvers,\x0a    getSelectors: getSelectors,\x0a    getActions: getActions,\x0a    subscribe: subscribe\x0a  };\x0a}\x0a/**\x0a * Creates a redux store for a namespace.\x0a *\x0a * @param {string} key      Part of the state shape to register the\x0a *                          selectors for.\x0a * @param {Object} options  Registered store options.\x0a * @param {Object} registry Registry reference, for resolver enhancer support.\x0a *\x0a * @return {Object} Newly created redux store.\x0a */\x0a\x0afunction createReduxStore(key, options, registry) {\x0a  var enhancers = [Object(redux[\x22a\x22 /* applyMiddleware */])(resolvers_cache_middleware(registry, key), promise_middleware)];\x0a\x0a  if (typeof window !== \x27undefined\x27 && window.__REDUX_DEVTOOLS_EXTENSION__) {\x0a    enhancers.push(window.__REDUX_DEVTOOLS_EXTENSION__({\x0a      name: key,\x0a      instanceId: key\x0a    }));\x0a  }\x0a\x0a  var reducer = options.reducer,\x0a      initialState = options.initialState;\x0a  return Object(redux[\x22c\x22 /* createStore */])(reducer, initialState, Object(external_lodash_[\x22flowRight\x22])(enhancers));\x0a}\x0a/**\x0a * Maps selectors to a redux store.\x0a *\x0a * @param {Object} selectors  Selectors to register. Keys will be used as the\x0a *                            public facing API. Selectors will get passed the\x0a *                            state as first argument.\x0a * @param {Object} store      The redux store to which the selectors should be mapped.\x0a * @param {Object} registry   Registry reference.\x0a *\x0a * @return {Object}           Selectors mapped to the redux store provided.\x0a */\x0a\x0a\x0afunction mapSelectors(selectors, store, registry) {\x0a  var createStateSelector = function createStateSelector(registeredSelector) {\x0a    var selector = registeredSelector.isRegistrySelector ? registeredSelector(registry.select) : registeredSelector;\x0a    return function runSelector() {\x0a      // This function is an optimized implementation of:\x0a      //\x0a      //   selector( store.getState(), ...arguments )\x0a      //\x0a      // Where the above would incur an `Array#concat` in its application,\x0a      // the logic here instead efficiently constructs an arguments array via\x0a      // direct assignment.\x0a      var argsLength = arguments.length;\x0a      var args = new Array(argsLength + 1);\x0a      args[0] = store.getState();\x0a\x0a      for (var i = 0; i \x3c argsLength; i++) {\x0a        args[i + 1] = arguments[i];\x0a      }\x0a\x0a      return selector.apply(void 0, args);\x0a    };\x0a  };\x0a\x0a  return Object(external_lodash_[\x22mapValues\x22])(selectors, createStateSelector);\x0a}\x0a/**\x0a * Maps actions to dispatch from a given store.\x0a *\x0a * @param {Object} actions    Actions to register.\x0a * @param {Object} store      The redux store to which the actions should be mapped.\x0a * @return {Object}           Actions mapped to the redux store provided.\x0a */\x0a\x0a\x0afunction mapActions(actions, store) {\x0a  var createBoundAction = function createBoundAction(action) {\x0a    return function () {\x0a      return store.dispatch(action.apply(void 0, arguments));\x0a    };\x0a  };\x0a\x0a  return Object(external_lodash_[\x22mapValues\x22])(actions, createBoundAction);\x0a}\x0a/**\x0a * Returns resolvers with matched selectors for a given namespace.\x0a * Resolvers are side effects invoked once per argument set of a given selector call,\x0a * used in ensuring that the data needs for the selector are satisfied.\x0a *\x0a * @param {Object} resolvers   Resolvers to register.\x0a * @param {Object} selectors   The current selectors to be modified.\x0a * @param {Object} fulfillment Fulfillment implementation functions.\x0a * @param {Object} store       The redux store to which the resolvers should be mapped.\x0a * @return {Object}            An object containing updated selectors and resolvers.\x0a */\x0a\x0a\x0afunction mapResolvers(resolvers, selectors, fulfillment, store) {\x0a  var mapSelector = function mapSelector(selector, selectorName) {\x0a    var resolver = resolvers[selectorName];\x0a\x0a    if (!resolver) {\x0a      return selector;\x0a    }\x0a\x0a    return function () {\x0a      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key \x3c _len; _key++) {\x0a        args[_key] = arguments[_key];\x0a      }\x0a\x0a      function fulfillSelector() {\x0a        return _fulfillSelector.apply(this, arguments);\x0a      }\x0a\x0a      function _fulfillSelector() {\x0a        _fulfillSelector = Object(asyncToGenerator[\x22a\x22 /* default */])(\x0a        /*#__PURE__*/\x0a        regenerator_default.a.mark(function _callee() {\x0a          var state;\x0a          return regenerator_default.a.wrap(function _callee$(_context) {\x0a            while (1) {\x0a              switch (_context.prev = _context.next) {\x0a                case 0:\x0a                  state = store.getState();\x0a\x0a                  if (!(typeof resolver.isFulfilled === \x27function\x27 && resolver.isFulfilled.apply(resolver, [state].concat(args)))) {\x0a                    _context.next = 3;\x0a                    break;\x0a                  }\x0a\x0a                  return _context.abrupt(\x22return\x22);\x0a\x0a                case 3:\x0a                  if (!fulfillment.hasStarted(selectorName, args)) {\x0a                    _context.next = 5;\x0a                    break;\x0a                  }\x0a\x0a                  return _context.abrupt(\x22return\x22);\x0a\x0a                case 5:\x0a                  fulfillment.start(selectorName, args);\x0a                  _context.next = 8;\x0a                  return fulfillment.fulfill.apply(fulfillment, [selectorName].concat(args));\x0a\x0a                case 8:\x0a                  fulfillment.finish(selectorName, args);\x0a\x0a                case 9:\x0a                case \x22end\x22:\x0a                  return _context.stop();\x0a              }\x0a            }\x0a          }, _callee, this);\x0a        }));\x0a        return _fulfillSelector.apply(this, arguments);\x0a      }\x0a\x0a      fulfillSelector.apply(void 0, args);\x0a      return selector.apply(void 0, args);\x0a    };\x0a  };\x0a\x0a  var mappedResolvers = Object(external_lodash_[\x22mapValues\x22])(resolvers, function (resolver) {\x0a    var _resolver$fulfill = resolver.fulfill,\x0a        resolverFulfill = _resolver$fulfill === void 0 ? resolver : _resolver$fulfill;\x0a    return Object(objectSpread[\x22a\x22 /* default */])({}, resolver, {\x0a      fulfill: resolverFulfill\x0a    });\x0a  });\x0a  return {\x0a    resolvers: mappedResolvers,\x0a    selectors: Object(external_lodash_[\x22mapValues\x22])(selectors, mapSelector)\x0a  };\x0a}\x0a/**\x0a * Bundles up fulfillment functions for resolvers.\x0a * @param {Object} registry     Registry reference, for fulfilling via resolvers\x0a * @param {string} key          Part of the state shape to register the\x0a *                              selectors for.\x0a * @return {Object}             An object providing fulfillment functions.\x0a */\x0a\x0a\x0afunction getCoreDataFulfillment(registry, key) {\x0a  var _registry$select = registry.select(\x27core/data\x27),\x0a      hasStartedResolution = _registry$select.hasStartedResolution;\x0a\x0a  var _registry$dispatch = registry.dispatch(\x27core/data\x27),\x0a      startResolution = _registry$dispatch.startResolution,\x0a      finishResolution = _registry$dispatch.finishResolution;\x0a\x0a  return {\x0a    hasStarted: function hasStarted() {\x0a      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 \x3c _len2; _key2++) {\x0a        args[_key2] = arguments[_key2];\x0a      }\x0a\x0a      return hasStartedResolution.apply(void 0, [key].concat(args));\x0a    },\x0a    start: function start() {\x0a      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 \x3c _len3; _key3++) {\x0a        args[_key3] = arguments[_key3];\x0a      }\x0a\x0a      return startResolution.apply(void 0, [key].concat(args));\x0a    },\x0a    finish: function finish() {\x0a      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 \x3c _len4; _key4++) {\x0a        args[_key4] = arguments[_key4];\x0a      }\x0a\x0a      return finishResolution.apply(void 0, [key].concat(args));\x0a    },\x0a    fulfill: function fulfill() {\x0a      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 \x3c _len5; _key5++) {\x0a        args[_key5] = arguments[_key5];\x0a      }\x0a\x0a      return fulfillWithRegistry.apply(void 0, [registry, key].concat(args));\x0a    }\x0a  };\x0a}\x0a/**\x0a * Calls a resolver given arguments\x0a *\x0a * @param {Object} registry     Registry reference, for fulfilling via resolvers\x0a * @param {string} key          Part of the state shape to register the\x0a *                              selectors for.\x0a * @param {string} selectorName Selector name to fulfill.\x0a * @param {Array} args         Selector Arguments.\x0a */\x0a\x0a\x0afunction fulfillWithRegistry(_x, _x2, _x3) {\x0a  return _fulfillWithRegistry.apply(this, arguments);\x0a}\x0a\x0afunction _fulfillWithRegistry() {\x0a  _fulfillWithRegistry = Object(asyncToGenerator[\x22a\x22 /* default */])(\x0a  /*#__PURE__*/\x0a  regenerator_default.a.mark(function _callee2(registry, key, selectorName) {\x0a    var namespace,\x0a        resolver,\x0a        _len6,\x0a        args,\x0a        _key6,\x0a        action,\x0a        _args2 = arguments;\x0a\x0a    return regenerator_default.a.wrap(function _callee2$(_context2) {\x0a      while (1) {\x0a        switch (_context2.prev = _context2.next) {\x0a          case 0:\x0a            namespace = registry.stores[key];\x0a            resolver = Object(external_lodash_[\x22get\x22])(namespace, [\x27resolvers\x27, selectorName]);\x0a\x0a            if (resolver) {\x0a              _context2.next = 4;\x0a              break;\x0a            }\x0a\x0a            return _context2.abrupt(\x22return\x22);\x0a\x0a          case 4:\x0a            for (_len6 = _args2.length, args = new Array(_len6 \x3e 3 ? _len6 - 3 : 0), _key6 = 3; _key6 \x3c _len6; _key6++) {\x0a              args[_key6 - 3] = _args2[_key6];\x0a            }\x0a\x0a            action = resolver.fulfill.apply(resolver, args);\x0a\x0a            if (!action) {\x0a              _context2.next = 9;\x0a              break;\x0a            }\x0a\x0a            _context2.next = 9;\x0a            return namespace.store.dispatch(action);\x0a\x0a          case 9:\x0a          case \x22end\x22:\x0a            return _context2.stop();\x0a        }\x0a      }\x0a    }, _callee2, this);\x0a  }));\x0a  return _fulfillWithRegistry.apply(this, arguments);\x0a}\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\x0avar defineProperty = __webpack_require__(15);\x0a\x0a// EXTERNAL MODULE: ./node_modules/equivalent-key-map/equivalent-key-map.js\x0avar equivalent_key_map = __webpack_require__(76);\x0avar equivalent_key_map_default = /*#__PURE__*/__webpack_require__.n(equivalent_key_map);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/store/utils.js\x0a\x0a\x0a\x0a/**\x0a * Higher-order reducer creator which creates a combined reducer object, keyed\x0a * by a property on the action object.\x0a *\x0a * @param {string} actionProperty Action property by which to key object.\x0a *\x0a * @return {Function} Higher-order reducer.\x0a */\x0avar utils_onSubKey = function onSubKey(actionProperty) {\x0a  return function (reducer) {\x0a    return function () {\x0a      var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a      var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a      // Retrieve subkey from action. Do not track if undefined; useful for cases\x0a      // where reducer is scoped by action shape.\x0a      var key = action[actionProperty];\x0a\x0a      if (key === undefined) {\x0a        return state;\x0a      } // Avoid updating state if unchanged. Note that this also accounts for a\x0a      // reducer which returns undefined on a key which is not yet tracked.\x0a\x0a\x0a      var nextKeyState = reducer(state[key], action);\x0a\x0a      if (nextKeyState === state[key]) {\x0a        return state;\x0a      }\x0a\x0a      return Object(objectSpread[\x22a\x22 /* default */])({}, state, Object(defineProperty[\x22a\x22 /* default */])({}, key, nextKeyState));\x0a    };\x0a  };\x0a};\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/store/reducer.js\x0a\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Reducer function returning next state for selector resolution of\x0a * subkeys, object form:\x0a *\x0a *  reducerKey -\x3e selectorName -\x3e EquivalentKeyMap\x3cArray,boolean\x3e\x0a *\x0a * @param {Object} state  Current state.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @returns {Object} Next state.\x0a */\x0a\x0avar subKeysIsResolved = Object(external_lodash_[\x22flowRight\x22])([utils_onSubKey(\x27reducerKey\x27), utils_onSubKey(\x27selectorName\x27)])(function () {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : new equivalent_key_map_default.a();\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27START_RESOLUTION\x27:\x0a    case \x27FINISH_RESOLUTION\x27:\x0a      {\x0a        var isStarting = action.type === \x27START_RESOLUTION\x27;\x0a        var nextState = new equivalent_key_map_default.a(state);\x0a        nextState.set(action.args, isStarting);\x0a        return nextState;\x0a      }\x0a\x0a    case \x27INVALIDATE_RESOLUTION\x27:\x0a      {\x0a        var _nextState = new equivalent_key_map_default.a(state);\x0a\x0a        _nextState.delete(action.args);\x0a\x0a        return _nextState;\x0a      }\x0a  }\x0a\x0a  return state;\x0a});\x0a/**\x0a * Reducer function returning next state for selector resolution, object form:\x0a *\x0a *   reducerKey -\x3e selectorName -\x3e EquivalentKeyMap\x3cArray, boolean\x3e\x0a *\x0a * @param {Object} state   Current state.\x0a * @param {Object} action  Dispatched action.\x0a *\x0a * @return {Object} Next state.\x0a */\x0a\x0avar reducer_isResolved = function isResolved() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27INVALIDATE_RESOLUTION_FOR_STORE\x27:\x0a      return Object(external_lodash_[\x22has\x22])(state, action.reducerKey) ? Object(external_lodash_[\x22omit\x22])(state, [action.reducerKey]) : state;\x0a\x0a    case \x27INVALIDATE_RESOLUTION_FOR_STORE_SELECTOR\x27:\x0a      return Object(external_lodash_[\x22has\x22])(state, [action.reducerKey, action.selectorName]) ? Object(objectSpread[\x22a\x22 /* default */])({}, state, Object(defineProperty[\x22a\x22 /* default */])({}, action.reducerKey, Object(external_lodash_[\x22omit\x22])(state[action.reducerKey], [action.selectorName]))) : state;\x0a\x0a    case \x27START_RESOLUTION\x27:\x0a    case \x27FINISH_RESOLUTION\x27:\x0a    case \x27INVALIDATE_RESOLUTION\x27:\x0a      return subKeysIsResolved(state, action);\x0a  }\x0a\x0a  return state;\x0a};\x0a\x0a/* harmony default export */ var store_reducer = (reducer_isResolved);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/store/selectors.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Returns the raw `isResolving` value for a given reducer key, selector name,\x0a * and arguments set. May be undefined if the selector has never been resolved\x0a * or not resolved for the given set of arguments, otherwise true or false for\x0a * resolution started and completed respectively.\x0a *\x0a * @param {Object} state        Data state.\x0a * @param {string} reducerKey   Registered store reducer key.\x0a * @param {string} selectorName Selector name.\x0a * @param {Array}  args         Arguments passed to selector.\x0a *\x0a * @return {?boolean} isResolving value.\x0a */\x0a\x0afunction getIsResolving(state, reducerKey, selectorName, args) {\x0a  var map = Object(external_lodash_[\x22get\x22])(state, [reducerKey, selectorName]);\x0a\x0a  if (!map) {\x0a    return;\x0a  }\x0a\x0a  return map.get(args);\x0a}\x0a/**\x0a * Returns true if resolution has already been triggered for a given reducer\x0a * key, selector name, and arguments set.\x0a *\x0a * @param {Object} state        Data state.\x0a * @param {string} reducerKey   Registered store reducer key.\x0a * @param {string} selectorName Selector name.\x0a * @param {?Array} args         Arguments passed to selector (default `[]`).\x0a *\x0a * @return {boolean} Whether resolution has been triggered.\x0a */\x0a\x0afunction hasStartedResolution(state, reducerKey, selectorName) {\x0a  var args = arguments.length \x3e 3 && arguments[3] !== undefined ? arguments[3] : [];\x0a  return getIsResolving(state, reducerKey, selectorName, args) !== undefined;\x0a}\x0a/**\x0a * Returns true if resolution has completed for a given reducer key, selector\x0a * name, and arguments set.\x0a *\x0a * @param {Object} state        Data state.\x0a * @param {string} reducerKey   Registered store reducer key.\x0a * @param {string} selectorName Selector name.\x0a * @param {?Array} args         Arguments passed to selector.\x0a *\x0a * @return {boolean} Whether resolution has completed.\x0a */\x0a\x0afunction hasFinishedResolution(state, reducerKey, selectorName) {\x0a  var args = arguments.length \x3e 3 && arguments[3] !== undefined ? arguments[3] : [];\x0a  return getIsResolving(state, reducerKey, selectorName, args) === false;\x0a}\x0a/**\x0a * Returns true if resolution has been triggered but has not yet completed for\x0a * a given reducer key, selector name, and arguments set.\x0a *\x0a * @param {Object} state        Data state.\x0a * @param {string} reducerKey   Registered store reducer key.\x0a * @param {string} selectorName Selector name.\x0a * @param {?Array} args         Arguments passed to selector.\x0a *\x0a * @return {boolean} Whether resolution is in progress.\x0a */\x0a\x0afunction isResolving(state, reducerKey, selectorName) {\x0a  var args = arguments.length \x3e 3 && arguments[3] !== undefined ? arguments[3] : [];\x0a  return getIsResolving(state, reducerKey, selectorName, args) === true;\x0a}\x0a/**\x0a * Returns the list of the cached resolvers.\x0a *\x0a * @param {Object} state      Data state.\x0a * @param {string} reducerKey Registered store reducer key.\x0a *\x0a * @return {Object} Resolvers mapped by args and selectorName.\x0a */\x0a\x0afunction getCachedResolvers(state, reducerKey) {\x0a  return state.hasOwnProperty(reducerKey) ? state[reducerKey] : {};\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/store/actions.js\x0a/**\x0a * Returns an action object used in signalling that selector resolution has\x0a * started.\x0a *\x0a * @param {string} reducerKey   Registered store reducer key.\x0a * @param {string} selectorName Name of selector for which resolver triggered.\x0a * @param {...*}   args         Arguments to associate for uniqueness.\x0a *\x0a * @return {Object} Action object.\x0a */\x0afunction startResolution(reducerKey, selectorName, args) {\x0a  return {\x0a    type: \x27START_RESOLUTION\x27,\x0a    reducerKey: reducerKey,\x0a    selectorName: selectorName,\x0a    args: args\x0a  };\x0a}\x0a/**\x0a * Returns an action object used in signalling that selector resolution has\x0a * completed.\x0a *\x0a * @param {string} reducerKey   Registered store reducer key.\x0a * @param {string} selectorName Name of selector for which resolver triggered.\x0a * @param {...*}   args         Arguments to associate for uniqueness.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction finishResolution(reducerKey, selectorName, args) {\x0a  return {\x0a    type: \x27FINISH_RESOLUTION\x27,\x0a    reducerKey: reducerKey,\x0a    selectorName: selectorName,\x0a    args: args\x0a  };\x0a}\x0a/**\x0a * Returns an action object used in signalling that we should invalidate the resolution cache.\x0a *\x0a * @param {string} reducerKey   Registered store reducer key.\x0a * @param {string} selectorName Name of selector for which resolver should be invalidated.\x0a * @param {Array}  args         Arguments to associate for uniqueness.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction invalidateResolution(reducerKey, selectorName, args) {\x0a  return {\x0a    type: \x27INVALIDATE_RESOLUTION\x27,\x0a    reducerKey: reducerKey,\x0a    selectorName: selectorName,\x0a    args: args\x0a  };\x0a}\x0a/**\x0a * Returns an action object used in signalling that the resolution cache for a\x0a * given reducerKey should be invalidated.\x0a *\x0a * @param {string} reducerKey Registered store reducer key.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction invalidateResolutionForStore(reducerKey) {\x0a  return {\x0a    type: \x27INVALIDATE_RESOLUTION_FOR_STORE\x27,\x0a    reducerKey: reducerKey\x0a  };\x0a}\x0a/**\x0a * Returns an action object used in signalling that the resolution cache for a\x0a * given reducerKey and selectorName should be invalidated.\x0a *\x0a * @param {string} reducerKey   Registered store reducer key.\x0a * @param {string} selectorName Name of selector for which all resolvers should\x0a *                              be invalidated.\x0a *\x0a * @return  {Object} Action object.\x0a */\x0a\x0afunction invalidateResolutionForStoreSelector(reducerKey, selectorName) {\x0a  return {\x0a    type: \x27INVALIDATE_RESOLUTION_FOR_STORE_SELECTOR\x27,\x0a    reducerKey: reducerKey,\x0a    selectorName: selectorName\x0a  };\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/store/index.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a/* harmony default export */ var build_module_store = ({\x0a  reducer: store_reducer,\x0a  actions: actions_namespaceObject,\x0a  selectors: selectors_namespaceObject\x0a});\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/registry.js\x0a\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * An isolated orchestrator of store registrations.\x0a *\x0a * @typedef {WPDataRegistry}\x0a *\x0a * @property {Function} registerGenericStore\x0a * @property {Function} registerStore\x0a * @property {Function} subscribe\x0a * @property {Function} select\x0a * @property {Function} dispatch\x0a */\x0a\x0a/**\x0a * An object of registry function overrides.\x0a *\x0a * @typedef {WPDataPlugin}\x0a */\x0a\x0a/**\x0a * Creates a new store registry, given an optional object of initial store\x0a * configurations.\x0a *\x0a * @param {Object} storeConfigs Initial store configurations.\x0a *\x0a * @return {WPDataRegistry} Data registry.\x0a */\x0a\x0afunction createRegistry() {\x0a  var storeConfigs = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a  var stores = {};\x0a  var listeners = [];\x0a  /**\x0a   * Global listener called for each store\x27s update.\x0a   */\x0a\x0a  function globalListener() {\x0a    listeners.forEach(function (listener) {\x0a      return listener();\x0a    });\x0a  }\x0a  /**\x0a   * Subscribe to changes to any data.\x0a   *\x0a   * @param {Function}   listener Listener function.\x0a   *\x0a   * @return {Function}           Unsubscribe function.\x0a   */\x0a\x0a\x0a  var subscribe = function subscribe(listener) {\x0a    listeners.push(listener);\x0a    return function () {\x0a      listeners = Object(external_lodash_[\x22without\x22])(listeners, listener);\x0a    };\x0a  };\x0a  /**\x0a   * Calls a selector given the current state and extra arguments.\x0a   *\x0a   * @param {string} reducerKey Part of the state shape to register the\x0a   *                            selectors for.\x0a   *\x0a   * @return {*} The selector\x27s returned value.\x0a   */\x0a\x0a\x0a  function select(reducerKey) {\x0a    var store = stores[reducerKey];\x0a    return store && store.getSelectors();\x0a  }\x0a  /**\x0a   * Returns the available actions for a part of the state.\x0a   *\x0a   * @param {string} reducerKey Part of the state shape to dispatch the\x0a   *                            action for.\x0a   *\x0a   * @return {*} The action\x27s returned value.\x0a   */\x0a\x0a\x0a  function dispatch(reducerKey) {\x0a    var store = stores[reducerKey];\x0a    return store && store.getActions();\x0a  } //\x0a  // Deprecated\x0a  // TODO: Remove this after `use()` is removed.\x0a  //\x0a\x0a\x0a  function withPlugins(attributes) {\x0a    return Object(external_lodash_[\x22mapValues\x22])(attributes, function (attribute, key) {\x0a      if (typeof attribute !== \x27function\x27) {\x0a        return attribute;\x0a      }\x0a\x0a      return function () {\x0a        return registry[key].apply(null, arguments);\x0a      };\x0a    });\x0a  }\x0a  /**\x0a   * Registers a generic store.\x0a   *\x0a   * @param {string} key    Store registry key.\x0a   * @param {Object} config Configuration (getSelectors, getActions, subscribe).\x0a   */\x0a\x0a\x0a  function registerGenericStore(key, config) {\x0a    if (typeof config.getSelectors !== \x27function\x27) {\x0a      throw new TypeError(\x27config.getSelectors must be a function\x27);\x0a    }\x0a\x0a    if (typeof config.getActions !== \x27function\x27) {\x0a      throw new TypeError(\x27config.getActions must be a function\x27);\x0a    }\x0a\x0a    if (typeof config.subscribe !== \x27function\x27) {\x0a      throw new TypeError(\x27config.subscribe must be a function\x27);\x0a    }\x0a\x0a    stores[key] = config;\x0a    config.subscribe(globalListener);\x0a  }\x0a\x0a  var registry = {\x0a    registerGenericStore: registerGenericStore,\x0a    stores: stores,\x0a    namespaces: stores,\x0a    // TODO: Deprecate/remove this.\x0a    subscribe: subscribe,\x0a    select: select,\x0a    dispatch: dispatch,\x0a    use: use\x0a  };\x0a  /**\x0a   * Registers a standard `@wordpress/data` store.\x0a   *\x0a   * @param {string} reducerKey Reducer key.\x0a   * @param {Object} options    Store description (reducer, actions, selectors, resolvers).\x0a   *\x0a   * @return {Object} Registered store object.\x0a   */\x0a\x0a  registry.registerStore = function (reducerKey, options) {\x0a    if (!options.reducer) {\x0a      throw new TypeError(\x27Must specify store reducer\x27);\x0a    }\x0a\x0a    var namespace = createNamespace(reducerKey, options, registry);\x0a    registerGenericStore(reducerKey, namespace);\x0a    return namespace.store;\x0a  }; //\x0a  // TODO:\x0a  // This function will be deprecated as soon as it is no longer internally referenced.\x0a  //\x0a\x0a\x0a  function use(plugin, options) {\x0a    registry = Object(objectSpread[\x22a\x22 /* default */])({}, registry, plugin(registry, options));\x0a    return registry;\x0a  }\x0a\x0a  Object.entries(Object(objectSpread[\x22a\x22 /* default */])({\x0a    \x27core/data\x27: build_module_store\x0a  }, storeConfigs)).map(function (_ref) {\x0a    var _ref2 = Object(slicedToArray[\x22a\x22 /* default */])(_ref, 2),\x0a        name = _ref2[0],\x0a        config = _ref2[1];\x0a\x0a    return registry.registerStore(name, config);\x0a  });\x0a  return withPlugins(registry);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/default-registry.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a/* harmony default export */ var default_registry = (createRegistry());\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22reduxRoutine\x22]}\x0avar external_this_wp_reduxRoutine_ = __webpack_require__(224);\x0avar external_this_wp_reduxRoutine_default = /*#__PURE__*/__webpack_require__.n(external_this_wp_reduxRoutine_);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/plugins/controls/index.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a/* harmony default export */ var controls = (function (registry) {\x0a  return {\x0a    registerStore: function registerStore(reducerKey, options) {\x0a      var store = registry.registerStore(reducerKey, options);\x0a\x0a      if (options.controls) {\x0a        var normalizedControls = Object(external_lodash_[\x22mapValues\x22])(options.controls, function (control) {\x0a          return control.isRegistryControl ? control(registry) : control;\x0a        });\x0a        var middleware = external_this_wp_reduxRoutine_default()(normalizedControls);\x0a        var enhancer = Object(redux[\x22a\x22 /* applyMiddleware */])(middleware);\x0a\x0a        var createStore = function createStore() {\x0a          return store;\x0a        };\x0a\x0a        Object.assign(store, enhancer(createStore)(options.reducer));\x0a        registry.namespaces[reducerKey].supportControls = true;\x0a      }\x0a\x0a      return store;\x0a    }\x0a  };\x0a});\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/plugins/persistence/storage/object.js\x0avar objectStorage;\x0avar object_storage = {\x0a  getItem: function getItem(key) {\x0a    if (!objectStorage || !objectStorage[key]) {\x0a      return null;\x0a    }\x0a\x0a    return objectStorage[key];\x0a  },\x0a  setItem: function setItem(key, value) {\x0a    if (!objectStorage) {\x0a      object_storage.clear();\x0a    }\x0a\x0a    objectStorage[key] = String(value);\x0a  },\x0a  clear: function clear() {\x0a    objectStorage = Object.create(null);\x0a  }\x0a};\x0a/* harmony default export */ var object = (object_storage);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/plugins/persistence/storage/default.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0avar default_storage;\x0a\x0atry {\x0a  // Private Browsing in Safari 10 and earlier will throw an error when\x0a  // attempting to set into localStorage. The test here is intentional in\x0a  // causing a thrown error as condition for using fallback object storage.\x0a  default_storage = window.localStorage;\x0a  default_storage.setItem(\x27__wpDataTestLocalStorage\x27, \x27\x27);\x0a  default_storage.removeItem(\x27__wpDataTestLocalStorage\x27);\x0a} catch (error) {\x0a  default_storage = object;\x0a}\x0a\x0a/* harmony default export */ var storage_default = (default_storage);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/plugins/persistence/index.js\x0a\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * Persistence plugin options.\x0a *\x0a * @property {Storage} storage    Persistent storage implementation. This must\x0a *                                at least implement `getItem` and `setItem` of\x0a *                                the Web Storage API.\x0a * @property {string}  storageKey Key on which to set in persistent storage.\x0a *\x0a * @typedef {WPDataPersistencePluginOptions}\x0a */\x0a\x0a/**\x0a * Default plugin storage.\x0a *\x0a * @type {Storage}\x0a */\x0a\x0avar DEFAULT_STORAGE = storage_default;\x0a/**\x0a * Default plugin storage key.\x0a *\x0a * @type {string}\x0a */\x0a\x0avar DEFAULT_STORAGE_KEY = \x27WP_DATA\x27;\x0a/**\x0a * Higher-order reducer which invokes the original reducer only if state is\x0a * inequal from that of the action\x27s `nextState` property, otherwise returning\x0a * the original state reference.\x0a *\x0a * @param {Function} reducer Original reducer.\x0a *\x0a * @return {Function} Enhanced reducer.\x0a */\x0a\x0avar withLazySameState = function withLazySameState(reducer) {\x0a  return function (state, action) {\x0a    if (action.nextState === state) {\x0a      return state;\x0a    }\x0a\x0a    return reducer(state, action);\x0a  };\x0a};\x0a/**\x0a * Creates a persistence interface, exposing getter and setter methods (`get`\x0a * and `set` respectively).\x0a *\x0a * @param {WPDataPersistencePluginOptions} options Plugin options.\x0a *\x0a * @return {Object} Persistence interface.\x0a */\x0a\x0afunction createPersistenceInterface(options) {\x0a  var _options$storage = options.storage,\x0a      storage = _options$storage === void 0 ? DEFAULT_STORAGE : _options$storage,\x0a      _options$storageKey = options.storageKey,\x0a      storageKey = _options$storageKey === void 0 ? DEFAULT_STORAGE_KEY : _options$storageKey;\x0a  var data;\x0a  /**\x0a   * Returns the persisted data as an object, defaulting to an empty object.\x0a   *\x0a   * @return {Object} Persisted data.\x0a   */\x0a\x0a  function get() {\x0a    if (data === undefined) {\x0a      // If unset, getItem is expected to return null. Fall back to\x0a      // empty object.\x0a      var persisted = storage.getItem(storageKey);\x0a\x0a      if (persisted === null) {\x0a        data = {};\x0a      } else {\x0a        try {\x0a          data = JSON.parse(persisted);\x0a        } catch (error) {\x0a          // Similarly, should any error be thrown during parse of\x0a          // the string (malformed JSON), fall back to empty object.\x0a          data = {};\x0a        }\x0a      }\x0a    }\x0a\x0a    return data;\x0a  }\x0a  /**\x0a   * Merges an updated reducer state into the persisted data.\x0a   *\x0a   * @param {string} key   Key to update.\x0a   * @param {*}      value Updated value.\x0a   */\x0a\x0a\x0a  function set(key, value) {\x0a    data = Object(objectSpread[\x22a\x22 /* default */])({}, data, Object(defineProperty[\x22a\x22 /* default */])({}, key, value));\x0a    storage.setItem(storageKey, JSON.stringify(data));\x0a  }\x0a\x0a  return {\x0a    get: get,\x0a    set: set\x0a  };\x0a}\x0a/**\x0a * Data plugin to persist store state into a single storage key.\x0a *\x0a * @param {WPDataRegistry}                  registry      Data registry.\x0a * @param {?WPDataPersistencePluginOptions} pluginOptions Plugin options.\x0a *\x0a * @return {WPDataPlugin} Data plugin.\x0a */\x0a\x0avar persistence_persistencePlugin = function persistencePlugin(registry, pluginOptions) {\x0a  var persistence = createPersistenceInterface(pluginOptions);\x0a  /**\x0a   * Creates an enhanced store dispatch function, triggering the state of the\x0a   * given reducer key to be persisted when changed.\x0a   *\x0a   * @param {Function}       getState   Function which returns current state.\x0a   * @param {string}         reducerKey Reducer key.\x0a   * @param {?Array\x3cstring\x3e} keys       Optional subset of keys to save.\x0a   *\x0a   * @return {Function} Enhanced dispatch function.\x0a   */\x0a\x0a  function createPersistOnChange(getState, reducerKey, keys) {\x0a    var getPersistedState;\x0a\x0a    if (Array.isArray(keys)) {\x0a      // Given keys, the persisted state should by produced as an object\x0a      // of the subset of keys. This implementation uses combineReducers\x0a      // to leverage its behavior of returning the same object when none\x0a      // of the property values changes. This allows a strict reference\x0a      // equality to bypass a persistence set on an unchanging state.\x0a      var reducers = keys.reduce(function (result, key) {\x0a        return Object.assign(result, Object(defineProperty[\x22a\x22 /* default */])({}, key, function (state, action) {\x0a          return action.nextState[key];\x0a        }));\x0a      }, {});\x0a      getPersistedState = withLazySameState(turbo_combine_reducers_default()(reducers));\x0a    } else {\x0a      getPersistedState = function getPersistedState(state, action) {\x0a        return action.nextState;\x0a      };\x0a    }\x0a\x0a    var lastState = getPersistedState(undefined, {\x0a      nextState: getState()\x0a    });\x0a    return function (result) {\x0a      var state = getPersistedState(lastState, {\x0a        nextState: getState()\x0a      });\x0a\x0a      if (state !== lastState) {\x0a        persistence.set(reducerKey, state);\x0a        lastState = state;\x0a      }\x0a\x0a      return result;\x0a    };\x0a  }\x0a\x0a  return {\x0a    registerStore: function registerStore(reducerKey, options) {\x0a      if (!options.persist) {\x0a        return registry.registerStore(reducerKey, options);\x0a      } // Load from persistence to use as initial state.\x0a\x0a\x0a      var persistedState = persistence.get()[reducerKey];\x0a\x0a      if (persistedState !== undefined) {\x0a        var initialState = options.reducer(undefined, {\x0a          type: \x27@@WP/PERSISTENCE_RESTORE\x27\x0a        });\x0a\x0a        if (Object(external_lodash_[\x22isPlainObject\x22])(initialState) && Object(external_lodash_[\x22isPlainObject\x22])(persistedState)) {\x0a          // If state is an object, ensure that:\x0a          // - Other keys are left intact when persisting only a\x0a          //   subset of keys.\x0a          // - New keys in what would otherwise be used as initial\x0a          //   state are deeply merged as base for persisted value.\x0a          initialState = Object(external_lodash_[\x22merge\x22])({}, initialState, persistedState);\x0a        } else {\x0a          // If there is a mismatch in object-likeness of default\x0a          // initial or persisted state, defer to persisted value.\x0a          initialState = persistedState;\x0a        }\x0a\x0a        options = Object(objectSpread[\x22a\x22 /* default */])({}, options, {\x0a          initialState: initialState\x0a        });\x0a      }\x0a\x0a      var store = registry.registerStore(reducerKey, options);\x0a      store.dispatch = Object(external_lodash_[\x22flow\x22])([store.dispatch, createPersistOnChange(store.getState, reducerKey, options.persist)]);\x0a      return store;\x0a    }\x0a  };\x0a};\x0a/**\x0a * Deprecated: Remove this function once WordPress 5.3 is released.\x0a */\x0a\x0a\x0apersistence_persistencePlugin.__unstableMigrate = function (pluginOptions) {\x0a  var persistence = createPersistenceInterface(pluginOptions); // Preferences migration to introduce the block editor module\x0a\x0a  var persistedState = persistence.get();\x0a  var coreEditorState = persistedState[\x27core/editor\x27];\x0a\x0a  if (coreEditorState && coreEditorState.preferences && coreEditorState.preferences.insertUsage) {\x0a    var blockEditorState = {\x0a      preferences: {\x0a        insertUsage: coreEditorState.preferences.insertUsage\x0a      }\x0a    };\x0a    persistence.set(\x27core/editor\x27, Object(objectSpread[\x22a\x22 /* default */])({}, coreEditorState, {\x0a      preferences: Object(external_lodash_[\x22omit\x22])(coreEditorState.preferences, [\x27insertUsage\x27])\x0a    }));\x0a    persistence.set(\x27core/block-editor\x27, blockEditorState);\x0a  }\x0a};\x0a\x0a/* harmony default export */ var plugins_persistence = (persistence_persistencePlugin);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/plugins/index.js\x0a\x0a\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\x0avar esm_extends = __webpack_require__(19);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\x0avar classCallCheck = __webpack_require__(10);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js\x0avar createClass = __webpack_require__(9);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\x0avar possibleConstructorReturn = __webpack_require__(11);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\x0avar getPrototypeOf = __webpack_require__(12);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js + 1 modules\x0avar inherits = __webpack_require__(13);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\x0avar assertThisInitialized = __webpack_require__(3);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22element\x22]}\x0avar external_this_wp_element_ = __webpack_require__(0);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22isShallowEqual\x22]}\x0avar external_this_wp_isShallowEqual_ = __webpack_require__(42);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22compose\x22]}\x0avar external_this_wp_compose_ = __webpack_require__(6);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22priorityQueue\x22]}\x0avar external_this_wp_priorityQueue_ = __webpack_require__(225);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/components/registry-provider/index.js\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0avar _createContext = Object(external_this_wp_element_[\x22createContext\x22])(default_registry),\x0a    Consumer = _createContext.Consumer,\x0a    Provider = _createContext.Provider;\x0a\x0avar RegistryConsumer = Consumer;\x0a/* harmony default export */ var registry_provider = (Provider);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/components/async-mode-provider/index.js\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0avar async_mode_provider_createContext = Object(external_this_wp_element_[\x22createContext\x22])(false),\x0a    async_mode_provider_Consumer = async_mode_provider_createContext.Consumer,\x0a    async_mode_provider_Provider = async_mode_provider_createContext.Provider;\x0a\x0avar AsyncModeConsumer = async_mode_provider_Consumer;\x0a/* harmony default export */ var async_mode_provider = (async_mode_provider_Provider);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/components/with-select/index.js\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0avar renderQueue = Object(external_this_wp_priorityQueue_[\x22createQueue\x22])();\x0a/**\x0a * Higher-order component used to inject state-derived props using registered\x0a * selectors.\x0a *\x0a * @param {Function} mapSelectToProps Function called on every state change,\x0a *                                   expected to return object of props to\x0a *                                   merge with the component\x27s own props.\x0a *\x0a * @return {Component} Enhanced component with merged state data props.\x0a */\x0a\x0avar with_select_withSelect = function withSelect(mapSelectToProps) {\x0a  return Object(external_this_wp_compose_[\x22createHigherOrderComponent\x22])(function (WrappedComponent) {\x0a    /**\x0a     * Default merge props. A constant value is used as the fallback since it\x0a     * can be more efficiently shallow compared in case component is repeatedly\x0a    \x09 * rendered without its own merge props.\x0a     *\x0a     * @type {Object}\x0a     */\x0a    var DEFAULT_MERGE_PROPS = {};\x0a    /**\x0a     * Given a props object, returns the next merge props by mapSelectToProps.\x0a     *\x0a     * @param {Object} props Props to pass as argument to mapSelectToProps.\x0a     *\x0a     * @return {Object} Props to merge into rendered wrapped element.\x0a     */\x0a\x0a    function getNextMergeProps(props) {\x0a      return mapSelectToProps(props.registry.select, props.ownProps, props.registry) || DEFAULT_MERGE_PROPS;\x0a    }\x0a\x0a    var ComponentWithSelect =\x0a    /*#__PURE__*/\x0a    function (_Component) {\x0a      Object(inherits[\x22a\x22 /* default */])(ComponentWithSelect, _Component);\x0a\x0a      function ComponentWithSelect(props) {\x0a        var _this;\x0a\x0a        Object(classCallCheck[\x22a\x22 /* default */])(this, ComponentWithSelect);\x0a\x0a        _this = Object(possibleConstructorReturn[\x22a\x22 /* default */])(this, Object(getPrototypeOf[\x22a\x22 /* default */])(ComponentWithSelect).call(this, props));\x0a        _this.onStoreChange = _this.onStoreChange.bind(Object(assertThisInitialized[\x22a\x22 /* default */])(Object(assertThisInitialized[\x22a\x22 /* default */])(_this)));\x0a\x0a        _this.subscribe(props.registry);\x0a\x0a        _this.mergeProps = getNextMergeProps(props);\x0a        return _this;\x0a      }\x0a\x0a      Object(createClass[\x22a\x22 /* default */])(ComponentWithSelect, [{\x0a        key: \x22componentDidMount\x22,\x0a        value: function componentDidMount() {\x0a          this.canRunSelection = true; // A state change may have occurred between the constructor and\x0a          // mount of the component (e.g. during the wrapped component\x27s own\x0a          // constructor), in which case selection should be rerun.\x0a\x0a          if (this.hasQueuedSelection) {\x0a            this.hasQueuedSelection = false;\x0a            this.onStoreChange();\x0a          }\x0a        }\x0a      }, {\x0a        key: \x22componentWillUnmount\x22,\x0a        value: function componentWillUnmount() {\x0a          this.canRunSelection = false;\x0a          this.unsubscribe();\x0a          renderQueue.flush(this);\x0a        }\x0a      }, {\x0a        key: \x22shouldComponentUpdate\x22,\x0a        value: function shouldComponentUpdate(nextProps, nextState) {\x0a          // Cycle subscription if registry changes.\x0a          var hasRegistryChanged = nextProps.registry !== this.props.registry;\x0a          var hasSyncRenderingChanged = nextProps.isAsync !== this.props.isAsync;\x0a\x0a          if (hasRegistryChanged) {\x0a            this.unsubscribe();\x0a            this.subscribe(nextProps.registry);\x0a          }\x0a\x0a          if (hasSyncRenderingChanged) {\x0a            renderQueue.flush(this);\x0a          } // Treat a registry change as equivalent to `ownProps`, to reflect\x0a          // `mergeProps` to rendered component if and only if updated.\x0a\x0a\x0a          var hasPropsChanged = hasRegistryChanged || !Object(external_this_wp_isShallowEqual_[\x22isShallowEqualObjects\x22])(this.props.ownProps, nextProps.ownProps); // Only render if props have changed or merge props have been updated\x0a          // from the store subscriber.\x0a\x0a          if (this.state === nextState && !hasPropsChanged && !hasSyncRenderingChanged) {\x0a            return false;\x0a          }\x0a\x0a          if (hasPropsChanged || hasSyncRenderingChanged) {\x0a            var nextMergeProps = getNextMergeProps(nextProps);\x0a\x0a            if (!Object(external_this_wp_isShallowEqual_[\x22isShallowEqualObjects\x22])(this.mergeProps, nextMergeProps)) {\x0a              // If merge props change as a result of the incoming props,\x0a              // they should be reflected as such in the upcoming render.\x0a              // While side effects are discouraged in lifecycle methods,\x0a              // this component is used heavily, and prior efforts to use\x0a              // `getDerivedStateFromProps` had demonstrated miserable\x0a              // performance.\x0a              this.mergeProps = nextMergeProps;\x0a            } // Regardless whether merge props are changing, fall through to\x0a            // incur the render since the component will need to receive\x0a            // the changed `ownProps`.\x0a\x0a          }\x0a\x0a          return true;\x0a        }\x0a      }, {\x0a        key: \x22onStoreChange\x22,\x0a        value: function onStoreChange() {\x0a          if (!this.canRunSelection) {\x0a            this.hasQueuedSelection = true;\x0a            return;\x0a          }\x0a\x0a          var nextMergeProps = getNextMergeProps(this.props);\x0a\x0a          if (Object(external_this_wp_isShallowEqual_[\x22isShallowEqualObjects\x22])(this.mergeProps, nextMergeProps)) {\x0a            return;\x0a          }\x0a\x0a          this.mergeProps = nextMergeProps; // Schedule an update. Merge props are not assigned to state since\x0a          // derivation of merge props from incoming props occurs within\x0a          // shouldComponentUpdate, where setState is not allowed. setState\x0a          // is used here instead of forceUpdate because forceUpdate bypasses\x0a          // shouldComponentUpdate altogether, which isn\x27t desireable if both\x0a          // state and props change within the same render. Unfortunately,\x0a          // this requires that next merge props are generated twice.\x0a\x0a          this.setState({});\x0a        }\x0a      }, {\x0a        key: \x22subscribe\x22,\x0a        value: function subscribe(registry) {\x0a          var _this2 = this;\x0a\x0a          this.unsubscribe = registry.subscribe(function () {\x0a            if (_this2.props.isAsync) {\x0a              renderQueue.add(_this2, _this2.onStoreChange);\x0a            } else {\x0a              _this2.onStoreChange();\x0a            }\x0a          });\x0a        }\x0a      }, {\x0a        key: \x22render\x22,\x0a        value: function render() {\x0a          return Object(external_this_wp_element_[\x22createElement\x22])(WrappedComponent, Object(esm_extends[\x22a\x22 /* default */])({}, this.props.ownProps, this.mergeProps));\x0a        }\x0a      }]);\x0a\x0a      return ComponentWithSelect;\x0a    }(external_this_wp_element_[\x22Component\x22]);\x0a\x0a    return function (ownProps) {\x0a      return Object(external_this_wp_element_[\x22createElement\x22])(AsyncModeConsumer, null, function (isAsync) {\x0a        return Object(external_this_wp_element_[\x22createElement\x22])(RegistryConsumer, null, function (registry) {\x0a          return Object(external_this_wp_element_[\x22createElement\x22])(ComponentWithSelect, {\x0a            ownProps: ownProps,\x0a            registry: registry,\x0a            isAsync: isAsync\x0a          });\x0a        });\x0a      });\x0a    };\x0a  }, \x27withSelect\x27);\x0a};\x0a\x0a/* harmony default export */ var with_select = (with_select_withSelect);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/components/with-dispatch/index.js\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Higher-order component used to add dispatch props using registered action\x0a * creators.\x0a *\x0a * @param {Object} mapDispatchToProps Object of prop names where value is a\x0a *                                    dispatch-bound action creator, or a\x0a *                                    function to be called with with the\x0a *                                    component\x27s props and returning an\x0a *                                    action creator.\x0a *\x0a * @return {Component} Enhanced component with merged dispatcher props.\x0a */\x0a\x0avar with_dispatch_withDispatch = function withDispatch(mapDispatchToProps) {\x0a  return Object(external_this_wp_compose_[\x22createHigherOrderComponent\x22])(function (WrappedComponent) {\x0a    var ComponentWithDispatch =\x0a    /*#__PURE__*/\x0a    function (_Component) {\x0a      Object(inherits[\x22a\x22 /* default */])(ComponentWithDispatch, _Component);\x0a\x0a      function ComponentWithDispatch(props) {\x0a        var _this;\x0a\x0a        Object(classCallCheck[\x22a\x22 /* default */])(this, ComponentWithDispatch);\x0a\x0a        _this = Object(possibleConstructorReturn[\x22a\x22 /* default */])(this, Object(getPrototypeOf[\x22a\x22 /* default */])(ComponentWithDispatch).apply(this, arguments));\x0a        _this.proxyProps = {};\x0a\x0a        _this.setProxyProps(props);\x0a\x0a        return _this;\x0a      }\x0a\x0a      Object(createClass[\x22a\x22 /* default */])(ComponentWithDispatch, [{\x0a        key: \x22proxyDispatch\x22,\x0a        value: function proxyDispatch(propName) {\x0a          var _mapDispatchToProps;\x0a\x0a          for (var _len = arguments.length, args = new Array(_len \x3e 1 ? _len - 1 : 0), _key = 1; _key \x3c _len; _key++) {\x0a            args[_key - 1] = arguments[_key];\x0a          }\x0a\x0a          // Original dispatcher is a pre-bound (dispatching) action creator.\x0a          (_mapDispatchToProps = mapDispatchToProps(this.props.registry.dispatch, this.props.ownProps, this.props.registry))[propName].apply(_mapDispatchToProps, args);\x0a        }\x0a      }, {\x0a        key: \x22setProxyProps\x22,\x0a        value: function setProxyProps(props) {\x0a          var _this2 = this;\x0a\x0a          // Assign as instance property so that in subsequent render\x0a          // reconciliation, the prop values are referentially equal.\x0a          // Importantly, note that while `mapDispatchToProps` is\x0a          // called, it is done only to determine the keys for which\x0a          // proxy functions should be created. The actual registry\x0a          // dispatch does not occur until the function is called.\x0a          var propsToDispatchers = mapDispatchToProps(this.props.registry.dispatch, props.ownProps, this.props.registry);\x0a          this.proxyProps = Object(external_lodash_[\x22mapValues\x22])(propsToDispatchers, function (dispatcher, propName) {\x0a            if (typeof dispatcher !== \x27function\x27) {\x0a              // eslint-disable-next-line no-console\x0a              console.warn(\x22Property \x22.concat(propName, \x22 returned from mapDispatchToProps in withDispatch must be a function.\x22));\x0a            } // Prebind with prop name so we have reference to the original\x0a            // dispatcher to invoke. Track between re-renders to avoid\x0a            // creating new function references every render.\x0a\x0a\x0a            if (_this2.proxyProps.hasOwnProperty(propName)) {\x0a              return _this2.proxyProps[propName];\x0a            }\x0a\x0a            return _this2.proxyDispatch.bind(_this2, propName);\x0a          });\x0a        }\x0a      }, {\x0a        key: \x22render\x22,\x0a        value: function render() {\x0a          return Object(external_this_wp_element_[\x22createElement\x22])(WrappedComponent, Object(esm_extends[\x22a\x22 /* default */])({}, this.props.ownProps, this.proxyProps));\x0a        }\x0a      }]);\x0a\x0a      return ComponentWithDispatch;\x0a    }(external_this_wp_element_[\x22Component\x22]);\x0a\x0a    return function (ownProps) {\x0a      return Object(external_this_wp_element_[\x22createElement\x22])(RegistryConsumer, null, function (registry) {\x0a        return Object(external_this_wp_element_[\x22createElement\x22])(ComponentWithDispatch, {\x0a          ownProps: ownProps,\x0a          registry: registry\x0a        });\x0a      });\x0a    };\x0a  }, \x27withDispatch\x27);\x0a};\x0a\x0a/* harmony default export */ var with_dispatch = (with_dispatch_withDispatch);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/components/with-registry/index.js\x0a\x0a\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Higher-order component which renders the original component with the current\x0a * registry context passed as its `registry` prop.\x0a *\x0a * @param {WPComponent} OriginalComponent Original component.\x0a *\x0a * @return {WPComponent} Enhanced component.\x0a */\x0a\x0avar withRegistry = Object(external_this_wp_compose_[\x22createHigherOrderComponent\x22])(function (OriginalComponent) {\x0a  return function (props) {\x0a    return Object(external_this_wp_element_[\x22createElement\x22])(RegistryConsumer, null, function (registry) {\x0a      return Object(external_this_wp_element_[\x22createElement\x22])(OriginalComponent, Object(esm_extends[\x22a\x22 /* default */])({}, props, {\x0a        registry: registry\x0a      }));\x0a    });\x0a  };\x0a}, \x27withRegistry\x27);\x0a/* harmony default export */ var with_registry = (withRegistry);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/factory.js\x0a/**\x0a * Mark a selector as a registry selector.\x0a *\x0a * @param {function} registrySelector Function receiving a registry object and returning a state selector.\x0a *\x0a * @return {function} marked registry selector.\x0a */\x0afunction createRegistrySelector(registrySelector) {\x0a  registrySelector.isRegistrySelector = true;\x0a  return registrySelector;\x0a}\x0a/**\x0a * Mark a control as a registry control.\x0a *\x0a * @param {function} registryControl Function receiving a registry object and returning a control.\x0a *\x0a * @return {function} marked registry control.\x0a */\x0a\x0afunction createRegistryControl(registryControl) {\x0a  registryControl.isRegistryControl = true;\x0a  return registryControl;\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/data/build-module/index.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22select\x22, function() { return build_module_select; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22dispatch\x22, function() { return build_module_dispatch; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22subscribe\x22, function() { return build_module_subscribe; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22registerGenericStore\x22, function() { return build_module_registerGenericStore; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22registerStore\x22, function() { return build_module_registerStore; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22use\x22, function() { return build_module_use; });\x0a/* concated harmony reexport withSelect */__webpack_require__.d(__webpack_exports__, \x22withSelect\x22, function() { return with_select; });\x0a/* concated harmony reexport withDispatch */__webpack_require__.d(__webpack_exports__, \x22withDispatch\x22, function() { return with_dispatch; });\x0a/* concated harmony reexport withRegistry */__webpack_require__.d(__webpack_exports__, \x22withRegistry\x22, function() { return with_registry; });\x0a/* concated harmony reexport RegistryProvider */__webpack_require__.d(__webpack_exports__, \x22RegistryProvider\x22, function() { return registry_provider; });\x0a/* concated harmony reexport RegistryConsumer */__webpack_require__.d(__webpack_exports__, \x22RegistryConsumer\x22, function() { return RegistryConsumer; });\x0a/* concated harmony reexport __experimentalAsyncModeProvider */__webpack_require__.d(__webpack_exports__, \x22__experimentalAsyncModeProvider\x22, function() { return async_mode_provider; });\x0a/* concated harmony reexport createRegistry */__webpack_require__.d(__webpack_exports__, \x22createRegistry\x22, function() { return createRegistry; });\x0a/* concated harmony reexport plugins */__webpack_require__.d(__webpack_exports__, \x22plugins\x22, function() { return plugins_namespaceObject; });\x0a/* concated harmony reexport createRegistrySelector */__webpack_require__.d(__webpack_exports__, \x22createRegistrySelector\x22, function() { return createRegistrySelector; });\x0a/* concated harmony reexport createRegistryControl */__webpack_require__.d(__webpack_exports__, \x22createRegistryControl\x22, function() { return createRegistryControl; });\x0a/* concated harmony reexport combineReducers */__webpack_require__.d(__webpack_exports__, \x22combineReducers\x22, function() { return turbo_combine_reducers_default.a; });\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a/**\x0a * The combineReducers helper function turns an object whose values are different\x0a * reducing functions into a single reducing function you can pass to registerReducer.\x0a *\x0a * @param {Object} reducers An object whose values correspond to different reducing\x0a *                          functions that need to be combined into one.\x0a *\x0a * @return {Function}       A reducer that invokes every reducer inside the reducers\x0a *                          object, and constructs a state object with the same shape.\x0a */\x0a\x0a\x0avar build_module_select = default_registry.select;\x0avar build_module_dispatch = default_registry.dispatch;\x0avar build_module_subscribe = default_registry.subscribe;\x0avar build_module_registerGenericStore = default_registry.registerGenericStore;\x0avar build_module_registerStore = default_registry.registerStore;\x0avar build_module_use = default_registry.use;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 37:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _arrayWithHoles; });\x0afunction _arrayWithHoles(arr) {\x0a  if (Array.isArray(arr)) return arr;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 38:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _nonIterableRest; });\x0afunction _nonIterableRest() {\x0a  throw new TypeError(\x22Invalid attempt to destructure non-iterable instance\x22);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 42:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22isShallowEqual\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 44:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _asyncToGenerator; });\x0afunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\x0a  try {\x0a    var info = gen[key](arg);\x0a    var value = info.value;\x0a  } catch (error) {\x0a    reject(error);\x0a    return;\x0a  }\x0a\x0a  if (info.done) {\x0a    resolve(value);\x0a  } else {\x0a    Promise.resolve(value).then(_next, _throw);\x0a  }\x0a}\x0a\x0afunction _asyncToGenerator(fn) {\x0a  return function () {\x0a    var self = this,\x0a        args = arguments;\x0a    return new Promise(function (resolve, reject) {\x0a      var gen = fn.apply(self, args);\x0a\x0a      function _next(value) {\x0a        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \x22next\x22, value);\x0a      }\x0a\x0a      function _throw(err) {\x0a        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \x22throw\x22, err);\x0a      }\x0a\x0a      _next(undefined);\x0a    });\x0a  };\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 54:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a/**\x0a * Copyright (c) 2014-present, Facebook, Inc.\x0a *\x0a * This source code is licensed under the MIT license found in the\x0a * LICENSE file in the root directory of this source tree.\x0a */\x0a\x0a// This method of obtaining a reference to the global object needs to be\x0a// kept identical to the way it is obtained in runtime.js\x0avar g = (function() {\x0a  return this || (typeof self === \x22object\x22 && self);\x0a})() || Function(\x22return this\x22)();\x0a\x0a// Use `getOwnPropertyNames` because not all browsers support calling\x0a// `hasOwnProperty` on the global `self` object in a worker. See #183.\x0avar hadRuntime = g.regeneratorRuntime &&\x0a  Object.getOwnPropertyNames(g).indexOf(\x22regeneratorRuntime\x22) \x3e= 0;\x0a\x0a// Save the old regeneratorRuntime in case it needs to be restored later.\x0avar oldRuntime = hadRuntime && g.regeneratorRuntime;\x0a\x0a// Force reevalutation of runtime.js.\x0ag.regeneratorRuntime = undefined;\x0a\x0amodule.exports = __webpack_require__(55);\x0a\x0aif (hadRuntime) {\x0a  // Restore the original runtime.\x0a  g.regeneratorRuntime = oldRuntime;\x0a} else {\x0a  // Remove the global property added by runtime.js.\x0a  try {\x0a    delete g.regeneratorRuntime;\x0a  } catch(e) {\x0a    g.regeneratorRuntime = undefined;\x0a  }\x0a}\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 55:\x0a/***/ (function(module, exports) {\x0a\x0a/**\x0a * Copyright (c) 2014-present, Facebook, Inc.\x0a *\x0a * This source code is licensed under the MIT license found in the\x0a * LICENSE file in the root directory of this source tree.\x0a */\x0a\x0a!(function(global) {\x0a  \x22use strict\x22;\x0a\x0a  var Op = Object.prototype;\x0a  var hasOwn = Op.hasOwnProperty;\x0a  var undefined; // More compressible than void 0.\x0a  var $Symbol = typeof Symbol === \x22function\x22 ? Symbol : {};\x0a  var iteratorSymbol = $Symbol.iterator || \x22@@iterator\x22;\x0a  var asyncIteratorSymbol = $Symbol.asyncIterator || \x22@@asyncIterator\x22;\x0a  var toStringTagSymbol = $Symbol.toStringTag || \x22@@toStringTag\x22;\x0a\x0a  var inModule = typeof module === \x22object\x22;\x0a  var runtime = global.regeneratorRuntime;\x0a  if (runtime) {\x0a    if (inModule) {\x0a      // If regeneratorRuntime is defined globally and we\x27re in a module,\x0a      // make the exports object identical to regeneratorRuntime.\x0a      module.exports = runtime;\x0a    }\x0a    // Don\x27t bother evaluating the rest of this file if the runtime was\x0a    // already defined globally.\x0a    return;\x0a  }\x0a\x0a  // Define the runtime globally (as expected by generated code) as either\x0a  // module.exports (if we\x27re in a module) or a new, empty object.\x0a  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\x0a\x0a  function wrap(innerFn, outerFn, self, tryLocsList) {\x0a    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\x0a    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\x0a    var generator = Object.create(protoGenerator.prototype);\x0a    var context = new Context(tryLocsList || []);\x0a\x0a    // The ._invoke method unifies the implementations of the .next,\x0a    // .throw, and .return methods.\x0a    generator._invoke = makeInvokeMethod(innerFn, self, context);\x0a\x0a    return generator;\x0a  }\x0a  runtime.wrap = wrap;\x0a\x0a  // Try/catch helper to minimize deoptimizations. Returns a completion\x0a  // record like context.tryEntries[i].completion. This interface could\x0a  // have been (and was previously) designed to take a closure to be\x0a  // invoked without arguments, but in all the cases we care about we\x0a  // already have an existing method we want to call, so there\x27s no need\x0a  // to create a new function object. We can even get away with assuming\x0a  // the method takes exactly one argument, since that happens to be true\x0a  // in every case, so we don\x27t have to touch the arguments object. The\x0a  // only additional allocation required is the completion record, which\x0a  // has a stable shape and so hopefully should be cheap to allocate.\x0a  function tryCatch(fn, obj, arg) {\x0a    try {\x0a      return { type: \x22normal\x22, arg: fn.call(obj, arg) };\x0a    } catch (err) {\x0a      return { type: \x22throw\x22, arg: err };\x0a    }\x0a  }\x0a\x0a  var GenStateSuspendedStart = \x22suspendedStart\x22;\x0a  var GenStateSuspendedYield = \x22suspendedYield\x22;\x0a  var GenStateExecuting = \x22executing\x22;\x0a  var GenStateCompleted = \x22completed\x22;\x0a\x0a  // Returning this object from the innerFn has the same effect as\x0a  // breaking out of the dispatch switch statement.\x0a  var ContinueSentinel = {};\x0a\x0a  // Dummy constructor functions that we use as the .constructor and\x0a  // .constructor.prototype properties for functions that return Generator\x0a  // objects. For full spec compliance, you may wish to configure your\x0a  // minifier not to mangle the names of these two functions.\x0a  function Generator() {}\x0a  function GeneratorFunction() {}\x0a  function GeneratorFunctionPrototype() {}\x0a\x0a  // This is a polyfill for %IteratorPrototype% for environments that\x0a  // don\x27t natively support it.\x0a  var IteratorPrototype = {};\x0a  IteratorPrototype[iteratorSymbol] = function () {\x0a    return this;\x0a  };\x0a\x0a  var getProto = Object.getPrototypeOf;\x0a  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\x0a  if (NativeIteratorPrototype &&\x0a      NativeIteratorPrototype !== Op &&\x0a      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\x0a    // This environment has a native %IteratorPrototype%; use it instead\x0a    // of the polyfill.\x0a    IteratorPrototype = NativeIteratorPrototype;\x0a  }\x0a\x0a  var Gp = GeneratorFunctionPrototype.prototype =\x0a    Generator.prototype = Object.create(IteratorPrototype);\x0a  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\x0a  GeneratorFunctionPrototype.constructor = GeneratorFunction;\x0a  GeneratorFunctionPrototype[toStringTagSymbol] =\x0a    GeneratorFunction.displayName = \x22GeneratorFunction\x22;\x0a\x0a  // Helper for defining the .next, .throw, and .return methods of the\x0a  // Iterator interface in terms of a single ._invoke method.\x0a  function defineIteratorMethods(prototype) {\x0a    [\x22next\x22, \x22throw\x22, \x22return\x22].forEach(function(method) {\x0a      prototype[method] = function(arg) {\x0a        return this._invoke(method, arg);\x0a      };\x0a    });\x0a  }\x0a\x0a  runtime.isGeneratorFunction = function(genFun) {\x0a    var ctor = typeof genFun === \x22function\x22 && genFun.constructor;\x0a    return ctor\x0a      ? ctor === GeneratorFunction ||\x0a        // For the native GeneratorFunction constructor, the best we can\x0a        // do is to check its .name property.\x0a        (ctor.displayName || ctor.name) === \x22GeneratorFunction\x22\x0a      : false;\x0a  };\x0a\x0a  runtime.mark = function(genFun) {\x0a    if (Object.setPrototypeOf) {\x0a      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\x0a    } else {\x0a      genFun.__proto__ = GeneratorFunctionPrototype;\x0a      if (!(toStringTagSymbol in genFun)) {\x0a        genFun[toStringTagSymbol] = \x22GeneratorFunction\x22;\x0a      }\x0a    }\x0a    genFun.prototype = Object.create(Gp);\x0a    return genFun;\x0a  };\x0a\x0a  // Within the body of any async function, `await x` is transformed to\x0a  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\x0a  // `hasOwn.call(value, \x22__await\x22)` to determine if the yielded value is\x0a  // meant to be awaited.\x0a  runtime.awrap = function(arg) {\x0a    return { __await: arg };\x0a  };\x0a\x0a  function AsyncIterator(generator) {\x0a    function invoke(method, arg, resolve, reject) {\x0a      var record = tryCatch(generator[method], generator, arg);\x0a      if (record.type === \x22throw\x22) {\x0a        reject(record.arg);\x0a      } else {\x0a        var result = record.arg;\x0a        var value = result.value;\x0a        if (value &&\x0a            typeof value === \x22object\x22 &&\x0a            hasOwn.call(value, \x22__await\x22)) {\x0a          return Promise.resolve(value.__await).then(function(value) {\x0a            invoke(\x22next\x22, value, resolve, reject);\x0a          }, function(err) {\x0a            invoke(\x22throw\x22, err, resolve, reject);\x0a          });\x0a        }\x0a\x0a        return Promise.resolve(value).then(function(unwrapped) {\x0a          // When a yielded Promise is resolved, its final value becomes\x0a          // the .value of the Promise\x3c{value,done}\x3e result for the\x0a          // current iteration.\x0a          result.value = unwrapped;\x0a          resolve(result);\x0a        }, function(error) {\x0a          // If a rejected Promise was yielded, throw the rejection back\x0a          // into the async generator function so it can be handled there.\x0a          return invoke(\x22throw\x22, error, resolve, reject);\x0a        });\x0a      }\x0a    }\x0a\x0a    var previousPromise;\x0a\x0a    function enqueue(method, arg) {\x0a      function callInvokeWithMethodAndArg() {\x0a        return new Promise(function(resolve, reject) {\x0a          invoke(method, arg, resolve, reject);\x0a        });\x0a      }\x0a\x0a      return previousPromise =\x0a        // If enqueue has been called before, then we want to wait until\x0a        // all previous Promises have been resolved before calling invoke,\x0a        // so that results are always delivered in the correct order. If\x0a        // enqueue has not been called before, then it is important to\x0a        // call invoke immediately, without waiting on a callback to fire,\x0a        // so that the async generator function has the opportunity to do\x0a        // any necessary setup in a predictable way. This predictability\x0a        // is why the Promise constructor synchronously invokes its\x0a        // executor callback, and why async functions synchronously\x0a        // execute code before the first await. Since we implement simple\x0a        // async functions in terms of async generators, it is especially\x0a        // important to get this right, even though it requires care.\x0a        previousPromise ? previousPromise.then(\x0a          callInvokeWithMethodAndArg,\x0a          // Avoid propagating failures to Promises returned by later\x0a          // invocations of the iterator.\x0a          callInvokeWithMethodAndArg\x0a        ) : callInvokeWithMethodAndArg();\x0a    }\x0a\x0a    // Define the unified helper method that is used to implement .next,\x0a    // .throw, and .return (see defineIteratorMethods).\x0a    this._invoke = enqueue;\x0a  }\x0a\x0a  defineIteratorMethods(AsyncIterator.prototype);\x0a  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\x0a    return this;\x0a  };\x0a  runtime.AsyncIterator = AsyncIterator;\x0a\x0a  // Note that simple async functions are implemented on top of\x0a  // AsyncIterator objects; they just return a Promise for the value of\x0a  // the final result produced by the iterator.\x0a  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\x0a    var iter = new AsyncIterator(\x0a      wrap(innerFn, outerFn, self, tryLocsList)\x0a    );\x0a\x0a    return runtime.isGeneratorFunction(outerFn)\x0a      ? iter // If outerFn is a generator, return the full iterator.\x0a      : iter.next().then(function(result) {\x0a          return result.done ? result.value : iter.next();\x0a        });\x0a  };\x0a\x0a  function makeInvokeMethod(innerFn, self, context) {\x0a    var state = GenStateSuspendedStart;\x0a\x0a    return function invoke(method, arg) {\x0a      if (state === GenStateExecuting) {\x0a        throw new Error(\x22Generator is already running\x22);\x0a      }\x0a\x0a      if (state === GenStateCompleted) {\x0a        if (method === \x22throw\x22) {\x0a          throw arg;\x0a        }\x0a\x0a        // Be forgiving, per 25.3.3.3.3 of the spec:\x0a        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\x0a        return doneResult();\x0a      }\x0a\x0a      context.method = method;\x0a      context.arg = arg;\x0a\x0a      while (true) {\x0a        var delegate = context.delegate;\x0a        if (delegate) {\x0a          var delegateResult = maybeInvokeDelegate(delegate, context);\x0a          if (delegateResult) {\x0a            if (delegateResult === ContinueSentinel) continue;\x0a            return delegateResult;\x0a          }\x0a        }\x0a\x0a        if (context.method === \x22next\x22) {\x0a          // Setting context._sent for legacy support of Babel\x27s\x0a          // function.sent implementation.\x0a          context.sent = context._sent = context.arg;\x0a\x0a        } else if (context.method === \x22throw\x22) {\x0a          if (state === GenStateSuspendedStart) {\x0a            state = GenStateCompleted;\x0a            throw context.arg;\x0a          }\x0a\x0a          context.dispatchException(context.arg);\x0a\x0a        } else if (context.method === \x22return\x22) {\x0a          context.abrupt(\x22return\x22, context.arg);\x0a        }\x0a\x0a        state = GenStateExecuting;\x0a\x0a        var record = tryCatch(innerFn, self, context);\x0a        if (record.type === \x22normal\x22) {\x0a          // If an exception is thrown from innerFn, we leave state ===\x0a          // GenStateExecuting and loop back for another invocation.\x0a          state = context.done\x0a            ? GenStateCompleted\x0a            : GenStateSuspendedYield;\x0a\x0a          if (record.arg === ContinueSentinel) {\x0a            continue;\x0a          }\x0a\x0a          return {\x0a            value: record.arg,\x0a            done: context.done\x0a          };\x0a\x0a        } else if (record.type === \x22throw\x22) {\x0a          state = GenStateCompleted;\x0a          // Dispatch the exception by looping back around to the\x0a          // context.dispatchException(context.arg) call above.\x0a          context.method = \x22throw\x22;\x0a          context.arg = record.arg;\x0a        }\x0a      }\x0a    };\x0a  }\x0a\x0a  // Call delegate.iterator[context.method](context.arg) and handle the\x0a  // result, either by returning a { value, done } result from the\x0a  // delegate iterator, or by modifying context.method and context.arg,\x0a  // setting context.delegate to null, and returning the ContinueSentinel.\x0a  function maybeInvokeDelegate(delegate, context) {\x0a    var method = delegate.iterator[context.method];\x0a    if (method === undefined) {\x0a      // A .throw or .return when the delegate iterator has no .throw\x0a      // method always terminates the yield* loop.\x0a      context.delegate = null;\x0a\x0a      if (context.method === \x22throw\x22) {\x0a        if (delegate.iterator.return) {\x0a          // If the delegate iterator has a return method, give it a\x0a          // chance to clean up.\x0a          context.method = \x22return\x22;\x0a          context.arg = undefined;\x0a          maybeInvokeDelegate(delegate, context);\x0a\x0a          if (context.method === \x22throw\x22) {\x0a            // If maybeInvokeDelegate(context) changed context.method from\x0a            // \x22return\x22 to \x22throw\x22, let that override the TypeError below.\x0a            return ContinueSentinel;\x0a          }\x0a        }\x0a\x0a        context.method = \x22throw\x22;\x0a        context.arg = new TypeError(\x0a          \x22The iterator does not provide a \x27throw\x27 method\x22);\x0a      }\x0a\x0a      return ContinueSentinel;\x0a    }\x0a\x0a    var record = tryCatch(method, delegate.iterator, context.arg);\x0a\x0a    if (record.type === \x22throw\x22) {\x0a      context.method = \x22throw\x22;\x0a      context.arg = record.arg;\x0a      context.delegate = null;\x0a      return ContinueSentinel;\x0a    }\x0a\x0a    var info = record.arg;\x0a\x0a    if (! info) {\x0a      context.method = \x22throw\x22;\x0a      context.arg = new TypeError(\x22iterator result is not an object\x22);\x0a      context.delegate = null;\x0a      return ContinueSentinel;\x0a    }\x0a\x0a    if (info.done) {\x0a      // Assign the result of the finished delegate to the temporary\x0a      // variable specified by delegate.resultName (see delegateYield).\x0a      context[delegate.resultName] = info.value;\x0a\x0a      // Resume execution at the desired location (see delegateYield).\x0a      context.next = delegate.nextLoc;\x0a\x0a      // If context.method was \x22throw\x22 but the delegate handled the\x0a      // exception, let the outer generator proceed normally. If\x0a      // context.method was \x22next\x22, forget context.arg since it has been\x0a      // \x22consumed\x22 by the delegate iterator. If context.method was\x0a      // \x22return\x22, allow the original .return call to continue in the\x0a      // outer generator.\x0a      if (context.method !== \x22return\x22) {\x0a        context.method = \x22next\x22;\x0a        context.arg = undefined;\x0a      }\x0a\x0a    } else {\x0a      // Re-yield the result returned by the delegate method.\x0a      return info;\x0a    }\x0a\x0a    // The delegate iterator is finished, so forget it and continue with\x0a    // the outer generator.\x0a    context.delegate = null;\x0a    return ContinueSentinel;\x0a  }\x0a\x0a  // Define Generator.prototype.{next,throw,return} in terms of the\x0a  // unified ._invoke helper method.\x0a  defineIteratorMethods(Gp);\x0a\x0a  Gp[toStringTagSymbol] = \x22Generator\x22;\x0a\x0a  // A Generator should always return itself as the iterator object when the\x0a  // @@iterator function is called on it. Some browsers\x27 implementations of the\x0a  // iterator prototype chain incorrectly implement this, causing the Generator\x0a  // object to not be returned from this call. This ensures that doesn\x27t happen.\x0a  // See https://github.com/facebook/regenerator/issues/274 for more details.\x0a  Gp[iteratorSymbol] = function() {\x0a    return this;\x0a  };\x0a\x0a  Gp.toString = function() {\x0a    return \x22[object Generator]\x22;\x0a  };\x0a\x0a  function pushTryEntry(locs) {\x0a    var entry = { tryLoc: locs[0] };\x0a\x0a    if (1 in locs) {\x0a      entry.catchLoc = locs[1];\x0a    }\x0a\x0a    if (2 in locs) {\x0a      entry.finallyLoc = locs[2];\x0a      entry.afterLoc = locs[3];\x0a    }\x0a\x0a    this.tryEntries.push(entry);\x0a  }\x0a\x0a  function resetTryEntry(entry) {\x0a    var record = entry.completion || {};\x0a    record.type = \x22normal\x22;\x0a    delete record.arg;\x0a    entry.completion = record;\x0a  }\x0a\x0a  function Context(tryLocsList) {\x0a    // The root entry object (effectively a try statement without a catch\x0a    // or a finally block) gives us a place to store values thrown from\x0a    // locations where there is no enclosing try statement.\x0a    this.tryEntries = [{ tryLoc: \x22root\x22 }];\x0a    tryLocsList.forEach(pushTryEntry, this);\x0a    this.reset(true);\x0a  }\x0a\x0a  runtime.keys = function(object) {\x0a    var keys = [];\x0a    for (var key in object) {\x0a      keys.push(key);\x0a    }\x0a    keys.reverse();\x0a\x0a    // Rather than returning an object with a next method, we keep\x0a    // things simple and return the next function itself.\x0a    return function next() {\x0a      while (keys.length) {\x0a        var key = keys.pop();\x0a        if (key in object) {\x0a          next.value = key;\x0a          next.done = false;\x0a          return next;\x0a        }\x0a      }\x0a\x0a      // To avoid creating an additional object, we just hang the .value\x0a      // and .done properties off the next function object itself. This\x0a      // also ensures that the minifier will not anonymize the function.\x0a      next.done = true;\x0a      return next;\x0a    };\x0a  };\x0a\x0a  function values(iterable) {\x0a    if (iterable) {\x0a      var iteratorMethod = iterable[iteratorSymbol];\x0a      if (iteratorMethod) {\x0a        return iteratorMethod.call(iterable);\x0a      }\x0a\x0a      if (typeof iterable.next === \x22function\x22) {\x0a        return iterable;\x0a      }\x0a\x0a      if (!isNaN(iterable.length)) {\x0a        var i = -1, next = function next() {\x0a          while (++i \x3c iterable.length) {\x0a            if (hasOwn.call(iterable, i)) {\x0a              next.value = iterable[i];\x0a              next.done = false;\x0a              return next;\x0a            }\x0a          }\x0a\x0a          next.value = undefined;\x0a          next.done = true;\x0a\x0a          return next;\x0a        };\x0a\x0a        return next.next = next;\x0a      }\x0a    }\x0a\x0a    // Return an iterator with no values.\x0a    return { next: doneResult };\x0a  }\x0a  runtime.values = values;\x0a\x0a  function doneResult() {\x0a    return { value: undefined, done: true };\x0a  }\x0a\x0a  Context.prototype = {\x0a    constructor: Context,\x0a\x0a    reset: function(skipTempReset) {\x0a      this.prev = 0;\x0a      this.next = 0;\x0a      // Resetting context._sent for legacy support of Babel\x27s\x0a      // function.sent implementation.\x0a      this.sent = this._sent = undefined;\x0a      this.done = false;\x0a      this.delegate = null;\x0a\x0a      this.method = \x22next\x22;\x0a      this.arg = undefined;\x0a\x0a      this.tryEntries.forEach(resetTryEntry);\x0a\x0a      if (!skipTempReset) {\x0a        for (var name in this) {\x0a          // Not sure about the optimal order of these conditions:\x0a          if (name.charAt(0) === \x22t\x22 &&\x0a              hasOwn.call(this, name) &&\x0a              !isNaN(+name.slice(1))) {\x0a            this[name] = undefined;\x0a          }\x0a        }\x0a      }\x0a    },\x0a\x0a    stop: function() {\x0a      this.done = true;\x0a\x0a      var rootEntry = this.tryEntries[0];\x0a      var rootRecord = rootEntry.completion;\x0a      if (rootRecord.type === \x22throw\x22) {\x0a        throw rootRecord.arg;\x0a      }\x0a\x0a      return this.rval;\x0a    },\x0a\x0a    dispatchException: function(exception) {\x0a      if (this.done) {\x0a        throw exception;\x0a      }\x0a\x0a      var context = this;\x0a      function handle(loc, caught) {\x0a        record.type = \x22throw\x22;\x0a        record.arg = exception;\x0a        context.next = loc;\x0a\x0a        if (caught) {\x0a          // If the dispatched exception was caught by a catch block,\x0a          // then let that catch block handle the exception normally.\x0a          context.method = \x22next\x22;\x0a          context.arg = undefined;\x0a        }\x0a\x0a        return !! caught;\x0a      }\x0a\x0a      for (var i = this.tryEntries.length - 1; i \x3e= 0; --i) {\x0a        var entry = this.tryEntries[i];\x0a        var record = entry.completion;\x0a\x0a        if (entry.tryLoc === \x22root\x22) {\x0a          // Exception thrown outside of any try block that could handle\x0a          // it, so set the completion value of the entire function to\x0a          // throw the exception.\x0a          return handle(\x22end\x22);\x0a        }\x0a\x0a        if (entry.tryLoc \x3c= this.prev) {\x0a          var hasCatch = hasOwn.call(entry, \x22catchLoc\x22);\x0a          var hasFinally = hasOwn.call(entry, \x22finallyLoc\x22);\x0a\x0a          if (hasCatch && hasFinally) {\x0a            if (this.prev \x3c entry.catchLoc) {\x0a              return handle(entry.catchLoc, true);\x0a            } else if (this.prev \x3c entry.finallyLoc) {\x0a              return handle(entry.finallyLoc);\x0a            }\x0a\x0a          } else if (hasCatch) {\x0a            if (this.prev \x3c entry.catchLoc) {\x0a              return handle(entry.catchLoc, true);\x0a            }\x0a\x0a          } else if (hasFinally) {\x0a            if (this.prev \x3c entry.finallyLoc) {\x0a              return handle(entry.finallyLoc);\x0a            }\x0a\x0a          } else {\x0a            throw new Error(\x22try statement without catch or finally\x22);\x0a          }\x0a        }\x0a      }\x0a    },\x0a\x0a    abrupt: function(type, arg) {\x0a      for (var i = this.tryEntries.length - 1; i \x3e= 0; --i) {\x0a        var entry = this.tryEntries[i];\x0a        if (entry.tryLoc \x3c= this.prev &&\x0a            hasOwn.call(entry, \x22finallyLoc\x22) &&\x0a            this.prev \x3c entry.finallyLoc) {\x0a          var finallyEntry = entry;\x0a          break;\x0a        }\x0a      }\x0a\x0a      if (finallyEntry &&\x0a          (type === \x22break\x22 ||\x0a           type === \x22continue\x22) &&\x0a          finallyEntry.tryLoc \x3c= arg &&\x0a          arg \x3c= finallyEntry.finallyLoc) {\x0a        // Ignore the finally entry if control is not jumping to a\x0a        // location outside the try/catch block.\x0a        finallyEntry = null;\x0a      }\x0a\x0a      var record = finallyEntry ? finallyEntry.completion : {};\x0a      record.type = type;\x0a      record.arg = arg;\x0a\x0a      if (finallyEntry) {\x0a        this.method = \x22next\x22;\x0a        this.next = finallyEntry.finallyLoc;\x0a        return ContinueSentinel;\x0a      }\x0a\x0a      return this.complete(record);\x0a    },\x0a\x0a    complete: function(record, afterLoc) {\x0a      if (record.type === \x22throw\x22) {\x0a        throw record.arg;\x0a      }\x0a\x0a      if (record.type === \x22break\x22 ||\x0a          record.type === \x22continue\x22) {\x0a        this.next = record.arg;\x0a      } else if (record.type === \x22return\x22) {\x0a        this.rval = this.arg = record.arg;\x0a        this.method = \x22return\x22;\x0a        this.next = \x22end\x22;\x0a      } else if (record.type === \x22normal\x22 && afterLoc) {\x0a        this.next = afterLoc;\x0a      }\x0a\x0a      return ContinueSentinel;\x0a    },\x0a\x0a    finish: function(finallyLoc) {\x0a      for (var i = this.tryEntries.length - 1; i \x3e= 0; --i) {\x0a        var entry = this.tryEntries[i];\x0a        if (entry.finallyLoc === finallyLoc) {\x0a          this.complete(entry.completion, entry.afterLoc);\x0a          resetTryEntry(entry);\x0a          return ContinueSentinel;\x0a        }\x0a      }\x0a    },\x0a\x0a    \x22catch\x22: function(tryLoc) {\x0a      for (var i = this.tryEntries.length - 1; i \x3e= 0; --i) {\x0a        var entry = this.tryEntries[i];\x0a        if (entry.tryLoc === tryLoc) {\x0a          var record = entry.completion;\x0a          if (record.type === \x22throw\x22) {\x0a            var thrown = record.arg;\x0a            resetTryEntry(entry);\x0a          }\x0a          return thrown;\x0a        }\x0a      }\x0a\x0a      // The context.catch method must only be called with a location\x0a      // argument that corresponds to a known catch block.\x0a      throw new Error(\x22illegal catch attempt\x22);\x0a    },\x0a\x0a    delegateYield: function(iterable, resultName, nextLoc) {\x0a      this.delegate = {\x0a        iterator: values(iterable),\x0a        resultName: resultName,\x0a        nextLoc: nextLoc\x0a      };\x0a\x0a      if (this.method === \x22next\x22) {\x0a        // Deliberately forget the last sent value so that we don\x27t\x0a        // accidentally pass it on to the delegate.\x0a        this.arg = undefined;\x0a      }\x0a\x0a      return ContinueSentinel;\x0a    }\x0a  };\x0a})(\x0a  // In sloppy mode, unbound `this` refers to the global object, fallback to\x0a  // Function constructor if we\x27re in global strict mode. That is sadly a form\x0a  // of indirect eval which violates Content Security Policy.\x0a  (function() {\x0a    return this || (typeof self === \x22object\x22 && self);\x0a  })() || Function(\x22return this\x22)()\x0a);\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 59:\x0a/***/ (function(module, exports) {\x0a\x0avar g;\x0a\x0a// This works in non-strict mode\x0ag = (function() {\x0a\x09return this;\x0a})();\x0a\x0atry {\x0a\x09// This works if eval is allowed (see CSP)\x0a\x09g = g || new Function(\x22return this\x22)();\x0a} catch (e) {\x0a\x09// This works if the window reference is available\x0a\x09if (typeof window === \x22object\x22) g = window;\x0a}\x0a\x0a// g can still be undefined, but nothing to do about it...\x0a// We return undefined, instead of nothing here, so it\x27s\x0a// easier to handle this case. if(!global) { ...}\x0a\x0amodule.exports = g;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 6:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22compose\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 7:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _objectSpread; });\x0a/* harmony import */ var _defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);\x0a\x0afunction _objectSpread(target) {\x0a  for (var i = 1; i \x3c arguments.length; i++) {\x0a    var source = arguments[i] != null ? arguments[i] : {};\x0a    var ownKeys = Object.keys(source);\x0a\x0a    if (typeof Object.getOwnPropertySymbols === \x27function\x27) {\x0a      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\x0a        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\x0a      }));\x0a    }\x0a\x0a    ownKeys.forEach(function (key) {\x0a      Object(_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22])(target, key, source[key]);\x0a    });\x0a  }\x0a\x0a  return target;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 71:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22c\x22, function() { return createStore; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22b\x22, function() { return combineReducers; });\x0a/* unused harmony export bindActionCreators */\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return applyMiddleware; });\x0a/* unused harmony export compose */\x0a/* unused harmony export __DO_NOT_USE__ActionTypes */\x0a/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);\x0a\x0a\x0a/**\x0a * These are private action types reserved by Redux.\x0a * For any unknown actions, you must return the current state.\x0a * If the current state is undefined, you must return the initial state.\x0a * Do not reference these action types directly in your code.\x0a */\x0avar randomString = function randomString() {\x0a  return Math.random().toString(36).substring(7).split(\x27\x27).join(\x27.\x27);\x0a};\x0a\x0avar ActionTypes = {\x0a  INIT: \x22@@redux/INIT\x22 + randomString(),\x0a  REPLACE: \x22@@redux/REPLACE\x22 + randomString(),\x0a  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\x0a    return \x22@@redux/PROBE_UNKNOWN_ACTION\x22 + randomString();\x0a  }\x0a};\x0a\x0a/**\x0a * @param {any} obj The object to inspect.\x0a * @returns {boolean} True if the argument appears to be a plain object.\x0a */\x0afunction isPlainObject(obj) {\x0a  if (typeof obj !== \x27object\x27 || obj === null) return false;\x0a  var proto = obj;\x0a\x0a  while (Object.getPrototypeOf(proto) !== null) {\x0a    proto = Object.getPrototypeOf(proto);\x0a  }\x0a\x0a  return Object.getPrototypeOf(obj) === proto;\x0a}\x0a\x0a/**\x0a * Creates a Redux store that holds the state tree.\x0a * The only way to change the data in the store is to call `dispatch()` on it.\x0a *\x0a * There should only be a single store in your app. To specify how different\x0a * parts of the state tree respond to actions, you may combine several reducers\x0a * into a single reducer function by using `combineReducers`.\x0a *\x0a * @param {Function} reducer A function that returns the next state tree, given\x0a * the current state tree and the action to handle.\x0a *\x0a * @param {any} [preloadedState] The initial state. You may optionally specify it\x0a * to hydrate the state from the server in universal apps, or to restore a\x0a * previously serialized user session.\x0a * If you use `combineReducers` to produce the root reducer function, this must be\x0a * an object with the same shape as `combineReducers` keys.\x0a *\x0a * @param {Function} [enhancer] The store enhancer. You may optionally specify it\x0a * to enhance the store with third-party capabilities such as middleware,\x0a * time travel, persistence, etc. The only store enhancer that ships with Redux\x0a * is `applyMiddleware()`.\x0a *\x0a * @returns {Store} A Redux store that lets you read the state, dispatch actions\x0a * and subscribe to changes.\x0a */\x0a\x0afunction createStore(reducer, preloadedState, enhancer) {\x0a  var _ref2;\x0a\x0a  if (typeof preloadedState === \x27function\x27 && typeof enhancer === \x27function\x27 || typeof enhancer === \x27function\x27 && typeof arguments[3] === \x27function\x27) {\x0a    throw new Error(\x27It looks like you are passing several store enhancers to \x27 + \x27createStore(). This is not supported. Instead, compose them \x27 + \x27together to a single function\x27);\x0a  }\x0a\x0a  if (typeof preloadedState === \x27function\x27 && typeof enhancer === \x27undefined\x27) {\x0a    enhancer = preloadedState;\x0a    preloadedState = undefined;\x0a  }\x0a\x0a  if (typeof enhancer !== \x27undefined\x27) {\x0a    if (typeof enhancer !== \x27function\x27) {\x0a      throw new Error(\x27Expected the enhancer to be a function.\x27);\x0a    }\x0a\x0a    return enhancer(createStore)(reducer, preloadedState);\x0a  }\x0a\x0a  if (typeof reducer !== \x27function\x27) {\x0a    throw new Error(\x27Expected the reducer to be a function.\x27);\x0a  }\x0a\x0a  var currentReducer = reducer;\x0a  var currentState = preloadedState;\x0a  var currentListeners = [];\x0a  var nextListeners = currentListeners;\x0a  var isDispatching = false;\x0a\x0a  function ensureCanMutateNextListeners() {\x0a    if (nextListeners === currentListeners) {\x0a      nextListeners = currentListeners.slice();\x0a    }\x0a  }\x0a  /**\x0a   * Reads the state tree managed by the store.\x0a   *\x0a   * @returns {any} The current state tree of your application.\x0a   */\x0a\x0a\x0a  function getState() {\x0a    if (isDispatching) {\x0a      throw new Error(\x27You may not call store.getState() while the reducer is executing. \x27 + \x27The reducer has already received the state as an argument. \x27 + \x27Pass it down from the top reducer instead of reading it from the store.\x27);\x0a    }\x0a\x0a    return currentState;\x0a  }\x0a  /**\x0a   * Adds a change listener. It will be called any time an action is dispatched,\x0a   * and some part of the state tree may potentially have changed. You may then\x0a   * call `getState()` to read the current state tree inside the callback.\x0a   *\x0a   * You may call `dispatch()` from a change listener, with the following\x0a   * caveats:\x0a   *\x0a   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\x0a   * If you subscribe or unsubscribe while the listeners are being invoked, this\x0a   * will not have any effect on the `dispatch()` that is currently in progress.\x0a   * However, the next `dispatch()` call, whether nested or not, will use a more\x0a   * recent snapshot of the subscription list.\x0a   *\x0a   * 2. The listener should not expect to see all state changes, as the state\x0a   * might have been updated multiple times during a nested `dispatch()` before\x0a   * the listener is called. It is, however, guaranteed that all subscribers\x0a   * registered before the `dispatch()` started will be called with the latest\x0a   * state by the time it exits.\x0a   *\x0a   * @param {Function} listener A callback to be invoked on every dispatch.\x0a   * @returns {Function} A function to remove this change listener.\x0a   */\x0a\x0a\x0a  function subscribe(listener) {\x0a    if (typeof listener !== \x27function\x27) {\x0a      throw new Error(\x27Expected the listener to be a function.\x27);\x0a    }\x0a\x0a    if (isDispatching) {\x0a      throw new Error(\x27You may not call store.subscribe() while the reducer is executing. \x27 + \x27If you would like to be notified after the store has been updated, subscribe from a \x27 + \x27component and invoke store.getState() in the callback to access the latest state. \x27 + \x27See https://redux.js.org/api-reference/store#subscribe(listener) for more details.\x27);\x0a    }\x0a\x0a    var isSubscribed = true;\x0a    ensureCanMutateNextListeners();\x0a    nextListeners.push(listener);\x0a    return function unsubscribe() {\x0a      if (!isSubscribed) {\x0a        return;\x0a      }\x0a\x0a      if (isDispatching) {\x0a        throw new Error(\x27You may not unsubscribe from a store listener while the reducer is executing. \x27 + \x27See https://redux.js.org/api-reference/store#subscribe(listener) for more details.\x27);\x0a      }\x0a\x0a      isSubscribed = false;\x0a      ensureCanMutateNextListeners();\x0a      var index = nextListeners.indexOf(listener);\x0a      nextListeners.splice(index, 1);\x0a    };\x0a  }\x0a  /**\x0a   * Dispatches an action. It is the only way to trigger a state change.\x0a   *\x0a   * The `reducer` function, used to create the store, will be called with the\x0a   * current state tree and the given `action`. Its return value will\x0a   * be considered the **next** state of the tree, and the change listeners\x0a   * will be notified.\x0a   *\x0a   * The base implementation only supports plain object actions. If you want to\x0a   * dispatch a Promise, an Observable, a thunk, or something else, you need to\x0a   * wrap your store creating function into the corresponding middleware. For\x0a   * example, see the documentation for the `redux-thunk` package. Even the\x0a   * middleware will eventually dispatch plain object actions using this method.\x0a   *\x0a   * @param {Object} action A plain object representing \xe2\x80\x9cwhat changed\xe2\x80\x9d. It is\x0a   * a good idea to keep actions serializable so you can record and replay user\x0a   * sessions, or use the time travelling `redux-devtools`. An action must have\x0a   * a `type` property which may not be `undefined`. It is a good idea to use\x0a   * string constants for action types.\x0a   *\x0a   * @returns {Object} For convenience, the same action object you dispatched.\x0a   *\x0a   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\x0a   * return something else (for example, a Promise you can await).\x0a   */\x0a\x0a\x0a  function dispatch(action) {\x0a    if (!isPlainObject(action)) {\x0a      throw new Error(\x27Actions must be plain objects. \x27 + \x27Use custom middleware for async actions.\x27);\x0a    }\x0a\x0a    if (typeof action.type === \x27undefined\x27) {\x0a      throw new Error(\x27Actions may not have an undefined \x22type\x22 property. \x27 + \x27Have you misspelled a constant?\x27);\x0a    }\x0a\x0a    if (isDispatching) {\x0a      throw new Error(\x27Reducers may not dispatch actions.\x27);\x0a    }\x0a\x0a    try {\x0a      isDispatching = true;\x0a      currentState = currentReducer(currentState, action);\x0a    } finally {\x0a      isDispatching = false;\x0a    }\x0a\x0a    var listeners = currentListeners = nextListeners;\x0a\x0a    for (var i = 0; i \x3c listeners.length; i++) {\x0a      var listener = listeners[i];\x0a      listener();\x0a    }\x0a\x0a    return action;\x0a  }\x0a  /**\x0a   * Replaces the reducer currently used by the store to calculate the state.\x0a   *\x0a   * You might need this if your app implements code splitting and you want to\x0a   * load some of the reducers dynamically. You might also need this if you\x0a   * implement a hot reloading mechanism for Redux.\x0a   *\x0a   * @param {Function} nextReducer The reducer for the store to use instead.\x0a   * @returns {void}\x0a   */\x0a\x0a\x0a  function replaceReducer(nextReducer) {\x0a    if (typeof nextReducer !== \x27function\x27) {\x0a      throw new Error(\x27Expected the nextReducer to be a function.\x27);\x0a    }\x0a\x0a    currentReducer = nextReducer;\x0a    dispatch({\x0a      type: ActionTypes.REPLACE\x0a    });\x0a  }\x0a  /**\x0a   * Interoperability point for observable/reactive libraries.\x0a   * @returns {observable} A minimal observable of state changes.\x0a   * For more information, see the observable proposal:\x0a   * https://github.com/tc39/proposal-observable\x0a   */\x0a\x0a\x0a  function observable() {\x0a    var _ref;\x0a\x0a    var outerSubscribe = subscribe;\x0a    return _ref = {\x0a      /**\x0a       * The minimal observable subscription method.\x0a       * @param {Object} observer Any object that can be used as an observer.\x0a       * The observer object should have a `next` method.\x0a       * @returns {subscription} An object with an `unsubscribe` method that can\x0a       * be used to unsubscribe the observable from the store, and prevent further\x0a       * emission of values from the observable.\x0a       */\x0a      subscribe: function subscribe(observer) {\x0a        if (typeof observer !== \x27object\x27 || observer === null) {\x0a          throw new TypeError(\x27Expected the observer to be an object.\x27);\x0a        }\x0a\x0a        function observeState() {\x0a          if (observer.next) {\x0a            observer.next(getState());\x0a          }\x0a        }\x0a\x0a        observeState();\x0a        var unsubscribe = outerSubscribe(observeState);\x0a        return {\x0a          unsubscribe: unsubscribe\x0a        };\x0a      }\x0a    }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22]] = function () {\x0a      return this;\x0a    }, _ref;\x0a  } // When a store is created, an \x22INIT\x22 action is dispatched so that every\x0a  // reducer returns their initial state. This effectively populates\x0a  // the initial state tree.\x0a\x0a\x0a  dispatch({\x0a    type: ActionTypes.INIT\x0a  });\x0a  return _ref2 = {\x0a    dispatch: dispatch,\x0a    subscribe: subscribe,\x0a    getState: getState,\x0a    replaceReducer: replaceReducer\x0a  }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22]] = observable, _ref2;\x0a}\x0a\x0a/**\x0a * Prints a warning in the console if it exists.\x0a *\x0a * @param {String} message The warning message.\x0a * @returns {void}\x0a */\x0afunction warning(message) {\x0a  /* eslint-disable no-console */\x0a  if (typeof console !== \x27undefined\x27 && typeof console.error === \x27function\x27) {\x0a    console.error(message);\x0a  }\x0a  /* eslint-enable no-console */\x0a\x0a\x0a  try {\x0a    // This error was thrown as a convenience so that if you enable\x0a    // \x22break on all exceptions\x22 in your console,\x0a    // it would pause the execution at this line.\x0a    throw new Error(message);\x0a  } catch (e) {} // eslint-disable-line no-empty\x0a\x0a}\x0a\x0afunction getUndefinedStateErrorMessage(key, action) {\x0a  var actionType = action && action.type;\x0a  var actionDescription = actionType && \x22action \x5c\x22\x22 + String(actionType) + \x22\x5c\x22\x22 || \x27an action\x27;\x0a  return \x22Given \x22 + actionDescription + \x22, reducer \x5c\x22\x22 + key + \x22\x5c\x22 returned undefined. \x22 + \x22To ignore an action, you must explicitly return the previous state. \x22 + \x22If you want this reducer to hold no value, you can return null instead of undefined.\x22;\x0a}\x0a\x0afunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\x0a  var reducerKeys = Object.keys(reducers);\x0a  var argumentName = action && action.type === ActionTypes.INIT ? \x27preloadedState argument passed to createStore\x27 : \x27previous state received by the reducer\x27;\x0a\x0a  if (reducerKeys.length === 0) {\x0a    return \x27Store does not have a valid reducer. Make sure the argument passed \x27 + \x27to combineReducers is an object whose values are reducers.\x27;\x0a  }\x0a\x0a  if (!isPlainObject(inputState)) {\x0a    return \x22The \x22 + argumentName + \x22 has unexpected type of \x5c\x22\x22 + {}.toString.call(inputState).match(/\x5cs([a-z|A-Z]+)/)[1] + \x22\x5c\x22. Expected argument to be an object with the following \x22 + (\x22keys: \x5c\x22\x22 + reducerKeys.join(\x27\x22, \x22\x27) + \x22\x5c\x22\x22);\x0a  }\x0a\x0a  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\x0a    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\x0a  });\x0a  unexpectedKeys.forEach(function (key) {\x0a    unexpectedKeyCache[key] = true;\x0a  });\x0a  if (action && action.type === ActionTypes.REPLACE) return;\x0a\x0a  if (unexpectedKeys.length \x3e 0) {\x0a    return \x22Unexpected \x22 + (unexpectedKeys.length \x3e 1 ? \x27keys\x27 : \x27key\x27) + \x22 \x22 + (\x22\x5c\x22\x22 + unexpectedKeys.join(\x27\x22, \x22\x27) + \x22\x5c\x22 found in \x22 + argumentName + \x22. \x22) + \x22Expected to find one of the known reducer keys instead: \x22 + (\x22\x5c\x22\x22 + reducerKeys.join(\x27\x22, \x22\x27) + \x22\x5c\x22. Unexpected keys will be ignored.\x22);\x0a  }\x0a}\x0a\x0afunction assertReducerShape(reducers) {\x0a  Object.keys(reducers).forEach(function (key) {\x0a    var reducer = reducers[key];\x0a    var initialState = reducer(undefined, {\x0a      type: ActionTypes.INIT\x0a    });\x0a\x0a    if (typeof initialState === \x27undefined\x27) {\x0a      throw new Error(\x22Reducer \x5c\x22\x22 + key + \x22\x5c\x22 returned undefined during initialization. \x22 + \x22If the state passed to the reducer is undefined, you must \x22 + \x22explicitly return the initial state. The initial state may \x22 + \x22not be undefined. If you don\x27t want to set a value for this reducer, \x22 + \x22you can use null instead of undefined.\x22);\x0a    }\x0a\x0a    if (typeof reducer(undefined, {\x0a      type: ActionTypes.PROBE_UNKNOWN_ACTION()\x0a    }) === \x27undefined\x27) {\x0a      throw new Error(\x22Reducer \x5c\x22\x22 + key + \x22\x5c\x22 returned undefined when probed with a random type. \x22 + (\x22Don\x27t try to handle \x22 + ActionTypes.INIT + \x22 or other actions in \x5c\x22redux/*\x5c\x22 \x22) + \x22namespace. They are considered private. Instead, you must return the \x22 + \x22current state for any unknown actions, unless it is undefined, \x22 + \x22in which case you must return the initial state, regardless of the \x22 + \x22action type. The initial state may not be undefined, but can be null.\x22);\x0a    }\x0a  });\x0a}\x0a/**\x0a * Turns an object whose values are different reducer functions, into a single\x0a * reducer function. It will call every child reducer, and gather their results\x0a * into a single state object, whose keys correspond to the keys of the passed\x0a * reducer functions.\x0a *\x0a * @param {Object} reducers An object whose values correspond to different\x0a * reducer functions that need to be combined into one. One handy way to obtain\x0a * it is to use ES6 `import * as reducers` syntax. The reducers may never return\x0a * undefined for any action. Instead, they should return their initial state\x0a * if the state passed to them was undefined, and the current state for any\x0a * unrecognized action.\x0a *\x0a * @returns {Function} A reducer function that invokes every reducer inside the\x0a * passed object, and builds a state object with the same shape.\x0a */\x0a\x0a\x0afunction combineReducers(reducers) {\x0a  var reducerKeys = Object.keys(reducers);\x0a  var finalReducers = {};\x0a\x0a  for (var i = 0; i \x3c reducerKeys.length; i++) {\x0a    var key = reducerKeys[i];\x0a\x0a    if (false) {}\x0a\x0a    if (typeof reducers[key] === \x27function\x27) {\x0a      finalReducers[key] = reducers[key];\x0a    }\x0a  }\x0a\x0a  var finalReducerKeys = Object.keys(finalReducers);\x0a  var unexpectedKeyCache;\x0a\x0a  if (false) {}\x0a\x0a  var shapeAssertionError;\x0a\x0a  try {\x0a    assertReducerShape(finalReducers);\x0a  } catch (e) {\x0a    shapeAssertionError = e;\x0a  }\x0a\x0a  return function combination(state, action) {\x0a    if (state === void 0) {\x0a      state = {};\x0a    }\x0a\x0a    if (shapeAssertionError) {\x0a      throw shapeAssertionError;\x0a    }\x0a\x0a    if (false) { var warningMessage; }\x0a\x0a    var hasChanged = false;\x0a    var nextState = {};\x0a\x0a    for (var _i = 0; _i \x3c finalReducerKeys.length; _i++) {\x0a      var _key = finalReducerKeys[_i];\x0a      var reducer = finalReducers[_key];\x0a      var previousStateForKey = state[_key];\x0a      var nextStateForKey = reducer(previousStateForKey, action);\x0a\x0a      if (typeof nextStateForKey === \x27undefined\x27) {\x0a        var errorMessage = getUndefinedStateErrorMessage(_key, action);\x0a        throw new Error(errorMessage);\x0a      }\x0a\x0a      nextState[_key] = nextStateForKey;\x0a      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\x0a    }\x0a\x0a    return hasChanged ? nextState : state;\x0a  };\x0a}\x0a\x0afunction bindActionCreator(actionCreator, dispatch) {\x0a  return function () {\x0a    return dispatch(actionCreator.apply(this, arguments));\x0a  };\x0a}\x0a/**\x0a * Turns an object whose values are action creators, into an object with the\x0a * same keys, but with every function wrapped into a `dispatch` call so they\x0a * may be invoked directly. This is just a convenience method, as you can call\x0a * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\x0a *\x0a * For convenience, you can also pass a single function as the first argument,\x0a * and get a function in return.\x0a *\x0a * @param {Function|Object} actionCreators An object whose values are action\x0a * creator functions. One handy way to obtain it is to use ES6 `import * as`\x0a * syntax. You may also pass a single function.\x0a *\x0a * @param {Function} dispatch The `dispatch` function available on your Redux\x0a * store.\x0a *\x0a * @returns {Function|Object} The object mimicking the original object, but with\x0a * every action creator wrapped into the `dispatch` call. If you passed a\x0a * function as `actionCreators`, the return value will also be a single\x0a * function.\x0a */\x0a\x0a\x0afunction bindActionCreators(actionCreators, dispatch) {\x0a  if (typeof actionCreators === \x27function\x27) {\x0a    return bindActionCreator(actionCreators, dispatch);\x0a  }\x0a\x0a  if (typeof actionCreators !== \x27object\x27 || actionCreators === null) {\x0a    throw new Error(\x22bindActionCreators expected an object or a function, instead received \x22 + (actionCreators === null ? \x27null\x27 : typeof actionCreators) + \x22. \x22 + \x22Did you write \x5c\x22import ActionCreators from\x5c\x22 instead of \x5c\x22import * as ActionCreators from\x5c\x22?\x22);\x0a  }\x0a\x0a  var keys = Object.keys(actionCreators);\x0a  var boundActionCreators = {};\x0a\x0a  for (var i = 0; i \x3c keys.length; i++) {\x0a    var key = keys[i];\x0a    var actionCreator = actionCreators[key];\x0a\x0a    if (typeof actionCreator === \x27function\x27) {\x0a      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\x0a    }\x0a  }\x0a\x0a  return boundActionCreators;\x0a}\x0a\x0afunction _defineProperty(obj, key, value) {\x0a  if (key in obj) {\x0a    Object.defineProperty(obj, key, {\x0a      value: value,\x0a      enumerable: true,\x0a      configurable: true,\x0a      writable: true\x0a    });\x0a  } else {\x0a    obj[key] = value;\x0a  }\x0a\x0a  return obj;\x0a}\x0a\x0afunction _objectSpread(target) {\x0a  for (var i = 1; i \x3c arguments.length; i++) {\x0a    var source = arguments[i] != null ? arguments[i] : {};\x0a    var ownKeys = Object.keys(source);\x0a\x0a    if (typeof Object.getOwnPropertySymbols === \x27function\x27) {\x0a      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\x0a        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\x0a      }));\x0a    }\x0a\x0a    ownKeys.forEach(function (key) {\x0a      _defineProperty(target, key, source[key]);\x0a    });\x0a  }\x0a\x0a  return target;\x0a}\x0a\x0a/**\x0a * Composes single-argument functions from right to left. The rightmost\x0a * function can take multiple arguments as it provides the signature for\x0a * the resulting composite function.\x0a *\x0a * @param {...Function} funcs The functions to compose.\x0a * @returns {Function} A function obtained by composing the argument functions\x0a * from right to left. For example, compose(f, g, h) is identical to doing\x0a * (...args) =\x3e f(g(h(...args))).\x0a */\x0afunction compose() {\x0a  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key \x3c _len; _key++) {\x0a    funcs[_key] = arguments[_key];\x0a  }\x0a\x0a  if (funcs.length === 0) {\x0a    return function (arg) {\x0a      return arg;\x0a    };\x0a  }\x0a\x0a  if (funcs.length === 1) {\x0a    return funcs[0];\x0a  }\x0a\x0a  return funcs.reduce(function (a, b) {\x0a    return function () {\x0a      return a(b.apply(void 0, arguments));\x0a    };\x0a  });\x0a}\x0a\x0a/**\x0a * Creates a store enhancer that applies middleware to the dispatch method\x0a * of the Redux store. This is handy for a variety of tasks, such as expressing\x0a * asynchronous actions in a concise manner, or logging every action payload.\x0a *\x0a * See `redux-thunk` package as an example of the Redux middleware.\x0a *\x0a * Because middleware is potentially asynchronous, this should be the first\x0a * store enhancer in the composition chain.\x0a *\x0a * Note that each middleware will be given the `dispatch` and `getState` functions\x0a * as named arguments.\x0a *\x0a * @param {...Function} middlewares The middleware chain to be applied.\x0a * @returns {Function} A store enhancer applying the middleware.\x0a */\x0a\x0afunction applyMiddleware() {\x0a  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key \x3c _len; _key++) {\x0a    middlewares[_key] = arguments[_key];\x0a  }\x0a\x0a  return function (createStore) {\x0a    return function () {\x0a      var store = createStore.apply(void 0, arguments);\x0a\x0a      var _dispatch = function dispatch() {\x0a        throw new Error(\x22Dispatching while constructing your middleware is not allowed. \x22 + \x22Other middleware would not be applied to this dispatch.\x22);\x0a      };\x0a\x0a      var middlewareAPI = {\x0a        getState: store.getState,\x0a        dispatch: function dispatch() {\x0a          return _dispatch.apply(void 0, arguments);\x0a        }\x0a      };\x0a      var chain = middlewares.map(function (middleware) {\x0a        return middleware(middlewareAPI);\x0a      });\x0a      _dispatch = compose.apply(void 0, chain)(store.dispatch);\x0a      return _objectSpread({}, store, {\x0a        dispatch: _dispatch\x0a      });\x0a    };\x0a  };\x0a}\x0a\x0a/*\x0a * This is a dummy function to check if the function name has been altered by minification.\x0a * If the function has been minified and NODE_ENV !== \x27production\x27, warn the user.\x0a */\x0a\x0afunction isCrushed() {}\x0a\x0aif (false) {}\x0a\x0a\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 76:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0afunction _typeof(obj) {\x0a  if (typeof Symbol === \x22function\x22 && typeof Symbol.iterator === \x22symbol\x22) {\x0a    _typeof = function (obj) {\x0a      return typeof obj;\x0a    };\x0a  } else {\x0a    _typeof = function (obj) {\x0a      return obj && typeof Symbol === \x22function\x22 && obj.constructor === Symbol && obj !== Symbol.prototype ? \x22symbol\x22 : typeof obj;\x0a    };\x0a  }\x0a\x0a  return _typeof(obj);\x0a}\x0a\x0afunction _classCallCheck(instance, Constructor) {\x0a  if (!(instance instanceof Constructor)) {\x0a    throw new TypeError(\x22Cannot call a class as a function\x22);\x0a  }\x0a}\x0a\x0afunction _defineProperties(target, props) {\x0a  for (var i = 0; i \x3c props.length; i++) {\x0a    var descriptor = props[i];\x0a    descriptor.enumerable = descriptor.enumerable || false;\x0a    descriptor.configurable = true;\x0a    if (\x22value\x22 in descriptor) descriptor.writable = true;\x0a    Object.defineProperty(target, descriptor.key, descriptor);\x0a  }\x0a}\x0a\x0afunction _createClass(Constructor, protoProps, staticProps) {\x0a  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\x0a  if (staticProps) _defineProperties(Constructor, staticProps);\x0a  return Constructor;\x0a}\x0a\x0a/**\x0a * Given an instance of EquivalentKeyMap, returns its internal value pair tuple\x0a * for a key, if one exists. The tuple members consist of the last reference\x0a * value for the key (used in efficient subsequent lookups) and the value\x0a * assigned for the key at the leaf node.\x0a *\x0a * @param {EquivalentKeyMap} instance EquivalentKeyMap instance.\x0a * @param {*} key                     The key for which to return value pair.\x0a *\x0a * @return {?Array} Value pair, if exists.\x0a */\x0afunction getValuePair(instance, key) {\x0a  var _map = instance._map,\x0a      _arrayTreeMap = instance._arrayTreeMap,\x0a      _objectTreeMap = instance._objectTreeMap; // Map keeps a reference to the last object-like key used to set the\x0a  // value, which can be used to shortcut immediately to the value.\x0a\x0a  if (_map.has(key)) {\x0a    return _map.get(key);\x0a  } // Sort keys to ensure stable retrieval from tree.\x0a\x0a\x0a  var properties = Object.keys(key).sort(); // Tree by type to avoid conflicts on numeric object keys, empty value.\x0a\x0a  var map = Array.isArray(key) ? _arrayTreeMap : _objectTreeMap;\x0a\x0a  for (var i = 0; i \x3c properties.length; i++) {\x0a    var property = properties[i];\x0a    map = map.get(property);\x0a\x0a    if (map === undefined) {\x0a      return;\x0a    }\x0a\x0a    var propertyValue = key[property];\x0a    map = map.get(propertyValue);\x0a\x0a    if (map === undefined) {\x0a      return;\x0a    }\x0a  }\x0a\x0a  var valuePair = map.get(\x27_ekm_value\x27);\x0a\x0a  if (!valuePair) {\x0a    return;\x0a  } // If reached, it implies that an object-like key was set with another\x0a  // reference, so delete the reference and replace with the current.\x0a\x0a\x0a  _map.delete(valuePair[0]);\x0a\x0a  valuePair[0] = key;\x0a  map.set(\x27_ekm_value\x27, valuePair);\x0a\x0a  _map.set(key, valuePair);\x0a\x0a  return valuePair;\x0a}\x0a/**\x0a * Variant of a Map object which enables lookup by equivalent (deeply equal)\x0a * object and array keys.\x0a */\x0a\x0a\x0avar EquivalentKeyMap =\x0a/*#__PURE__*/\x0afunction () {\x0a  /**\x0a   * Constructs a new instance of EquivalentKeyMap.\x0a   *\x0a   * @param {Iterable.\x3c*\x3e} iterable Initial pair of key, value for map.\x0a   */\x0a  function EquivalentKeyMap(iterable) {\x0a    _classCallCheck(this, EquivalentKeyMap);\x0a\x0a    this.clear();\x0a\x0a    if (iterable instanceof EquivalentKeyMap) {\x0a      // Map#forEach is only means of iterating with support for IE11.\x0a      var iterablePairs = [];\x0a      iterable.forEach(function (value, key) {\x0a        iterablePairs.push([key, value]);\x0a      });\x0a      iterable = iterablePairs;\x0a    }\x0a\x0a    if (iterable != null) {\x0a      for (var i = 0; i \x3c iterable.length; i++) {\x0a        this.set(iterable[i][0], iterable[i][1]);\x0a      }\x0a    }\x0a  }\x0a  /**\x0a   * Accessor property returning the number of elements.\x0a   *\x0a   * @return {number} Number of elements.\x0a   */\x0a\x0a\x0a  _createClass(EquivalentKeyMap, [{\x0a    key: \x22set\x22,\x0a\x0a    /**\x0a     * Add or update an element with a specified key and value.\x0a     *\x0a     * @param {*} key   The key of the element to add.\x0a     * @param {*} value The value of the element to add.\x0a     *\x0a     * @return {EquivalentKeyMap} Map instance.\x0a     */\x0a    value: function set(key, value) {\x0a      // Shortcut non-object-like to set on internal Map.\x0a      if (key === null || _typeof(key) !== \x27object\x27) {\x0a        this._map.set(key, value);\x0a\x0a        return this;\x0a      } // Sort keys to ensure stable assignment into tree.\x0a\x0a\x0a      var properties = Object.keys(key).sort();\x0a      var valuePair = [key, value]; // Tree by type to avoid conflicts on numeric object keys, empty value.\x0a\x0a      var map = Array.isArray(key) ? this._arrayTreeMap : this._objectTreeMap;\x0a\x0a      for (var i = 0; i \x3c properties.length; i++) {\x0a        var property = properties[i];\x0a\x0a        if (!map.has(property)) {\x0a          map.set(property, new EquivalentKeyMap());\x0a        }\x0a\x0a        map = map.get(property);\x0a        var propertyValue = key[property];\x0a\x0a        if (!map.has(propertyValue)) {\x0a          map.set(propertyValue, new EquivalentKeyMap());\x0a        }\x0a\x0a        map = map.get(propertyValue);\x0a      } // If an _ekm_value exists, there was already an equivalent key. Before\x0a      // overriding, ensure that the old key reference is removed from map to\x0a      // avoid memory leak of accumulating equivalent keys. This is, in a\x0a      // sense, a poor man\x27s WeakMap, while still enabling iterability.\x0a\x0a\x0a      var previousValuePair = map.get(\x27_ekm_value\x27);\x0a\x0a      if (previousValuePair) {\x0a        this._map.delete(previousValuePair[0]);\x0a      }\x0a\x0a      map.set(\x27_ekm_value\x27, valuePair);\x0a\x0a      this._map.set(key, valuePair);\x0a\x0a      return this;\x0a    }\x0a    /**\x0a     * Returns a specified element.\x0a     *\x0a     * @param {*} key The key of the element to return.\x0a     *\x0a     * @return {?*} The element associated with the specified key or undefined\x0a     *              if the key can\x27t be found.\x0a     */\x0a\x0a  }, {\x0a    key: \x22get\x22,\x0a    value: function get(key) {\x0a      // Shortcut non-object-like to get from internal Map.\x0a      if (key === null || _typeof(key) !== \x27object\x27) {\x0a        return this._map.get(key);\x0a      }\x0a\x0a      var valuePair = getValuePair(this, key);\x0a\x0a      if (valuePair) {\x0a        return valuePair[1];\x0a      }\x0a    }\x0a    /**\x0a     * Returns a boolean indicating whether an element with the specified key\x0a     * exists or not.\x0a     *\x0a     * @param {*} key The key of the element to test for presence.\x0a     *\x0a     * @return {boolean} Whether an element with the specified key exists.\x0a     */\x0a\x0a  }, {\x0a    key: \x22has\x22,\x0a    value: function has(key) {\x0a      if (key === null || _typeof(key) !== \x27object\x27) {\x0a        return this._map.has(key);\x0a      } // Test on the _presence_ of the pair, not its value, as even undefined\x0a      // can be a valid member value for a key.\x0a\x0a\x0a      return getValuePair(this, key) !== undefined;\x0a    }\x0a    /**\x0a     * Removes the specified element.\x0a     *\x0a     * @param {*} key The key of the element to remove.\x0a     *\x0a     * @return {boolean} Returns true if an element existed and has been\x0a     *                   removed, or false if the element does not exist.\x0a     */\x0a\x0a  }, {\x0a    key: \x22delete\x22,\x0a    value: function _delete(key) {\x0a      if (!this.has(key)) {\x0a        return false;\x0a      } // This naive implementation will leave orphaned child trees. A better\x0a      // implementation should traverse and remove orphans.\x0a\x0a\x0a      this.set(key, undefined);\x0a      return true;\x0a    }\x0a    /**\x0a     * Executes a provided function once per each key/value pair, in insertion\x0a     * order.\x0a     *\x0a     * @param {Function} callback Function to execute for each element.\x0a     * @param {*}        thisArg  Value to use as `this` when executing\x0a     *                            `callback`.\x0a     */\x0a\x0a  }, {\x0a    key: \x22forEach\x22,\x0a    value: function forEach(callback) {\x0a      var _this = this;\x0a\x0a      var thisArg = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : this;\x0a\x0a      this._map.forEach(function (value, key) {\x0a        // Unwrap value from object-like value pair.\x0a        if (key !== null && _typeof(key) === \x27object\x27) {\x0a          value = value[1];\x0a        }\x0a\x0a        callback.call(thisArg, value, key, _this);\x0a      });\x0a    }\x0a    /**\x0a     * Removes all elements.\x0a     */\x0a\x0a  }, {\x0a    key: \x22clear\x22,\x0a    value: function clear() {\x0a      this._map = new Map();\x0a      this._arrayTreeMap = new Map();\x0a      this._objectTreeMap = new Map();\x0a    }\x0a  }, {\x0a    key: \x22size\x22,\x0a    get: function get() {\x0a      return this._map.size;\x0a    }\x0a  }]);\x0a\x0a  return EquivalentKeyMap;\x0a}();\x0a\x0amodule.exports = EquivalentKeyMap;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 77:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99);\x0a/* global window */\x0a\x0a\x0avar root;\x0a\x0aif (typeof self !== \x27undefined\x27) {\x0a  root = self;\x0a} else if (typeof window !== \x27undefined\x27) {\x0a  root = window;\x0a} else if (typeof global !== \x27undefined\x27) {\x0a  root = global;\x0a} else if (true) {\x0a  root = module;\x0a} else {}\x0a\x0avar result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22])(root);\x0a/* harmony default export */ __webpack_exports__[\x22a\x22] = (result);\x0a\x0a/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(59), __webpack_require__(132)(module)))\x0a\x0a/***/ }),\x0a\x0a/***/ 9:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _createClass; });\x0afunction _defineProperties(target, props) {\x0a  for (var i = 0; i \x3c props.length; i++) {\x0a    var descriptor = props[i];\x0a    descriptor.enumerable = descriptor.enumerable || false;\x0a    descriptor.configurable = true;\x0a    if (\x22value\x22 in descriptor) descriptor.writable = true;\x0a    Object.defineProperty(target, descriptor.key, descriptor);\x0a  }\x0a}\x0a\x0afunction _createClass(Constructor, protoProps, staticProps) {\x0a  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\x0a  if (staticProps) _defineProperties(Constructor, staticProps);\x0a  return Constructor;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 99:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return symbolObservablePonyfill; });\x0afunction symbolObservablePonyfill(root) {\x0a\x09var result;\x0a\x09var Symbol = root.Symbol;\x0a\x0a\x09if (typeof Symbol === \x27function\x27) {\x0a\x09\x09if (Symbol.observable) {\x0a\x09\x09\x09result = Symbol.observable;\x0a\x09\x09} else {\x0a\x09\x09\x09result = Symbol(\x27observable\x27);\x0a\x09\x09\x09Symbol.observable = result;\x0a\x09\x09}\x0a\x09} else {\x0a\x09\x09result = \x27@@observable\x27;\x0a\x09}\x0a\x0a\x09return result;\x0a};\x0a\x0a\x0a/***/ })\x0a\x0a/******/ });'}