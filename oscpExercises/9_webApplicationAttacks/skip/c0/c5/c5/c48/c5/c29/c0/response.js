var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:10:32 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Mon, 22 Apr 2019 12:40:04 GMT\x0aETag: \x22203e9-5871dc47ed100-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-31680/31681\x0aContent-Length: 31681\x0aKeep-Alive: timeout=5, max=20\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0athis[\x22wp\x22] = this[\x22wp\x22] || {}; this[\x22wp\x22][\x22coreData\x22] =\x0a/******/ (function(modules) { // webpackBootstrap\x0a/******/ \x09// The module cache\x0a/******/ \x09var installedModules = {};\x0a/******/\x0a/******/ \x09// The require function\x0a/******/ \x09function __webpack_require__(moduleId) {\x0a/******/\x0a/******/ \x09\x09// Check if module is in cache\x0a/******/ \x09\x09if(installedModules[moduleId]) {\x0a/******/ \x09\x09\x09return installedModules[moduleId].exports;\x0a/******/ \x09\x09}\x0a/******/ \x09\x09// Create a new module (and put it into the cache)\x0a/******/ \x09\x09var module = installedModules[moduleId] = {\x0a/******/ \x09\x09\x09i: moduleId,\x0a/******/ \x09\x09\x09l: false,\x0a/******/ \x09\x09\x09exports: {}\x0a/******/ \x09\x09};\x0a/******/\x0a/******/ \x09\x09// Execute the module function\x0a/******/ \x09\x09modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\x0a/******/\x0a/******/ \x09\x09// Flag the module as loaded\x0a/******/ \x09\x09module.l = true;\x0a/******/\x0a/******/ \x09\x09// Return the exports of the module\x0a/******/ \x09\x09return module.exports;\x0a/******/ \x09}\x0a/******/\x0a/******/\x0a/******/ \x09// expose the modules object (__webpack_modules__)\x0a/******/ \x09__webpack_require__.m = modules;\x0a/******/\x0a/******/ \x09// expose the module cache\x0a/******/ \x09__webpack_require__.c = installedModules;\x0a/******/\x0a/******/ \x09// define getter function for harmony exports\x0a/******/ \x09__webpack_require__.d = function(exports, name, getter) {\x0a/******/ \x09\x09if(!__webpack_require__.o(exports, name)) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, name, { enumerable: true, get: getter });\x0a/******/ \x09\x09}\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// define __esModule on exports\x0a/******/ \x09__webpack_require__.r = function(exports) {\x0a/******/ \x09\x09if(typeof Symbol !== \x27undefined\x27 && Symbol.toStringTag) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, Symbol.toStringTag, { value: \x27Module\x27 });\x0a/******/ \x09\x09}\x0a/******/ \x09\x09Object.defineProperty(exports, \x27__esModule\x27, { value: true });\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// create a fake namespace object\x0a/******/ \x09// mode & 1: value is a module id, require it\x0a/******/ \x09// mode & 2: merge all properties of value into the ns\x0a/******/ \x09// mode & 4: return value when already ns object\x0a/******/ \x09// mode & 8|1: behave like require\x0a/******/ \x09__webpack_require__.t = function(value, mode) {\x0a/******/ \x09\x09if(mode & 1) value = __webpack_require__(value);\x0a/******/ \x09\x09if(mode & 8) return value;\x0a/******/ \x09\x09if((mode & 4) && typeof value === \x27object\x27 && value && value.__esModule) return value;\x0a/******/ \x09\x09var ns = Object.create(null);\x0a/******/ \x09\x09__webpack_require__.r(ns);\x0a/******/ \x09\x09Object.defineProperty(ns, \x27default\x27, { enumerable: true, value: value });\x0a/******/ \x09\x09if(mode & 2 && typeof value != \x27string\x27) for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\x0a/******/ \x09\x09return ns;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// getDefaultExport function for compatibility with non-harmony modules\x0a/******/ \x09__webpack_require__.n = function(module) {\x0a/******/ \x09\x09var getter = module && module.__esModule ?\x0a/******/ \x09\x09\x09function getDefault() { return module[\x27default\x27]; } :\x0a/******/ \x09\x09\x09function getModuleExports() { return module; };\x0a/******/ \x09\x09__webpack_require__.d(getter, \x27a\x27, getter);\x0a/******/ \x09\x09return getter;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// Object.prototype.hasOwnProperty.call\x0a/******/ \x09__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\x0a/******/\x0a/******/ \x09// __webpack_public_path__\x0a/******/ \x09__webpack_require__.p = \x22\x22;\x0a/******/\x0a/******/\x0a/******/ \x09// Load entry module and return exports\x0a/******/ \x09return __webpack_require__(__webpack_require__.s = 364);\x0a/******/ })\x0a/************************************************************************/\x0a/******/ ({\x0a\x0a/***/ 132:\x0a/***/ (function(module, exports) {\x0a\x0amodule.exports = function(originalModule) {\x0a\x09if (!originalModule.webpackPolyfill) {\x0a\x09\x09var module = Object.create(originalModule);\x0a\x09\x09// module.parent = undefined by default\x0a\x09\x09if (!module.children) module.children = [];\x0a\x09\x09Object.defineProperty(module, \x22loaded\x22, {\x0a\x09\x09\x09enumerable: true,\x0a\x09\x09\x09get: function() {\x0a\x09\x09\x09\x09return module.l;\x0a\x09\x09\x09}\x0a\x09\x09});\x0a\x09\x09Object.defineProperty(module, \x22id\x22, {\x0a\x09\x09\x09enumerable: true,\x0a\x09\x09\x09get: function() {\x0a\x09\x09\x09\x09return module.i;\x0a\x09\x09\x09}\x0a\x09\x09});\x0a\x09\x09Object.defineProperty(module, \x22exports\x22, {\x0a\x09\x09\x09enumerable: true\x0a\x09\x09});\x0a\x09\x09module.webpackPolyfill = 1;\x0a\x09}\x0a\x09return module;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 15:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _defineProperty; });\x0afunction _defineProperty(obj, key, value) {\x0a  if (key in obj) {\x0a    Object.defineProperty(obj, key, {\x0a      value: value,\x0a      enumerable: true,\x0a      configurable: true,\x0a      writable: true\x0a    });\x0a  } else {\x0a    obj[key] = value;\x0a  }\x0a\x0a  return obj;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 17:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\x0afunction _arrayWithoutHoles(arr) {\x0a  if (Array.isArray(arr)) {\x0a    for (var i = 0, arr2 = new Array(arr.length); i \x3c arr.length; i++) {\x0a      arr2[i] = arr[i];\x0a    }\x0a\x0a    return arr2;\x0a  }\x0a}\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js\x0avar iterableToArray = __webpack_require__(34);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\x0afunction _nonIterableSpread() {\x0a  throw new TypeError(\x22Invalid attempt to spread non-iterable instance\x22);\x0a}\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _toConsumableArray; });\x0a\x0a\x0a\x0afunction _toConsumableArray(arr) {\x0a  return _arrayWithoutHoles(arr) || Object(iterableToArray[\x22a\x22 /* default */])(arr) || _nonIterableSpread();\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 2:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22lodash\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 23:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0amodule.exports = __webpack_require__(54);\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 25:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22url\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 28:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\x0avar arrayWithHoles = __webpack_require__(37);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\x0afunction _iterableToArrayLimit(arr, i) {\x0a  var _arr = [];\x0a  var _n = true;\x0a  var _d = false;\x0a  var _e = undefined;\x0a\x0a  try {\x0a    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\x0a      _arr.push(_s.value);\x0a\x0a      if (i && _arr.length === i) break;\x0a    }\x0a  } catch (err) {\x0a    _d = true;\x0a    _e = err;\x0a  } finally {\x0a    try {\x0a      if (!_n && _i[\x22return\x22] != null) _i[\x22return\x22]();\x0a    } finally {\x0a      if (_d) throw _e;\x0a    }\x0a  }\x0a\x0a  return _arr;\x0a}\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\x0avar nonIterableRest = __webpack_require__(38);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _slicedToArray; });\x0a\x0a\x0a\x0afunction _slicedToArray(arr, i) {\x0a  return Object(arrayWithHoles[\x22a\x22 /* default */])(arr) || _iterableToArrayLimit(arr, i) || Object(nonIterableRest[\x22a\x22 /* default */])();\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 30:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0avar LEAF_KEY, hasWeakMap;\x0a\x0a/**\x0a * Arbitrary value used as key for referencing cache object in WeakMap tree.\x0a *\x0a * @type {Object}\x0a */\x0aLEAF_KEY = {};\x0a\x0a/**\x0a * Whether environment supports WeakMap.\x0a *\x0a * @type {boolean}\x0a */\x0ahasWeakMap = typeof WeakMap !== \x27undefined\x27;\x0a\x0a/**\x0a * Returns the first argument as the sole entry in an array.\x0a *\x0a * @param {*} value Value to return.\x0a *\x0a * @return {Array} Value returned as entry in array.\x0a */\x0afunction arrayOf( value ) {\x0a\x09return [ value ];\x0a}\x0a\x0a/**\x0a * Returns true if the value passed is object-like, or false otherwise. A value\x0a * is object-like if it can support property assignment, e.g. object or array.\x0a *\x0a * @param {*} value Value to test.\x0a *\x0a * @return {boolean} Whether value is object-like.\x0a */\x0afunction isObjectLike( value ) {\x0a\x09return !! value && \x27object\x27 === typeof value;\x0a}\x0a\x0a/**\x0a * Creates and returns a new cache object.\x0a *\x0a * @return {Object} Cache object.\x0a */\x0afunction createCache() {\x0a\x09var cache = {\x0a\x09\x09clear: function() {\x0a\x09\x09\x09cache.head = null;\x0a\x09\x09},\x0a\x09};\x0a\x0a\x09return cache;\x0a}\x0a\x0a/**\x0a * Returns true if entries within the two arrays are strictly equal by\x0a * reference from a starting index.\x0a *\x0a * @param {Array}  a         First array.\x0a * @param {Array}  b         Second array.\x0a * @param {number} fromIndex Index from which to start comparison.\x0a *\x0a * @return {boolean} Whether arrays are shallowly equal.\x0a */\x0afunction isShallowEqual( a, b, fromIndex ) {\x0a\x09var i;\x0a\x0a\x09if ( a.length !== b.length ) {\x0a\x09\x09return false;\x0a\x09}\x0a\x0a\x09for ( i = fromIndex; i \x3c a.length; i++ ) {\x0a\x09\x09if ( a[ i ] !== b[ i ] ) {\x0a\x09\x09\x09return false;\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09return true;\x0a}\x0a\x0a/**\x0a * Returns a memoized selector function. The getDependants function argument is\x0a * called before the memoized selector and is expected to return an immutable\x0a * reference or array of references on which the selector depends for computing\x0a * its own return value. The memoize cache is preserved only as long as those\x0a * dependant references remain the same. If getDependants returns a different\x0a * reference(s), the cache is cleared and the selector value regenerated.\x0a *\x0a * @param {Function} selector      Selector function.\x0a * @param {Function} getDependants Dependant getter returning an immutable\x0a *                                 reference or array of reference used in\x0a *                                 cache bust consideration.\x0a *\x0a * @return {Function} Memoized selector.\x0a */\x0a/* harmony default export */ __webpack_exports__[\x22a\x22] = (function( selector, getDependants ) {\x0a\x09var rootCache, getCache;\x0a\x0a\x09// Use object source as dependant if getter not provided\x0a\x09if ( ! getDependants ) {\x0a\x09\x09getDependants = arrayOf;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Returns the root cache. If WeakMap is supported, this is assigned to the\x0a\x09 * root WeakMap cache set, otherwise it is a shared instance of the default\x0a\x09 * cache object.\x0a\x09 *\x0a\x09 * @return {(WeakMap|Object)} Root cache object.\x0a\x09 */\x0a\x09function getRootCache() {\x0a\x09\x09return rootCache;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Returns the cache for a given dependants array. When possible, a WeakMap\x0a\x09 * will be used to create a unique cache for each set of dependants. This\x0a\x09 * is feasible due to the nature of WeakMap in allowing garbage collection\x0a\x09 * to occur on entries where the key object is no longer referenced. Since\x0a\x09 * WeakMap requires the key to be an object, this is only possible when the\x0a\x09 * dependant is object-like. The root cache is created as a hierarchy where\x0a\x09 * each top-level key is the first entry in a dependants set, the value a\x0a\x09 * WeakMap where each key is the next dependant, and so on. This continues\x0a\x09 * so long as the dependants are object-like. If no dependants are object-\x0a\x09 * like, then the cache is shared across all invocations.\x0a\x09 *\x0a\x09 * @see isObjectLike\x0a\x09 *\x0a\x09 * @param {Array} dependants Selector dependants.\x0a\x09 *\x0a\x09 * @return {Object} Cache object.\x0a\x09 */\x0a\x09function getWeakMapCache( dependants ) {\x0a\x09\x09var caches = rootCache,\x0a\x09\x09\x09isUniqueByDependants = true,\x0a\x09\x09\x09i, dependant, map, cache;\x0a\x0a\x09\x09for ( i = 0; i \x3c dependants.length; i++ ) {\x0a\x09\x09\x09dependant = dependants[ i ];\x0a\x0a\x09\x09\x09// Can only compose WeakMap from object-like key.\x0a\x09\x09\x09if ( ! isObjectLike( dependant ) ) {\x0a\x09\x09\x09\x09isUniqueByDependants = false;\x0a\x09\x09\x09\x09break;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Does current segment of cache already have a WeakMap?\x0a\x09\x09\x09if ( caches.has( dependant ) ) {\x0a\x09\x09\x09\x09// Traverse into nested WeakMap.\x0a\x09\x09\x09\x09caches = caches.get( dependant );\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09// Create, set, and traverse into a new one.\x0a\x09\x09\x09\x09map = new WeakMap();\x0a\x09\x09\x09\x09caches.set( dependant, map );\x0a\x09\x09\x09\x09caches = map;\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09// We use an arbitrary (but consistent) object as key for the last item\x0a\x09\x09// in the WeakMap to serve as our running cache.\x0a\x09\x09if ( ! caches.has( LEAF_KEY ) ) {\x0a\x09\x09\x09cache = createCache();\x0a\x09\x09\x09cache.isUniqueByDependants = isUniqueByDependants;\x0a\x09\x09\x09caches.set( LEAF_KEY, cache );\x0a\x09\x09}\x0a\x0a\x09\x09return caches.get( LEAF_KEY );\x0a\x09}\x0a\x0a\x09// Assign cache handler by availability of WeakMap\x0a\x09getCache = hasWeakMap ? getWeakMapCache : getRootCache;\x0a\x0a\x09/**\x0a\x09 * Resets root memoization cache.\x0a\x09 */\x0a\x09function clear() {\x0a\x09\x09rootCache = hasWeakMap ? new WeakMap() : createCache();\x0a\x09}\x0a\x0a\x09// eslint-disable-next-line jsdoc/check-param-names\x0a\x09/**\x0a\x09 * The augmented selector call, considering first whether dependants have\x0a\x09 * changed before passing it to underlying memoize function.\x0a\x09 *\x0a\x09 * @param {Object} source    Source object for derivation.\x0a\x09 * @param {...*}   extraArgs Additional arguments to pass to selector.\x0a\x09 *\x0a\x09 * @return {*} Selector result.\x0a\x09 */\x0a\x09function callSelector( /* source, ...extraArgs */ ) {\x0a\x09\x09var len = arguments.length,\x0a\x09\x09\x09cache, node, i, args, dependants;\x0a\x0a\x09\x09// Create copy of arguments (avoid leaking deoptimization).\x0a\x09\x09args = new Array( len );\x0a\x09\x09for ( i = 0; i \x3c len; i++ ) {\x0a\x09\x09\x09args[ i ] = arguments[ i ];\x0a\x09\x09}\x0a\x0a\x09\x09dependants = getDependants.apply( null, args );\x0a\x09\x09cache = getCache( dependants );\x0a\x0a\x09\x09// If not guaranteed uniqueness by dependants (primitive type or lack\x0a\x09\x09// of WeakMap support), shallow compare against last dependants and, if\x0a\x09\x09// references have changed, destroy cache to recalculate result.\x0a\x09\x09if ( ! cache.isUniqueByDependants ) {\x0a\x09\x09\x09if ( cache.lastDependants && ! isShallowEqual( dependants, cache.lastDependants, 0 ) ) {\x0a\x09\x09\x09\x09cache.clear();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09cache.lastDependants = dependants;\x0a\x09\x09}\x0a\x0a\x09\x09node = cache.head;\x0a\x09\x09while ( node ) {\x0a\x09\x09\x09// Check whether node arguments match arguments\x0a\x09\x09\x09if ( ! isShallowEqual( node.args, args, 1 ) ) {\x0a\x09\x09\x09\x09node = node.next;\x0a\x09\x09\x09\x09continue;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// At this point we can assume we\x27ve found a match\x0a\x0a\x09\x09\x09// Surface matched node to head if not already\x0a\x09\x09\x09if ( node !== cache.head ) {\x0a\x09\x09\x09\x09// Adjust siblings to point to each other.\x0a\x09\x09\x09\x09node.prev.next = node.next;\x0a\x09\x09\x09\x09if ( node.next ) {\x0a\x09\x09\x09\x09\x09node.next.prev = node.prev;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09node.next = cache.head;\x0a\x09\x09\x09\x09node.prev = null;\x0a\x09\x09\x09\x09cache.head.prev = node;\x0a\x09\x09\x09\x09cache.head = node;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Return immediately\x0a\x09\x09\x09return node.val;\x0a\x09\x09}\x0a\x0a\x09\x09// No cached value found. Continue to insertion phase:\x0a\x0a\x09\x09node = {\x0a\x09\x09\x09// Generate the result from original function\x0a\x09\x09\x09val: selector.apply( null, args ),\x0a\x09\x09};\x0a\x0a\x09\x09// Avoid including the source object in the cache.\x0a\x09\x09args[ 0 ] = null;\x0a\x09\x09node.args = args;\x0a\x0a\x09\x09// Don\x27t need to check whether node is already head, since it would\x0a\x09\x09// have been returned above already if it was\x0a\x0a\x09\x09// Shift existing head down list\x0a\x09\x09if ( cache.head ) {\x0a\x09\x09\x09cache.head.prev = node;\x0a\x09\x09\x09node.next = cache.head;\x0a\x09\x09}\x0a\x0a\x09\x09cache.head = node;\x0a\x0a\x09\x09return node.val;\x0a\x09}\x0a\x0a\x09callSelector.getDependants = getDependants;\x0a\x09callSelector.clear = clear;\x0a\x09clear();\x0a\x0a\x09return callSelector;\x0a});\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 33:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22apiFetch\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 34:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _iterableToArray; });\x0afunction _iterableToArray(iter) {\x0a  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \x22[object Arguments]\x22) return Array.from(iter);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 364:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0avar build_module_actions_namespaceObject = {};\x0a__webpack_require__.r(build_module_actions_namespaceObject);\x0a__webpack_require__.d(build_module_actions_namespaceObject, \x22receiveUserQuery\x22, function() { return receiveUserQuery; });\x0a__webpack_require__.d(build_module_actions_namespaceObject, \x22addEntities\x22, function() { return addEntities; });\x0a__webpack_require__.d(build_module_actions_namespaceObject, \x22receiveEntityRecords\x22, function() { return receiveEntityRecords; });\x0a__webpack_require__.d(build_module_actions_namespaceObject, \x22receiveThemeSupports\x22, function() { return receiveThemeSupports; });\x0a__webpack_require__.d(build_module_actions_namespaceObject, \x22receiveEmbedPreview\x22, function() { return receiveEmbedPreview; });\x0a__webpack_require__.d(build_module_actions_namespaceObject, \x22saveEntityRecord\x22, function() { return saveEntityRecord; });\x0a__webpack_require__.d(build_module_actions_namespaceObject, \x22receiveUploadPermissions\x22, function() { return receiveUploadPermissions; });\x0a__webpack_require__.d(build_module_actions_namespaceObject, \x22receiveUserPermission\x22, function() { return receiveUserPermission; });\x0avar build_module_selectors_namespaceObject = {};\x0a__webpack_require__.r(build_module_selectors_namespaceObject);\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22isRequestingEmbedPreview\x22, function() { return isRequestingEmbedPreview; });\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22getAuthors\x22, function() { return getAuthors; });\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22getUserQueryResults\x22, function() { return getUserQueryResults; });\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22getEntitiesByKind\x22, function() { return getEntitiesByKind; });\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22getEntity\x22, function() { return getEntity; });\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22getEntityRecord\x22, function() { return getEntityRecord; });\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22getEntityRecords\x22, function() { return getEntityRecords; });\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22getThemeSupports\x22, function() { return getThemeSupports; });\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22getEmbedPreview\x22, function() { return getEmbedPreview; });\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22isPreviewEmbedFallback\x22, function() { return isPreviewEmbedFallback; });\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22hasUploadPermissions\x22, function() { return hasUploadPermissions; });\x0a__webpack_require__.d(build_module_selectors_namespaceObject, \x22canUser\x22, function() { return canUser; });\x0avar resolvers_namespaceObject = {};\x0a__webpack_require__.r(resolvers_namespaceObject);\x0a__webpack_require__.d(resolvers_namespaceObject, \x22getAuthors\x22, function() { return resolvers_getAuthors; });\x0a__webpack_require__.d(resolvers_namespaceObject, \x22getEntityRecord\x22, function() { return resolvers_getEntityRecord; });\x0a__webpack_require__.d(resolvers_namespaceObject, \x22getEntityRecords\x22, function() { return resolvers_getEntityRecords; });\x0a__webpack_require__.d(resolvers_namespaceObject, \x22getThemeSupports\x22, function() { return resolvers_getThemeSupports; });\x0a__webpack_require__.d(resolvers_namespaceObject, \x22getEmbedPreview\x22, function() { return resolvers_getEmbedPreview; });\x0a__webpack_require__.d(resolvers_namespaceObject, \x22hasUploadPermissions\x22, function() { return resolvers_hasUploadPermissions; });\x0a__webpack_require__.d(resolvers_namespaceObject, \x22canUser\x22, function() { return resolvers_canUser; });\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread.js\x0avar objectSpread = __webpack_require__(7);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22data\x22]}\x0avar external_this_wp_data_ = __webpack_require__(5);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 1 modules\x0avar slicedToArray = __webpack_require__(28);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules\x0avar toConsumableArray = __webpack_require__(17);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\x0avar defineProperty = __webpack_require__(15);\x0a\x0a// EXTERNAL MODULE: external \x22lodash\x22\x0avar external_lodash_ = __webpack_require__(2);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/utils/if-matching-action.js\x0a/**\x0a * A higher-order reducer creator which invokes the original reducer only if\x0a * the dispatching action matches the given predicate, **OR** if state is\x0a * initializing (undefined).\x0a *\x0a * @param {Function} isMatch Function predicate for allowing reducer call.\x0a *\x0a * @return {Function} Higher-order reducer.\x0a */\x0avar ifMatchingAction = function ifMatchingAction(isMatch) {\x0a  return function (reducer) {\x0a    return function (state, action) {\x0a      if (state === undefined || isMatch(action)) {\x0a        return reducer(state, action);\x0a      }\x0a\x0a      return state;\x0a    };\x0a  };\x0a};\x0a\x0a/* harmony default export */ var if_matching_action = (ifMatchingAction);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/utils/on-sub-key.js\x0a\x0a\x0a\x0a/**\x0a * Higher-order reducer creator which creates a combined reducer object, keyed\x0a * by a property on the action object.\x0a *\x0a * @param {string} actionProperty Action property by which to key object.\x0a *\x0a * @return {Function} Higher-order reducer.\x0a */\x0avar on_sub_key_onSubKey = function onSubKey(actionProperty) {\x0a  return function (reducer) {\x0a    return function () {\x0a      var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a      var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a      // Retrieve subkey from action. Do not track if undefined; useful for cases\x0a      // where reducer is scoped by action shape.\x0a      var key = action[actionProperty];\x0a\x0a      if (key === undefined) {\x0a        return state;\x0a      } // Avoid updating state if unchanged. Note that this also accounts for a\x0a      // reducer which returns undefined on a key which is not yet tracked.\x0a\x0a\x0a      var nextKeyState = reducer(state[key], action);\x0a\x0a      if (nextKeyState === state[key]) {\x0a        return state;\x0a      }\x0a\x0a      return Object(objectSpread[\x22a\x22 /* default */])({}, state, Object(defineProperty[\x22a\x22 /* default */])({}, key, nextKeyState));\x0a    };\x0a  };\x0a};\x0a/* harmony default export */ var on_sub_key = (on_sub_key_onSubKey);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/utils/replace-action.js\x0a/**\x0a * Higher-order reducer creator which substitutes the action object before\x0a * passing to the original reducer.\x0a *\x0a * @param {Function} replacer Function mapping original action to replacement.\x0a *\x0a * @return {Function} Higher-order reducer.\x0a */\x0avar replaceAction = function replaceAction(replacer) {\x0a  return function (reducer) {\x0a    return function (state, action) {\x0a      return reducer(state, replacer(action));\x0a    };\x0a  };\x0a};\x0a\x0a/* harmony default export */ var replace_action = (replaceAction);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/utils/with-weak-map-cache.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Given a function, returns an enhanced function which caches the result and\x0a * tracks in WeakMap. The result is only cached if the original function is\x0a * passed a valid object-like argument (requirement for WeakMap key).\x0a *\x0a * @param {Function} fn Original function.\x0a *\x0a * @return {Function} Enhanced caching function.\x0a */\x0a\x0afunction withWeakMapCache(fn) {\x0a  var cache = new WeakMap();\x0a  return function (key) {\x0a    var value;\x0a\x0a    if (cache.has(key)) {\x0a      value = cache.get(key);\x0a    } else {\x0a      value = fn(key); // Can reach here if key is not valid for WeakMap, since `has`\x0a      // will return false for invalid key. Since `set` will throw,\x0a      // ensure that key is valid before setting into cache.\x0a\x0a      if (Object(external_lodash_[\x22isObjectLike\x22])(key)) {\x0a        cache.set(key, value);\x0a      }\x0a    }\x0a\x0a    return value;\x0a  };\x0a}\x0a\x0a/* harmony default export */ var with_weak_map_cache = (withWeakMapCache);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/utils/index.js\x0a\x0a\x0a\x0a\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/queried-data/actions.js\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Returns an action object used in signalling that items have been received.\x0a *\x0a * @param {Array} items Items received.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction receiveItems(items) {\x0a  return {\x0a    type: \x27RECEIVE_ITEMS\x27,\x0a    items: Object(external_lodash_[\x22castArray\x22])(items)\x0a  };\x0a}\x0a/**\x0a * Returns an action object used in signalling that queried data has been\x0a * received.\x0a *\x0a * @param {Array}   items Queried items received.\x0a * @param {?Object} query Optional query object.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction receiveQueriedItems(items) {\x0a  var query = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : {};\x0a  return Object(objectSpread[\x22a\x22 /* default */])({}, receiveItems(items), {\x0a    query: query\x0a  });\x0a}\x0a\x0a// EXTERNAL MODULE: ./node_modules/rememo/es/rememo.js\x0avar rememo = __webpack_require__(30);\x0a\x0a// EXTERNAL MODULE: ./node_modules/equivalent-key-map/equivalent-key-map.js\x0avar equivalent_key_map = __webpack_require__(76);\x0avar equivalent_key_map_default = /*#__PURE__*/__webpack_require__.n(equivalent_key_map);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22url\x22]}\x0avar external_this_wp_url_ = __webpack_require__(25);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/queried-data/get-query-parts.js\x0a\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * An object of properties describing a specific query.\x0a *\x0a * @typedef {WPQueriedDataQueryParts}\x0a *\x0a * @property {number} page      The query page (1-based index, default 1).\x0a * @property {number} perPage   Items per page for query (default 10).\x0a * @property {string} stableKey An encoded stable string of all non-pagination\x0a *                              query parameters.\x0a */\x0a\x0a/**\x0a * Given a query object, returns an object of parts, including pagination\x0a * details (`page` and `perPage`, or default values). All other properties are\x0a * encoded into a stable (idempotent) `stableKey` value.\x0a *\x0a * @param {Object} query Optional query object.\x0a *\x0a * @return {WPQueriedDataQueryParts} Query parts.\x0a */\x0a\x0afunction getQueryParts(query) {\x0a  /**\x0a   * @type {WPQueriedDataQueryParts}\x0a   */\x0a  var parts = {\x0a    stableKey: \x27\x27,\x0a    page: 1,\x0a    perPage: 10\x0a  }; // Ensure stable key by sorting keys. Also more efficient for iterating.\x0a\x0a  var keys = Object.keys(query).sort();\x0a\x0a  for (var i = 0; i \x3c keys.length; i++) {\x0a    var key = keys[i];\x0a    var value = query[key];\x0a\x0a    switch (key) {\x0a      case \x27page\x27:\x0a        parts[key] = Number(value);\x0a        break;\x0a\x0a      case \x27per_page\x27:\x0a        parts.perPage = Number(value);\x0a        break;\x0a\x0a      default:\x0a        // While it could be any deterministic string, for simplicity\x27s\x0a        // sake mimic querystring encoding for stable key.\x0a        //\x0a        // TODO: For consistency with PHP implementation, addQueryArgs\x0a        // should accept a key value pair, which may optimize its\x0a        // implementation for our use here, vs. iterating an object\x0a        // with only a single key.\x0a        parts.stableKey += (parts.stableKey ? \x27&\x27 : \x27\x27) + Object(external_this_wp_url_[\x22addQueryArgs\x22])(\x27\x27, Object(defineProperty[\x22a\x22 /* default */])({}, key, value)).slice(1);\x0a    }\x0a  }\x0a\x0a  return parts;\x0a}\x0a/* harmony default export */ var get_query_parts = (with_weak_map_cache(getQueryParts));\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/queried-data/selectors.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Cache of state keys to EquivalentKeyMap where the inner map tracks queries\x0a * to their resulting items set. WeakMap allows garbage collection on expired\x0a * state references.\x0a *\x0a * @type {WeakMap\x3cObject,EquivalentKeyMap\x3e}\x0a */\x0a\x0avar queriedItemsCacheByState = new WeakMap();\x0a/**\x0a * Returns items for a given query, or null if the items are not known.\x0a *\x0a * @param {Object}  state State object.\x0a * @param {?Object} query Optional query.\x0a *\x0a * @return {?Array} Query items.\x0a */\x0a\x0afunction getQueriedItemsUncached(state, query) {\x0a  var _getQueryParts = get_query_parts(query),\x0a      stableKey = _getQueryParts.stableKey,\x0a      page = _getQueryParts.page,\x0a      perPage = _getQueryParts.perPage;\x0a\x0a  if (!state.queries[stableKey]) {\x0a    return null;\x0a  }\x0a\x0a  var itemIds = state.queries[stableKey];\x0a\x0a  if (!itemIds) {\x0a    return null;\x0a  }\x0a\x0a  var startOffset = perPage === -1 ? 0 : (page - 1) * perPage;\x0a  var endOffset = perPage === -1 ? itemIds.length : Math.min(startOffset + perPage, itemIds.length);\x0a  var items = [];\x0a\x0a  for (var i = startOffset; i \x3c endOffset; i++) {\x0a    var itemId = itemIds[i];\x0a    items.push(state.items[itemId]);\x0a  }\x0a\x0a  return items;\x0a}\x0a/**\x0a * Returns items for a given query, or null if the items are not known. Caches\x0a * result both per state (by reference) and per query (by deep equality).\x0a * The caching approach is intended to be durable to query objects which are\x0a * deeply but not referentially equal, since otherwise:\x0a *\x0a * `getQueriedItems( state, {} ) !== getQueriedItems( state, {} )`\x0a *\x0a * @param {Object}  state State object.\x0a * @param {?Object} query Optional query.\x0a *\x0a * @return {?Array} Query items.\x0a */\x0a\x0a\x0avar getQueriedItems = Object(rememo[\x22a\x22 /* default */])(function (state) {\x0a  var query = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : {};\x0a  var queriedItemsCache = queriedItemsCacheByState.get(state);\x0a\x0a  if (queriedItemsCache) {\x0a    var queriedItems = queriedItemsCache.get(query);\x0a\x0a    if (queriedItems !== undefined) {\x0a      return queriedItems;\x0a    }\x0a  } else {\x0a    queriedItemsCache = new equivalent_key_map_default.a();\x0a    queriedItemsCacheByState.set(state, queriedItemsCache);\x0a  }\x0a\x0a  var items = getQueriedItemsUncached(state, query);\x0a  queriedItemsCache.set(query, items);\x0a  return items;\x0a});\x0a\x0a// EXTERNAL MODULE: ./node_modules/redux/es/redux.js\x0avar redux = __webpack_require__(71);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\x0avar regenerator = __webpack_require__(23);\x0avar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22apiFetch\x22]}\x0avar external_this_wp_apiFetch_ = __webpack_require__(33);\x0avar external_this_wp_apiFetch_default = /*#__PURE__*/__webpack_require__.n(external_this_wp_apiFetch_);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/controls.js\x0a\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a/**\x0a * Trigger an API Fetch request.\x0a *\x0a * @param {Object} request API Fetch Request Object.\x0a * @return {Object} control descriptor.\x0a */\x0a\x0afunction apiFetch(request) {\x0a  return {\x0a    type: \x27API_FETCH\x27,\x0a    request: request\x0a  };\x0a}\x0a/**\x0a * Calls a selector using the current state.\x0a * @param {string} selectorName Selector name.\x0a * @param  {Array} args         Selector arguments.\x0a *\x0a * @return {Object} control descriptor.\x0a */\x0a\x0afunction controls_select(selectorName) {\x0a  for (var _len = arguments.length, args = new Array(_len \x3e 1 ? _len - 1 : 0), _key = 1; _key \x3c _len; _key++) {\x0a    args[_key - 1] = arguments[_key];\x0a  }\x0a\x0a  return {\x0a    type: \x27SELECT\x27,\x0a    selectorName: selectorName,\x0a    args: args\x0a  };\x0a}\x0avar controls = {\x0a  API_FETCH: function API_FETCH(_ref) {\x0a    var request = _ref.request;\x0a    return external_this_wp_apiFetch_default()(request);\x0a  },\x0a  SELECT: Object(external_this_wp_data_[\x22createRegistryControl\x22])(function (registry) {\x0a    return function (_ref2) {\x0a      var _registry$select;\x0a\x0a      var selectorName = _ref2.selectorName,\x0a          args = _ref2.args;\x0a      return (_registry$select = registry.select(\x27core\x27))[selectorName].apply(_registry$select, Object(toConsumableArray[\x22a\x22 /* default */])(args));\x0a    };\x0a  })\x0a};\x0a/* harmony default export */ var build_module_controls = (controls);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/actions.js\x0a\x0a\x0a\x0avar _marked =\x0a/*#__PURE__*/\x0aregenerator_default.a.mark(saveEntityRecord);\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0a/**\x0a * Returns an action object used in signalling that authors have been received.\x0a *\x0a * @param {string}       queryID Query ID.\x0a * @param {Array|Object} users   Users received.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction receiveUserQuery(queryID, users) {\x0a  return {\x0a    type: \x27RECEIVE_USER_QUERY\x27,\x0a    users: Object(external_lodash_[\x22castArray\x22])(users),\x0a    queryID: queryID\x0a  };\x0a}\x0a/**\x0a * Returns an action object used in adding new entities.\x0a *\x0a * @param {Array} entities  Entities received.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction addEntities(entities) {\x0a  return {\x0a    type: \x27ADD_ENTITIES\x27,\x0a    entities: entities\x0a  };\x0a}\x0a/**\x0a * Returns an action object used in signalling that entity records have been received.\x0a *\x0a * @param {string}       kind            Kind of the received entity.\x0a * @param {string}       name            Name of the received entity.\x0a * @param {Array|Object} records         Records received.\x0a * @param {?Object}      query           Query Object.\x0a * @param {?boolean}     invalidateCache Should invalidate query caches\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction receiveEntityRecords(kind, name, records, query) {\x0a  var invalidateCache = arguments.length \x3e 4 && arguments[4] !== undefined ? arguments[4] : false;\x0a  var action;\x0a\x0a  if (query) {\x0a    action = receiveQueriedItems(records, query);\x0a  } else {\x0a    action = receiveItems(records);\x0a  }\x0a\x0a  return Object(objectSpread[\x22a\x22 /* default */])({}, action, {\x0a    kind: kind,\x0a    name: name,\x0a    invalidateCache: invalidateCache\x0a  });\x0a}\x0a/**\x0a * Returns an action object used in signalling that the index has been received.\x0a *\x0a * @param {Object} themeSupports Theme support for the current theme.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction receiveThemeSupports(themeSupports) {\x0a  return {\x0a    type: \x27RECEIVE_THEME_SUPPORTS\x27,\x0a    themeSupports: themeSupports\x0a  };\x0a}\x0a/**\x0a * Returns an action object used in signalling that the preview data for\x0a * a given URl has been received.\x0a *\x0a * @param {string}  url      URL to preview the embed for.\x0a * @param {Mixed}   preview  Preview data.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction receiveEmbedPreview(url, preview) {\x0a  return {\x0a    type: \x27RECEIVE_EMBED_PREVIEW\x27,\x0a    url: url,\x0a    preview: preview\x0a  };\x0a}\x0a/**\x0a * Action triggered to save an entity record.\x0a *\x0a * @param {string} kind    Kind of the received entity.\x0a * @param {string} name    Name of the received entity.\x0a * @param {Object} record  Record to be saved.\x0a *\x0a * @return {Object} Updated record.\x0a */\x0a\x0afunction saveEntityRecord(kind, name, record) {\x0a  var entities, entity, key, recordId, updatedRecord;\x0a  return regenerator_default.a.wrap(function saveEntityRecord$(_context) {\x0a    while (1) {\x0a      switch (_context.prev = _context.next) {\x0a        case 0:\x0a          _context.next = 2;\x0a          return getKindEntities(kind);\x0a\x0a        case 2:\x0a          entities = _context.sent;\x0a          entity = Object(external_lodash_[\x22find\x22])(entities, {\x0a            kind: kind,\x0a            name: name\x0a          });\x0a\x0a          if (entity) {\x0a            _context.next = 6;\x0a            break;\x0a          }\x0a\x0a          return _context.abrupt(\x22return\x22);\x0a\x0a        case 6:\x0a          key = entity.key || DEFAULT_ENTITY_KEY;\x0a          recordId = record[key];\x0a          _context.next = 10;\x0a          return apiFetch({\x0a            path: \x22\x22.concat(entity.baseURL).concat(recordId ? \x27/\x27 + recordId : \x27\x27),\x0a            method: recordId ? \x27PUT\x27 : \x27POST\x27,\x0a            data: record\x0a          });\x0a\x0a        case 10:\x0a          updatedRecord = _context.sent;\x0a          _context.next = 13;\x0a          return receiveEntityRecords(kind, name, updatedRecord, undefined, true);\x0a\x0a        case 13:\x0a          return _context.abrupt(\x22return\x22, updatedRecord);\x0a\x0a        case 14:\x0a        case \x22end\x22:\x0a          return _context.stop();\x0a      }\x0a    }\x0a  }, _marked, this);\x0a}\x0a/**\x0a * Returns an action object used in signalling that Upload permissions have been received.\x0a *\x0a * @param {boolean} hasUploadPermissions Does the user have permission to upload files?\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction receiveUploadPermissions(hasUploadPermissions) {\x0a  return {\x0a    type: \x27RECEIVE_USER_PERMISSION\x27,\x0a    key: \x27create/media\x27,\x0a    isAllowed: hasUploadPermissions\x0a  };\x0a}\x0a/**\x0a * Returns an action object used in signalling that the current user has\x0a * permission to perform an action on a REST resource.\x0a *\x0a * @param {string}  key       A key that represents the action and REST resource.\x0a * @param {boolean} isAllowed Whether or not the user can perform the action.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction receiveUserPermission(key, isAllowed) {\x0a  return {\x0a    type: \x27RECEIVE_USER_PERMISSION\x27,\x0a    key: key,\x0a    isAllowed: isAllowed\x0a  };\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/entities.js\x0a\x0a\x0avar entities_marked =\x0a/*#__PURE__*/\x0aregenerator_default.a.mark(loadPostTypeEntities),\x0a    _marked2 =\x0a/*#__PURE__*/\x0aregenerator_default.a.mark(loadTaxonomyEntities),\x0a    _marked3 =\x0a/*#__PURE__*/\x0aregenerator_default.a.mark(getKindEntities);\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0avar DEFAULT_ENTITY_KEY = \x27id\x27;\x0avar defaultEntities = [{\x0a  name: \x27postType\x27,\x0a  kind: \x27root\x27,\x0a  key: \x27slug\x27,\x0a  baseURL: \x27/wp/v2/types\x27\x0a}, {\x0a  name: \x27media\x27,\x0a  kind: \x27root\x27,\x0a  baseURL: \x27/wp/v2/media\x27,\x0a  plural: \x27mediaItems\x27\x0a}, {\x0a  name: \x27taxonomy\x27,\x0a  kind: \x27root\x27,\x0a  key: \x27slug\x27,\x0a  baseURL: \x27/wp/v2/taxonomies\x27,\x0a  plural: \x27taxonomies\x27\x0a}];\x0avar kinds = [{\x0a  name: \x27postType\x27,\x0a  loadEntities: loadPostTypeEntities\x0a}, {\x0a  name: \x27taxonomy\x27,\x0a  loadEntities: loadTaxonomyEntities\x0a}];\x0a/**\x0a * Returns the list of post type entities.\x0a *\x0a * @return {Promise} Entities promise\x0a */\x0a\x0afunction loadPostTypeEntities() {\x0a  var postTypes;\x0a  return regenerator_default.a.wrap(function loadPostTypeEntities$(_context) {\x0a    while (1) {\x0a      switch (_context.prev = _context.next) {\x0a        case 0:\x0a          _context.next = 2;\x0a          return apiFetch({\x0a            path: \x27/wp/v2/types?context=edit\x27\x0a          });\x0a\x0a        case 2:\x0a          postTypes = _context.sent;\x0a          return _context.abrupt(\x22return\x22, Object(external_lodash_[\x22map\x22])(postTypes, function (postType, name) {\x0a            return {\x0a              kind: \x27postType\x27,\x0a              baseURL: \x27/wp/v2/\x27 + postType.rest_base,\x0a              name: name\x0a            };\x0a          }));\x0a\x0a        case 4:\x0a        case \x22end\x22:\x0a          return _context.stop();\x0a      }\x0a    }\x0a  }, entities_marked, this);\x0a}\x0a/**\x0a * Returns the list of the taxonomies entities.\x0a *\x0a * @return {Promise} Entities promise\x0a */\x0a\x0a\x0afunction loadTaxonomyEntities() {\x0a  var taxonomies;\x0a  return regenerator_default.a.wrap(function loadTaxonomyEntities$(_context2) {\x0a    while (1) {\x0a      switch (_context2.prev = _context2.next) {\x0a        case 0:\x0a          _context2.next = 2;\x0a          return apiFetch({\x0a            path: \x27/wp/v2/taxonomies?context=edit\x27\x0a          });\x0a\x0a        case 2:\x0a          taxonomies = _context2.sent;\x0a          return _context2.abrupt(\x22return\x22, Object(external_lodash_[\x22map\x22])(taxonomies, function (taxonomy, name) {\x0a            return {\x0a              kind: \x27taxonomy\x27,\x0a              baseURL: \x27/wp/v2/\x27 + taxonomy.rest_base,\x0a              name: name\x0a            };\x0a          }));\x0a\x0a        case 4:\x0a        case \x22end\x22:\x0a          return _context2.stop();\x0a      }\x0a    }\x0a  }, _marked2, this);\x0a}\x0a/**\x0a * Returns the entity\x27s getter method name given its kind and name.\x0a *\x0a * @param {string}  kind      Entity kind.\x0a * @param {string}  name      Entity name.\x0a * @param {string}  prefix    Function prefix.\x0a * @param {boolean} usePlural Whether to use the plural form or not.\x0a *\x0a * @return {string} Method name\x0a */\x0a\x0a\x0avar entities_getMethodName = function getMethodName(kind, name) {\x0a  var prefix = arguments.length \x3e 2 && arguments[2] !== undefined ? arguments[2] : \x27get\x27;\x0a  var usePlural = arguments.length \x3e 3 && arguments[3] !== undefined ? arguments[3] : false;\x0a  var entity = Object(external_lodash_[\x22find\x22])(defaultEntities, {\x0a    kind: kind,\x0a    name: name\x0a  });\x0a  var kindPrefix = kind === \x27root\x27 ? \x27\x27 : Object(external_lodash_[\x22upperFirst\x22])(Object(external_lodash_[\x22camelCase\x22])(kind));\x0a  var nameSuffix = Object(external_lodash_[\x22upperFirst\x22])(Object(external_lodash_[\x22camelCase\x22])(name)) + (usePlural ? \x27s\x27 : \x27\x27);\x0a  var suffix = usePlural && entity.plural ? Object(external_lodash_[\x22upperFirst\x22])(Object(external_lodash_[\x22camelCase\x22])(entity.plural)) : nameSuffix;\x0a  return \x22\x22.concat(prefix).concat(kindPrefix).concat(suffix);\x0a};\x0a/**\x0a * Loads the kind entities into the store.\x0a *\x0a * @param {string} kind  Kind\x0a *\x0a * @return {Array} Entities\x0a */\x0a\x0afunction getKindEntities(kind) {\x0a  var entities, kindConfig;\x0a  return regenerator_default.a.wrap(function getKindEntities$(_context3) {\x0a    while (1) {\x0a      switch (_context3.prev = _context3.next) {\x0a        case 0:\x0a          _context3.next = 2;\x0a          return controls_select(\x27getEntitiesByKind\x27, kind);\x0a\x0a        case 2:\x0a          entities = _context3.sent;\x0a\x0a          if (!(entities && entities.length !== 0)) {\x0a            _context3.next = 5;\x0a            break;\x0a          }\x0a\x0a          return _context3.abrupt(\x22return\x22, entities);\x0a\x0a        case 5:\x0a          kindConfig = Object(external_lodash_[\x22find\x22])(kinds, {\x0a            name: kind\x0a          });\x0a\x0a          if (kindConfig) {\x0a            _context3.next = 8;\x0a            break;\x0a          }\x0a\x0a          return _context3.abrupt(\x22return\x22, []);\x0a\x0a        case 8:\x0a          _context3.next = 10;\x0a          return kindConfig.loadEntities();\x0a\x0a        case 10:\x0a          entities = _context3.sent;\x0a          _context3.next = 13;\x0a          return addEntities(entities);\x0a\x0a        case 13:\x0a          return _context3.abrupt(\x22return\x22, entities);\x0a\x0a        case 14:\x0a        case \x22end\x22:\x0a          return _context3.stop();\x0a      }\x0a    }\x0a  }, _marked3, this);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/queried-data/reducer.js\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0a/**\x0a * Returns a merged array of item IDs, given details of the received paginated\x0a * items. The array is sparse-like with `undefined` entries where holes exist.\x0a *\x0a * @param {?Array\x3cnumber\x3e} itemIds     Original item IDs (default empty array).\x0a * @param {number[]}       nextItemIds Item IDs to merge.\x0a * @param {number}         page        Page of items merged.\x0a * @param {number}         perPage     Number of items per page.\x0a *\x0a * @return {number[]} Merged array of item IDs.\x0a */\x0a\x0afunction getMergedItemIds(itemIds, nextItemIds, page, perPage) {\x0a  var nextItemIdsStartIndex = (page - 1) * perPage; // If later page has already been received, default to the larger known\x0a  // size of the existing array, else calculate as extending the existing.\x0a\x0a  var size = Math.max(itemIds.length, nextItemIdsStartIndex + nextItemIds.length); // Preallocate array since size is known.\x0a\x0a  var mergedItemIds = new Array(size);\x0a\x0a  for (var i = 0; i \x3c size; i++) {\x0a    // Preserve existing item ID except for subset of range of next items.\x0a    var isInNextItemsRange = i \x3e= nextItemIdsStartIndex && i \x3c nextItemIdsStartIndex + nextItemIds.length;\x0a    mergedItemIds[i] = isInNextItemsRange ? nextItemIds[i - nextItemIdsStartIndex] : itemIds[i];\x0a  }\x0a\x0a  return mergedItemIds;\x0a}\x0a/**\x0a * Reducer tracking items state, keyed by ID. Items are assumed to be normal,\x0a * where identifiers are common across all queries.\x0a *\x0a * @param {Object} state  Current state.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @return {Object} Next state.\x0a */\x0a\x0afunction reducer_items() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27RECEIVE_ITEMS\x27:\x0a      return Object(objectSpread[\x22a\x22 /* default */])({}, state, Object(external_lodash_[\x22keyBy\x22])(action.items, action.key || DEFAULT_ENTITY_KEY));\x0a  }\x0a\x0a  return state;\x0a}\x0a/**\x0a * Reducer tracking queries state, keyed by stable query key. Each reducer\x0a * query object includes `itemIds` and `requestingPageByPerPage`.\x0a *\x0a * @param {Object} state  Current state.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @return {Object} Next state.\x0a */\x0a\x0a\x0avar queries = Object(external_lodash_[\x22flowRight\x22])([// Limit to matching action type so we don\x27t attempt to replace action on\x0a// an unhandled action.\x0aif_matching_action(function (action) {\x0a  return \x27query\x27 in action;\x0a}), // Inject query parts into action for use both in `onSubKey` and reducer.\x0areplace_action(function (action) {\x0a  // `ifMatchingAction` still passes on initialization, where state is\x0a  // undefined and a query is not assigned. Avoid attempting to parse\x0a  // parts. `onSubKey` will omit by lack of `stableKey`.\x0a  if (action.query) {\x0a    return Object(objectSpread[\x22a\x22 /* default */])({}, action, get_query_parts(action.query));\x0a  }\x0a\x0a  return action;\x0a}), // Queries shape is shared, but keyed by query `stableKey` part. Original\x0a// reducer tracks only a single query object.\x0aon_sub_key(\x27stableKey\x27)])(function () {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : null;\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a  var type = action.type,\x0a      page = action.page,\x0a      perPage = action.perPage,\x0a      _action$key = action.key,\x0a      key = _action$key === void 0 ? DEFAULT_ENTITY_KEY : _action$key;\x0a\x0a  if (type !== \x27RECEIVE_ITEMS\x27) {\x0a    return state;\x0a  }\x0a\x0a  return getMergedItemIds(state || [], Object(external_lodash_[\x22map\x22])(action.items, key), page, perPage);\x0a});\x0a/* harmony default export */ var queried_data_reducer = (Object(redux[\x22b\x22 /* combineReducers */])({\x0a  items: reducer_items,\x0a  queries: queries\x0a}));\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/queried-data/index.js\x0a\x0a\x0a\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/reducer.js\x0a\x0a\x0a\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0a/**\x0a * Reducer managing terms state. Keyed by taxonomy slug, the value is either\x0a * undefined (if no request has been made for given taxonomy), null (if a\x0a * request is in-flight for given taxonomy), or the array of terms for the\x0a * taxonomy.\x0a *\x0a * @param {Object} state  Current state.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @return {Object} Updated state.\x0a */\x0a\x0afunction terms() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27RECEIVE_TERMS\x27:\x0a      return Object(objectSpread[\x22a\x22 /* default */])({}, state, Object(defineProperty[\x22a\x22 /* default */])({}, action.taxonomy, action.terms));\x0a  }\x0a\x0a  return state;\x0a}\x0a/**\x0a * Reducer managing authors state. Keyed by id.\x0a *\x0a * @param {Object} state  Current state.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @return {Object} Updated state.\x0a */\x0a\x0afunction reducer_users() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {\x0a    byId: {},\x0a    queries: {}\x0a  };\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27RECEIVE_USER_QUERY\x27:\x0a      return {\x0a        byId: Object(objectSpread[\x22a\x22 /* default */])({}, state.byId, Object(external_lodash_[\x22keyBy\x22])(action.users, \x27id\x27)),\x0a        queries: Object(objectSpread[\x22a\x22 /* default */])({}, state.queries, Object(defineProperty[\x22a\x22 /* default */])({}, action.queryID, Object(external_lodash_[\x22map\x22])(action.users, function (user) {\x0a          return user.id;\x0a        })))\x0a      };\x0a  }\x0a\x0a  return state;\x0a}\x0a/**\x0a * Reducer managing taxonomies.\x0a *\x0a * @param {Object} state  Current state.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @return {Object} Updated state.\x0a */\x0a\x0afunction reducer_taxonomies() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : [];\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27RECEIVE_TAXONOMIES\x27:\x0a      return action.taxonomies;\x0a  }\x0a\x0a  return state;\x0a}\x0a/**\x0a * Reducer managing theme supports data.\x0a *\x0a * @param {Object} state  Current state.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @return {Object} Updated state.\x0a */\x0a\x0afunction themeSupports() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27RECEIVE_THEME_SUPPORTS\x27:\x0a      return Object(objectSpread[\x22a\x22 /* default */])({}, state, action.themeSupports);\x0a  }\x0a\x0a  return state;\x0a}\x0a/**\x0a * Higher Order Reducer for a given entity config. It supports:\x0a *\x0a *  - Fetching a record by primary key\x0a *\x0a * @param {Object} entityConfig  Entity config.\x0a *\x0a * @return {Function} Reducer.\x0a */\x0a\x0afunction reducer_entity(entityConfig) {\x0a  return Object(external_lodash_[\x22flowRight\x22])([// Limit to matching action type so we don\x27t attempt to replace action on\x0a  // an unhandled action.\x0a  if_matching_action(function (action) {\x0a    return action.name && action.kind && action.name === entityConfig.name && action.kind === entityConfig.kind;\x0a  }), // Inject the entity config into the action.\x0a  replace_action(function (action) {\x0a    return Object(objectSpread[\x22a\x22 /* default */])({}, action, {\x0a      key: entityConfig.key || DEFAULT_ENTITY_KEY\x0a    });\x0a  })])(queried_data_reducer);\x0a}\x0a/**\x0a * Reducer keeping track of the registered entities.\x0a *\x0a * @param {Object} state  Current state.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @return {Object} Updated state.\x0a */\x0a\x0a\x0afunction entitiesConfig() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : defaultEntities;\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27ADD_ENTITIES\x27:\x0a      return [].concat(Object(toConsumableArray[\x22a\x22 /* default */])(state), Object(toConsumableArray[\x22a\x22 /* default */])(action.entities));\x0a  }\x0a\x0a  return state;\x0a}\x0a/**\x0a * Reducer keeping track of the registered entities config and data.\x0a *\x0a * @param {Object} state  Current state.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @return {Object} Updated state.\x0a */\x0a\x0avar reducer_entities = function entities() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a  var newConfig = entitiesConfig(state.config, action); // Generates a dynamic reducer for the entities\x0a\x0a  var entitiesDataReducer = state.reducer;\x0a\x0a  if (!entitiesDataReducer || newConfig !== state.config) {\x0a    var entitiesByKind = Object(external_lodash_[\x22groupBy\x22])(newConfig, \x27kind\x27);\x0a    entitiesDataReducer = Object(external_this_wp_data_[\x22combineReducers\x22])(Object.entries(entitiesByKind).reduce(function (memo, _ref) {\x0a      var _ref2 = Object(slicedToArray[\x22a\x22 /* default */])(_ref, 2),\x0a          kind = _ref2[0],\x0a          subEntities = _ref2[1];\x0a\x0a      var kindReducer = Object(external_this_wp_data_[\x22combineReducers\x22])(subEntities.reduce(function (kindMemo, entityConfig) {\x0a        return Object(objectSpread[\x22a\x22 /* default */])({}, kindMemo, Object(defineProperty[\x22a\x22 /* default */])({}, entityConfig.name, reducer_entity(entityConfig)));\x0a      }, {}));\x0a      memo[kind] = kindReducer;\x0a      return memo;\x0a    }, {}));\x0a  }\x0a\x0a  var newData = entitiesDataReducer(state.data, action);\x0a\x0a  if (newData === state.data && newConfig === state.config && entitiesDataReducer === state.reducer) {\x0a    return state;\x0a  }\x0a\x0a  return {\x0a    reducer: entitiesDataReducer,\x0a    data: newData,\x0a    config: newConfig\x0a  };\x0a};\x0a/**\x0a * Reducer managing embed preview data.\x0a *\x0a * @param {Object} state  Current state.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @return {Object} Updated state.\x0a */\x0a\x0afunction embedPreviews() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27RECEIVE_EMBED_PREVIEW\x27:\x0a      var url = action.url,\x0a          preview = action.preview;\x0a      return Object(objectSpread[\x22a\x22 /* default */])({}, state, Object(defineProperty[\x22a\x22 /* default */])({}, url, preview));\x0a  }\x0a\x0a  return state;\x0a}\x0a/**\x0a * State which tracks whether the user can perform an action on a REST\x0a * resource.\x0a *\x0a * @param  {Object} state  Current state.\x0a * @param  {Object} action Dispatched action.\x0a *\x0a * @return {Object} Updated state.\x0a */\x0a\x0afunction userPermissions() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27RECEIVE_USER_PERMISSION\x27:\x0a      return Object(objectSpread[\x22a\x22 /* default */])({}, state, Object(defineProperty[\x22a\x22 /* default */])({}, action.key, action.isAllowed));\x0a  }\x0a\x0a  return state;\x0a}\x0a/* harmony default export */ var build_module_reducer = (Object(external_this_wp_data_[\x22combineReducers\x22])({\x0a  terms: terms,\x0a  users: reducer_users,\x0a  taxonomies: reducer_taxonomies,\x0a  themeSupports: themeSupports,\x0a  entities: reducer_entities,\x0a  embedPreviews: embedPreviews,\x0a  userPermissions: userPermissions\x0a}));\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22deprecated\x22]}\x0avar external_this_wp_deprecated_ = __webpack_require__(49);\x0avar external_this_wp_deprecated_default = /*#__PURE__*/__webpack_require__.n(external_this_wp_deprecated_);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/name.js\x0a/**\x0a * The reducer key used by core data in store registration.\x0a * This is defined in a separate file to avoid cycle-dependency\x0a *\x0a * @type {string}\x0a */\x0avar REDUCER_KEY = \x27core\x27;\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/selectors.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * Returns true if a request is in progress for embed preview data, or false\x0a * otherwise.\x0a *\x0a * @param {Object} state Data state.\x0a * @param {string} url   URL the preview would be for.\x0a *\x0a * @return {boolean} Whether a request is in progress for an embed preview.\x0a */\x0a\x0avar isRequestingEmbedPreview = Object(external_this_wp_data_[\x22createRegistrySelector\x22])(function (select) {\x0a  return function (state, url) {\x0a    return select(\x27core/data\x27).isResolving(REDUCER_KEY, \x27getEmbedPreview\x27, [url]);\x0a  };\x0a});\x0a/**\x0a * Returns all available authors.\x0a *\x0a * @param {Object} state Data state.\x0a *\x0a * @return {Array} Authors list.\x0a */\x0a\x0afunction getAuthors(state) {\x0a  return getUserQueryResults(state, \x27authors\x27);\x0a}\x0a/**\x0a * Returns all the users returned by a query ID.\x0a *\x0a * @param {Object} state   Data state.\x0a * @param {string} queryID Query ID.\x0a *\x0a * @return {Array} Users list.\x0a */\x0a\x0avar getUserQueryResults = Object(rememo[\x22a\x22 /* default */])(function (state, queryID) {\x0a  var queryResults = state.users.queries[queryID];\x0a  return Object(external_lodash_[\x22map\x22])(queryResults, function (id) {\x0a    return state.users.byId[id];\x0a  });\x0a}, function (state, queryID) {\x0a  return [state.users.queries[queryID], state.users.byId];\x0a});\x0a/**\x0a * Returns whether the entities for the give kind are loaded.\x0a *\x0a * @param {Object} state   Data state.\x0a * @param {string} kind  Entity kind.\x0a *\x0a * @return {boolean} Whether the entities are loaded\x0a */\x0a\x0afunction getEntitiesByKind(state, kind) {\x0a  return Object(external_lodash_[\x22filter\x22])(state.entities.config, {\x0a    kind: kind\x0a  });\x0a}\x0a/**\x0a * Returns the entity object given its kind and name.\x0a *\x0a * @param {Object} state   Data state.\x0a * @param {string} kind  Entity kind.\x0a * @param {string} name  Entity name.\x0a *\x0a * @return {Object} Entity\x0a */\x0a\x0afunction getEntity(state, kind, name) {\x0a  return Object(external_lodash_[\x22find\x22])(state.entities.config, {\x0a    kind: kind,\x0a    name: name\x0a  });\x0a}\x0a/**\x0a * Returns the Entity\x27s record object by key.\x0a *\x0a * @param {Object} state  State tree\x0a * @param {string} kind   Entity kind.\x0a * @param {string} name   Entity name.\x0a * @param {number} key    Record\x27s key\x0a *\x0a * @return {Object?} Record.\x0a */\x0a\x0afunction getEntityRecord(state, kind, name, key) {\x0a  return Object(external_lodash_[\x22get\x22])(state.entities.data, [kind, name, \x27items\x27, key]);\x0a}\x0a/**\x0a * Returns the Entity\x27s records.\x0a *\x0a * @param {Object}  state  State tree\x0a * @param {string}  kind   Entity kind.\x0a * @param {string}  name   Entity name.\x0a * @param {?Object} query  Optional terms query.\x0a *\x0a * @return {Array} Records.\x0a */\x0a\x0afunction getEntityRecords(state, kind, name, query) {\x0a  var queriedState = Object(external_lodash_[\x22get\x22])(state.entities.data, [kind, name]);\x0a\x0a  if (!queriedState) {\x0a    return [];\x0a  }\x0a\x0a  return getQueriedItems(queriedState, query);\x0a}\x0a/**\x0a * Return theme supports data in the index.\x0a *\x0a * @param {Object} state Data state.\x0a *\x0a * @return {*}           Index data.\x0a */\x0a\x0afunction getThemeSupports(state) {\x0a  return state.themeSupports;\x0a}\x0a/**\x0a * Returns the embed preview for the given URL.\x0a *\x0a * @param {Object} state    Data state.\x0a * @param {string} url      Embedded URL.\x0a *\x0a * @return {*} Undefined if the preview has not been fetched, otherwise, the preview fetched from the embed preview API.\x0a */\x0a\x0afunction getEmbedPreview(state, url) {\x0a  return state.embedPreviews[url];\x0a}\x0a/**\x0a * Determines if the returned preview is an oEmbed link fallback.\x0a *\x0a * WordPress can be configured to return a simple link to a URL if it is not embeddable.\x0a * We need to be able to determine if a URL is embeddable or not, based on what we\x0a * get back from the oEmbed preview API.\x0a *\x0a * @param {Object} state    Data state.\x0a * @param {string} url      Embedded URL.\x0a *\x0a * @return {booleans} Is the preview for the URL an oEmbed link fallback.\x0a */\x0a\x0afunction isPreviewEmbedFallback(state, url) {\x0a  var preview = state.embedPreviews[url];\x0a  var oEmbedLinkCheck = \x27\x3ca href=\x22\x27 + url + \x27\x22\x3e\x27 + url + \x27\x3c/a\x3e\x27;\x0a\x0a  if (!preview) {\x0a    return false;\x0a  }\x0a\x0a  return preview.html === oEmbedLinkCheck;\x0a}\x0a/**\x0a * Returns whether the current user can upload media.\x0a *\x0a * Calling this may trigger an OPTIONS request to the REST API via the\x0a * `canUser()` resolver.\x0a *\x0a * https://developer.wordpress.org/rest-api/reference/\x0a *\x0a * @deprecated since 5.0. Callers should use the more generic `canUser()` selector instead of\x0a *             `hasUploadPermissions()`, e.g. `canUser( \x27create\x27, \x27media\x27 )`.\x0a *\x0a * @param {Object} state Data state.\x0a *\x0a * @return {boolean} Whether or not the user can upload media. Defaults to `true` if the OPTIONS\x0a *                   request is being made.\x0a */\x0a\x0afunction hasUploadPermissions(state) {\x0a  external_this_wp_deprecated_default()(\x22select( \x27core\x27 ).hasUploadPermissions()\x22, {\x0a    alternative: \x22select( \x27core\x27 ).canUser( \x27create\x27, \x27media\x27 )\x22\x0a  });\x0a  return Object(external_lodash_[\x22defaultTo\x22])(canUser(state, \x27create\x27, \x27media\x27), true);\x0a}\x0a/**\x0a * Returns whether the current user can perform the given action on the given\x0a * REST resource.\x0a *\x0a * Calling this may trigger an OPTIONS request to the REST API via the\x0a * `canUser()` resolver.\x0a *\x0a * https://developer.wordpress.org/rest-api/reference/\x0a *\x0a * @param {Object}   state            Data state.\x0a * @param {string}   action           Action to check. One of: \x27create\x27, \x27read\x27, \x27update\x27, \x27delete\x27.\x0a * @param {string}   resource         REST resource to check, e.g. \x27media\x27 or \x27posts\x27.\x0a * @param {string=}  id               Optional ID of the rest resource to check.\x0a *\x0a * @return {boolean|undefined} Whether or not the user can perform the action,\x0a *                             or `undefined` if the OPTIONS request is still being made.\x0a */\x0a\x0afunction canUser(state, action, resource, id) {\x0a  var key = Object(external_lodash_[\x22compact\x22])([action, resource, id]).join(\x27/\x27);\x0a  return Object(external_lodash_[\x22get\x22])(state, [\x27userPermissions\x27, key]);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/resolvers.js\x0a\x0a\x0a\x0avar resolvers_marked =\x0a/*#__PURE__*/\x0aregenerator_default.a.mark(resolvers_getAuthors),\x0a    resolvers_marked2 =\x0a/*#__PURE__*/\x0aregenerator_default.a.mark(resolvers_getEntityRecord),\x0a    resolvers_marked3 =\x0a/*#__PURE__*/\x0aregenerator_default.a.mark(resolvers_getEntityRecords),\x0a    _marked4 =\x0a/*#__PURE__*/\x0aregenerator_default.a.mark(resolvers_getThemeSupports),\x0a    _marked5 =\x0a/*#__PURE__*/\x0aregenerator_default.a.mark(resolvers_getEmbedPreview),\x0a    _marked6 =\x0a/*#__PURE__*/\x0aregenerator_default.a.mark(resolvers_hasUploadPermissions),\x0a    _marked7 =\x0a/*#__PURE__*/\x0aregenerator_default.a.mark(resolvers_canUser);\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0a/**\x0a * Requests authors from the REST API.\x0a */\x0a\x0afunction resolvers_getAuthors() {\x0a  var users;\x0a  return regenerator_default.a.wrap(function getAuthors$(_context) {\x0a    while (1) {\x0a      switch (_context.prev = _context.next) {\x0a        case 0:\x0a          _context.next = 2;\x0a          return apiFetch({\x0a            path: \x27/wp/v2/users/?who=authors&per_page=-1\x27\x0a          });\x0a\x0a        case 2:\x0a          users = _context.sent;\x0a          _context.next = 5;\x0a          return receiveUserQuery(\x27authors\x27, users);\x0a\x0a        case 5:\x0a        case \x22end\x22:\x0a          return _context.stop();\x0a      }\x0a    }\x0a  }, resolvers_marked, this);\x0a}\x0a/**\x0a * Requests an entity\x27s record from the REST API.\x0a *\x0a * @param {string} kind   Entity kind.\x0a * @param {string} name   Entity name.\x0a * @param {number} key    Record\x27s key\x0a */\x0a\x0afunction resolvers_getEntityRecord(kind, name, key) {\x0a  var entities, entity, record;\x0a  return regenerator_default.a.wrap(function getEntityRecord$(_context2) {\x0a    while (1) {\x0a      switch (_context2.prev = _context2.next) {\x0a        case 0:\x0a          _context2.next = 2;\x0a          return getKindEntities(kind);\x0a\x0a        case 2:\x0a          entities = _context2.sent;\x0a          entity = Object(external_lodash_[\x22find\x22])(entities, {\x0a            kind: kind,\x0a            name: name\x0a          });\x0a\x0a          if (entity) {\x0a            _context2.next = 6;\x0a            break;\x0a          }\x0a\x0a          return _context2.abrupt(\x22return\x22);\x0a\x0a        case 6:\x0a          _context2.next = 8;\x0a          return apiFetch({\x0a            path: \x22\x22.concat(entity.baseURL, \x22/\x22).concat(key, \x22?context=edit\x22)\x0a          });\x0a\x0a        case 8:\x0a          record = _context2.sent;\x0a          _context2.next = 11;\x0a          return receiveEntityRecords(kind, name, record);\x0a\x0a        case 11:\x0a        case \x22end\x22:\x0a          return _context2.stop();\x0a      }\x0a    }\x0a  }, resolvers_marked2, this);\x0a}\x0a/**\x0a * Requests the entity\x27s records from the REST API.\x0a *\x0a * @param {string}  kind   Entity kind.\x0a * @param {string}  name   Entity name.\x0a * @param {Object?} query  Query Object.\x0a */\x0a\x0afunction resolvers_getEntityRecords(kind, name) {\x0a  var query,\x0a      entities,\x0a      entity,\x0a      path,\x0a      records,\x0a      _args3 = arguments;\x0a  return regenerator_default.a.wrap(function getEntityRecords$(_context3) {\x0a    while (1) {\x0a      switch (_context3.prev = _context3.next) {\x0a        case 0:\x0a          query = _args3.length \x3e 2 && _args3[2] !== undefined ? _args3[2] : {};\x0a          _context3.next = 3;\x0a          return getKindEntities(kind);\x0a\x0a        case 3:\x0a          entities = _context3.sent;\x0a          entity = Object(external_lodash_[\x22find\x22])(entities, {\x0a            kind: kind,\x0a            name: name\x0a          });\x0a\x0a          if (entity) {\x0a            _context3.next = 7;\x0a            break;\x0a          }\x0a\x0a          return _context3.abrupt(\x22return\x22);\x0a\x0a        case 7:\x0a          path = Object(external_this_wp_url_[\x22addQueryArgs\x22])(entity.baseURL, Object(objectSpread[\x22a\x22 /* default */])({}, query, {\x0a            context: \x27edit\x27\x0a          }));\x0a          _context3.next = 10;\x0a          return apiFetch({\x0a            path: path\x0a          });\x0a\x0a        case 10:\x0a          records = _context3.sent;\x0a          _context3.next = 13;\x0a          return receiveEntityRecords(kind, name, Object.values(records), query);\x0a\x0a        case 13:\x0a        case \x22end\x22:\x0a          return _context3.stop();\x0a      }\x0a    }\x0a  }, resolvers_marked3, this);\x0a}\x0a\x0aresolvers_getEntityRecords.shouldInvalidate = function (action, kind, name) {\x0a  return action.type === \x27RECEIVE_ITEMS\x27 && action.invalidateCache && kind === action.kind && name === action.name;\x0a};\x0a/**\x0a * Requests theme supports data from the index.\x0a */\x0a\x0a\x0afunction resolvers_getThemeSupports() {\x0a  var activeThemes;\x0a  return regenerator_default.a.wrap(function getThemeSupports$(_context4) {\x0a    while (1) {\x0a      switch (_context4.prev = _context4.next) {\x0a        case 0:\x0a          _context4.next = 2;\x0a          return apiFetch({\x0a            path: \x27/wp/v2/themes?status=active\x27\x0a          });\x0a\x0a        case 2:\x0a          activeThemes = _context4.sent;\x0a          _context4.next = 5;\x0a          return receiveThemeSupports(activeThemes[0].theme_supports);\x0a\x0a        case 5:\x0a        case \x22end\x22:\x0a          return _context4.stop();\x0a      }\x0a    }\x0a  }, _marked4, this);\x0a}\x0a/**\x0a * Requests a preview from the from the Embed API.\x0a *\x0a * @param {string} url   URL to get the preview for.\x0a */\x0a\x0afunction resolvers_getEmbedPreview(url) {\x0a  var embedProxyResponse;\x0a  return regenerator_default.a.wrap(function getEmbedPreview$(_context5) {\x0a    while (1) {\x0a      switch (_context5.prev = _context5.next) {\x0a        case 0:\x0a          _context5.prev = 0;\x0a          _context5.next = 3;\x0a          return apiFetch({\x0a            path: Object(external_this_wp_url_[\x22addQueryArgs\x22])(\x27/oembed/1.0/proxy\x27, {\x0a              url: url\x0a            })\x0a          });\x0a\x0a        case 3:\x0a          embedProxyResponse = _context5.sent;\x0a          _context5.next = 6;\x0a          return receiveEmbedPreview(url, embedProxyResponse);\x0a\x0a        case 6:\x0a          _context5.next = 12;\x0a          break;\x0a\x0a        case 8:\x0a          _context5.prev = 8;\x0a          _context5.t0 = _context5[\x22catch\x22](0);\x0a          _context5.next = 12;\x0a          return receiveEmbedPreview(url, false);\x0a\x0a        case 12:\x0a        case \x22end\x22:\x0a          return _context5.stop();\x0a      }\x0a    }\x0a  }, _marked5, this, [[0, 8]]);\x0a}\x0a/**\x0a * Requests Upload Permissions from the REST API.\x0a *\x0a * @deprecated since 5.0. Callers should use the more generic `canUser()` selector instead of\x0a *            `hasUploadPermissions()`, e.g. `canUser( \x27create\x27, \x27media\x27 )`.\x0a */\x0a\x0afunction resolvers_hasUploadPermissions() {\x0a  return regenerator_default.a.wrap(function hasUploadPermissions$(_context6) {\x0a    while (1) {\x0a      switch (_context6.prev = _context6.next) {\x0a        case 0:\x0a          external_this_wp_deprecated_default()(\x22select( \x27core\x27 ).hasUploadPermissions()\x22, {\x0a            alternative: \x22select( \x27core\x27 ).canUser( \x27create\x27, \x27media\x27 )\x22\x0a          });\x0a          return _context6.delegateYield(resolvers_canUser(\x27create\x27, \x27media\x27), \x22t0\x22, 2);\x0a\x0a        case 2:\x0a        case \x22end\x22:\x0a          return _context6.stop();\x0a      }\x0a    }\x0a  }, _marked6, this);\x0a}\x0a/**\x0a * Checks whether the current user can perform the given action on the given\x0a * REST resource.\x0a *\x0a * @param {string}  action   Action to check. One of: \x27create\x27, \x27read\x27, \x27update\x27,\x0a *                           \x27delete\x27.\x0a * @param {string}  resource REST resource to check, e.g. \x27media\x27 or \x27posts\x27.\x0a * @param {?string} id       ID of the rest resource to check.\x0a */\x0a\x0afunction resolvers_canUser(action, resource, id) {\x0a  var methods, method, path, response, allowHeader, key, isAllowed;\x0a  return regenerator_default.a.wrap(function canUser$(_context7) {\x0a    while (1) {\x0a      switch (_context7.prev = _context7.next) {\x0a        case 0:\x0a          methods = {\x0a            create: \x27POST\x27,\x0a            read: \x27GET\x27,\x0a            update: \x27PUT\x27,\x0a            delete: \x27DELETE\x27\x0a          };\x0a          method = methods[action];\x0a\x0a          if (method) {\x0a            _context7.next = 4;\x0a            break;\x0a          }\x0a\x0a          throw new Error(\x22\x27\x22.concat(action, \x22\x27 is not a valid action.\x22));\x0a\x0a        case 4:\x0a          path = id ? \x22/wp/v2/\x22.concat(resource, \x22/\x22).concat(id) : \x22/wp/v2/\x22.concat(resource);\x0a          _context7.prev = 5;\x0a          _context7.next = 8;\x0a          return apiFetch({\x0a            path: path,\x0a            // Ideally this would always be an OPTIONS request, but unfortunately there\x27s\x0a            // a bug in the REST API which causes the Allow header to not be sent on\x0a            // OPTIONS requests to /posts/:id routes.\x0a            // https://core.trac.wordpress.org/ticket/45753\x0a            method: id ? \x27GET\x27 : \x27OPTIONS\x27,\x0a            parse: false\x0a          });\x0a\x0a        case 8:\x0a          response = _context7.sent;\x0a          _context7.next = 14;\x0a          break;\x0a\x0a        case 11:\x0a          _context7.prev = 11;\x0a          _context7.t0 = _context7[\x22catch\x22](5);\x0a          return _context7.abrupt(\x22return\x22);\x0a\x0a        case 14:\x0a          if (Object(external_lodash_[\x22hasIn\x22])(response, [\x27headers\x27, \x27get\x27])) {\x0a            // If the request is fetched using the fetch api, the header can be\x0a            // retrieved using the \x27get\x27 method.\x0a            allowHeader = response.headers.get(\x27allow\x27);\x0a          } else {\x0a            // If the request was preloaded server-side and is returned by the\x0a            // preloading middleware, the header will be a simple property.\x0a            allowHeader = Object(external_lodash_[\x22get\x22])(response, [\x27headers\x27, \x27Allow\x27], \x27\x27);\x0a          }\x0a\x0a          key = Object(external_lodash_[\x22compact\x22])([action, resource, id]).join(\x27/\x27);\x0a          isAllowed = Object(external_lodash_[\x22includes\x22])(allowHeader, method);\x0a          _context7.next = 19;\x0a          return receiveUserPermission(key, isAllowed);\x0a\x0a        case 19:\x0a        case \x22end\x22:\x0a          return _context7.stop();\x0a      }\x0a    }\x0a  }, _marked7, this, [[5, 11]]);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/core-data/build-module/index.js\x0a\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0a\x0a\x0a\x0a // The entity selectors/resolvers and actions are shortcuts to their generic equivalents\x0a// (getEntityRecord, getEntityRecords, updateEntityRecord, updateEntityRecordss)\x0a// Instead of getEntityRecord, the consumer could use more user-frieldly named selector: getPostType, getTaxonomy...\x0a// The \x22kind\x22 and the \x22name\x22 of the entity are combined to generate these shortcuts.\x0a\x0avar entitySelectors = defaultEntities.reduce(function (result, entity) {\x0a  var kind = entity.kind,\x0a      name = entity.name;\x0a\x0a  result[entities_getMethodName(kind, name)] = function (state, key) {\x0a    return getEntityRecord(state, kind, name, key);\x0a  };\x0a\x0a  result[entities_getMethodName(kind, name, \x27get\x27, true)] = function (state) {\x0a    for (var _len = arguments.length, args = new Array(_len \x3e 1 ? _len - 1 : 0), _key = 1; _key \x3c _len; _key++) {\x0a      args[_key - 1] = arguments[_key];\x0a    }\x0a\x0a    return getEntityRecords.apply(build_module_selectors_namespaceObject, [state, kind, name].concat(args));\x0a  };\x0a\x0a  return result;\x0a}, {});\x0avar entityResolvers = defaultEntities.reduce(function (result, entity) {\x0a  var kind = entity.kind,\x0a      name = entity.name;\x0a\x0a  result[entities_getMethodName(kind, name)] = function (key) {\x0a    return resolvers_getEntityRecord(kind, name, key);\x0a  };\x0a\x0a  var pluralMethodName = entities_getMethodName(kind, name, \x27get\x27, true);\x0a\x0a  result[pluralMethodName] = function () {\x0a    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 \x3c _len2; _key2++) {\x0a      args[_key2] = arguments[_key2];\x0a    }\x0a\x0a    return resolvers_getEntityRecords.apply(resolvers_namespaceObject, [kind, name].concat(args));\x0a  };\x0a\x0a  result[pluralMethodName].shouldInvalidate = function (action) {\x0a    var _resolvers$getEntityR;\x0a\x0a    for (var _len3 = arguments.length, args = new Array(_len3 \x3e 1 ? _len3 - 1 : 0), _key3 = 1; _key3 \x3c _len3; _key3++) {\x0a      args[_key3 - 1] = arguments[_key3];\x0a    }\x0a\x0a    return (_resolvers$getEntityR = resolvers_getEntityRecords).shouldInvalidate.apply(_resolvers$getEntityR, [action, kind, name].concat(args));\x0a  };\x0a\x0a  return result;\x0a}, {});\x0avar entityActions = defaultEntities.reduce(function (result, entity) {\x0a  var kind = entity.kind,\x0a      name = entity.name;\x0a\x0a  result[entities_getMethodName(kind, name, \x27save\x27)] = function (key) {\x0a    return saveEntityRecord(kind, name, key);\x0a  };\x0a\x0a  return result;\x0a}, {});\x0aObject(external_this_wp_data_[\x22registerStore\x22])(REDUCER_KEY, {\x0a  reducer: build_module_reducer,\x0a  controls: build_module_controls,\x0a  actions: Object(objectSpread[\x22a\x22 /* default */])({}, build_module_actions_namespaceObject, entityActions),\x0a  selectors: Object(objectSpread[\x22a\x22 /* default */])({}, build_module_selectors_namespaceObject, entitySelectors),\x0a  resolvers: Object(objectSpread[\x22a\x22 /* default */])({}, resolvers_namespaceObject, entityResolvers)\x0a});\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 37:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _arrayWithHoles; });\x0afunction _arrayWithHoles(arr) {\x0a  if (Array.isArray(arr)) return arr;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 38:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _nonIterableRest; });\x0afunction _nonIterableRest() {\x0a  throw new TypeError(\x22Invalid attempt to destructure non-iterable instance\x22);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 49:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22deprecated\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 5:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22data\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 54:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a/**\x0a * Copyright (c) 2014-present, Facebook, Inc.\x0a *\x0a * This source code is licensed under the MIT license found in the\x0a * LICENSE file in the root directory of this source tree.\x0a */\x0a\x0a// This method of obtaining a reference to the global object needs to be\x0a// kept identical to the way it is obtained in runtime.js\x0avar g = (function() {\x0a  return this || (typeof self === \x22object\x22 && self);\x0a})() || Function(\x22return this\x22)();\x0a\x0a// Use `getOwnPropertyNames` because not all browsers support calling\x0a// `hasOwnProperty` on the global `self` object in a worker. See #183.\x0avar hadRuntime = g.regeneratorRuntime &&\x0a  Object.getOwnPropertyNames(g).indexOf(\x22regeneratorRuntime\x22) \x3e= 0;\x0a\x0a// Save the old regeneratorRuntime in case it needs to be restored later.\x0avar oldRuntime = hadRuntime && g.regeneratorRuntime;\x0a\x0a// Force reevalutation of runtime.js.\x0ag.regeneratorRuntime = undefined;\x0a\x0amodule.exports = __webpack_require__(55);\x0a\x0aif (hadRuntime) {\x0a  // Restore the original runtime.\x0a  g.regeneratorRuntime = oldRuntime;\x0a} else {\x0a  // Remove the global property added by runtime.js.\x0a  try {\x0a    delete g.regeneratorRuntime;\x0a  } catch(e) {\x0a    g.regeneratorRuntime = undefined;\x0a  }\x0a}\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 55:\x0a/***/ (function(module, exports) {\x0a\x0a/**\x0a * Copyright (c) 2014-present, Facebook, Inc.\x0a *\x0a * This source code is licensed under the MIT license found in the\x0a * LICENSE file in the root directory of this source tree.\x0a */\x0a\x0a!(function(global) {\x0a  \x22use strict\x22;\x0a\x0a  var Op = Object.prototype;\x0a  var hasOwn = Op.hasOwnProperty;\x0a  var undefined; // More compressible than void 0.\x0a  var $Symbol = typeof Symbol === \x22function\x22 ? Symbol : {};\x0a  var iteratorSymbol = $Symbol.iterator || \x22@@iterator\x22;\x0a  var asyncIteratorSymbol = $Symbol.asyncIterator || \x22@@asyncIterator\x22;\x0a  var toStringTagSymbol = $Symbol.toStringTag || \x22@@toStringTag\x22;\x0a\x0a  var inModule = typeof module === \x22object\x22;\x0a  var runtime = global.regeneratorRuntime;\x0a  if (runtime) {\x0a    if (inModule) {\x0a      // If regeneratorRuntime is defined globally and we\x27re in a module,\x0a      // make the exports object identical to regeneratorRuntime.\x0a      module.exports = runtime;\x0a    }\x0a    // Don\x27t bother evaluating the rest of this file if the runtime was\x0a    // already defined globally.\x0a    return;\x0a  }\x0a\x0a  // Define the runtime globally (as expected by generated code) as either\x0a  // module.exports (if we\x27re in a module) or a new, empty object.\x0a  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\x0a\x0a  function wrap(innerFn, outerFn, self, tryLocsList) {\x0a    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\x0a    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\x0a    var generator = Object.create(protoGenerator.prototype);\x0a    var context = new Context(tryLocsList || []);\x0a\x0a    // The ._invoke method unifies the implementations of the .next,\x0a    // .throw, and .return methods.\x0a    generator._invoke = makeInvokeMethod(innerFn, self, context);\x0a\x0a    return generator;\x0a  }\x0a  runtime.wrap = wrap;\x0a\x0a  // Try/catch helper to minimize deoptimizations. Returns a completion\x0a  // record like context.tryEntries[i].completion. This interface could\x0a  // have been (and was previously) designed to take a closure to be\x0a  // invoked without arguments, but in all the cases we care about we\x0a  // already have an existing method we want to call, so there\x27s no need\x0a  // to create a new function object. We can even get away with assuming\x0a  // the method takes exactly one argument, since that happens to be true\x0a  // in every case, so we don\x27t have to touch the arguments object. The\x0a  // only additional allocation required is the completion record, which\x0a  // has a stable shape and so hopefully should be cheap to allocate.\x0a  function tryCatch(fn, obj, arg) {\x0a    try {\x0a      return { type: \x22normal\x22, arg: fn.call(obj, arg) };\x0a    } catch (err) {\x0a      return { type: \x22throw\x22, arg: err };\x0a    }\x0a  }\x0a\x0a  var GenStateSuspendedStart = \x22suspendedStart\x22;\x0a  var GenStateSuspendedYield = \x22suspendedYield\x22;\x0a  var GenStateExecuting = \x22executing\x22;\x0a  var GenStateCompleted = \x22completed\x22;\x0a\x0a  // Returning this object from the innerFn has the same effect as\x0a  // breaking out of the dispatch switch statement.\x0a  var ContinueSentinel = {};\x0a\x0a  // Dummy constructor functions that we use as the .constructor and\x0a  // .constructor.prototype properties for functions that return Generator\x0a  // objects. For full spec compliance, you may wish to configure your\x0a  // minifier not to mangle the names of these two functions.\x0a  function Generator() {}\x0a  function GeneratorFunction() {}\x0a  function GeneratorFunctionPrototype() {}\x0a\x0a  // This is a polyfill for %IteratorPrototype% for environments that\x0a  // don\x27t natively support it.\x0a  var IteratorPrototype = {};\x0a  IteratorPrototype[iteratorSymbol] = function () {\x0a    return this;\x0a  };\x0a\x0a  var getProto = Object.getPrototypeOf;\x0a  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\x0a  if (NativeIteratorPrototype &&\x0a      NativeIteratorPrototype !== Op &&\x0a      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\x0a    // This environment has a native %IteratorPrototype%; use it instead\x0a    // of the polyfill.\x0a    IteratorPrototype = NativeIteratorPrototype;\x0a  }\x0a\x0a  var Gp = GeneratorFunctionPrototype.prototype =\x0a    Generator.prototype = Object.create(IteratorPrototype);\x0a  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\x0a  GeneratorFunctionPrototype.constructor = GeneratorFunction;\x0a  GeneratorFunctionPrototype[toStringTagSymbol] =\x0a    GeneratorFunction.displayName = \x22GeneratorFunction\x22;\x0a\x0a  // Helper for defining the .next, .throw, and .return methods of the\x0a  // Iterator interface in terms of a single ._invoke method.\x0a  function defineIteratorMethods(prototype) {\x0a    [\x22next\x22, \x22throw\x22, \x22return\x22].forEach(function(method) {\x0a      prototype[method] = function(arg) {\x0a        return this._invoke(method, arg);\x0a      };\x0a    });\x0a  }\x0a\x0a  runtime.isGeneratorFunction = function(genFun) {\x0a    var ctor = typeof genFun === \x22function\x22 && genFun.constructor;\x0a    return ctor\x0a      ? ctor === GeneratorFunction ||\x0a        // For the native GeneratorFunction constructor, the best we can\x0a        // do is to check its .name property.\x0a        (ctor.displayName || ctor.name) === \x22GeneratorFunction\x22\x0a      : false;\x0a  };\x0a\x0a  runtime.mark = function(genFun) {\x0a    if (Object.setPrototypeOf) {\x0a      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\x0a    } else {\x0a      genFun.__proto__ = GeneratorFunctionPrototype;\x0a      if (!(toStringTagSymbol in genFun)) {\x0a        genFun[toStringTagSymbol] = \x22GeneratorFunction\x22;\x0a      }\x0a    }\x0a    genFun.prototype = Object.create(Gp);\x0a    return genFun;\x0a  };\x0a\x0a  // Within the body of any async function, `await x` is transformed to\x0a  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\x0a  // `hasOwn.call(value, \x22__await\x22)` to determine if the yielded value is\x0a  // meant to be awaited.\x0a  runtime.awrap = function(arg) {\x0a    return { __await: arg };\x0a  };\x0a\x0a  function AsyncIterator(generator) {\x0a    function invoke(method, arg, resolve, reject) {\x0a      var record = tryCatch(generator[method], generator, arg);\x0a      if (record.type === \x22throw\x22) {\x0a        reject(record.arg);\x0a      } else {\x0a        var result = record.arg;\x0a        var value = result.value;\x0a        if (value &&\x0a            typeof value === \x22object\x22 &&\x0a            hasOwn.call(value, \x22__await\x22)) {\x0a          return Promise.resolve(value.__await).then(function(value) {\x0a            invoke(\x22next\x22, value, resolve, reject);\x0a          }, function(err) {\x0a            invoke(\x22throw\x22, err, resolve, reject);\x0a          });\x0a        }\x0a\x0a        return Promise.resolve(value).then(function(unwrapped) {\x0a          // When a yielded Promise is resolved, its final value becomes\x0a          // the .value of the Promise\x3c{value,done}\x3e result for the\x0a          // current iteration.\x0a          result.value = unwrapped;\x0a          resolve(result);\x0a        }, function(error) {\x0a          // If a rejected Promise was yielded, throw the rejection back\x0a          // into the async generator function so it can be handled there.\x0a          return invoke(\x22throw\x22, error, resolve, reject);\x0a        });\x0a      }\x0a    }\x0a\x0a    var previousPromise;\x0a\x0a    function enqueue(method, arg) {\x0a      function callInvokeWithMethodAndArg() {\x0a        return new Promise(function(resolve, reject) {\x0a          invoke(method, arg, resolve, reject);\x0a        });\x0a      }\x0a\x0a      return previousPromise =\x0a        // If enqueue has been called before, then we want to wait until\x0a        // all previous Promises have been resolved before calling invoke,\x0a        // so that results are always delivered in the correct order. If\x0a        // enqueue has not been called before, then it is important to\x0a        // call invoke immediately, without waiting on a callback to fire,\x0a        // so that the async generator function has the opportunity to do\x0a        // any necessary setup in a predictable way. This predictability\x0a        // is why the Promise constructor synchronously invokes its\x0a        // executor callback, and why async functions synchronously\x0a        // execute code before the first await. Since we implement simple\x0a        // async functions in terms of async generators, it is especially\x0a        // important to get this right, even though it requires care.\x0a        previousPromise ? previousPromise.then(\x0a          callInvokeWithMethodAndArg,\x0a          // Avoid propagating failures to Promises returned by later\x0a          // invocations of the iterator.\x0a          callInvokeWithMethodAndArg\x0a        ) : callInvokeWithMethodAndArg();\x0a    }\x0a\x0a    // Define the unified helper method that is used to implement .next,\x0a    // .throw, and .return (see defineIteratorMethods).\x0a    this._invoke = enqueue;\x0a  }\x0a\x0a  defineIteratorMethods(AsyncIterator.prototype);\x0a  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\x0a    return this;\x0a  };\x0a  runtime.AsyncIterator = AsyncIterator;\x0a\x0a  // Note that simple async functions are implemented on top of\x0a  // AsyncIterator objects; they just return a Promise for the value of\x0a  // the final result produced by the iterator.\x0a  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\x0a    var iter = new AsyncIterator(\x0a      wrap(innerFn, outerFn, self, tryLocsList)\x0a    );\x0a\x0a    return runtime.isGeneratorFunction(outerFn)\x0a      ? iter // If outerFn is a generator, return the full iterator.\x0a      : iter.next().then(function(result) {\x0a          return result.done ? result.value : iter.next();\x0a        });\x0a  };\x0a\x0a  function makeInvokeMethod(innerFn, self, context) {\x0a    var state = GenStateSuspendedStart;\x0a\x0a    return function invoke(method, arg) {\x0a      if (state === GenStateExecuting) {\x0a        throw new Error(\x22Generator is already running\x22);\x0a      }\x0a\x0a      if (state === GenStateCompleted) {\x0a        if (method === \x22throw\x22) {\x0a          throw arg;\x0a        }\x0a\x0a        // Be forgiving, per 25.3.3.3.3 of the spec:\x0a        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\x0a        return doneResult();\x0a      }\x0a\x0a      context.method = method;\x0a      context.arg = arg;\x0a\x0a      while (true) {\x0a        var delegate = context.delegate;\x0a        if (delegate) {\x0a          var delegateResult = maybeInvokeDelegate(delegate, context);\x0a          if (delegateResult) {\x0a            if (delegateResult === ContinueSentinel) continue;\x0a            return delegateResult;\x0a          }\x0a        }\x0a\x0a        if (context.method === \x22next\x22) {\x0a          // Setting context._sent for legacy support of Babel\x27s\x0a          // function.sent implementation.\x0a          context.sent = context._sent = context.arg;\x0a\x0a        } else if (context.method === \x22throw\x22) {\x0a          if (state === GenStateSuspendedStart) {\x0a            state = GenStateCompleted;\x0a            throw context.arg;\x0a          }\x0a\x0a          context.dispatchException(context.arg);\x0a\x0a        } else if (context.method === \x22return\x22) {\x0a          context.abrupt(\x22return\x22, context.arg);\x0a        }\x0a\x0a        state = GenStateExecuting;\x0a\x0a        var record = tryCatch(innerFn, self, context);\x0a        if (record.type === \x22normal\x22) {\x0a          // If an exception is thrown from innerFn, we leave state ===\x0a          // GenStateExecuting and loop back for another invocation.\x0a          state = context.done\x0a            ? GenStateCompleted\x0a            : GenStateSuspendedYield;\x0a\x0a          if (record.arg === ContinueSentinel) {\x0a            continue;\x0a          }\x0a\x0a          return {\x0a            value: record.arg,\x0a            done: context.done\x0a          };\x0a\x0a        } else if (record.type === \x22throw\x22) {\x0a          state = GenStateCompleted;\x0a          // Dispatch the exception by looping back around to the\x0a          // context.dispatchException(context.arg) call above.\x0a          context.method = \x22throw\x22;\x0a          context.arg = record.arg;\x0a        }\x0a      }\x0a    };\x0a  }\x0a\x0a  // Call delegate.iterator[context.method](context.arg) and handle the\x0a  // result, either by returning a { value, done } result from the\x0a  // delegate iterator, or by modifying context.method and context.arg,\x0a  // setting context.delegate to null, and returning the ContinueSentinel.\x0a  function maybeInvokeDelegate(delegate, context) {\x0a    var method = delegate.iterator[context.method];\x0a    if (method === undefined) {\x0a      // A .throw or .return when the delegate iterator has no .throw\x0a      // method always terminates the yield* loop.\x0a      context.delegate = null;\x0a\x0a      if (context.method === \x22throw\x22) {\x0a        if (delegate.iterator.return) {\x0a          // If the delegate iterator has a return method, give it a\x0a          // chance to clean up.\x0a          context.method = \x22return\x22;\x0a          context.arg = undefined;\x0a          maybeInvokeDelegate(delegate, context);\x0a\x0a          if (context.method === \x22throw\x22) {\x0a            // If maybeInvokeDelegate(context) changed context.method from\x0a            // \x22return\x22 to \x22throw\x22, let that override the TypeError below.\x0a            return ContinueSentinel;\x0a          }\x0a        }\x0a\x0a        context.method = \x22throw\x22;\x0a        context.arg = new TypeError(\x0a          \x22The iterator does not provide a \x27throw\x27 method\x22);\x0a      }\x0a\x0a      return ContinueSentinel;\x0a    }\x0a\x0a    var record = tryCatch(method, delegate.iterator, context.arg);\x0a\x0a    if (record.type === \x22throw\x22) {\x0a      context.method = \x22throw\x22;\x0a      context.arg = record.arg;\x0a      context.delegate = null;\x0a      return ContinueSentinel;\x0a    }\x0a\x0a    var info = record.arg;\x0a\x0a    if (! info) {\x0a      context.method = \x22throw\x22;\x0a      context.arg = new TypeError(\x22iterator result is not an object\x22);\x0a      context.delegate = null;\x0a      return ContinueSentinel;\x0a    }\x0a\x0a    if (info.done) {\x0a      // Assign the result of the finished delegate to the temporary\x0a      // variable specified by delegate.resultName (see delegateYield).\x0a      context[delegate.resultName] = info.value;\x0a\x0a      // Resume execution at the desired location (see delegateYield).\x0a      context.next = delegate.nextLoc;\x0a\x0a      // If context.method was \x22throw\x22 but the delegate handled the\x0a      // exception, let the outer generator proceed normally. If\x0a      // context.method was \x22next\x22, forget context.arg since it has been\x0a      // \x22consumed\x22 by the delegate iterator. If context.method was\x0a      // \x22return\x22, allow the original .return call to continue in the\x0a      // outer generator.\x0a      if (context.method !== \x22return\x22) {\x0a        context.method = \x22next\x22;\x0a        context.arg = undefined;\x0a      }\x0a\x0a    } else {\x0a      // Re-yield the result returned by the delegate method.\x0a      return info;\x0a    }\x0a\x0a    // The delegate iterator is finished, so forget it and continue with\x0a    // the outer generator.\x0a    context.delegate = null;\x0a    return ContinueSentinel;\x0a  }\x0a\x0a  // Define Generator.prototype.{next,throw,return} in terms of the\x0a  // unified ._invoke helper method.\x0a  defineIteratorMethods(Gp);\x0a\x0a  Gp[toStringTagSymbol] = \x22Generator\x22;\x0a\x0a  // A Generator should always return itself as the iterator object when the\x0a  // @@iterator function is called on it. Some browsers\x27 implementations of the\x0a  // iterator prototype chain incorrectly implement this, causing the Generator\x0a  // object to not be returned from this call. This ensures that doesn\x27t happen.\x0a  // See https://github.com/facebook/regenerator/issues/274 for more details.\x0a  Gp[iteratorSymbol] = function() {\x0a    return this;\x0a  };\x0a\x0a  Gp.toString = function() {\x0a    return \x22[object Generator]\x22;\x0a  };\x0a\x0a  function pushTryEntry(locs) {\x0a    var entry = { tryLoc: locs[0] };\x0a\x0a    if (1 in locs) {\x0a      entry.catchLoc = locs[1];\x0a    }\x0a\x0a    if (2 in locs) {\x0a      entry.finallyLoc = locs[2];\x0a      entry.afterLoc = locs[3];\x0a    }\x0a\x0a    this.tryEntries.push(entry);\x0a  }\x0a\x0a  function resetTryEntry(entry) {\x0a    var record = entry.completion || {};\x0a    record.type = \x22normal\x22;\x0a    delete record.arg;\x0a    entry.completion = record;\x0a  }\x0a\x0a  function Context(tryLocsList) {\x0a    // The root entry object (effectively a try statement without a catch\x0a    // or a finally block) gives us a place to store values thrown from\x0a    // locations where there is no enclosing try statement.\x0a    this.tryEntries = [{ tryLoc: \x22root\x22 }];\x0a    tryLocsList.forEach(pushTryEntry, this);\x0a    this.reset(true);\x0a  }\x0a\x0a  runtime.keys = function(object) {\x0a    var keys = [];\x0a    for (var key in object) {\x0a      keys.push(key);\x0a    }\x0a    keys.reverse();\x0a\x0a    // Rather than returning an object with a next method, we keep\x0a    // things simple and return the next function itself.\x0a    return function next() {\x0a      while (keys.length) {\x0a        var key = keys.pop();\x0a        if (key in object) {\x0a          next.value = key;\x0a          next.done = false;\x0a          return next;\x0a        }\x0a      }\x0a\x0a      // To avoid creating an additional object, we just hang the .value\x0a      // and .done properties off the next function object itself. This\x0a      // also ensures that the minifier will not anonymize the function.\x0a      next.done = true;\x0a      return next;\x0a    };\x0a  };\x0a\x0a  function values(iterable) {\x0a    if (iterable) {\x0a      var iteratorMethod = iterable[iteratorSymbol];\x0a      if (iteratorMethod) {\x0a        return iteratorMethod.call(iterable);\x0a      }\x0a\x0a      if (typeof iterable.next === \x22function\x22) {\x0a        return iterable;\x0a      }\x0a\x0a      if (!isNaN(iterable.length)) {\x0a        var i = -1, next = function next() {\x0a          while (++i \x3c iterable.length) {\x0a            if (hasOwn.call(iterable, i)) {\x0a              next.value = iterable[i];\x0a              next.done = false;\x0a              return next;\x0a            }\x0a          }\x0a\x0a          next.value = undefined;\x0a          next.done = true;\x0a\x0a          return next;\x0a        };\x0a\x0a        return next.next = next;\x0a      }\x0a    }\x0a\x0a    // Return an iterator with no values.\x0a    return { next: doneResult };\x0a  }\x0a  runtime.values = values;\x0a\x0a  function doneResult() {\x0a    return { value: undefined, done: true };\x0a  }\x0a\x0a  Context.prototype = {\x0a    constructor: Context,\x0a\x0a    reset: function(skipTempReset) {\x0a      this.prev = 0;\x0a      this.next = 0;\x0a      // Resetting context._sent for legacy support of Babel\x27s\x0a      // function.sent implementation.\x0a      this.sent = this._sent = undefined;\x0a      this.done = false;\x0a      this.delegate = null;\x0a\x0a      this.method = \x22next\x22;\x0a      this.arg = undefined;\x0a\x0a      this.tryEntries.forEach(resetTryEntry);\x0a\x0a      if (!skipTempReset) {\x0a        for (var name in this) {\x0a          // Not sure about the optimal order of these conditions:\x0a          if (name.charAt(0) === \x22t\x22 &&\x0a              hasOwn.call(this, name) &&\x0a              !isNaN(+name.slice(1))) {\x0a            this[name] = undefined;\x0a          }\x0a        }\x0a      }\x0a    },\x0a\x0a    stop: function() {\x0a      this.done = true;\x0a\x0a      var rootEntry = this.tryEntries[0];\x0a      var rootRecord = rootEntry.completion;\x0a      if (rootRecord.type === \x22throw\x22) {\x0a        throw rootRecord.arg;\x0a      }\x0a\x0a      return this.rval;\x0a    },\x0a\x0a    dispatchException: function(exception) {\x0a      if (this.done) {\x0a        throw exception;\x0a      }\x0a\x0a      var context = this;\x0a      function handle(loc, caught) {\x0a        record.type = \x22throw\x22;\x0a        record.arg = exception;\x0a        context.next = loc;\x0a\x0a        if (caught) {\x0a          // If the dispatched exception was caught by a catch block,\x0a          // then let that catch block handle the exception normally.\x0a          context.method = \x22next\x22;\x0a          context.arg = undefined;\x0a        }\x0a\x0a        return !! caught;\x0a      }\x0a\x0a      for (var i = this.tryEntries.length - 1; i \x3e= 0; --i) {\x0a        var entry = this.tryEntries[i];\x0a        var record = entry.completion;\x0a\x0a        if (entry.tryLoc === \x22root\x22) {\x0a          // Exception thrown outside of any try block that could handle\x0a          // it, so set the completion value of the entire function to\x0a          // throw the exception.\x0a          return handle(\x22end\x22);\x0a        }\x0a\x0a        if (entry.tryLoc \x3c= this.prev) {\x0a          var hasCatch = hasOwn.call(entry, \x22catchLoc\x22);\x0a          var hasFinally = hasOwn.call(entry, \x22finallyLoc\x22);\x0a\x0a          if (hasCatch && hasFinally) {\x0a            if (this.prev \x3c entry.catchLoc) {\x0a              return handle(entry.catchLoc, true);\x0a            } else if (this.prev \x3c entry.finallyLoc) {\x0a              return handle(entry.finallyLoc);\x0a            }\x0a\x0a          } else if (hasCatch) {\x0a            if (this.prev \x3c entry.catchLoc) {\x0a              return handle(entry.catchLoc, true);\x0a            }\x0a\x0a          } else if (hasFinally) {\x0a            if (this.prev \x3c entry.finallyLoc) {\x0a              return handle(entry.finallyLoc);\x0a            }\x0a\x0a          } else {\x0a            throw new Error(\x22try statement without catch or finally\x22);\x0a          }\x0a        }\x0a      }\x0a    },\x0a\x0a    abrupt: function(type, arg) {\x0a      for (var i = this.tryEntries.length - 1; i \x3e= 0; --i) {\x0a        var entry = this.tryEntries[i];\x0a        if (entry.tryLoc \x3c= this.prev &&\x0a            hasOwn.call(entry, \x22finallyLoc\x22) &&\x0a            this.prev \x3c entry.finallyLoc) {\x0a          var finallyEntry = entry;\x0a          break;\x0a        }\x0a      }\x0a\x0a      if (finallyEntry &&\x0a          (type === \x22break\x22 ||\x0a           type === \x22continue\x22) &&\x0a          finallyEntry.tryLoc \x3c= arg &&\x0a          arg \x3c= finallyEntry.finallyLoc) {\x0a        // Ignore the finally entry if control is not jumping to a\x0a        // location outside the try/catch block.\x0a        finallyEntry = null;\x0a      }\x0a\x0a      var record = finallyEntry ? finallyEntry.completion : {};\x0a      record.type = type;\x0a      record.arg = arg;\x0a\x0a      if (finallyEntry) {\x0a        this.method = \x22next\x22;\x0a        this.next = finallyEntry.finallyLoc;\x0a        return ContinueSentinel;\x0a      }\x0a\x0a      return this.complete(record);\x0a    },\x0a\x0a    complete: function(record, afterLoc) {\x0a      if (record.type === \x22throw\x22) {\x0a        throw record.arg;\x0a      }\x0a\x0a      if (record.type === \x22break\x22 ||\x0a          record.type === \x22continue\x22) {\x0a        this.next = record.arg;\x0a      } else if (record.type === \x22return\x22) {\x0a        this.rval = this.arg = record.arg;\x0a        this.method = \x22return\x22;\x0a        this.next = \x22end\x22;\x0a      } else if (record.type === \x22normal\x22 && afterLoc) {\x0a        this.next = afterLoc;\x0a      }\x0a\x0a      return ContinueSentinel;\x0a    },\x0a\x0a    finish: function(finallyLoc) {\x0a      for (var i = this.tryEntries.length - 1; i \x3e= 0; --i) {\x0a        var entry = this.tryEntries[i];\x0a        if (entry.finallyLoc === finallyLoc) {\x0a          this.complete(entry.completion, entry.afterLoc);\x0a          resetTryEntry(entry);\x0a          return ContinueSentinel;\x0a        }\x0a      }\x0a    },\x0a\x0a    \x22catch\x22: function(tryLoc) {\x0a      for (var i = this.tryEntries.length - 1; i \x3e= 0; --i) {\x0a        var entry = this.tryEntries[i];\x0a        if (entry.tryLoc === tryLoc) {\x0a          var record = entry.completion;\x0a          if (record.type === \x22throw\x22) {\x0a            var thrown = record.arg;\x0a            resetTryEntry(entry);\x0a          }\x0a          return thrown;\x0a        }\x0a      }\x0a\x0a      // The context.catch method must only be called with a location\x0a      // argument that corresponds to a known catch block.\x0a      throw new Error(\x22illegal catch attempt\x22);\x0a    },\x0a\x0a    delegateYield: function(iterable, resultName, nextLoc) {\x0a      this.delegate = {\x0a        iterator: values(iterable),\x0a        resultName: resultName,\x0a        nextLoc: nextLoc\x0a      };\x0a\x0a      if (this.method === \x22next\x22) {\x0a        // Deliberately forget the last sent value so that we don\x27t\x0a        // accidentally pass it on to the delegate.\x0a        this.arg = undefined;\x0a      }\x0a\x0a      return ContinueSentinel;\x0a    }\x0a  };\x0a})(\x0a  // In sloppy mode, unbound `this` refers to the global object, fallback to\x0a  // Function constructor if we\x27re in global strict mode. That is sadly a form\x0a  // of indirect eval which violates Content Security Policy.\x0a  (function() {\x0a    return this || (typeof self === \x22object\x22 && self);\x0a  })() || Function(\x22return this\x22)()\x0a);\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 59:\x0a/***/ (function(module, exports) {\x0a\x0avar g;\x0a\x0a// This works in non-strict mode\x0ag = (function() {\x0a\x09return this;\x0a})();\x0a\x0atry {\x0a\x09// This works if eval is allowed (see CSP)\x0a\x09g = g || new Function(\x22return this\x22)();\x0a} catch (e) {\x0a\x09// This works if the window reference is available\x0a\x09if (typeof window === \x22object\x22) g = window;\x0a}\x0a\x0a// g can still be undefined, but nothing to do about it...\x0a// We return undefined, instead of nothing here, so it\x27s\x0a// easier to handle this case. if(!global) { ...}\x0a\x0amodule.exports = g;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 7:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _objectSpread; });\x0a/* harmony import */ var _defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);\x0a\x0afunction _objectSpread(target) {\x0a  for (var i = 1; i \x3c arguments.length; i++) {\x0a    var source = arguments[i] != null ? arguments[i] : {};\x0a    var ownKeys = Object.keys(source);\x0a\x0a    if (typeof Object.getOwnPropertySymbols === \x27function\x27) {\x0a      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\x0a        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\x0a      }));\x0a    }\x0a\x0a    ownKeys.forEach(function (key) {\x0a      Object(_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22])(target, key, source[key]);\x0a    });\x0a  }\x0a\x0a  return target;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 71:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22c\x22, function() { return createStore; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22b\x22, function() { return combineReducers; });\x0a/* unused harmony export bindActionCreators */\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return applyMiddleware; });\x0a/* unused harmony export compose */\x0a/* unused harmony export __DO_NOT_USE__ActionTypes */\x0a/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);\x0a\x0a\x0a/**\x0a * These are private action types reserved by Redux.\x0a * For any unknown actions, you must return the current state.\x0a * If the current state is undefined, you must return the initial state.\x0a * Do not reference these action types directly in your code.\x0a */\x0avar randomString = function randomString() {\x0a  return Math.random().toString(36).substring(7).split(\x27\x27).join(\x27.\x27);\x0a};\x0a\x0avar ActionTypes = {\x0a  INIT: \x22@@redux/INIT\x22 + randomString(),\x0a  REPLACE: \x22@@redux/REPLACE\x22 + randomString(),\x0a  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\x0a    return \x22@@redux/PROBE_UNKNOWN_ACTION\x22 + randomString();\x0a  }\x0a};\x0a\x0a/**\x0a * @param {any} obj The object to inspect.\x0a * @returns {boolean} True if the argument appears to be a plain object.\x0a */\x0afunction isPlainObject(obj) {\x0a  if (typeof obj !== \x27object\x27 || obj === null) return false;\x0a  var proto = obj;\x0a\x0a  while (Object.getPrototypeOf(proto) !== null) {\x0a    proto = Object.getPrototypeOf(proto);\x0a  }\x0a\x0a  return Object.getPrototypeOf(obj) === proto;\x0a}\x0a\x0a/**\x0a * Creates a Redux store that holds the state tree.\x0a * The only way to change the data in the store is to call `dispatch()` on it.\x0a *\x0a * There should only be a single store in your app. To specify how different\x0a * parts of the state tree respond to actions, you may combine several reducers\x0a * into a single reducer function by using `combineReducers`.\x0a *\x0a * @param {Function} reducer A function that returns the next state tree, given\x0a * the current state tree and the action to handle.\x0a *\x0a * @param {any} [preloadedState] The initial state. You may optionally specify it\x0a * to hydrate the state from the server in universal apps, or to restore a\x0a * previously serialized user session.\x0a * If you use `combineReducers` to produce the root reducer function, this must be\x0a * an object with the same shape as `combineReducers` keys.\x0a *\x0a * @param {Function} [enhancer] The store enhancer. You may optionally specify it\x0a * to enhance the store with third-party capabilities such as middleware,\x0a * time travel, persistence, etc. The only store enhancer that ships with Redux\x0a * is `applyMiddleware()`.\x0a *\x0a * @returns {Store} A Redux store that lets you read the state, dispatch actions\x0a * and subscribe to changes.\x0a */\x0a\x0afunction createStore(reducer, preloadedState, enhancer) {\x0a  var _ref2;\x0a\x0a  if (typeof preloadedState === \x27function\x27 && typeof enhancer === \x27function\x27 || typeof enhancer === \x27function\x27 && typeof arguments[3] === \x27function\x27) {\x0a    throw new Error(\x27It looks like you are passing several store enhancers to \x27 + \x27createStore(). This is not supported. Instead, compose them \x27 + \x27together to a single function\x27);\x0a  }\x0a\x0a  if (typeof preloadedState === \x27function\x27 && typeof enhancer === \x27undefined\x27) {\x0a    enhancer = preloadedState;\x0a    preloadedState = undefined;\x0a  }\x0a\x0a  if (typeof enhancer !== \x27undefined\x27) {\x0a    if (typeof enhancer !== \x27function\x27) {\x0a      throw new Error(\x27Expected the enhancer to be a function.\x27);\x0a    }\x0a\x0a    return enhancer(createStore)(reducer, preloadedState);\x0a  }\x0a\x0a  if (typeof reducer !== \x27function\x27) {\x0a    throw new Error(\x27Expected the reducer to be a function.\x27);\x0a  }\x0a\x0a  var currentReducer = reducer;\x0a  var currentState = preloadedState;\x0a  var currentListeners = [];\x0a  var nextListeners = currentListeners;\x0a  var isDispatching = false;\x0a\x0a  function ensureCanMutateNextListeners() {\x0a    if (nextListeners === currentListeners) {\x0a      nextListeners = currentListeners.slice();\x0a    }\x0a  }\x0a  /**\x0a   * Reads the state tree managed by the store.\x0a   *\x0a   * @returns {any} The current state tree of your application.\x0a   */\x0a\x0a\x0a  function getState() {\x0a    if (isDispatching) {\x0a      throw new Error(\x27You may not call store.getState() while the reducer is executing. \x27 + \x27The reducer has already received the state as an argument. \x27 + \x27Pass it down from the top reducer instead of reading it from the store.\x27);\x0a    }\x0a\x0a    return currentState;\x0a  }\x0a  /**\x0a   * Adds a change listener. It will be called any time an action is dispatched,\x0a   * and some part of the state tree may potentially have changed. You may then\x0a   * call `getState()` to read the current state tree inside the callback.\x0a   *\x0a   * You may call `dispatch()` from a change listener, with the following\x0a   * caveats:\x0a   *\x0a   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\x0a   * If you subscribe or unsubscribe while the listeners are being invoked, this\x0a   * will not have any effect on the `dispatch()` that is currently in progress.\x0a   * However, the next `dispatch()` call, whether nested or not, will use a more\x0a   * recent snapshot of the subscription list.\x0a   *\x0a   * 2. The listener should not expect to see all state changes, as the state\x0a   * might have been updated multiple times during a nested `dispatch()` before\x0a   * the listener is called. It is, however, guaranteed that all subscribers\x0a   * registered before the `dispatch()` started will be called with the latest\x0a   * state by the time it exits.\x0a   *\x0a   * @param {Function} listener A callback to be invoked on every dispatch.\x0a   * @returns {Function} A function to remove this change listener.\x0a   */\x0a\x0a\x0a  function subscribe(listener) {\x0a    if (typeof listener !== \x27function\x27) {\x0a      throw new Error(\x27Expected the listener to be a function.\x27);\x0a    }\x0a\x0a    if (isDispatching) {\x0a      throw new Error(\x27You may not call store.subscribe() while the reducer is executing. \x27 + \x27If you would like to be notified after the store has been updated, subscribe from a \x27 + \x27component and invoke store.getState() in the callback to access the latest state. \x27 + \x27See https://redux.js.org/api-reference/store#subscribe(listener) for more details.\x27);\x0a    }\x0a\x0a    var isSubscribed = true;\x0a    ensureCanMutateNextListeners();\x0a    nextListeners.push(listener);\x0a    return function unsubscribe() {\x0a      if (!isSubscribed) {\x0a        return;\x0a      }\x0a\x0a      if (isDispatching) {\x0a        throw new Error(\x27You may not unsubscribe from a store listener while the reducer is executing. \x27 + \x27See https://redux.js.org/api-reference/store#subscribe(listener) for more details.\x27);\x0a      }\x0a\x0a      isSubscribed = false;\x0a      ensureCanMutateNextListeners();\x0a      var index = nextListeners.indexOf(listener);\x0a      nextListeners.splice(index, 1);\x0a    };\x0a  }\x0a  /**\x0a   * Dispatches an action. It is the only way to trigger a state change.\x0a   *\x0a   * The `reducer` function, used to create the store, will be called with the\x0a   * current state tree and the given `action`. Its return value will\x0a   * be considered the **next** state of the tree, and the change listeners\x0a   * will be notified.\x0a   *\x0a   * The base implementation only supports plain object actions. If you want to\x0a   * dispatch a Promise, an Observable, a thunk, or something else, you need to\x0a   * wrap your store creating function into the corresponding middleware. For\x0a   * example, see the documentation for the `redux-thunk` package. Even the\x0a   * middleware will eventually dispatch plain object actions using this method.\x0a   *\x0a   * @param {Object} action A plain object representing \xe2\x80\x9cwhat changed\xe2\x80\x9d. It is\x0a   * a good idea to keep actions serializable so you can record and replay user\x0a   * sessions, or use the time travelling `redux-devtools`. An action must have\x0a   * a `type` property which may not be `undefined`. It is a good idea to use\x0a   * string constants for action types.\x0a   *\x0a   * @returns {Object} For convenience, the same action object you dispatched.\x0a   *\x0a   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\x0a   * return something else (for example, a Promise you can await).\x0a   */\x0a\x0a\x0a  function dispatch(action) {\x0a    if (!isPlainObject(action)) {\x0a      throw new Error(\x27Actions must be plain objects. \x27 + \x27Use custom middleware for async actions.\x27);\x0a    }\x0a\x0a    if (typeof action.type === \x27undefined\x27) {\x0a      throw new Error(\x27Actions may not have an undefined \x22type\x22 property. \x27 + \x27Have you misspelled a constant?\x27);\x0a    }\x0a\x0a    if (isDispatching) {\x0a      throw new Error(\x27Reducers may not dispatch actions.\x27);\x0a    }\x0a\x0a    try {\x0a      isDispatching = true;\x0a      currentState = currentReducer(currentState, action);\x0a    } finally {\x0a      isDispatching = false;\x0a    }\x0a\x0a    var listeners = currentListeners = nextListeners;\x0a\x0a    for (var i = 0; i \x3c listeners.length; i++) {\x0a      var listener = listeners[i];\x0a      listener();\x0a    }\x0a\x0a    return action;\x0a  }\x0a  /**\x0a   * Replaces the reducer currently used by the store to calculate the state.\x0a   *\x0a   * You might need this if your app implements code splitting and you want to\x0a   * load some of the reducers dynamically. You might also need this if you\x0a   * implement a hot reloading mechanism for Redux.\x0a   *\x0a   * @param {Function} nextReducer The reducer for the store to use instead.\x0a   * @returns {void}\x0a   */\x0a\x0a\x0a  function replaceReducer(nextReducer) {\x0a    if (typeof nextReducer !== \x27function\x27) {\x0a      throw new Error(\x27Expected the nextReducer to be a function.\x27);\x0a    }\x0a\x0a    currentReducer = nextReducer;\x0a    dispatch({\x0a      type: ActionTypes.REPLACE\x0a    });\x0a  }\x0a  /**\x0a   * Interoperability point for observable/reactive libraries.\x0a   * @returns {observable} A minimal observable of state changes.\x0a   * For more information, see the observable proposal:\x0a   * https://github.com/tc39/proposal-observable\x0a   */\x0a\x0a\x0a  function observable() {\x0a    var _ref;\x0a\x0a    var outerSubscribe = subscribe;\x0a    return _ref = {\x0a      /**\x0a       * The minimal observable subscription method.\x0a       * @param {Object} observer Any object that can be used as an observer.\x0a       * The observer object should have a `next` method.\x0a       * @returns {subscription} An object with an `unsubscribe` method that can\x0a       * be used to unsubscribe the observable from the store, and prevent further\x0a       * emission of values from the observable.\x0a       */\x0a      subscribe: function subscribe(observer) {\x0a        if (typeof observer !== \x27object\x27 || observer === null) {\x0a          throw new TypeError(\x27Expected the observer to be an object.\x27);\x0a        }\x0a\x0a        function observeState() {\x0a          if (observer.next) {\x0a            observer.next(getState());\x0a          }\x0a        }\x0a\x0a        observeState();\x0a        var unsubscribe = outerSubscribe(observeState);\x0a        return {\x0a          unsubscribe: unsubscribe\x0a        };\x0a      }\x0a    }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22]] = function () {\x0a      return this;\x0a    }, _ref;\x0a  } // When a store is created, an \x22INIT\x22 action is dispatched so that every\x0a  // reducer returns their initial state. This effectively populates\x0a  // the initial state tree.\x0a\x0a\x0a  dispatch({\x0a    type: ActionTypes.INIT\x0a  });\x0a  return _ref2 = {\x0a    dispatch: dispatch,\x0a    subscribe: subscribe,\x0a    getState: getState,\x0a    replaceReducer: replaceReducer\x0a  }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22]] = observable, _ref2;\x0a}\x0a\x0a/**\x0a * Prints a warning in the console if it exists.\x0a *\x0a * @param {String} message The warning message.\x0a * @returns {void}\x0a */\x0afunction warning(message) {\x0a  /* eslint-disable no-console */\x0a  if (typeof console !== \x27undefined\x27 && typeof console.error === \x27function\x27) {\x0a    console.error(message);\x0a  }\x0a  /* eslint-enable no-console */\x0a\x0a\x0a  try {\x0a    // This error was thrown as a convenience so that if you enable\x0a    // \x22break on all exceptions\x22 in your console,\x0a    // it would pause the execution at this line.\x0a    throw new Error(message);\x0a  } catch (e) {} // eslint-disable-line no-empty\x0a\x0a}\x0a\x0afunction getUndefinedStateErrorMessage(key, action) {\x0a  var actionType = action && action.type;\x0a  var actionDescription = actionType && \x22action \x5c\x22\x22 + String(actionType) + \x22\x5c\x22\x22 || \x27an action\x27;\x0a  return \x22Given \x22 + actionDescription + \x22, reducer \x5c\x22\x22 + key + \x22\x5c\x22 returned undefined. \x22 + \x22To ignore an action, you must explicitly return the previous state. \x22 + \x22If you want this reducer to hold no value, you can return null instead of undefined.\x22;\x0a}\x0a\x0afunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\x0a  var reducerKeys = Object.keys(reducers);\x0a  var argumentName = action && action.type === ActionTypes.INIT ? \x27preloadedState argument passed to createStore\x27 : \x27previous state received by the reducer\x27;\x0a\x0a  if (reducerKeys.length === 0) {\x0a    return \x27Store does not have a valid reducer. Make sure the argument passed \x27 + \x27to combineReducers is an object whose values are reducers.\x27;\x0a  }\x0a\x0a  if (!isPlainObject(inputState)) {\x0a    return \x22The \x22 + argumentName + \x22 has unexpected type of \x5c\x22\x22 + {}.toString.call(inputState).match(/\x5cs([a-z|A-Z]+)/)[1] + \x22\x5c\x22. Expected argument to be an object with the following \x22 + (\x22keys: \x5c\x22\x22 + reducerKeys.join(\x27\x22, \x22\x27) + \x22\x5c\x22\x22);\x0a  }\x0a\x0a  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\x0a    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\x0a  });\x0a  unexpectedKeys.forEach(function (key) {\x0a    unexpectedKeyCache[key] = true;\x0a  });\x0a  if (action && action.type === ActionTypes.REPLACE) return;\x0a\x0a  if (unexpectedKeys.length \x3e 0) {\x0a    return \x22Unexpected \x22 + (unexpectedKeys.length \x3e 1 ? \x27keys\x27 : \x27key\x27) + \x22 \x22 + (\x22\x5c\x22\x22 + unexpectedKeys.join(\x27\x22, \x22\x27) + \x22\x5c\x22 found in \x22 + argumentName + \x22. \x22) + \x22Expected to find one of the known reducer keys instead: \x22 + (\x22\x5c\x22\x22 + reducerKeys.join(\x27\x22, \x22\x27) + \x22\x5c\x22. Unexpected keys will be ignored.\x22);\x0a  }\x0a}\x0a\x0afunction assertReducerShape(reducers) {\x0a  Object.keys(reducers).forEach(function (key) {\x0a    var reducer = reducers[key];\x0a    var initialState = reducer(undefined, {\x0a      type: ActionTypes.INIT\x0a    });\x0a\x0a    if (typeof initialState === \x27undefined\x27) {\x0a      throw new Error(\x22Reducer \x5c\x22\x22 + key + \x22\x5c\x22 returned undefined during initialization. \x22 + \x22If the state passed to the reducer is undefined, you must \x22 + \x22explicitly return the initial state. The initial state may \x22 + \x22not be undefined. If you don\x27t want to set a value for this reducer, \x22 + \x22you can use null instead of undefined.\x22);\x0a    }\x0a\x0a    if (typeof reducer(undefined, {\x0a      type: ActionTypes.PROBE_UNKNOWN_ACTION()\x0a    }) === \x27undefined\x27) {\x0a      throw new Error(\x22Reducer \x5c\x22\x22 + key + \x22\x5c\x22 returned undefined when probed with a random type. \x22 + (\x22Don\x27t try to handle \x22 + ActionTypes.INIT + \x22 or other actions in \x5c\x22redux/*\x5c\x22 \x22) + \x22namespace. They are considered private. Instead, you must return the \x22 + \x22current state for any unknown actions, unless it is undefined, \x22 + \x22in which case you must return the initial state, regardless of the \x22 + \x22action type. The initial state may not be undefined, but can be null.\x22);\x0a    }\x0a  });\x0a}\x0a/**\x0a * Turns an object whose values are different reducer functions, into a single\x0a * reducer function. It will call every child reducer, and gather their results\x0a * into a single state object, whose keys correspond to the keys of the passed\x0a * reducer functions.\x0a *\x0a * @param {Object} reducers An object whose values correspond to different\x0a * reducer functions that need to be combined into one. One handy way to obtain\x0a * it is to use ES6 `import * as reducers` syntax. The reducers may never return\x0a * undefined for any action. Instead, they should return their initial state\x0a * if the state passed to them was undefined, and the current state for any\x0a * unrecognized action.\x0a *\x0a * @returns {Function} A reducer function that invokes every reducer inside the\x0a * passed object, and builds a state object with the same shape.\x0a */\x0a\x0a\x0afunction combineReducers(reducers) {\x0a  var reducerKeys = Object.keys(reducers);\x0a  var finalReducers = {};\x0a\x0a  for (var i = 0; i \x3c reducerKeys.length; i++) {\x0a    var key = reducerKeys[i];\x0a\x0a    if (false) {}\x0a\x0a    if (typeof reducers[key] === \x27function\x27) {\x0a      finalReducers[key] = reducers[key];\x0a    }\x0a  }\x0a\x0a  var finalReducerKeys = Object.keys(finalReducers);\x0a  var unexpectedKeyCache;\x0a\x0a  if (false) {}\x0a\x0a  var shapeAssertionError;\x0a\x0a  try {\x0a    assertReducerShape(finalReducers);\x0a  } catch (e) {\x0a    shapeAssertionError = e;\x0a  }\x0a\x0a  return function combination(state, action) {\x0a    if (state === void 0) {\x0a      state = {};\x0a    }\x0a\x0a    if (shapeAssertionError) {\x0a      throw shapeAssertionError;\x0a    }\x0a\x0a    if (false) { var warningMessage; }\x0a\x0a    var hasChanged = false;\x0a    var nextState = {};\x0a\x0a    for (var _i = 0; _i \x3c finalReducerKeys.length; _i++) {\x0a      var _key = finalReducerKeys[_i];\x0a      var reducer = finalReducers[_key];\x0a      var previousStateForKey = state[_key];\x0a      var nextStateForKey = reducer(previousStateForKey, action);\x0a\x0a      if (typeof nextStateForKey === \x27undefined\x27) {\x0a        var errorMessage = getUndefinedStateErrorMessage(_key, action);\x0a        throw new Error(errorMessage);\x0a      }\x0a\x0a      nextState[_key] = nextStateForKey;\x0a      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\x0a    }\x0a\x0a    return hasChanged ? nextState : state;\x0a  };\x0a}\x0a\x0afunction bindActionCreator(actionCreator, dispatch) {\x0a  return function () {\x0a    return dispatch(actionCreator.apply(this, arguments));\x0a  };\x0a}\x0a/**\x0a * Turns an object whose values are action creators, into an object with the\x0a * same keys, but with every function wrapped into a `dispatch` call so they\x0a * may be invoked directly. This is just a convenience method, as you can call\x0a * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\x0a *\x0a * For convenience, you can also pass a single function as the first argument,\x0a * and get a function in return.\x0a *\x0a * @param {Function|Object} actionCreators An object whose values are action\x0a * creator functions. One handy way to obtain it is to use ES6 `import * as`\x0a * syntax. You may also pass a single function.\x0a *\x0a * @param {Function} dispatch The `dispatch` function available on your Redux\x0a * store.\x0a *\x0a * @returns {Function|Object} The object mimicking the original object, but with\x0a * every action creator wrapped into the `dispatch` call. If you passed a\x0a * function as `actionCreators`, the return value will also be a single\x0a * function.\x0a */\x0a\x0a\x0afunction bindActionCreators(actionCreators, dispatch) {\x0a  if (typeof actionCreators === \x27function\x27) {\x0a    return bindActionCreator(actionCreators, dispatch);\x0a  }\x0a\x0a  if (typeof actionCreators !== \x27object\x27 || actionCreators === null) {\x0a    throw new Error(\x22bindActionCreators expected an object or a function, instead received \x22 + (actionCreators === null ? \x27null\x27 : typeof actionCreators) + \x22. \x22 + \x22Did you write \x5c\x22import ActionCreators from\x5c\x22 instead of \x5c\x22import * as ActionCreators from\x5c\x22?\x22);\x0a  }\x0a\x0a  var keys = Object.keys(actionCreators);\x0a  var boundActionCreators = {};\x0a\x0a  for (var i = 0; i \x3c keys.length; i++) {\x0a    var key = keys[i];\x0a    var actionCreator = actionCreators[key];\x0a\x0a    if (typeof actionCreator === \x27function\x27) {\x0a      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\x0a    }\x0a  }\x0a\x0a  return boundActionCreators;\x0a}\x0a\x0afunction _defineProperty(obj, key, value) {\x0a  if (key in obj) {\x0a    Object.defineProperty(obj, key, {\x0a      value: value,\x0a      enumerable: true,\x0a      configurable: true,\x0a      writable: true\x0a    });\x0a  } else {\x0a    obj[key] = value;\x0a  }\x0a\x0a  return obj;\x0a}\x0a\x0afunction _objectSpread(target) {\x0a  for (var i = 1; i \x3c arguments.length; i++) {\x0a    var source = arguments[i] != null ? arguments[i] : {};\x0a    var ownKeys = Object.keys(source);\x0a\x0a    if (typeof Object.getOwnPropertySymbols === \x27function\x27) {\x0a      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\x0a        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\x0a      }));\x0a    }\x0a\x0a    ownKeys.forEach(function (key) {\x0a      _defineProperty(target, key, source[key]);\x0a    });\x0a  }\x0a\x0a  return target;\x0a}\x0a\x0a/**\x0a * Composes single-argument functions from right to left. The rightmost\x0a * function can take multiple arguments as it provides the signature for\x0a * the resulting composite function.\x0a *\x0a * @param {...Function} funcs The functions to compose.\x0a * @returns {Function} A function obtained by composing the argument functions\x0a * from right to left. For example, compose(f, g, h) is identical to doing\x0a * (...args) =\x3e f(g(h(...args))).\x0a */\x0afunction compose() {\x0a  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key \x3c _len; _key++) {\x0a    funcs[_key] = arguments[_key];\x0a  }\x0a\x0a  if (funcs.length === 0) {\x0a    return function (arg) {\x0a      return arg;\x0a    };\x0a  }\x0a\x0a  if (funcs.length === 1) {\x0a    return funcs[0];\x0a  }\x0a\x0a  return funcs.reduce(function (a, b) {\x0a    return function () {\x0a      return a(b.apply(void 0, arguments));\x0a    };\x0a  });\x0a}\x0a\x0a/**\x0a * Creates a store enhancer that applies middleware to the dispatch method\x0a * of the Redux store. This is handy for a variety of tasks, such as expressing\x0a * asynchronous actions in a concise manner, or logging every action payload.\x0a *\x0a * See `redux-thunk` package as an example of the Redux middleware.\x0a *\x0a * Because middleware is potentially asynchronous, this should be the first\x0a * store enhancer in the composition chain.\x0a *\x0a * Note that each middleware will be given the `dispatch` and `getState` functions\x0a * as named arguments.\x0a *\x0a * @param {...Function} middlewares The middleware chain to be applied.\x0a * @returns {Function} A store enhancer applying the middleware.\x0a */\x0a\x0afunction applyMiddleware() {\x0a  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key \x3c _len; _key++) {\x0a    middlewares[_key] = arguments[_key];\x0a  }\x0a\x0a  return function (createStore) {\x0a    return function () {\x0a      var store = createStore.apply(void 0, arguments);\x0a\x0a      var _dispatch = function dispatch() {\x0a        throw new Error(\x22Dispatching while constructing your middleware is not allowed. \x22 + \x22Other middleware would not be applied to this dispatch.\x22);\x0a      };\x0a\x0a      var middlewareAPI = {\x0a        getState: store.getState,\x0a        dispatch: function dispatch() {\x0a          return _dispatch.apply(void 0, arguments);\x0a        }\x0a      };\x0a      var chain = middlewares.map(function (middleware) {\x0a        return middleware(middlewareAPI);\x0a      });\x0a      _dispatch = compose.apply(void 0, chain)(store.dispatch);\x0a      return _objectSpread({}, store, {\x0a        dispatch: _dispatch\x0a      });\x0a    };\x0a  };\x0a}\x0a\x0a/*\x0a * This is a dummy function to check if the function name has been altered by minification.\x0a * If the function has been minified and NODE_ENV !== \x27production\x27, warn the user.\x0a */\x0a\x0afunction isCrushed() {}\x0a\x0aif (false) {}\x0a\x0a\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 76:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0afunction _typeof(obj) {\x0a  if (typeof Symbol === \x22function\x22 && typeof Symbol.iterator === \x22symbol\x22) {\x0a    _typeof = function (obj) {\x0a      return typeof obj;\x0a    };\x0a  } else {\x0a    _typeof = function (obj) {\x0a      return obj && typeof Symbol === \x22function\x22 && obj.constructor === Symbol && obj !== Symbol.prototype ? \x22symbol\x22 : typeof obj;\x0a    };\x0a  }\x0a\x0a  return _typeof(obj);\x0a}\x0a\x0afunction _classCallCheck(instance, Constructor) {\x0a  if (!(instance instanceof Constructor)) {\x0a    throw new TypeError(\x22Cannot call a class as a function\x22);\x0a  }\x0a}\x0a\x0afunction _defineProperties(target, props) {\x0a  for (var i = 0; i \x3c props.length; i++) {\x0a    var descriptor = props[i];\x0a    descriptor.enumerable = descriptor.enumerable || false;\x0a    descriptor.configurable = true;\x0a    if (\x22value\x22 in descriptor) descriptor.writable = true;\x0a    Object.defineProperty(target, descriptor.key, descriptor);\x0a  }\x0a}\x0a\x0afunction _createClass(Constructor, protoProps, staticProps) {\x0a  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\x0a  if (staticProps) _defineProperties(Constructor, staticProps);\x0a  return Constructor;\x0a}\x0a\x0a/**\x0a * Given an instance of EquivalentKeyMap, returns its internal value pair tuple\x0a * for a key, if one exists. The tuple members consist of the last reference\x0a * value for the key (used in efficient subsequent lookups) and the value\x0a * assigned for the key at the leaf node.\x0a *\x0a * @param {EquivalentKeyMap} instance EquivalentKeyMap instance.\x0a * @param {*} key                     The key for which to return value pair.\x0a *\x0a * @return {?Array} Value pair, if exists.\x0a */\x0afunction getValuePair(instance, key) {\x0a  var _map = instance._map,\x0a      _arrayTreeMap = instance._arrayTreeMap,\x0a      _objectTreeMap = instance._objectTreeMap; // Map keeps a reference to the last object-like key used to set the\x0a  // value, which can be used to shortcut immediately to the value.\x0a\x0a  if (_map.has(key)) {\x0a    return _map.get(key);\x0a  } // Sort keys to ensure stable retrieval from tree.\x0a\x0a\x0a  var properties = Object.keys(key).sort(); // Tree by type to avoid conflicts on numeric object keys, empty value.\x0a\x0a  var map = Array.isArray(key) ? _arrayTreeMap : _objectTreeMap;\x0a\x0a  for (var i = 0; i \x3c properties.length; i++) {\x0a    var property = properties[i];\x0a    map = map.get(property);\x0a\x0a    if (map === undefined) {\x0a      return;\x0a    }\x0a\x0a    var propertyValue = key[property];\x0a    map = map.get(propertyValue);\x0a\x0a    if (map === undefined) {\x0a      return;\x0a    }\x0a  }\x0a\x0a  var valuePair = map.get(\x27_ekm_value\x27);\x0a\x0a  if (!valuePair) {\x0a    return;\x0a  } // If reached, it implies that an object-like key was set with another\x0a  // reference, so delete the reference and replace with the current.\x0a\x0a\x0a  _map.delete(valuePair[0]);\x0a\x0a  valuePair[0] = key;\x0a  map.set(\x27_ekm_value\x27, valuePair);\x0a\x0a  _map.set(key, valuePair);\x0a\x0a  return valuePair;\x0a}\x0a/**\x0a * Variant of a Map object which enables lookup by equivalent (deeply equal)\x0a * object and array keys.\x0a */\x0a\x0a\x0avar EquivalentKeyMap =\x0a/*#__PURE__*/\x0afunction () {\x0a  /**\x0a   * Constructs a new instance of EquivalentKeyMap.\x0a   *\x0a   * @param {Iterable.\x3c*\x3e} iterable Initial pair of key, value for map.\x0a   */\x0a  function EquivalentKeyMap(iterable) {\x0a    _classCallCheck(this, EquivalentKeyMap);\x0a\x0a    this.clear();\x0a\x0a    if (iterable instanceof EquivalentKeyMap) {\x0a      // Map#forEach is only means of iterating with support for IE11.\x0a      var iterablePairs = [];\x0a      iterable.forEach(function (value, key) {\x0a        iterablePairs.push([key, value]);\x0a      });\x0a      iterable = iterablePairs;\x0a    }\x0a\x0a    if (iterable != null) {\x0a      for (var i = 0; i \x3c iterable.length; i++) {\x0a        this.set(iterable[i][0], iterable[i][1]);\x0a      }\x0a    }\x0a  }\x0a  /**\x0a   * Accessor property returning the number of elements.\x0a   *\x0a   * @return {number} Number of elements.\x0a   */\x0a\x0a\x0a  _createClass(EquivalentKeyMap, [{\x0a    key: \x22set\x22,\x0a\x0a    /**\x0a     * Add or update an element with a specified key and value.\x0a     *\x0a     * @param {*} key   The key of the element to add.\x0a     * @param {*} value The value of the element to add.\x0a     *\x0a     * @return {EquivalentKeyMap} Map instance.\x0a     */\x0a    value: function set(key, value) {\x0a      // Shortcut non-object-like to set on internal Map.\x0a      if (key === null || _typeof(key) !== \x27object\x27) {\x0a        this._map.set(key, value);\x0a\x0a        return this;\x0a      } // Sort keys to ensure stable assignment into tree.\x0a\x0a\x0a      var properties = Object.keys(key).sort();\x0a      var valuePair = [key, value]; // Tree by type to avoid conflicts on numeric object keys, empty value.\x0a\x0a      var map = Array.isArray(key) ? this._arrayTreeMap : this._objectTreeMap;\x0a\x0a      for (var i = 0; i \x3c properties.length; i++) {\x0a        var property = properties[i];\x0a\x0a        if (!map.has(property)) {\x0a          map.set(property, new EquivalentKeyMap());\x0a        }\x0a\x0a        map = map.get(property);\x0a        var propertyValue = key[property];\x0a\x0a        if (!map.has(propertyValue)) {\x0a          map.set(propertyValue, new EquivalentKeyMap());\x0a        }\x0a\x0a        map = map.get(propertyValue);\x0a      } // If an _ekm_value exists, there was already an equivalent key. Before\x0a      // overriding, ensure that the old key reference is removed from map to\x0a      // avoid memory leak of accumulating equivalent keys. This is, in a\x0a      // sense, a poor man\x27s WeakMap, while still enabling iterability.\x0a\x0a\x0a      var previousValuePair = map.get(\x27_ekm_value\x27);\x0a\x0a      if (previousValuePair) {\x0a        this._map.delete(previousValuePair[0]);\x0a      }\x0a\x0a      map.set(\x27_ekm_value\x27, valuePair);\x0a\x0a      this._map.set(key, valuePair);\x0a\x0a      return this;\x0a    }\x0a    /**\x0a     * Returns a specified element.\x0a     *\x0a     * @param {*} key The key of the element to return.\x0a     *\x0a     * @return {?*} The element associated with the specified key or undefined\x0a     *              if the key can\x27t be found.\x0a     */\x0a\x0a  }, {\x0a    key: \x22get\x22,\x0a    value: function get(key) {\x0a      // Shortcut non-object-like to get from internal Map.\x0a      if (key === null || _typeof(key) !== \x27object\x27) {\x0a        return this._map.get(key);\x0a      }\x0a\x0a      var valuePair = getValuePair(this, key);\x0a\x0a      if (valuePair) {\x0a        return valuePair[1];\x0a      }\x0a    }\x0a    /**\x0a     * Returns a boolean indicating whether an element with the specified key\x0a     * exists or not.\x0a     *\x0a     * @param {*} key The key of the element to test for presence.\x0a     *\x0a     * @return {boolean} Whether an element with the specified key exists.\x0a     */\x0a\x0a  }, {\x0a    key: \x22has\x22,\x0a    value: function has(key) {\x0a      if (key === null || _typeof(key) !== \x27object\x27) {\x0a        return this._map.has(key);\x0a      } // Test on the _presence_ of the pair, not its value, as even undefined\x0a      // can be a valid member value for a key.\x0a\x0a\x0a      return getValuePair(this, key) !== undefined;\x0a    }\x0a    /**\x0a     * Removes the specified element.\x0a     *\x0a     * @param {*} key The key of the element to remove.\x0a     *\x0a     * @return {boolean} Returns true if an element existed and has been\x0a     *                   removed, or false if the element does not exist.\x0a     */\x0a\x0a  }, {\x0a    key: \x22delete\x22,\x0a    value: function _delete(key) {\x0a      if (!this.has(key)) {\x0a        return false;\x0a      } // This naive implementation will leave orphaned child trees. A better\x0a      // implementation should traverse and remove orphans.\x0a\x0a\x0a      this.set(key, undefined);\x0a      return true;\x0a    }\x0a    /**\x0a     * Executes a provided function once per each key/value pair, in insertion\x0a     * order.\x0a     *\x0a     * @param {Function} callback Function to execute for each element.\x0a     * @param {*}        thisArg  Value to use as `this` when executing\x0a     *                            `callback`.\x0a     */\x0a\x0a  }, {\x0a    key: \x22forEach\x22,\x0a    value: function forEach(callback) {\x0a      var _this = this;\x0a\x0a      var thisArg = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : this;\x0a\x0a      this._map.forEach(function (value, key) {\x0a        // Unwrap value from object-like value pair.\x0a        if (key !== null && _typeof(key) === \x27object\x27) {\x0a          value = value[1];\x0a        }\x0a\x0a        callback.call(thisArg, value, key, _this);\x0a      });\x0a    }\x0a    /**\x0a     * Removes all elements.\x0a     */\x0a\x0a  }, {\x0a    key: \x22clear\x22,\x0a    value: function clear() {\x0a      this._map = new Map();\x0a      this._arrayTreeMap = new Map();\x0a      this._objectTreeMap = new Map();\x0a    }\x0a  }, {\x0a    key: \x22size\x22,\x0a    get: function get() {\x0a      return this._map.size;\x0a    }\x0a  }]);\x0a\x0a  return EquivalentKeyMap;\x0a}();\x0a\x0amodule.exports = EquivalentKeyMap;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 77:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99);\x0a/* global window */\x0a\x0a\x0avar root;\x0a\x0aif (typeof self !== \x27undefined\x27) {\x0a  root = self;\x0a} else if (typeof window !== \x27undefined\x27) {\x0a  root = window;\x0a} else if (typeof global !== \x27undefined\x27) {\x0a  root = global;\x0a} else if (true) {\x0a  root = module;\x0a} else {}\x0a\x0avar result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22])(root);\x0a/* harmony default export */ __webpack_exports__[\x22a\x22] = (result);\x0a\x0a/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(59), __webpack_require__(132)(module)))\x0a\x0a/***/ }),\x0a\x0a/***/ 99:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return symbolObservablePonyfill; });\x0afunction symbolObservablePonyfill(root) {\x0a\x09var result;\x0a\x09var Symbol = root.Symbol;\x0a\x0a\x09if (typeof Symbol === \x27function\x27) {\x0a\x09\x09if (Symbol.observable) {\x0a\x09\x09\x09result = Symbol.observable;\x0a\x09\x09} else {\x0a\x09\x09\x09result = Symbol(\x27observable\x27);\x0a\x09\x09\x09Symbol.observable = result;\x0a\x09\x09}\x0a\x09} else {\x0a\x09\x09result = \x27@@observable\x27;\x0a\x09}\x0a\x0a\x09return result;\x0a};\x0a\x0a\x0a/***/ })\x0a\x0a/******/ });'}