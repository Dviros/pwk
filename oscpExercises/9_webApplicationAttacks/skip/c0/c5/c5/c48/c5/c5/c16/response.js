var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:05:06 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 07 Feb 2019 06:28:03 GMT\x0aETag: \x22259f-58147f1cda2c0-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-2905/2906\x0aContent-Length: 2906\x0aKeep-Alive: timeout=5, max=40\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0aif (typeof FormData === \x27undefined\x27 || !FormData.prototype.keys) {\x0a  const global = typeof window === \x27object\x27\x0a    ? window : typeof self === \x27object\x27\x0a    ? self : this\x0a\x0a  // keep a reference to native implementation\x0a  const _FormData = global.FormData\x0a\x0a  // To be monkey patched\x0a  const _send = global.XMLHttpRequest && global.XMLHttpRequest.prototype.send\x0a  const _fetch = global.Request && global.fetch\x0a\x0a  // Unable to patch Request constructor correctly\x0a  // const _Request = global.Request\x0a  // only way is to use ES6 class extend\x0a  // https://github.com/babel/babel/issues/1966\x0a\x0a  const stringTag = global.Symbol && Symbol.toStringTag\x0a  const map = new WeakMap\x0a  const wm = o =\x3e map.get(o)\x0a  const arrayFrom = Array.from || (obj =\x3e [].slice.call(obj))\x0a\x0a  // Add missing stringTags to blob and files\x0a  if (stringTag) {\x0a    if (!Blob.prototype[stringTag]) {\x0a      Blob.prototype[stringTag] = \x27Blob\x27\x0a    }\x0a\x0a    if (\x27File\x27 in global && !File.prototype[stringTag]) {\x0a      File.prototype[stringTag] = \x27File\x27\x0a    }\x0a  }\x0a\x0a  // Fix so you can construct your own File\x0a  try {\x0a    new File([], \x27\x27)\x0a  } catch (a) {\x0a    global.File = function(b, d, c) {\x0a      const blob = new Blob(b, c)\x0a      const t = c && void 0 !== c.lastModified ? new Date(c.lastModified) : new Date\x0a\x0a      Object.defineProperties(blob, {\x0a        name: {\x0a          value: d\x0a        },\x0a        lastModifiedDate: {\x0a          value: t\x0a        },\x0a        lastModified: {\x0a          value: +t\x0a        },\x0a        toString: {\x0a          value() {\x0a            return \x27[object File]\x27\x0a          }\x0a        }\x0a      })\x0a\x0a      if (stringTag) {\x0a        Object.defineProperty(blob, stringTag, {\x0a          value: \x27File\x27\x0a        })\x0a      }\x0a\x0a      return blob\x0a    }\x0a  }\x0a\x0a  function normalizeValue([value, filename]) {\x0a    if (value instanceof Blob)\x0a      // Should always returns a new File instance\x0a      // console.assert(fd.get(x) !== fd.get(x))\x0a      value = new File([value], filename, {\x0a        type: value.type,\x0a        lastModified: value.lastModified\x0a      })\x0a\x0a    return value\x0a  }\x0a\x0a  function stringify(name) {\x0a    if (!arguments.length)\x0a      throw new TypeError(\x271 argument required, but only 0 present.\x27)\x0a\x0a    return [name + \x27\x27]\x0a  }\x0a\x0a  function normalizeArgs(name, value, filename) {\x0a    if (arguments.length \x3c 2)\x0a      throw new TypeError(\x0a        `2 arguments required, but only ${arguments.length} present.`\x0a      )\x0a\x0a    return value instanceof Blob\x0a      // normalize name and filename if adding an attachment\x0a      ? [name + \x27\x27, value, filename !== undefined\x0a        ? filename + \x27\x27 // Cast filename to string if 3th arg isn\x27t undefined\x0a        : typeof value.name === \x27string\x27 // if name prop exist\x0a          ? value.name // Use File.name\x0a          : \x27blob\x27] // otherwise fallback to Blob\x0a\x0a      // If no attachment, just cast the args to strings\x0a      : [name + \x27\x27, value + \x27\x27]\x0a  }\x0a\x0a  function each (arr, cb) {\x0a    for (let i = 0; i \x3c arr.length; i++) {\x0a      cb(arr[i])\x0a    }\x0a  }\x0a\x0a  /**\x0a   * @implements {Iterable}\x0a   */\x0a  class FormDataPolyfill {\x0a\x0a    /**\x0a     * FormData class\x0a     *\x0a     * @param {HTMLElement=} form\x0a     */\x0a    constructor(form) {\x0a      map.set(this, Object.create(null))\x0a\x0a      if (!form)\x0a        return this\x0a\x0a      const self = this\x0a\x0a      each(form.elements, elm =\x3e {\x0a        if (!elm.name || elm.disabled || elm.type === \x27submit\x27 || elm.type === \x27button\x27) return\x0a\x0a        if (elm.type === \x27file\x27) {\x0a          each(elm.files || [], file =\x3e {\x0a            self.append(elm.name, file)\x0a          })\x0a        } else if (elm.type === \x27select-multiple\x27 || elm.type === \x27select-one\x27) {\x0a          each(elm.options, opt =\x3e {\x0a            !opt.disabled && opt.selected && self.append(elm.name, opt.value)\x0a          })\x0a        } else if (elm.type === \x27checkbox\x27 || elm.type === \x27radio\x27) {\x0a          if (elm.checked) self.append(elm.name, elm.value)\x0a        } else {\x0a          self.append(elm.name, elm.value)\x0a        }\x0a      })\x0a    }\x0a\x0a\x0a    /**\x0a     * Append a field\x0a     *\x0a     * @param   {String}           name      field name\x0a     * @param   {String|Blob|File} value     string / blob / file\x0a     * @param   {String=}          filename  filename to use with blob\x0a     * @return  {Undefined}\x0a     */\x0a    append(name, value, filename) {\x0a      const map = wm(this)\x0a\x0a      if (!map[name])\x0a        map[name] = []\x0a\x0a      map[name].push([value, filename])\x0a    }\x0a\x0a\x0a    /**\x0a     * Delete all fields values given name\x0a     *\x0a     * @param   {String}  name  Field name\x0a     * @return  {Undefined}\x0a     */\x0a    delete(name) {\x0a      delete wm(this)[name]\x0a    }\x0a\x0a\x0a    /**\x0a     * Iterate over all fields as [name, value]\x0a     *\x0a     * @return {Iterator}\x0a     */\x0a    *entries() {\x0a      const map = wm(this)\x0a\x0a      for (let name in map)\x0a        for (let value of map[name])\x0a          yield [name, normalizeValue(value)]\x0a    }\x0a\x0a    /**\x0a     * Iterate over all fields\x0a     *\x0a     * @param   {Function}  callback  Executed for each item with parameters (value, name, thisArg)\x0a     * @param   {Object=}   thisArg   `this` context for callback function\x0a     * @return  {Undefined}\x0a     */\x0a    forEach(callback, thisArg) {\x0a      for (let [name, value] of this)\x0a        callback.call(thisArg, value, name, this)\x0a    }\x0a\x0a\x0a    /**\x0a     * Return first field value given name\x0a     * or null if non existen\x0a     *\x0a     * @param   {String}  name      Field name\x0a     * @return  {String|File|null}  value Fields value\x0a     */\x0a    get(name) {\x0a      const map = wm(this)\x0a      return map[name] ? normalizeValue(map[name][0]) : null\x0a    }\x0a\x0a\x0a    /**\x0a     * Return all fields values given name\x0a     *\x0a     * @param   {String}  name  Fields name\x0a     * @return  {Array}         [{String|File}]\x0a     */\x0a    getAll(name) {\x0a      return (wm(this)[name] || []).map(normalizeValue)\x0a    }\x0a\x0a\x0a    /**\x0a     * Check for field name existence\x0a     *\x0a     * @param   {String}   name  Field name\x0a     * @return  {boolean}\x0a     */\x0a    has(name) {\x0a      return name in wm(this)\x0a    }\x0a\x0a\x0a    /**\x0a     * Iterate over all fields name\x0a     *\x0a     * @return {Iterator}\x0a     */\x0a    *keys() {\x0a      for (let [name] of this)\x0a        yield name\x0a    }\x0a\x0a\x0a    /**\x0a     * Overwrite all values given name\x0a     *\x0a     * @param   {String}    name      Filed name\x0a     * @param   {String}    value     Field value\x0a     * @param   {String=}   filename  Filename (optional)\x0a     * @return  {Undefined}\x0a     */\x0a    set(name, value, filename) {\x0a      wm(this)[name] = [[value, filename]]\x0a    }\x0a\x0a\x0a    /**\x0a     * Iterate over all fields\x0a     *\x0a     * @return {Iterator}\x0a     */\x0a    *values() {\x0a      for (let [name, value] of this)\x0a        yield value\x0a    }\x0a\x0a\x0a    /**\x0a     * Return a native (perhaps degraded) FormData with only a `append` method\x0a     * Can throw if it\x27s not supported\x0a     *\x0a     * @return {FormData}\x0a     */\x0a    [\x27_asNative\x27]() {\x0a      const fd = new _FormData\x0a\x0a      for (let [name, value] of this)\x0a        fd.append(name, value)\x0a\x0a      return fd\x0a    }\x0a\x0a\x0a    /**\x0a     * [_blob description]\x0a     *\x0a     * @return {Blob} [description]\x0a     */\x0a    [\x27_blob\x27]() {\x0a      const boundary = \x27----formdata-polyfill-\x27 + Math.random()\x0a      const chunks = []\x0a\x0a      for (let [name, value] of this) {\x0a        chunks.push(`--${boundary}\x5cr\x5cn`)\x0a\x0a        if (value instanceof Blob) {\x0a          chunks.push(\x0a            `Content-Disposition: form-data; name=\x22${name}\x22; filename=\x22${value.name}\x22\x5cr\x5cn`,\x0a            `Content-Type: ${value.type || \x27application/octet-stream\x27}\x5cr\x5cn\x5cr\x5cn`,\x0a            value,\x0a            \x27\x5cr\x5cn\x27\x0a          )\x0a        } else {\x0a          chunks.push(\x0a            `Content-Disposition: form-data; name=\x22${name}\x22\x5cr\x5cn\x5cr\x5cn${value}\x5cr\x5cn`\x0a          )\x0a        }\x0a      }\x0a\x0a      chunks.push(`--${boundary}--`)\x0a\x0a      return new Blob(chunks, {type: \x27multipart/form-data; boundary=\x27 + boundary})\x0a    }\x0a\x0a\x0a    /**\x0a     * The class itself is iterable\x0a     * alias for formdata.entries()\x0a     *\x0a     * @return  {Iterator}\x0a     */\x0a    [Symbol.iterator]() {\x0a      return this.entries()\x0a    }\x0a\x0a\x0a    /**\x0a     * Create the default string description.\x0a     *\x0a     * @return  {String} [object FormData]\x0a     */\x0a    toString() {\x0a      return \x27[object FormData]\x27\x0a    }\x0a  }\x0a\x0a\x0a  if (stringTag) {\x0a    /**\x0a     * Create the default string description.\x0a     * It is accessed internally by the Object.prototype.toString().\x0a     *\x0a     * @return {String} FormData\x0a     */\x0a    FormDataPolyfill.prototype[stringTag] = \x27FormData\x27\x0a  }\x0a\x0a  const decorations = [\x0a    [\x27append\x27, normalizeArgs],\x0a    [\x27delete\x27, stringify],\x0a    [\x27get\x27,    stringify],\x0a    [\x27getAll\x27, stringify],\x0a    [\x27has\x27,    stringify],\x0a    [\x27set\x27,    normalizeArgs]\x0a  ]\x0a\x0a  decorations.forEach(arr =\x3e {\x0a    const orig = FormDataPolyfill.prototype[arr[0]]\x0a    FormDataPolyfill.prototype[arr[0]] = function() {\x0a      return orig.apply(this, arr[1].apply(this, arrayFrom(arguments)))\x0a    }\x0a  })\x0a\x0a  // Patch xhr\x27s send method to call _blob transparently\x0a  if (_send) {\x0a    XMLHttpRequest.prototype.send = function(data) {\x0a      // I would check if Content-Type isn\x27t already set\x0a      // But xhr lacks getRequestHeaders functionallity\x0a      // https://github.com/jimmywarting/FormData/issues/44\x0a      if (data instanceof FormDataPolyfill) {\x0a        const blob = data[\x27_blob\x27]()\x0a        this.setRequestHeader(\x27Content-Type\x27, blob.type)\x0a        _send.call(this, blob)\x0a      } else {\x0a        _send.call(this, data)\x0a      }\x0a    }\x0a  }\x0a\x0a  // Patch fetch\x27s function to call _blob transparently\x0a  if (_fetch) {\x0a    const _fetch = global.fetch\x0a\x0a    global.fetch = function(input, init) {\x0a      if (init && init.body && init.body instanceof FormDataPolyfill) {\x0a        init.body = init.body[\x27_blob\x27]()\x0a      }\x0a\x0a      return _fetch(input, init)\x0a    }\x0a  }\x0a\x0a  global[\x27FormData\x27] = FormDataPolyfill\x0a}\x0a'}