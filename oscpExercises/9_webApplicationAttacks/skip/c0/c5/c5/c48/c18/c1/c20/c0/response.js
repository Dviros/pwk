var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 14:57:08 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Sun, 06 Nov 2016 23:38:33 GMT\x0aETag: \x222266-540aa67c2f040-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-2800/2801\x0aContent-Length: 2801\x0aKeep-Alive: timeout=5, max=58\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/**\x0a * Text pattern plugin for TinyMCE\x0a *\x0a * @since 4.3.0\x0a *\x0a * This plugin can automatically format text patterns as you type. It includes several groups of patterns.\x0a *\x0a * Start of line patterns:\x0a *  As-you-type:\x0a *  - Unordered list (`* ` and `- `).\x0a *  - Ordered list (`1. ` and `1) `).\x0a *\x0a *  On enter:\x0a *  - h2 (## ).\x0a *  - h3 (### ).\x0a *  - h4 (#### ).\x0a *  - h5 (##### ).\x0a *  - h6 (###### ).\x0a *  - blockquote (\x3e ).\x0a *  - hr (---).\x0a *\x0a * Inline patterns:\x0a *  - \x3ccode\x3e (`) (backtick).\x0a *\x0a * If the transformation in unwanted, the user can undo the change by pressing backspace,\x0a * using the undo shortcut, or the undo button in the toolbar.\x0a *\x0a * Setting for the patterns can be overridden by plugins by using the `tiny_mce_before_init` PHP filter.\x0a * The setting name is `wptextpattern` and the value is an object containing override arrays for each\x0a * patterns group. There are three groups: \x22space\x22, \x22enter\x22, and \x22inline\x22. Example (PHP):\x0a *\x0a * add_filter( \x27tiny_mce_before_init\x27, \x27my_mce_init_wptextpattern\x27 );\x0a * function my_mce_init_wptextpattern( $init ) {\x0a *   $init[\x27wptextpattern\x27] = wp_json_encode( array(\x0a *      \x27inline\x27 =\x3e array(\x0a *        array( \x27delimiter\x27 =\x3e \x27**\x27, \x27format\x27 =\x3e \x27bold\x27 ),\x0a *        array( \x27delimiter\x27 =\x3e \x27__\x27, \x27format\x27 =\x3e \x27italic\x27 ),\x0a *      ),\x0a *   ) );\x0a *\x0a *   return $init;\x0a * }\x0a *\x0a * Note that setting this will override the default text patterns. You will need to include them\x0a * in your settings array if you want to keep them working.\x0a */\x0a( function( tinymce, setTimeout ) {\x0a\x09if ( tinymce.Env.ie && tinymce.Env.ie \x3c 9 ) {\x0a\x09\x09return;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Escapes characters for use in a Regular Expression.\x0a\x09 *\x0a\x09 * @param  {String} string Characters to escape\x0a\x09 *\x0a\x09 * @return {String}        Escaped characters\x0a\x09 */\x0a\x09function escapeRegExp( string ) {\x0a\x09\x09return string.replace( /[\x5c-\x5c[\x5c]\x5c/\x5c{\x5c}\x5c(\x5c)\x5c*\x5c+\x5c?\x5c.\x5c\x5c\x5c^\x5c$\x5c|]/g, \x27\x5c\x5c$&\x27 );\x0a\x09}\x0a\x0a\x09tinymce.PluginManager.add( \x27wptextpattern\x27, function( editor ) {\x0a\x09\x09var VK = tinymce.util.VK;\x0a\x09\x09var settings = editor.settings.wptextpattern || {};\x0a\x0a\x09\x09var spacePatterns = settings.space || [\x0a\x09\x09\x09{ regExp: /^[*-]\x5cs/, cmd: \x27InsertUnorderedList\x27 },\x0a\x09\x09\x09{ regExp: /^1[.)]\x5cs/, cmd: \x27InsertOrderedList\x27 }\x0a\x09\x09];\x0a\x0a\x09\x09var enterPatterns = settings.enter || [\x0a\x09\x09\x09{ start: \x27##\x27, format: \x27h2\x27 },\x0a\x09\x09\x09{ start: \x27###\x27, format: \x27h3\x27 },\x0a\x09\x09\x09{ start: \x27####\x27, format: \x27h4\x27 },\x0a\x09\x09\x09{ start: \x27#####\x27, format: \x27h5\x27 },\x0a\x09\x09\x09{ start: \x27######\x27, format: \x27h6\x27 },\x0a\x09\x09\x09{ start: \x27\x3e\x27, format: \x27blockquote\x27 },\x0a\x09\x09\x09{ regExp: /^(-){3,}$/, element: \x27hr\x27 }\x0a\x09\x09];\x0a\x0a\x09\x09var inlinePatterns = settings.inline || [\x0a\x09\x09\x09{ delimiter: \x27`\x27, format: \x27code\x27 }\x0a\x09\x09];\x0a\x0a\x09\x09var canUndo;\x0a\x0a\x09\x09editor.on( \x27selectionchange\x27, function() {\x0a\x09\x09\x09canUndo = null;\x0a\x09\x09} );\x0a\x0a\x09\x09editor.on( \x27keydown\x27, function( event ) {\x0a\x09\x09\x09if ( ( canUndo && event.keyCode === 27 /* ESCAPE */ ) || ( canUndo === \x27space\x27 && event.keyCode === VK.BACKSPACE ) ) {\x0a\x09\x09\x09\x09editor.undoManager.undo();\x0a\x09\x09\x09\x09event.preventDefault();\x0a\x09\x09\x09\x09event.stopImmediatePropagation();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if ( VK.metaKeyPressed( event ) ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if ( event.keyCode === VK.ENTER ) {\x0a\x09\x09\x09\x09enter();\x0a\x09\x09\x09// Wait for the browser to insert the character.\x0a\x09\x09\x09} else if ( event.keyCode === VK.SPACEBAR ) {\x0a\x09\x09\x09\x09setTimeout( space );\x0a\x09\x09\x09} else if ( event.keyCode \x3e 47 && ! ( event.keyCode \x3e= 91 && event.keyCode \x3c= 93 ) ) {\x0a\x09\x09\x09\x09setTimeout( inline );\x0a\x09\x09\x09}\x0a\x09\x09}, true );\x0a\x0a\x09\x09function inline() {\x0a\x09\x09\x09var rng = editor.selection.getRng();\x0a\x09\x09\x09var node = rng.startContainer;\x0a\x09\x09\x09var offset = rng.startOffset;\x0a\x09\x09\x09var startOffset;\x0a\x09\x09\x09var endOffset;\x0a\x09\x09\x09var pattern;\x0a\x09\x09\x09var format;\x0a\x09\x09\x09var zero;\x0a\x0a\x09\x09\x09// We need a non empty text node with an offset greater than zero.\x0a\x09\x09\x09if ( ! node || node.nodeType !== 3 || ! node.data.length || ! offset ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09var string = node.data.slice( 0, offset );\x0a\x09\x09\x09var lastChar = node.data.charAt( offset - 1 );\x0a\x0a\x09\x09\x09tinymce.each( inlinePatterns, function( p ) {\x0a\x09\x09\x09\x09// Character before selection should be delimiter.\x0a\x09\x09\x09\x09if ( lastChar !== p.delimiter.slice( -1 ) ) {\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09var escDelimiter = escapeRegExp( p.delimiter );\x0a\x09\x09\x09\x09var delimiterFirstChar = p.delimiter.charAt( 0 );\x0a\x09\x09\x09\x09var regExp = new RegExp( \x27(.*)\x27 + escDelimiter + \x27.+\x27 + escDelimiter + \x27$\x27 );\x0a\x09\x09\x09\x09var match = string.match( regExp );\x0a\x0a\x09\x09\x09\x09if ( ! match ) {\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09startOffset = match[1].length;\x0a\x09\x09\x09\x09endOffset = offset - p.delimiter.length;\x0a\x0a\x09\x09\x09\x09var before = string.charAt( startOffset - 1 );\x0a\x09\x09\x09\x09var after = string.charAt( startOffset + p.delimiter.length );\x0a\x0a\x09\x09\x09\x09// test*test* =\x3e format applied\x0a\x09\x09\x09\x09// test *test* =\x3e applied\x0a\x09\x09\x09\x09// test* test* =\x3e not applied\x0a\x09\x09\x09\x09if ( startOffset && /\x5cS/.test( before ) ) {\x0a\x09\x09\x09\x09\x09if ( /\x5cs/.test( after ) || before === delimiterFirstChar ) {\x0a\x09\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Do not replace when only whitespace and delimiter characters.\x0a\x09\x09\x09\x09if ( ( new RegExp( \x27^[\x5c\x5cs\x27 + escapeRegExp( delimiterFirstChar ) + \x27]+$\x27 ) ).test( string.slice( startOffset, endOffset ) ) ) {\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09pattern = p;\x0a\x0a\x09\x09\x09\x09return false;\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09if ( ! pattern ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09format = editor.formatter.get( pattern.format );\x0a\x0a\x09\x09\x09if ( format && format[0].inline ) {\x0a\x09\x09\x09\x09editor.undoManager.add();\x0a\x0a\x09\x09\x09\x09editor.undoManager.transact( function() {\x0a\x09\x09\x09\x09\x09node.insertData( offset, \x27\x5cuFEFF\x27 );\x0a\x0a\x09\x09\x09\x09\x09node = node.splitText( startOffset );\x0a\x09\x09\x09\x09\x09zero = node.splitText( offset - startOffset );\x0a\x0a\x09\x09\x09\x09\x09node.deleteData( 0, pattern.delimiter.length );\x0a\x09\x09\x09\x09\x09node.deleteData( node.data.length - pattern.delimiter.length, pattern.delimiter.length );\x0a\x0a\x09\x09\x09\x09\x09editor.formatter.apply( pattern.format, {}, node );\x0a\x0a\x09\x09\x09\x09\x09editor.selection.setCursorLocation( zero, 1 );\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09// We need to wait for native events to be triggered.\x0a\x09\x09\x09\x09setTimeout( function() {\x0a\x09\x09\x09\x09\x09canUndo = \x27space\x27;\x0a\x0a\x09\x09\x09\x09\x09editor.once( \x27selectionchange\x27, function() {\x0a\x09\x09\x09\x09\x09\x09var offset;\x0a\x0a\x09\x09\x09\x09\x09\x09if ( zero ) {\x0a\x09\x09\x09\x09\x09\x09\x09offset = zero.data.indexOf( \x27\x5cuFEFF\x27 );\x0a\x0a\x09\x09\x09\x09\x09\x09\x09if ( offset !== -1 ) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09zero.deleteData( offset, offset + 1 );\x0a\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09function firstTextNode( node ) {\x0a\x09\x09\x09var parent = editor.dom.getParent( node, \x27p\x27 ),\x0a\x09\x09\x09\x09child;\x0a\x0a\x09\x09\x09if ( ! parent ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09while ( child = parent.firstChild ) {\x0a\x09\x09\x09\x09if ( child.nodeType !== 3 ) {\x0a\x09\x09\x09\x09\x09parent = child;\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09break;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if ( ! child ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if ( ! child.data ) {\x0a\x09\x09\x09\x09if ( child.nextSibling && child.nextSibling.nodeType === 3 ) {\x0a\x09\x09\x09\x09\x09child = child.nextSibling;\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09child = null;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09return child;\x0a\x09\x09}\x0a\x0a\x09\x09function space() {\x0a\x09\x09\x09var rng = editor.selection.getRng(),\x0a\x09\x09\x09\x09node = rng.startContainer,\x0a\x09\x09\x09\x09parent,\x0a\x09\x09\x09\x09text;\x0a\x0a\x09\x09\x09if ( ! node || firstTextNode( node ) !== node ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09parent = node.parentNode;\x0a\x09\x09\x09text = node.data;\x0a\x0a\x09\x09\x09tinymce.each( spacePatterns, function( pattern ) {\x0a\x09\x09\x09\x09var match = text.match( pattern.regExp );\x0a\x0a\x09\x09\x09\x09if ( ! match || rng.startOffset !== match[0].length ) {\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09editor.undoManager.add();\x0a\x0a\x09\x09\x09\x09editor.undoManager.transact( function() {\x0a\x09\x09\x09\x09\x09node.deleteData( 0, match[0].length );\x0a\x0a\x09\x09\x09\x09\x09if ( ! parent.innerHTML ) {\x0a\x09\x09\x09\x09\x09\x09parent.appendChild( document.createElement( \x27br\x27 ) );\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09editor.selection.setCursorLocation( parent );\x0a\x09\x09\x09\x09\x09editor.execCommand( pattern.cmd );\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09// We need to wait for native events to be triggered.\x0a\x09\x09\x09\x09setTimeout( function() {\x0a\x09\x09\x09\x09\x09canUndo = \x27space\x27;\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09return false;\x0a\x09\x09\x09} );\x0a\x09\x09}\x0a\x0a\x09\x09function enter() {\x0a\x09\x09\x09var rng = editor.selection.getRng(),\x0a\x09\x09\x09\x09start = rng.startContainer,\x0a\x09\x09\x09\x09node = firstTextNode( start ),\x0a\x09\x09\x09\x09i = enterPatterns.length,\x0a\x09\x09\x09\x09text, pattern, parent;\x0a\x0a\x09\x09\x09if ( ! node ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09text = node.data;\x0a\x0a\x09\x09\x09while ( i-- ) {\x0a\x09\x09\x09\x09if ( enterPatterns[ i ].start ) {\x0a\x09\x09\x09\x09\x09if ( text.indexOf( enterPatterns[ i ].start ) === 0 ) {\x0a\x09\x09\x09\x09\x09\x09pattern = enterPatterns[ i ];\x0a\x09\x09\x09\x09\x09\x09break;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09} else if ( enterPatterns[ i ].regExp ) {\x0a\x09\x09\x09\x09\x09if ( enterPatterns[ i ].regExp.test( text ) ) {\x0a\x09\x09\x09\x09\x09\x09pattern = enterPatterns[ i ];\x0a\x09\x09\x09\x09\x09\x09break;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if ( ! pattern ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if ( node === start && tinymce.trim( text ) === pattern.start ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09editor.once( \x27keyup\x27, function() {\x0a\x09\x09\x09\x09editor.undoManager.add();\x0a\x0a\x09\x09\x09\x09editor.undoManager.transact( function() {\x0a\x09\x09\x09\x09\x09if ( pattern.format ) {\x0a\x09\x09\x09\x09\x09\x09editor.formatter.apply( pattern.format, {}, node );\x0a\x09\x09\x09\x09\x09\x09node.replaceData( 0, node.data.length, ltrim( node.data.slice( pattern.start.length ) ) );\x0a\x09\x09\x09\x09\x09} else if ( pattern.element ) {\x0a\x09\x09\x09\x09\x09\x09parent = node.parentNode && node.parentNode.parentNode;\x0a\x0a\x09\x09\x09\x09\x09\x09if ( parent ) {\x0a\x09\x09\x09\x09\x09\x09\x09parent.replaceChild( document.createElement( pattern.element ), node.parentNode );\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09// We need to wait for native events to be triggered.\x0a\x09\x09\x09\x09setTimeout( function() {\x0a\x09\x09\x09\x09\x09canUndo = \x27enter\x27;\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09} );\x0a\x09\x09}\x0a\x0a\x09\x09function ltrim( text ) {\x0a\x09\x09\x09return text ? text.replace( /^\x5cs+/, \x27\x27 ) : \x27\x27;\x0a\x09\x09}\x0a\x09} );\x0a} )( window.tinymce, window.setTimeout );\x0a'}