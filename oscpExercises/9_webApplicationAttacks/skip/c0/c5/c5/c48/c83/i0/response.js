var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 14:53:27 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 10 Jan 2019 01:39:50 GMT\x0aETag: \x22ceb7-57f10a780e580-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-14830/14831\x0aContent-Length: 14831\x0aKeep-Alive: timeout=5, max=56\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a//     Underscore.js 1.8.3\x0a//     http://underscorejs.org\x0a//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\x0a//     Underscore may be freely distributed under the MIT license.\x0a\x0a(function() {\x0a\x0a  // Baseline setup\x0a  // --------------\x0a\x0a  // Establish the root object, `window` in the browser, or `exports` on the server.\x0a  var root = this;\x0a\x0a  // Save the previous value of the `_` variable.\x0a  var previousUnderscore = root._;\x0a\x0a  // Save bytes in the minified (but not gzipped) version:\x0a  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\x0a\x0a  // Create quick reference variables for speed access to core prototypes.\x0a  var\x0a    push             = ArrayProto.push,\x0a    slice            = ArrayProto.slice,\x0a    toString         = ObjProto.toString,\x0a    hasOwnProperty   = ObjProto.hasOwnProperty;\x0a\x0a  // All **ECMAScript 5** native function implementations that we hope to use\x0a  // are declared here.\x0a  var\x0a    nativeIsArray      = Array.isArray,\x0a    nativeKeys         = Object.keys,\x0a    nativeBind         = FuncProto.bind,\x0a    nativeCreate       = Object.create;\x0a\x0a  // Naked function reference for surrogate-prototype-swapping.\x0a  var Ctor = function(){};\x0a\x0a  // Create a safe reference to the Underscore object for use below.\x0a  var _ = function(obj) {\x0a    if (obj instanceof _) return obj;\x0a    if (!(this instanceof _)) return new _(obj);\x0a    this._wrapped = obj;\x0a  };\x0a\x0a  // Export the Underscore object for **Node.js**, with\x0a  // backwards-compatibility for the old `require()` API. If we\x27re in\x0a  // the browser, add `_` as a global object.\x0a  if (typeof exports !== \x27undefined\x27) {\x0a    if (typeof module !== \x27undefined\x27 && module.exports) {\x0a      exports = module.exports = _;\x0a    }\x0a    exports._ = _;\x0a  } else {\x0a    root._ = _;\x0a  }\x0a\x0a  // Current version.\x0a  _.VERSION = \x271.8.3\x27;\x0a\x0a  // Internal function that returns an efficient (for current engines) version\x0a  // of the passed-in callback, to be repeatedly applied in other Underscore\x0a  // functions.\x0a  var optimizeCb = function(func, context, argCount) {\x0a    if (context === void 0) return func;\x0a    switch (argCount == null ? 3 : argCount) {\x0a      case 1: return function(value) {\x0a        return func.call(context, value);\x0a      };\x0a      case 2: return function(value, other) {\x0a        return func.call(context, value, other);\x0a      };\x0a      case 3: return function(value, index, collection) {\x0a        return func.call(context, value, index, collection);\x0a      };\x0a      case 4: return function(accumulator, value, index, collection) {\x0a        return func.call(context, accumulator, value, index, collection);\x0a      };\x0a    }\x0a    return function() {\x0a      return func.apply(context, arguments);\x0a    };\x0a  };\x0a\x0a  // A mostly-internal function to generate callbacks that can be applied\x0a  // to each element in a collection, returning the desired result \xe2\x80\x94 either\x0a  // identity, an arbitrary callback, a property matcher, or a property accessor.\x0a  var cb = function(value, context, argCount) {\x0a    if (value == null) return _.identity;\x0a    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\x0a    if (_.isObject(value)) return _.matcher(value);\x0a    return _.property(value);\x0a  };\x0a  _.iteratee = function(value, context) {\x0a    return cb(value, context, Infinity);\x0a  };\x0a\x0a  // An internal function for creating assigner functions.\x0a  var createAssigner = function(keysFunc, undefinedOnly) {\x0a    return function(obj) {\x0a      var length = arguments.length;\x0a      if (length \x3c 2 || obj == null) return obj;\x0a      for (var index = 1; index \x3c length; index++) {\x0a        var source = arguments[index],\x0a            keys = keysFunc(source),\x0a            l = keys.length;\x0a        for (var i = 0; i \x3c l; i++) {\x0a          var key = keys[i];\x0a          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\x0a        }\x0a      }\x0a      return obj;\x0a    };\x0a  };\x0a\x0a  // An internal function for creating a new object that inherits from another.\x0a  var baseCreate = function(prototype) {\x0a    if (!_.isObject(prototype)) return {};\x0a    if (nativeCreate) return nativeCreate(prototype);\x0a    Ctor.prototype = prototype;\x0a    var result = new Ctor;\x0a    Ctor.prototype = null;\x0a    return result;\x0a  };\x0a\x0a  var property = function(key) {\x0a    return function(obj) {\x0a      return obj == null ? void 0 : obj[key];\x0a    };\x0a  };\x0a\x0a  // Helper for collection methods to determine whether a collection\x0a  // should be iterated as an array or as an object\x0a  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\x0a  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\x0a  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\x0a  var getLength = property(\x27length\x27);\x0a  var isArrayLike = function(collection) {\x0a    var length = getLength(collection);\x0a    return typeof length == \x27number\x27 && length \x3e= 0 && length \x3c= MAX_ARRAY_INDEX;\x0a  };\x0a\x0a  // Collection Functions\x0a  // --------------------\x0a\x0a  // The cornerstone, an `each` implementation, aka `forEach`.\x0a  // Handles raw objects in addition to array-likes. Treats all\x0a  // sparse array-likes as if they were dense.\x0a  _.each = _.forEach = function(obj, iteratee, context) {\x0a    iteratee = optimizeCb(iteratee, context);\x0a    var i, length;\x0a    if (isArrayLike(obj)) {\x0a      for (i = 0, length = obj.length; i \x3c length; i++) {\x0a        iteratee(obj[i], i, obj);\x0a      }\x0a    } else {\x0a      var keys = _.keys(obj);\x0a      for (i = 0, length = keys.length; i \x3c length; i++) {\x0a        iteratee(obj[keys[i]], keys[i], obj);\x0a      }\x0a    }\x0a    return obj;\x0a  };\x0a\x0a  // Return the results of applying the iteratee to each element.\x0a  _.map = _.collect = function(obj, iteratee, context) {\x0a    iteratee = cb(iteratee, context);\x0a    var keys = !isArrayLike(obj) && _.keys(obj),\x0a        length = (keys || obj).length,\x0a        results = Array(length);\x0a    for (var index = 0; index \x3c length; index++) {\x0a      var currentKey = keys ? keys[index] : index;\x0a      results[index] = iteratee(obj[currentKey], currentKey, obj);\x0a    }\x0a    return results;\x0a  };\x0a\x0a  // Create a reducing function iterating left or right.\x0a  function createReduce(dir) {\x0a    // Optimized iterator function as using arguments.length\x0a    // in the main function will deoptimize the, see #1991.\x0a    function iterator(obj, iteratee, memo, keys, index, length) {\x0a      for (; index \x3e= 0 && index \x3c length; index += dir) {\x0a        var currentKey = keys ? keys[index] : index;\x0a        memo = iteratee(memo, obj[currentKey], currentKey, obj);\x0a      }\x0a      return memo;\x0a    }\x0a\x0a    return function(obj, iteratee, memo, context) {\x0a      iteratee = optimizeCb(iteratee, context, 4);\x0a      var keys = !isArrayLike(obj) && _.keys(obj),\x0a          length = (keys || obj).length,\x0a          index = dir \x3e 0 ? 0 : length - 1;\x0a      // Determine the initial value if none is provided.\x0a      if (arguments.length \x3c 3) {\x0a        memo = obj[keys ? keys[index] : index];\x0a        index += dir;\x0a      }\x0a      return iterator(obj, iteratee, memo, keys, index, length);\x0a    };\x0a  }\x0a\x0a  // **Reduce** builds up a single result from a list of values, aka `inject`,\x0a  // or `foldl`.\x0a  _.reduce = _.foldl = _.inject = createReduce(1);\x0a\x0a  // The right-associative version of reduce, also known as `foldr`.\x0a  _.reduceRight = _.foldr = createReduce(-1);\x0a\x0a  // Return the first value which passes a truth test. Aliased as `detect`.\x0a  _.find = _.detect = function(obj, predicate, context) {\x0a    var key;\x0a    if (isArrayLike(obj)) {\x0a      key = _.findIndex(obj, predicate, context);\x0a    } else {\x0a      key = _.findKey(obj, predicate, context);\x0a    }\x0a    if (key !== void 0 && key !== -1) return obj[key];\x0a  };\x0a\x0a  // Return all the elements that pass a truth test.\x0a  // Aliased as `select`.\x0a  _.filter = _.select = function(obj, predicate, context) {\x0a    var results = [];\x0a    predicate = cb(predicate, context);\x0a    _.each(obj, function(value, index, list) {\x0a      if (predicate(value, index, list)) results.push(value);\x0a    });\x0a    return results;\x0a  };\x0a\x0a  // Return all the elements for which a truth test fails.\x0a  _.reject = function(obj, predicate, context) {\x0a    return _.filter(obj, _.negate(cb(predicate)), context);\x0a  };\x0a\x0a  // Determine whether all of the elements match a truth test.\x0a  // Aliased as `all`.\x0a  _.every = _.all = function(obj, predicate, context) {\x0a    predicate = cb(predicate, context);\x0a    var keys = !isArrayLike(obj) && _.keys(obj),\x0a        length = (keys || obj).length;\x0a    for (var index = 0; index \x3c length; index++) {\x0a      var currentKey = keys ? keys[index] : index;\x0a      if (!predicate(obj[currentKey], currentKey, obj)) return false;\x0a    }\x0a    return true;\x0a  };\x0a\x0a  // Determine if at least one element in the object matches a truth test.\x0a  // Aliased as `any`.\x0a  _.some = _.any = function(obj, predicate, context) {\x0a    predicate = cb(predicate, context);\x0a    var keys = !isArrayLike(obj) && _.keys(obj),\x0a        length = (keys || obj).length;\x0a    for (var index = 0; index \x3c length; index++) {\x0a      var currentKey = keys ? keys[index] : index;\x0a      if (predicate(obj[currentKey], currentKey, obj)) return true;\x0a    }\x0a    return false;\x0a  };\x0a\x0a  // Determine if the array or object contains a given item (using `===`).\x0a  // Aliased as `includes` and `include`.\x0a  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\x0a    if (!isArrayLike(obj)) obj = _.values(obj);\x0a    if (typeof fromIndex != \x27number\x27 || guard) fromIndex = 0;\x0a    return _.indexOf(obj, item, fromIndex) \x3e= 0;\x0a  };\x0a\x0a  // Invoke a method (with arguments) on every item in a collection.\x0a  _.invoke = function(obj, method) {\x0a    var args = slice.call(arguments, 2);\x0a    var isFunc = _.isFunction(method);\x0a    return _.map(obj, function(value) {\x0a      var func = isFunc ? method : value[method];\x0a      return func == null ? func : func.apply(value, args);\x0a    });\x0a  };\x0a\x0a  // Convenience version of a common use case of `map`: fetching a property.\x0a  _.pluck = function(obj, key) {\x0a    return _.map(obj, _.property(key));\x0a  };\x0a\x0a  // Convenience version of a common use case of `filter`: selecting only objects\x0a  // containing specific `key:value` pairs.\x0a  _.where = function(obj, attrs) {\x0a    return _.filter(obj, _.matcher(attrs));\x0a  };\x0a\x0a  // Convenience version of a common use case of `find`: getting the first object\x0a  // containing specific `key:value` pairs.\x0a  _.findWhere = function(obj, attrs) {\x0a    return _.find(obj, _.matcher(attrs));\x0a  };\x0a\x0a  // Return the maximum element (or element-based computation).\x0a  _.max = function(obj, iteratee, context) {\x0a    var result = -Infinity, lastComputed = -Infinity,\x0a        value, computed;\x0a    if (iteratee == null && obj != null) {\x0a      obj = isArrayLike(obj) ? obj : _.values(obj);\x0a      for (var i = 0, length = obj.length; i \x3c length; i++) {\x0a        value = obj[i];\x0a        if (value \x3e result) {\x0a          result = value;\x0a        }\x0a      }\x0a    } else {\x0a      iteratee = cb(iteratee, context);\x0a      _.each(obj, function(value, index, list) {\x0a        computed = iteratee(value, index, list);\x0a        if (computed \x3e lastComputed || computed === -Infinity && result === -Infinity) {\x0a          result = value;\x0a          lastComputed = computed;\x0a        }\x0a      });\x0a    }\x0a    return result;\x0a  };\x0a\x0a  // Return the minimum element (or element-based computation).\x0a  _.min = function(obj, iteratee, context) {\x0a    var result = Infinity, lastComputed = Infinity,\x0a        value, computed;\x0a    if (iteratee == null && obj != null) {\x0a      obj = isArrayLike(obj) ? obj : _.values(obj);\x0a      for (var i = 0, length = obj.length; i \x3c length; i++) {\x0a        value = obj[i];\x0a        if (value \x3c result) {\x0a          result = value;\x0a        }\x0a      }\x0a    } else {\x0a      iteratee = cb(iteratee, context);\x0a      _.each(obj, function(value, index, list) {\x0a        computed = iteratee(value, index, list);\x0a        if (computed \x3c lastComputed || computed === Infinity && result === Infinity) {\x0a          result = value;\x0a          lastComputed = computed;\x0a        }\x0a      });\x0a    }\x0a    return result;\x0a  };\x0a\x0a  // Shuffle a collection, using the modern version of the\x0a  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher\xe2\x80\x93Yates_shuffle).\x0a  _.shuffle = function(obj) {\x0a    var set = isArrayLike(obj) ? obj : _.values(obj);\x0a    var length = set.length;\x0a    var shuffled = Array(length);\x0a    for (var index = 0, rand; index \x3c length; index++) {\x0a      rand = _.random(0, index);\x0a      if (rand !== index) shuffled[index] = shuffled[rand];\x0a      shuffled[rand] = set[index];\x0a    }\x0a    return shuffled;\x0a  };\x0a\x0a  // Sample **n** random values from a collection.\x0a  // If **n** is not specified, returns a single random element.\x0a  // The internal `guard` argument allows it to work with `map`.\x0a  _.sample = function(obj, n, guard) {\x0a    if (n == null || guard) {\x0a      if (!isArrayLike(obj)) obj = _.values(obj);\x0a      return obj[_.random(obj.length - 1)];\x0a    }\x0a    return _.shuffle(obj).slice(0, Math.max(0, n));\x0a  };\x0a\x0a  // Sort the object\x27s values by a criterion produced by an iteratee.\x0a  _.sortBy = function(obj, iteratee, context) {\x0a    iteratee = cb(iteratee, context);\x0a    return _.pluck(_.map(obj, function(value, index, list) {\x0a      return {\x0a        value: value,\x0a        index: index,\x0a        criteria: iteratee(value, index, list)\x0a      };\x0a    }).sort(function(left, right) {\x0a      var a = left.criteria;\x0a      var b = right.criteria;\x0a      if (a !== b) {\x0a        if (a \x3e b || a === void 0) return 1;\x0a        if (a \x3c b || b === void 0) return -1;\x0a      }\x0a      return left.index - right.index;\x0a    }), \x27value\x27);\x0a  };\x0a\x0a  // An internal function used for aggregate \x22group by\x22 operations.\x0a  var group = function(behavior) {\x0a    return function(obj, iteratee, context) {\x0a      var result = {};\x0a      iteratee = cb(iteratee, context);\x0a      _.each(obj, function(value, index) {\x0a        var key = iteratee(value, index, obj);\x0a        behavior(result, value, key);\x0a      });\x0a      return result;\x0a    };\x0a  };\x0a\x0a  // Groups the object\x27s values by a criterion. Pass either a string attribute\x0a  // to group by, or a function that returns the criterion.\x0a  _.groupBy = group(function(result, value, key) {\x0a    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\x0a  });\x0a\x0a  // Indexes the object\x27s values by a criterion, similar to `groupBy`, but for\x0a  // when you know that your index values will be unique.\x0a  _.indexBy = group(function(result, value, key) {\x0a    result[key] = value;\x0a  });\x0a\x0a  // Counts instances of an object that group by a certain criterion. Pass\x0a  // either a string attribute to count by, or a function that returns the\x0a  // criterion.\x0a  _.countBy = group(function(result, value, key) {\x0a    if (_.has(result, key)) result[key]++; else result[key] = 1;\x0a  });\x0a\x0a  // Safely create a real, live array from anything iterable.\x0a  _.toArray = function(obj) {\x0a    if (!obj) return [];\x0a    if (_.isArray(obj)) return slice.call(obj);\x0a    if (isArrayLike(obj)) return _.map(obj, _.identity);\x0a    return _.values(obj);\x0a  };\x0a\x0a  // Return the number of elements in an object.\x0a  _.size = function(obj) {\x0a    if (obj == null) return 0;\x0a    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\x0a  };\x0a\x0a  // Split a collection into two arrays: one whose elements all satisfy the given\x0a  // predicate, and one whose elements all do not satisfy the predicate.\x0a  _.partition = function(obj, predicate, context) {\x0a    predicate = cb(predicate, context);\x0a    var pass = [], fail = [];\x0a    _.each(obj, function(value, key, obj) {\x0a      (predicate(value, key, obj) ? pass : fail).push(value);\x0a    });\x0a    return [pass, fail];\x0a  };\x0a\x0a  // Array Functions\x0a  // ---------------\x0a\x0a  // Get the first element of an array. Passing **n** will return the first N\x0a  // values in the array. Aliased as `head` and `take`. The **guard** check\x0a  // allows it to work with `_.map`.\x0a  _.first = _.head = _.take = function(array, n, guard) {\x0a    if (array == null) return void 0;\x0a    if (n == null || guard) return array[0];\x0a    return _.initial(array, array.length - n);\x0a  };\x0a\x0a  // Returns everything but the last entry of the array. Especially useful on\x0a  // the arguments object. Passing **n** will return all the values in\x0a  // the array, excluding the last N.\x0a  _.initial = function(array, n, guard) {\x0a    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\x0a  };\x0a\x0a  // Get the last element of an array. Passing **n** will return the last N\x0a  // values in the array.\x0a  _.last = function(array, n, guard) {\x0a    if (array == null) return void 0;\x0a    if (n == null || guard) return array[array.length - 1];\x0a    return _.rest(array, Math.max(0, array.length - n));\x0a  };\x0a\x0a  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\x0a  // Especially useful on the arguments object. Passing an **n** will return\x0a  // the rest N values in the array.\x0a  _.rest = _.tail = _.drop = function(array, n, guard) {\x0a    return slice.call(array, n == null || guard ? 1 : n);\x0a  };\x0a\x0a  // Trim out all falsy values from an array.\x0a  _.compact = function(array) {\x0a    return _.filter(array, _.identity);\x0a  };\x0a\x0a  // Internal implementation of a recursive `flatten` function.\x0a  var flatten = function(input, shallow, strict, startIndex) {\x0a    var output = [], idx = 0;\x0a    for (var i = startIndex || 0, length = getLength(input); i \x3c length; i++) {\x0a      var value = input[i];\x0a      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\x0a        //flatten current level of array or arguments object\x0a        if (!shallow) value = flatten(value, shallow, strict);\x0a        var j = 0, len = value.length;\x0a        output.length += len;\x0a        while (j \x3c len) {\x0a          output[idx++] = value[j++];\x0a        }\x0a      } else if (!strict) {\x0a        output[idx++] = value;\x0a      }\x0a    }\x0a    return output;\x0a  };\x0a\x0a  // Flatten out an array, either recursively (by default), or just one level.\x0a  _.flatten = function(array, shallow) {\x0a    return flatten(array, shallow, false);\x0a  };\x0a\x0a  // Return a version of the array that does not contain the specified value(s).\x0a  _.without = function(array) {\x0a    return _.difference(array, slice.call(arguments, 1));\x0a  };\x0a\x0a  // Produce a duplicate-free version of the array. If the array has already\x0a  // been sorted, you have the option of using a faster algorithm.\x0a  // Aliased as `unique`.\x0a  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\x0a    if (!_.isBoolean(isSorted)) {\x0a      context = iteratee;\x0a      iteratee = isSorted;\x0a      isSorted = false;\x0a    }\x0a    if (iteratee != null) iteratee = cb(iteratee, context);\x0a    var result = [];\x0a    var seen = [];\x0a    for (var i = 0, length = getLength(array); i \x3c length; i++) {\x0a      var value = array[i],\x0a          computed = iteratee ? iteratee(value, i, array) : value;\x0a      if (isSorted) {\x0a        if (!i || seen !== computed) result.push(value);\x0a        seen = computed;\x0a      } else if (iteratee) {\x0a        if (!_.contains(seen, computed)) {\x0a          seen.push(computed);\x0a          result.push(value);\x0a        }\x0a      } else if (!_.contains(result, value)) {\x0a        result.push(value);\x0a      }\x0a    }\x0a    return result;\x0a  };\x0a\x0a  // Produce an array that contains the union: each distinct element from all of\x0a  // the passed-in arrays.\x0a  _.union = function() {\x0a    return _.uniq(flatten(arguments, true, true));\x0a  };\x0a\x0a  // Produce an array that contains every item shared between all the\x0a  // passed-in arrays.\x0a  _.intersection = function(array) {\x0a    var result = [];\x0a    var argsLength = arguments.length;\x0a    for (var i = 0, length = getLength(array); i \x3c length; i++) {\x0a      var item = array[i];\x0a      if (_.contains(result, item)) continue;\x0a      for (var j = 1; j \x3c argsLength; j++) {\x0a        if (!_.contains(arguments[j], item)) break;\x0a      }\x0a      if (j === argsLength) result.push(item);\x0a    }\x0a    return result;\x0a  };\x0a\x0a  // Take the difference between one array and a number of other arrays.\x0a  // Only the elements present in just the first array will remain.\x0a  _.difference = function(array) {\x0a    var rest = flatten(arguments, true, true, 1);\x0a    return _.filter(array, function(value){\x0a      return !_.contains(rest, value);\x0a    });\x0a  };\x0a\x0a  // Zip together multiple lists into a single array -- elements that share\x0a  // an index go together.\x0a  _.zip = function() {\x0a    return _.unzip(arguments);\x0a  };\x0a\x0a  // Complement of _.zip. Unzip accepts an array of arrays and groups\x0a  // each array\x27s elements on shared indices\x0a  _.unzip = function(array) {\x0a    var length = array && _.max(array, getLength).length || 0;\x0a    var result = Array(length);\x0a\x0a    for (var index = 0; index \x3c length; index++) {\x0a      result[index] = _.pluck(array, index);\x0a    }\x0a    return result;\x0a  };\x0a\x0a  // Converts lists into objects. Pass either a single array of `[key, value]`\x0a  // pairs, or two parallel arrays of the same length -- one of keys, and one of\x0a  // the corresponding values.\x0a  _.object = function(list, values) {\x0a    var result = {};\x0a    for (var i = 0, length = getLength(list); i \x3c length; i++) {\x0a      if (values) {\x0a        result[list[i]] = values[i];\x0a      } else {\x0a        result[list[i][0]] = list[i][1];\x0a      }\x0a    }\x0a    return result;\x0a  };\x0a\x0a  // Generator function to create the findIndex and findLastIndex functions\x0a  function createPredicateIndexFinder(dir) {\x0a    return function(array, predicate, context) {\x0a      predicate = cb(predicate, context);\x0a      var length = getLength(array);\x0a      var index = dir \x3e 0 ? 0 : length - 1;\x0a      for (; index \x3e= 0 && index \x3c length; index += dir) {\x0a        if (predicate(array[index], index, array)) return index;\x0a      }\x0a      return -1;\x0a    };\x0a  }\x0a\x0a  // Returns the first index on an array-like that passes a predicate test\x0a  _.findIndex = createPredicateIndexFinder(1);\x0a  _.findLastIndex = createPredicateIndexFinder(-1);\x0a\x0a  // Use a comparator function to figure out the smallest index at which\x0a  // an object should be inserted so as to maintain order. Uses binary search.\x0a  _.sortedIndex = function(array, obj, iteratee, context) {\x0a    iteratee = cb(iteratee, context, 1);\x0a    var value = iteratee(obj);\x0a    var low = 0, high = getLength(array);\x0a    while (low \x3c high) {\x0a      var mid = Math.floor((low + high) / 2);\x0a      if (iteratee(array[mid]) \x3c value) low = mid + 1; else high = mid;\x0a    }\x0a    return low;\x0a  };\x0a\x0a  // Generator function to create the indexOf and lastIndexOf functions\x0a  function createIndexFinder(dir, predicateFind, sortedIndex) {\x0a    return function(array, item, idx) {\x0a      var i = 0, length = getLength(array);\x0a      if (typeof idx == \x27number\x27) {\x0a        if (dir \x3e 0) {\x0a            i = idx \x3e= 0 ? idx : Math.max(idx + length, i);\x0a        } else {\x0a            length = idx \x3e= 0 ? Math.min(idx + 1, length) : idx + length + 1;\x0a        }\x0a      } else if (sortedIndex && idx && length) {\x0a        idx = sortedIndex(array, item);\x0a        return array[idx] === item ? idx : -1;\x0a      }\x0a      if (item !== item) {\x0a        idx = predicateFind(slice.call(array, i, length), _.isNaN);\x0a        return idx \x3e= 0 ? idx + i : -1;\x0a      }\x0a      for (idx = dir \x3e 0 ? i : length - 1; idx \x3e= 0 && idx \x3c length; idx += dir) {\x0a        if (array[idx] === item) return idx;\x0a      }\x0a      return -1;\x0a    };\x0a  }\x0a\x0a  // Return the position of the first occurrence of an item in an array,\x0a  // or -1 if the item is not included in the array.\x0a  // If the array is large and already in sort order, pass `true`\x0a  // for **isSorted** to use binary search.\x0a  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\x0a  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\x0a\x0a  // Generate an integer Array containing an arithmetic progression. A port of\x0a  // the native Python `range()` function. See\x0a  // [the Python documentation](http://docs.python.org/library/functions.html#range).\x0a  _.range = function(start, stop, step) {\x0a    if (stop == null) {\x0a      stop = start || 0;\x0a      start = 0;\x0a    }\x0a    step = step || 1;\x0a\x0a    var length = Math.max(Math.ceil((stop - start) / step), 0);\x0a    var range = Array(length);\x0a\x0a    for (var idx = 0; idx \x3c length; idx++, start += step) {\x0a      range[idx] = start;\x0a    }\x0a\x0a    return range;\x0a  };\x0a\x0a  // Function (ahem) Functions\x0a  // ------------------\x0a\x0a  // Determines whether to execute a function as a constructor\x0a  // or a normal function with the provided arguments\x0a  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\x0a    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\x0a    var self = baseCreate(sourceFunc.prototype);\x0a    var result = sourceFunc.apply(self, args);\x0a    if (_.isObject(result)) return result;\x0a    return self;\x0a  };\x0a\x0a  // Create a function bound to a given object (assigning `this`, and arguments,\x0a  // optionally). Delegates to **ECMAScript 5**\x27s native `Function.bind` if\x0a  // available.\x0a  _.bind = function(func, context) {\x0a    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\x0a    if (!_.isFunction(func)) throw new TypeError(\x27Bind must be called on a function\x27);\x0a    var args = slice.call(arguments, 2);\x0a    var bound = function() {\x0a      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\x0a    };\x0a    return bound;\x0a  };\x0a\x0a  // Partially apply a function by creating a version that has had some of its\x0a  // arguments pre-filled, without changing its dynamic `this` context. _ acts\x0a  // as a placeholder, allowing any combination of arguments to be pre-filled.\x0a  _.partial = function(func) {\x0a    var boundArgs = slice.call(arguments, 1);\x0a    var bound = function() {\x0a      var position = 0, length = boundArgs.length;\x0a      var args = Array(length);\x0a      for (var i = 0; i \x3c length; i++) {\x0a        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\x0a      }\x0a      while (position \x3c arguments.length) args.push(arguments[position++]);\x0a      return executeBound(func, bound, this, this, args);\x0a    };\x0a    return bound;\x0a  };\x0a\x0a  // Bind a number of an object\x27s methods to that object. Remaining arguments\x0a  // are the method names to be bound. Useful for ensuring that all callbacks\x0a  // defined on an object belong to it.\x0a  _.bindAll = function(obj) {\x0a    var i, length = arguments.length, key;\x0a    if (length \x3c= 1) throw new Error(\x27bindAll must be passed function names\x27);\x0a    for (i = 1; i \x3c length; i++) {\x0a      key = arguments[i];\x0a      obj[key] = _.bind(obj[key], obj);\x0a    }\x0a    return obj;\x0a  };\x0a\x0a  // Memoize an expensive function by storing its results.\x0a  _.memoize = function(func, hasher) {\x0a    var memoize = function(key) {\x0a      var cache = memoize.cache;\x0a      var address = \x27\x27 + (hasher ? hasher.apply(this, arguments) : key);\x0a      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\x0a      return cache[address];\x0a    };\x0a    memoize.cache = {};\x0a    return memoize;\x0a  };\x0a\x0a  // Delays a function for the given number of milliseconds, and then calls\x0a  // it with the arguments supplied.\x0a  _.delay = function(func, wait) {\x0a    var args = slice.call(arguments, 2);\x0a    return setTimeout(function(){\x0a      return func.apply(null, args);\x0a    }, wait);\x0a  };\x0a\x0a  // Defers a function, scheduling it to run after the current call stack has\x0a  // cleared.\x0a  _.defer = _.partial(_.delay, _, 1);\x0a\x0a  // Returns a function, that, when invoked, will only be triggered at most once\x0a  // during a given window of time. Normally, the throttled function will run\x0a  // as much as it can, without ever going more than once per `wait` duration;\x0a  // but if you\x27d like to disable the execution on the leading edge, pass\x0a  // `{leading: false}`. To disable execution on the trailing edge, ditto.\x0a  _.throttle = function(func, wait, options) {\x0a    var context, args, result;\x0a    var timeout = null;\x0a    var previous = 0;\x0a    if (!options) options = {};\x0a    var later = function() {\x0a      previous = options.leading === false ? 0 : _.now();\x0a      timeout = null;\x0a      result = func.apply(context, args);\x0a      if (!timeout) context = args = null;\x0a    };\x0a    return function() {\x0a      var now = _.now();\x0a      if (!previous && options.leading === false) previous = now;\x0a      var remaining = wait - (now - previous);\x0a      context = this;\x0a      args = arguments;\x0a      if (remaining \x3c= 0 || remaining \x3e wait) {\x0a        if (timeout) {\x0a          clearTimeout(timeout);\x0a          timeout = null;\x0a        }\x0a        previous = now;\x0a        result = func.apply(context, args);\x0a        if (!timeout) context = args = null;\x0a      } else if (!timeout && options.trailing !== false) {\x0a        timeout = setTimeout(later, remaining);\x0a      }\x0a      return result;\x0a    };\x0a  };\x0a\x0a  // Returns a function, that, as long as it continues to be invoked, will not\x0a  // be triggered. The function will be called after it stops being called for\x0a  // N milliseconds. If `immediate` is passed, trigger the function on the\x0a  // leading edge, instead of the trailing.\x0a  _.debounce = function(func, wait, immediate) {\x0a    var timeout, args, context, timestamp, result;\x0a\x0a    var later = function() {\x0a      var last = _.now() - timestamp;\x0a\x0a      if (last \x3c wait && last \x3e= 0) {\x0a        timeout = setTimeout(later, wait - last);\x0a      } else {\x0a        timeout = null;\x0a        if (!immediate) {\x0a          result = func.apply(context, args);\x0a          if (!timeout) context = args = null;\x0a        }\x0a      }\x0a    };\x0a\x0a    return function() {\x0a      context = this;\x0a      args = arguments;\x0a      timestamp = _.now();\x0a      var callNow = immediate && !timeout;\x0a      if (!timeout) timeout = setTimeout(later, wait);\x0a      if (callNow) {\x0a        result = func.apply(context, args);\x0a        context = args = null;\x0a      }\x0a\x0a      return result;\x0a    };\x0a  };\x0a\x0a  // Returns the first function passed as an argument to the second,\x0a  // allowing you to adjust arguments, run code before and after, and\x0a  // conditionally execute the original function.\x0a  _.wrap = function(func, wrapper) {\x0a    return _.partial(wrapper, func);\x0a  };\x0a\x0a  // Returns a negated version of the passed-in predicate.\x0a  _.negate = function(predicate) {\x0a    return function() {\x0a      return !predicate.apply(this, arguments);\x0a    };\x0a  };\x0a\x0a  // Returns a function that is the composition of a list of functions, each\x0a  // consuming the return value of the function that follows.\x0a  _.compose = function() {\x0a    var args = arguments;\x0a    var start = args.length - 1;\x0a    return function() {\x0a      var i = start;\x0a      var result = args[start].apply(this, arguments);\x0a      while (i--) result = args[i].call(this, result);\x0a      return result;\x0a    };\x0a  };\x0a\x0a  // Returns a function that will only be executed on and after the Nth call.\x0a  _.after = function(times, func) {\x0a    return function() {\x0a      if (--times \x3c 1) {\x0a        return func.apply(this, arguments);\x0a      }\x0a    };\x0a  };\x0a\x0a  // Returns a function that will only be executed up to (but not including) the Nth call.\x0a  _.before = function(times, func) {\x0a    var memo;\x0a    return function() {\x0a      if (--times \x3e 0) {\x0a        memo = func.apply(this, arguments);\x0a      }\x0a      if (times \x3c= 1) func = null;\x0a      return memo;\x0a    };\x0a  };\x0a\x0a  // Returns a function that will be executed at most one time, no matter how\x0a  // often you call it. Useful for lazy initialization.\x0a  _.once = _.partial(_.before, 2);\x0a\x0a  // Object Functions\x0a  // ----------------\x0a\x0a  // Keys in IE \x3c 9 that won\x27t be iterated by `for key in ...` and thus missed.\x0a  var hasEnumBug = !{toString: null}.propertyIsEnumerable(\x27toString\x27);\x0a  var nonEnumerableProps = [\x27valueOf\x27, \x27isPrototypeOf\x27, \x27toString\x27,\x0a                      \x27propertyIsEnumerable\x27, \x27hasOwnProperty\x27, \x27toLocaleString\x27];\x0a\x0a  function collectNonEnumProps(obj, keys) {\x0a    var nonEnumIdx = nonEnumerableProps.length;\x0a    var constructor = obj.constructor;\x0a    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\x0a\x0a    // Constructor is a special case.\x0a    var prop = \x27constructor\x27;\x0a    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\x0a\x0a    while (nonEnumIdx--) {\x0a      prop = nonEnumerableProps[nonEnumIdx];\x0a      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\x0a        keys.push(prop);\x0a      }\x0a    }\x0a  }\x0a\x0a  // Retrieve the names of an object\x27s own properties.\x0a  // Delegates to **ECMAScript 5**\x27s native `Object.keys`\x0a  _.keys = function(obj) {\x0a    if (!_.isObject(obj)) return [];\x0a    if (nativeKeys) return nativeKeys(obj);\x0a    var keys = [];\x0a    for (var key in obj) if (_.has(obj, key)) keys.push(key);\x0a    // Ahem, IE \x3c 9.\x0a    if (hasEnumBug) collectNonEnumProps(obj, keys);\x0a    return keys;\x0a  };\x0a\x0a  // Retrieve all the property names of an object.\x0a  _.allKeys = function(obj) {\x0a    if (!_.isObject(obj)) return [];\x0a    var keys = [];\x0a    for (var key in obj) keys.push(key);\x0a    // Ahem, IE \x3c 9.\x0a    if (hasEnumBug) collectNonEnumProps(obj, keys);\x0a    return keys;\x0a  };\x0a\x0a  // Retrieve the values of an object\x27s properties.\x0a  _.values = function(obj) {\x0a    var keys = _.keys(obj);\x0a    var length = keys.length;\x0a    var values = Array(length);\x0a    for (var i = 0; i \x3c length; i++) {\x0a      values[i] = obj[keys[i]];\x0a    }\x0a    return values;\x0a  };\x0a\x0a  // Returns the results of applying the iteratee to each element of the object\x0a  // In contrast to _.map it returns an object\x0a  _.mapObject = function(obj, iteratee, context) {\x0a    iteratee = cb(iteratee, context);\x0a    var keys =  _.keys(obj),\x0a          length = keys.length,\x0a          results = {},\x0a          currentKey;\x0a      for (var index = 0; index \x3c length; index++) {\x0a        currentKey = keys[index];\x0a        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\x0a      }\x0a      return results;\x0a  };\x0a\x0a  // Convert an object into a list of `[key, value]` pairs.\x0a  _.pairs = function(obj) {\x0a    var keys = _.keys(obj);\x0a    var length = keys.length;\x0a    var pairs = Array(length);\x0a    for (var i = 0; i \x3c length; i++) {\x0a      pairs[i] = [keys[i], obj[keys[i]]];\x0a    }\x0a    return pairs;\x0a  };\x0a\x0a  // Invert the keys and values of an object. The values must be serializable.\x0a  _.invert = function(obj) {\x0a    var result = {};\x0a    var keys = _.keys(obj);\x0a    for (var i = 0, length = keys.length; i \x3c length; i++) {\x0a      result[obj[keys[i]]] = keys[i];\x0a    }\x0a    return result;\x0a  };\x0a\x0a  // Return a sorted list of the function names available on the object.\x0a  // Aliased as `methods`\x0a  _.functions = _.methods = function(obj) {\x0a    var names = [];\x0a    for (var key in obj) {\x0a      if (_.isFunction(obj[key])) names.push(key);\x0a    }\x0a    return names.sort();\x0a  };\x0a\x0a  // Extend a given object with all the properties in passed-in object(s).\x0a  _.extend = createAssigner(_.allKeys);\x0a\x0a  // Assigns a given object with all the own properties in the passed-in object(s)\x0a  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\x0a  _.extendOwn = _.assign = createAssigner(_.keys);\x0a\x0a  // Returns the first key on an object that passes a predicate test\x0a  _.findKey = function(obj, predicate, context) {\x0a    predicate = cb(predicate, context);\x0a    var keys = _.keys(obj), key;\x0a    for (var i = 0, length = keys.length; i \x3c length; i++) {\x0a      key = keys[i];\x0a      if (predicate(obj[key], key, obj)) return key;\x0a    }\x0a  };\x0a\x0a  // Return a copy of the object only containing the whitelisted properties.\x0a  _.pick = function(object, oiteratee, context) {\x0a    var result = {}, obj = object, iteratee, keys;\x0a    if (obj == null) return result;\x0a    if (_.isFunction(oiteratee)) {\x0a      keys = _.allKeys(obj);\x0a      iteratee = optimizeCb(oiteratee, context);\x0a    } else {\x0a      keys = flatten(arguments, false, false, 1);\x0a      iteratee = function(value, key, obj) { return key in obj; };\x0a      obj = Object(obj);\x0a    }\x0a    for (var i = 0, length = keys.length; i \x3c length; i++) {\x0a      var key = keys[i];\x0a      var value = obj[key];\x0a      if (iteratee(value, key, obj)) result[key] = value;\x0a    }\x0a    return result;\x0a  };\x0a\x0a   // Return a copy of the object without the blacklisted properties.\x0a  _.omit = function(obj, iteratee, context) {\x0a    if (_.isFunction(iteratee)) {\x0a      iteratee = _.negate(iteratee);\x0a    } else {\x0a      var keys = _.map(flatten(arguments, false, false, 1), String);\x0a      iteratee = function(value, key) {\x0a        return !_.contains(keys, key);\x0a      };\x0a    }\x0a    return _.pick(obj, iteratee, context);\x0a  };\x0a\x0a  // Fill in a given object with default properties.\x0a  _.defaults = createAssigner(_.allKeys, true);\x0a\x0a  // Creates an object that inherits from the given prototype object.\x0a  // If additional properties are provided then they will be added to the\x0a  // created object.\x0a  _.create = function(prototype, props) {\x0a    var result = baseCreate(prototype);\x0a    if (props) _.extendOwn(result, props);\x0a    return result;\x0a  };\x0a\x0a  // Create a (shallow-cloned) duplicate of an object.\x0a  _.clone = function(obj) {\x0a    if (!_.isObject(obj)) return obj;\x0a    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\x0a  };\x0a\x0a  // Invokes interceptor with the obj, and then returns obj.\x0a  // The primary purpose of this method is to \x22tap into\x22 a method chain, in\x0a  // order to perform operations on intermediate results within the chain.\x0a  _.tap = function(obj, interceptor) {\x0a    interceptor(obj);\x0a    return obj;\x0a  };\x0a\x0a  // Returns whether an object has a given set of `key:value` pairs.\x0a  _.isMatch = function(object, attrs) {\x0a    var keys = _.keys(attrs), length = keys.length;\x0a    if (object == null) return !length;\x0a    var obj = Object(object);\x0a    for (var i = 0; i \x3c length; i++) {\x0a      var key = keys[i];\x0a      if (attrs[key] !== obj[key] || !(key in obj)) return false;\x0a    }\x0a    return true;\x0a  };\x0a\x0a\x0a  // Internal recursive comparison function for `isEqual`.\x0a  var eq = function(a, b, aStack, bStack) {\x0a    // Identical objects are equal. `0 === -0`, but they aren\x27t identical.\x0a    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\x0a    if (a === b) return a !== 0 || 1 / a === 1 / b;\x0a    // A strict comparison is necessary because `null == undefined`.\x0a    if (a == null || b == null) return a === b;\x0a    // Unwrap any wrapped objects.\x0a    if (a instanceof _) a = a._wrapped;\x0a    if (b instanceof _) b = b._wrapped;\x0a    // Compare `[[Class]]` names.\x0a    var className = toString.call(a);\x0a    if (className !== toString.call(b)) return false;\x0a    switch (className) {\x0a      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\x0a      case \x27[object RegExp]\x27:\x0a      // RegExps are coerced to strings for comparison (Note: \x27\x27 + /a/i === \x27/a/i\x27)\x0a      case \x27[object String]\x27:\x0a        // Primitives and their corresponding object wrappers are equivalent; thus, `\x225\x22` is\x0a        // equivalent to `new String(\x225\x22)`.\x0a        return \x27\x27 + a === \x27\x27 + b;\x0a      case \x27[object Number]\x27:\x0a        // `NaN`s are equivalent, but non-reflexive.\x0a        // Object(NaN) is equivalent to NaN\x0a        if (+a !== +a) return +b !== +b;\x0a        // An `egal` comparison is performed for other numeric values.\x0a        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\x0a      case \x27[object Date]\x27:\x0a      case \x27[object Boolean]\x27:\x0a        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\x0a        // millisecond representations. Note that invalid dates with millisecond representations\x0a        // of `NaN` are not equivalent.\x0a        return +a === +b;\x0a    }\x0a\x0a    var areArrays = className === \x27[object Array]\x27;\x0a    if (!areArrays) {\x0a      if (typeof a != \x27object\x27 || typeof b != \x27object\x27) return false;\x0a\x0a      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\x0a      // from different frames are.\x0a      var aCtor = a.constructor, bCtor = b.constructor;\x0a      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\x0a                               _.isFunction(bCtor) && bCtor instanceof bCtor)\x0a                          && (\x27constructor\x27 in a && \x27constructor\x27 in b)) {\x0a        return false;\x0a      }\x0a    }\x0a    // Assume equality for cyclic structures. The algorithm for detecting cyclic\x0a    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\x0a\x0a    // Initializing stack of traversed objects.\x0a    // It\x27s done here since we only need them for objects and arrays comparison.\x0a    aStack = aStack || [];\x0a    bStack = bStack || [];\x0a    var length = aStack.length;\x0a    while (length--) {\x0a      // Linear search. Performance is inversely proportional to the number of\x0a      // unique nested structures.\x0a      if (aStack[length] === a) return bStack[length] === b;\x0a    }\x0a\x0a    // Add the first object to the stack of traversed objects.\x0a    aStack.push(a);\x0a    bStack.push(b);\x0a\x0a    // Recursively compare objects and arrays.\x0a    if (areArrays) {\x0a      // Compare array lengths to determine if a deep comparison is necessary.\x0a      length = a.length;\x0a      if (length !== b.length) return false;\x0a      // Deep compare the contents, ignoring non-numeric properties.\x0a      while (length--) {\x0a        if (!eq(a[length], b[length], aStack, bStack)) return false;\x0a      }\x0a    } else {\x0a      // Deep compare objects.\x0a      var keys = _.keys(a), key;\x0a      length = keys.length;\x0a      // Ensure that both objects contain the same number of properties before comparing deep equality.\x0a      if (_.keys(b).length !== length) return false;\x0a      while (length--) {\x0a        // Deep compare each member\x0a        key = keys[length];\x0a        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\x0a      }\x0a    }\x0a    // Remove the first object from the stack of traversed objects.\x0a    aStack.pop();\x0a    bStack.pop();\x0a    return true;\x0a  };\x0a\x0a  // Perform a deep comparison to check if two objects are equal.\x0a  _.isEqual = function(a, b) {\x0a    return eq(a, b);\x0a  };\x0a\x0a  // Is a given array, string, or object empty?\x0a  // An \x22empty\x22 object has no enumerable own-properties.\x0a  _.isEmpty = function(obj) {\x0a    if (obj == null) return true;\x0a    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\x0a    return _.keys(obj).length === 0;\x0a  };\x0a\x0a  // Is a given value a DOM element?\x0a  _.isElement = function(obj) {\x0a    return !!(obj && obj.nodeType === 1);\x0a  };\x0a\x0a  // Is a given value an array?\x0a  // Delegates to ECMA5\x27s native Array.isArray\x0a  _.isArray = nativeIsArray || function(obj) {\x0a    return toString.call(obj) === \x27[object Array]\x27;\x0a  };\x0a\x0a  // Is a given variable an object?\x0a  _.isObject = function(obj) {\x0a    var type = typeof obj;\x0a    return type === \x27function\x27 || type === \x27object\x27 && !!obj;\x0a  };\x0a\x0a  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\x0a  _.each([\x27Arguments\x27, \x27Function\x27, \x27String\x27, \x27Number\x27, \x27Date\x27, \x27RegExp\x27, \x27Error\x27], function(name) {\x0a    _[\x27is\x27 + name] = function(obj) {\x0a      return toString.call(obj) === \x27[object \x27 + name + \x27]\x27;\x0a    };\x0a  });\x0a\x0a  // Define a fallback version of the method in browsers (ahem, IE \x3c 9), where\x0a  // there isn\x27t any inspectable \x22Arguments\x22 type.\x0a  if (!_.isArguments(arguments)) {\x0a    _.isArguments = function(obj) {\x0a      return _.has(obj, \x27callee\x27);\x0a    };\x0a  }\x0a\x0a  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\x0a  // IE 11 (#1621), and in Safari 8 (#1929).\x0a  if (typeof /./ != \x27function\x27 && typeof Int8Array != \x27object\x27) {\x0a    _.isFunction = function(obj) {\x0a      return typeof obj == \x27function\x27 || false;\x0a    };\x0a  }\x0a\x0a  // Is a given object a finite number?\x0a  _.isFinite = function(obj) {\x0a    return isFinite(obj) && !isNaN(parseFloat(obj));\x0a  };\x0a\x0a  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\x0a  _.isNaN = function(obj) {\x0a    return _.isNumber(obj) && obj !== +obj;\x0a  };\x0a\x0a  // Is a given value a boolean?\x0a  _.isBoolean = function(obj) {\x0a    return obj === true || obj === false || toString.call(obj) === \x27[object Boolean]\x27;\x0a  };\x0a\x0a  // Is a given value equal to null?\x0a  _.isNull = function(obj) {\x0a    return obj === null;\x0a  };\x0a\x0a  // Is a given variable undefined?\x0a  _.isUndefined = function(obj) {\x0a    return obj === void 0;\x0a  };\x0a\x0a  // Shortcut function for checking if an object has a given property directly\x0a  // on itself (in other words, not on a prototype).\x0a  _.has = function(obj, key) {\x0a    return obj != null && hasOwnProperty.call(obj, key);\x0a  };\x0a\x0a  // Utility Functions\x0a  // -----------------\x0a\x0a  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\x0a  // previous owner. Returns a reference to the Underscore object.\x0a  _.noConflict = function() {\x0a    root._ = previousUnderscore;\x0a    return this;\x0a  };\x0a\x0a  // Keep the identity function around for default iteratees.\x0a  _.identity = function(value) {\x0a    return value;\x0a  };\x0a\x0a  // Predicate-generating functions. Often useful outside of Underscore.\x0a  _.constant = function(value) {\x0a    return function() {\x0a      return value;\x0a    };\x0a  };\x0a\x0a  _.noop = function(){};\x0a\x0a  _.property = property;\x0a\x0a  // Generates a function for a given object that returns a given property.\x0a  _.propertyOf = function(obj) {\x0a    return obj == null ? function(){} : function(key) {\x0a      return obj[key];\x0a    };\x0a  };\x0a\x0a  // Returns a predicate for checking whether an object has a given set of\x0a  // `key:value` pairs.\x0a  _.matcher = _.matches = function(attrs) {\x0a    attrs = _.extendOwn({}, attrs);\x0a    return function(obj) {\x0a      return _.isMatch(obj, attrs);\x0a    };\x0a  };\x0a\x0a  // Run a function **n** times.\x0a  _.times = function(n, iteratee, context) {\x0a    var accum = Array(Math.max(0, n));\x0a    iteratee = optimizeCb(iteratee, context, 1);\x0a    for (var i = 0; i \x3c n; i++) accum[i] = iteratee(i);\x0a    return accum;\x0a  };\x0a\x0a  // Return a random integer between min and max (inclusive).\x0a  _.random = function(min, max) {\x0a    if (max == null) {\x0a      max = min;\x0a      min = 0;\x0a    }\x0a    return min + Math.floor(Math.random() * (max - min + 1));\x0a  };\x0a\x0a  // A (possibly faster) way to get the current timestamp as an integer.\x0a  _.now = Date.now || function() {\x0a    return new Date().getTime();\x0a  };\x0a\x0a   // List of HTML entities for escaping.\x0a  var escapeMap = {\x0a    \x27&\x27: \x27&amp;\x27,\x0a    \x27\x3c\x27: \x27&lt;\x27,\x0a    \x27\x3e\x27: \x27&gt;\x27,\x0a    \x27\x22\x27: \x27&quot;\x27,\x0a    \x22\x27\x22: \x27&#x27;\x27,\x0a    \x27`\x27: \x27&#x60;\x27\x0a  };\x0a  var unescapeMap = _.invert(escapeMap);\x0a\x0a  // Functions for escaping and unescaping strings to/from HTML interpolation.\x0a  var createEscaper = function(map) {\x0a    var escaper = function(match) {\x0a      return map[match];\x0a    };\x0a    // Regexes for identifying a key that needs to be escaped\x0a    var source = \x27(?:\x27 + _.keys(map).join(\x27|\x27) + \x27)\x27;\x0a    var testRegexp = RegExp(source);\x0a    var replaceRegexp = RegExp(source, \x27g\x27);\x0a    return function(string) {\x0a      string = string == null ? \x27\x27 : \x27\x27 + string;\x0a      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\x0a    };\x0a  };\x0a  _.escape = createEscaper(escapeMap);\x0a  _.unescape = createEscaper(unescapeMap);\x0a\x0a  // If the value of the named `property` is a function then invoke it with the\x0a  // `object` as context; otherwise, return it.\x0a  _.result = function(object, property, fallback) {\x0a    var value = object == null ? void 0 : object[property];\x0a    if (value === void 0) {\x0a      value = fallback;\x0a    }\x0a    return _.isFunction(value) ? value.call(object) : value;\x0a  };\x0a\x0a  // Generate a unique integer id (unique within the entire client session).\x0a  // Useful for temporary DOM ids.\x0a  var idCounter = 0;\x0a  _.uniqueId = function(prefix) {\x0a    var id = ++idCounter + \x27\x27;\x0a    return prefix ? prefix + id : id;\x0a  };\x0a\x0a  // By default, Underscore uses ERB-style template delimiters, change the\x0a  // following template settings to use alternative delimiters.\x0a  _.templateSettings = {\x0a    evaluate    : /\x3c%([\x5cs\x5cS]+?)%\x3e/g,\x0a    interpolate : /\x3c%=([\x5cs\x5cS]+?)%\x3e/g,\x0a    escape      : /\x3c%-([\x5cs\x5cS]+?)%\x3e/g\x0a  };\x0a\x0a  // When customizing `templateSettings`, if you don\x27t want to define an\x0a  // interpolation, evaluation or escaping regex, we need one that is\x0a  // guaranteed not to match.\x0a  var noMatch = /(.)^/;\x0a\x0a  // Certain characters need to be escaped so that they can be put into a\x0a  // string literal.\x0a  var escapes = {\x0a    \x22\x27\x22:      \x22\x27\x22,\x0a    \x27\x5c\x5c\x27:     \x27\x5c\x5c\x27,\x0a    \x27\x5cr\x27:     \x27r\x27,\x0a    \x27\x5cn\x27:     \x27n\x27,\x0a    \x27\x5cu2028\x27: \x27u2028\x27,\x0a    \x27\x5cu2029\x27: \x27u2029\x27\x0a  };\x0a\x0a  var escaper = /\x5c\x5c|\x27|\x5cr|\x5cn|\x5cu2028|\x5cu2029/g;\x0a\x0a  var escapeChar = function(match) {\x0a    return \x27\x5c\x5c\x27 + escapes[match];\x0a  };\x0a\x0a  // JavaScript micro-templating, similar to John Resig\x27s implementation.\x0a  // Underscore templating handles arbitrary delimiters, preserves whitespace,\x0a  // and correctly escapes quotes within interpolated code.\x0a  // NB: `oldSettings` only exists for backwards compatibility.\x0a  _.template = function(text, settings, oldSettings) {\x0a    if (!settings && oldSettings) settings = oldSettings;\x0a    settings = _.defaults({}, settings, _.templateSettings);\x0a\x0a    // Combine delimiters into one regular expression via alternation.\x0a    var matcher = RegExp([\x0a      (settings.escape || noMatch).source,\x0a      (settings.interpolate || noMatch).source,\x0a      (settings.evaluate || noMatch).source\x0a    ].join(\x27|\x27) + \x27|$\x27, \x27g\x27);\x0a\x0a    // Compile the template source, escaping string literals appropriately.\x0a    var index = 0;\x0a    var source = \x22__p+=\x27\x22;\x0a    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\x0a      source += text.slice(index, offset).replace(escaper, escapeChar);\x0a      index = offset + match.length;\x0a\x0a      if (escape) {\x0a        source += \x22\x27+\x5cn((__t=(\x22 + escape + \x22))==null?\x27\x27:_.escape(__t))+\x5cn\x27\x22;\x0a      } else if (interpolate) {\x0a        source += \x22\x27+\x5cn((__t=(\x22 + interpolate + \x22))==null?\x27\x27:__t)+\x5cn\x27\x22;\x0a      } else if (evaluate) {\x0a        source += \x22\x27;\x5cn\x22 + evaluate + \x22\x5cn__p+=\x27\x22;\x0a      }\x0a\x0a      // Adobe VMs need the match returned to produce the correct offest.\x0a      return match;\x0a    });\x0a    source += \x22\x27;\x5cn\x22;\x0a\x0a    // If a variable is not specified, place data values in local scope.\x0a    if (!settings.variable) source = \x27with(obj||{}){\x5cn\x27 + source + \x27}\x5cn\x27;\x0a\x0a    source = \x22var __t,__p=\x27\x27,__j=Array.prototype.join,\x22 +\x0a      \x22print=function(){__p+=__j.call(arguments,\x27\x27);};\x5cn\x22 +\x0a      source + \x27return __p;\x5cn\x27;\x0a\x0a    try {\x0a      var render = new Function(settings.variable || \x27obj\x27, \x27_\x27, source);\x0a    } catch (e) {\x0a      e.source = source;\x0a      throw e;\x0a    }\x0a\x0a    var template = function(data) {\x0a      return render.call(this, data, _);\x0a    };\x0a\x0a    // Provide the compiled source as a convenience for precompilation.\x0a    var argument = settings.variable || \x27obj\x27;\x0a    template.source = \x27function(\x27 + argument + \x27){\x5cn\x27 + source + \x27}\x27;\x0a\x0a    return template;\x0a  };\x0a\x0a  // Add a \x22chain\x22 function. Start chaining a wrapped Underscore object.\x0a  _.chain = function(obj) {\x0a    var instance = _(obj);\x0a    instance._chain = true;\x0a    return instance;\x0a  };\x0a\x0a  // OOP\x0a  // ---------------\x0a  // If Underscore is called as a function, it returns a wrapped object that\x0a  // can be used OO-style. This wrapper holds altered versions of all the\x0a  // underscore functions. Wrapped objects may be chained.\x0a\x0a  // Helper function to continue chaining intermediate results.\x0a  var result = function(instance, obj) {\x0a    return instance._chain ? _(obj).chain() : obj;\x0a  };\x0a\x0a  // Add your own custom functions to the Underscore object.\x0a  _.mixin = function(obj) {\x0a    _.each(_.functions(obj), function(name) {\x0a      var func = _[name] = obj[name];\x0a      _.prototype[name] = function() {\x0a        var args = [this._wrapped];\x0a        push.apply(args, arguments);\x0a        return result(this, func.apply(_, args));\x0a      };\x0a    });\x0a  };\x0a\x0a  // Add all of the Underscore functions to the wrapper object.\x0a  _.mixin(_);\x0a\x0a  // Add all mutator Array functions to the wrapper.\x0a  _.each([\x27pop\x27, \x27push\x27, \x27reverse\x27, \x27shift\x27, \x27sort\x27, \x27splice\x27, \x27unshift\x27], function(name) {\x0a    var method = ArrayProto[name];\x0a    _.prototype[name] = function() {\x0a      var obj = this._wrapped;\x0a      method.apply(obj, arguments);\x0a      if ((name === \x27shift\x27 || name === \x27splice\x27) && obj.length === 0) delete obj[0];\x0a      return result(this, obj);\x0a    };\x0a  });\x0a\x0a  // Add all accessor Array functions to the wrapper.\x0a  _.each([\x27concat\x27, \x27join\x27, \x27slice\x27], function(name) {\x0a    var method = ArrayProto[name];\x0a    _.prototype[name] = function() {\x0a      return result(this, method.apply(this._wrapped, arguments));\x0a    };\x0a  });\x0a\x0a  // Extracts the result from a wrapped and chained object.\x0a  _.prototype.value = function() {\x0a    return this._wrapped;\x0a  };\x0a\x0a  // Provide unwrapping proxy for some methods used in engine operations\x0a  // such as arithmetic and JSON stringification.\x0a  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\x0a\x0a  _.prototype.toString = function() {\x0a    return \x27\x27 + this._wrapped;\x0a  };\x0a\x0a  // AMD registration happens at the end for compatibility with AMD loaders\x0a  // that may not enforce next-turn semantics on modules. Even though general\x0a  // practice for AMD registration is to be anonymous, underscore registers\x0a  // as a named module because, like jQuery, it is a base library that is\x0a  // popular enough to be bundled in a third party lib, but not be part of\x0a  // an AMD load request. Those cases could generate an error when an\x0a  // anonymous define() is called outside of a loader request.\x0a  if (typeof define === \x27function\x27 && define.amd) {\x0a    define(\x27underscore\x27, [], function() {\x0a      return _;\x0a    });\x0a  }\x0a}.call(this));\x0a\x91A\x14r\x22\xf0I\x13\x1c\xafe1'}