var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:11:59 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 28 Jun 2018 02:30:15 GMT\x0aETag: \x22822e-56faa82e93bc0-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-8921/8922\x0aContent-Length: 8922\x0aKeep-Alive: timeout=5, max=20\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/**\x0a * @output wp-includes/js/customize-selective-refresh.js\x0a */\x0a\x0a/* global jQuery, JSON, _customizePartialRefreshExports, console */\x0a\x0a/** @namespace wp.customize.selectiveRefresh */\x0awp.customize.selectiveRefresh = ( function( $, api ) {\x0a\x09\x27use strict\x27;\x0a\x09var self, Partial, Placement;\x0a\x0a\x09self = {\x0a\x09\x09ready: $.Deferred(),\x0a\x09\x09editShortcutVisibility: new api.Value(),\x0a\x09\x09data: {\x0a\x09\x09\x09partials: {},\x0a\x09\x09\x09renderQueryVar: \x27\x27,\x0a\x09\x09\x09l10n: {\x0a\x09\x09\x09\x09shiftClickToEdit: \x27\x27\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x09\x09currentRequest: null\x0a\x09};\x0a\x0a\x09_.extend( self, api.Events );\x0a\x0a\x09/**\x0a\x09 * A Customizer Partial.\x0a\x09 *\x0a\x09 * A partial provides a rendering of one or more settings according to a template.\x0a\x09 *\x0a\x09 * @memberOf wp.customize.selectiveRefresh\x0a\x09 *\x0a\x09 * @see PHP class WP_Customize_Partial.\x0a\x09 *\x0a\x09 * @class\x0a\x09 * @augments wp.customize.Class\x0a\x09 * @since 4.5.0\x0a\x09 */\x0a\x09Partial = self.Partial = api.Class.extend(/** @lends wp.customize.SelectiveRefresh.Partial.prototype */{\x0a\x0a\x09\x09id: null,\x0a\x0a\x09\x09/**\x0a\x09\x09 * Default params.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.9.0\x0a\x09\x09 * @var {object}\x0a\x09\x09 */\x0a\x09\x09defaults: {\x0a\x09\x09\x09selector: null,\x0a\x09\x09\x09primarySetting: null,\x0a\x09\x09\x09containerInclusive: false,\x0a\x09\x09\x09fallbackRefresh: true // Note this needs to be false in a front-end editing context.\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Constructor.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @param {string} id                      - Unique identifier for the partial instance.\x0a\x09\x09 * @param {object} options                 - Options hash for the partial instance.\x0a\x09\x09 * @param {string} options.type            - Type of partial (e.g. nav_menu, widget, etc)\x0a\x09\x09 * @param {string} options.selector        - jQuery selector to find the container element in the page.\x0a\x09\x09 * @param {array}  options.settings        - The IDs for the settings the partial relates to.\x0a\x09\x09 * @param {string} options.primarySetting  - The ID for the primary setting the partial renders.\x0a\x09\x09 * @param {bool}   options.fallbackRefresh - Whether to refresh the entire preview in case of a partial refresh failure.\x0a\x09\x09 * @param {object} [options.params]        - Deprecated wrapper for the above properties.\x0a\x09\x09 */\x0a\x09\x09initialize: function( id, options ) {\x0a\x09\x09\x09var partial = this;\x0a\x09\x09\x09options = options || {};\x0a\x09\x09\x09partial.id = id;\x0a\x0a\x09\x09\x09partial.params = _.extend(\x0a\x09\x09\x09\x09{\x0a\x09\x09\x09\x09\x09settings: []\x0a\x09\x09\x09\x09},\x0a\x09\x09\x09\x09partial.defaults,\x0a\x09\x09\x09\x09options.params || options\x0a\x09\x09\x09);\x0a\x0a\x09\x09\x09partial.deferred = {};\x0a\x09\x09\x09partial.deferred.ready = $.Deferred();\x0a\x0a\x09\x09\x09partial.deferred.ready.done( function() {\x0a\x09\x09\x09\x09partial.ready();\x0a\x09\x09\x09} );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Set up the partial.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 */\x0a\x09\x09ready: function() {\x0a\x09\x09\x09var partial = this;\x0a\x09\x09\x09_.each( partial.placements(), function( placement ) {\x0a\x09\x09\x09\x09$( placement.container ).attr( \x27title\x27, self.data.l10n.shiftClickToEdit );\x0a\x09\x09\x09\x09partial.createEditShortcutForPlacement( placement );\x0a\x09\x09\x09} );\x0a\x09\x09\x09$( document ).on( \x27click\x27, partial.params.selector, function( e ) {\x0a\x09\x09\x09\x09if ( ! e.shiftKey ) {\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09e.preventDefault();\x0a\x09\x09\x09\x09_.each( partial.placements(), function( placement ) {\x0a\x09\x09\x09\x09\x09if ( $( placement.container ).is( e.currentTarget ) ) {\x0a\x09\x09\x09\x09\x09\x09partial.showControl();\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09} );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Create and show the edit shortcut for a given partial placement container.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.7.0\x0a\x09\x09 * @access public\x0a\x09\x09 *\x0a\x09\x09 * @param {Placement} placement The placement container element.\x0a\x09\x09 * @returns {void}\x0a\x09\x09 */\x0a\x09\x09createEditShortcutForPlacement: function( placement ) {\x0a\x09\x09\x09var partial = this, $shortcut, $placementContainer, illegalAncestorSelector, illegalContainerSelector;\x0a\x09\x09\x09if ( ! placement.container ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x09\x09\x09$placementContainer = $( placement.container );\x0a\x09\x09\x09illegalAncestorSelector = \x27head\x27;\x0a\x09\x09\x09illegalContainerSelector = \x27area, audio, base, bdi, bdo, br, button, canvas, col, colgroup, command, datalist, embed, head, hr, html, iframe, img, input, keygen, label, link, map, math, menu, meta, noscript, object, optgroup, option, param, progress, rp, rt, ruby, script, select, source, style, svg, table, tbody, textarea, tfoot, thead, title, tr, track, video, wbr\x27;\x0a\x09\x09\x09if ( ! $placementContainer.length || $placementContainer.is( illegalContainerSelector ) || $placementContainer.closest( illegalAncestorSelector ).length ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x09\x09\x09$shortcut = partial.createEditShortcut();\x0a\x09\x09\x09$shortcut.on( \x27click\x27, function( event ) {\x0a\x09\x09\x09\x09event.preventDefault();\x0a\x09\x09\x09\x09event.stopPropagation();\x0a\x09\x09\x09\x09partial.showControl();\x0a\x09\x09\x09} );\x0a\x09\x09\x09partial.addEditShortcutToPlacement( placement, $shortcut );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Add an edit shortcut to the placement container.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.7.0\x0a\x09\x09 * @access public\x0a\x09\x09 *\x0a\x09\x09 * @param {Placement} placement The placement for the partial.\x0a\x09\x09 * @param {jQuery} $editShortcut The shortcut element as a jQuery object.\x0a\x09\x09 * @returns {void}\x0a\x09\x09 */\x0a\x09\x09addEditShortcutToPlacement: function( placement, $editShortcut ) {\x0a\x09\x09\x09var $placementContainer = $( placement.container );\x0a\x09\x09\x09$placementContainer.prepend( $editShortcut );\x0a\x09\x09\x09if ( ! $placementContainer.is( \x27:visible\x27 ) || \x27none\x27 === $placementContainer.css( \x27display\x27 ) ) {\x0a\x09\x09\x09\x09$editShortcut.addClass( \x27customize-partial-edit-shortcut-hidden\x27 );\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Return the unique class name for the edit shortcut button for this partial.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.7.0\x0a\x09\x09 * @access public\x0a\x09\x09 *\x0a\x09\x09 * @return {string} Partial ID converted into a class name for use in shortcut.\x0a\x09\x09 */\x0a\x09\x09getEditShortcutClassName: function() {\x0a\x09\x09\x09var partial = this, cleanId;\x0a\x09\x09\x09cleanId = partial.id.replace( /]/g, \x27\x27 ).replace( /\x5c[/g, \x27-\x27 );\x0a\x09\x09\x09return \x27customize-partial-edit-shortcut-\x27 + cleanId;\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Return the appropriate translated string for the edit shortcut button.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.7.0\x0a\x09\x09 * @access public\x0a\x09\x09 *\x0a\x09\x09 * @return {string} Tooltip for edit shortcut.\x0a\x09\x09 */\x0a\x09\x09getEditShortcutTitle: function() {\x0a\x09\x09\x09var partial = this, l10n = self.data.l10n;\x0a\x09\x09\x09switch ( partial.getType() ) {\x0a\x09\x09\x09\x09case \x27widget\x27:\x0a\x09\x09\x09\x09\x09return l10n.clickEditWidget;\x0a\x09\x09\x09\x09case \x27blogname\x27:\x0a\x09\x09\x09\x09\x09return l10n.clickEditTitle;\x0a\x09\x09\x09\x09case \x27blogdescription\x27:\x0a\x09\x09\x09\x09\x09return l10n.clickEditTitle;\x0a\x09\x09\x09\x09case \x27nav_menu\x27:\x0a\x09\x09\x09\x09\x09return l10n.clickEditMenu;\x0a\x09\x09\x09\x09default:\x0a\x09\x09\x09\x09\x09return l10n.clickEditMisc;\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Return the type of this partial\x0a\x09\x09 *\x0a\x09\x09 * Will use `params.type` if set, but otherwise will try to infer type from settingId.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.7.0\x0a\x09\x09 * @access public\x0a\x09\x09 *\x0a\x09\x09 * @return {string} Type of partial derived from type param or the related setting ID.\x0a\x09\x09 */\x0a\x09\x09getType: function() {\x0a\x09\x09\x09var partial = this, settingId;\x0a\x09\x09\x09settingId = partial.params.primarySetting || _.first( partial.settings() ) || \x27unknown\x27;\x0a\x09\x09\x09if ( partial.params.type ) {\x0a\x09\x09\x09\x09return partial.params.type;\x0a\x09\x09\x09}\x0a\x09\x09\x09if ( settingId.match( /^nav_menu_instance\x5c[/ ) ) {\x0a\x09\x09\x09\x09return \x27nav_menu\x27;\x0a\x09\x09\x09}\x0a\x09\x09\x09if ( settingId.match( /^widget_.+\x5c[\x5cd+]$/ ) ) {\x0a\x09\x09\x09\x09return \x27widget\x27;\x0a\x09\x09\x09}\x0a\x09\x09\x09return settingId;\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Create an edit shortcut button for this partial.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.7.0\x0a\x09\x09 * @access public\x0a\x09\x09 *\x0a\x09\x09 * @return {jQuery} The edit shortcut button element.\x0a\x09\x09 */\x0a\x09\x09createEditShortcut: function() {\x0a\x09\x09\x09var partial = this, shortcutTitle, $buttonContainer, $button, $image;\x0a\x09\x09\x09shortcutTitle = partial.getEditShortcutTitle();\x0a\x09\x09\x09$buttonContainer = $( \x27\x3cspan\x3e\x27, {\x0a\x09\x09\x09\x09\x27class\x27: \x27customize-partial-edit-shortcut \x27 + partial.getEditShortcutClassName()\x0a\x09\x09\x09} );\x0a\x09\x09\x09$button = $( \x27\x3cbutton\x3e\x27, {\x0a\x09\x09\x09\x09\x27aria-label\x27: shortcutTitle,\x0a\x09\x09\x09\x09\x27title\x27: shortcutTitle,\x0a\x09\x09\x09\x09\x27class\x27: \x27customize-partial-edit-shortcut-button\x27\x0a\x09\x09\x09} );\x0a\x09\x09\x09$image = $( \x27\x3csvg xmlns=\x22http://www.w3.org/2000/svg\x22 viewBox=\x220 0 20 20\x22\x3e\x3cpath d=\x22M13.89 3.39l2.71 2.72c.46.46.42 1.24.03 1.64l-8.01 8.02-5.56 1.16 1.16-5.58s7.6-7.63 7.99-8.03c.39-.39 1.22-.39 1.68.07zm-2.73 2.79l-5.59 5.61 1.11 1.11 5.54-5.65zm-2.97 8.23l5.58-5.6-1.07-1.08-5.59 5.6z\x22/\x3e\x3c/svg\x3e\x27 );\x0a\x09\x09\x09$button.append( $image );\x0a\x09\x09\x09$buttonContainer.append( $button );\x0a\x09\x09\x09return $buttonContainer;\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Find all placements for this partial in the document.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @return {Array.\x3cPlacement\x3e}\x0a\x09\x09 */\x0a\x09\x09placements: function() {\x0a\x09\x09\x09var partial = this, selector;\x0a\x0a\x09\x09\x09selector = partial.params.selector || \x27\x27;\x0a\x09\x09\x09if ( selector ) {\x0a\x09\x09\x09\x09selector += \x27, \x27;\x0a\x09\x09\x09}\x0a\x09\x09\x09selector += \x27[data-customize-partial-id=\x22\x27 + partial.id + \x27\x22]\x27; // @todo Consider injecting customize-partial-id-${id} classnames instead.\x0a\x0a\x09\x09\x09return $( selector ).map( function() {\x0a\x09\x09\x09\x09var container = $( this ), context;\x0a\x0a\x09\x09\x09\x09context = container.data( \x27customize-partial-placement-context\x27 );\x0a\x09\x09\x09\x09if ( _.isString( context ) && \x27{\x27 === context.substr( 0, 1 ) ) {\x0a\x09\x09\x09\x09\x09throw new Error( \x27context JSON parse error\x27 );\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09return new Placement( {\x0a\x09\x09\x09\x09\x09partial: partial,\x0a\x09\x09\x09\x09\x09container: container,\x0a\x09\x09\x09\x09\x09context: context\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09} ).get();\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Get list of setting IDs related to this partial.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @return {String[]}\x0a\x09\x09 */\x0a\x09\x09settings: function() {\x0a\x09\x09\x09var partial = this;\x0a\x09\x09\x09if ( partial.params.settings && 0 !== partial.params.settings.length ) {\x0a\x09\x09\x09\x09return partial.params.settings;\x0a\x09\x09\x09} else if ( partial.params.primarySetting ) {\x0a\x09\x09\x09\x09return [ partial.params.primarySetting ];\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09return [ partial.id ];\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Return whether the setting is related to the partial.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @param {wp.customize.Value|string} setting  ID or object for setting.\x0a\x09\x09 * @return {boolean} Whether the setting is related to the partial.\x0a\x09\x09 */\x0a\x09\x09isRelatedSetting: function( setting /*... newValue, oldValue */ ) {\x0a\x09\x09\x09var partial = this;\x0a\x09\x09\x09if ( _.isString( setting ) ) {\x0a\x09\x09\x09\x09setting = api( setting );\x0a\x09\x09\x09}\x0a\x09\x09\x09if ( ! setting ) {\x0a\x09\x09\x09\x09return false;\x0a\x09\x09\x09}\x0a\x09\x09\x09return -1 !== _.indexOf( partial.settings(), setting.id );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Show the control to modify this partial\x27s setting(s).\x0a\x09\x09 *\x0a\x09\x09 * This may be overridden for inline editing.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 */\x0a\x09\x09showControl: function() {\x0a\x09\x09\x09var partial = this, settingId = partial.params.primarySetting;\x0a\x09\x09\x09if ( ! settingId ) {\x0a\x09\x09\x09\x09settingId = _.first( partial.settings() );\x0a\x09\x09\x09}\x0a\x09\x09\x09if ( partial.getType() === \x27nav_menu\x27 ) {\x0a\x09\x09\x09\x09if ( partial.params.navMenuArgs.theme_location ) {\x0a\x09\x09\x09\x09\x09settingId = \x27nav_menu_locations[\x27 + partial.params.navMenuArgs.theme_location + \x27]\x27;\x0a\x09\x09\x09\x09} else if ( partial.params.navMenuArgs.menu )   {\x0a\x09\x09\x09\x09\x09settingId = \x27nav_menu[\x27 + String( partial.params.navMenuArgs.menu ) + \x27]\x27;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x09\x09\x09api.preview.send( \x27focus-control-for-setting\x27, settingId );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Prepare container for selective refresh.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @param {Placement} placement\x0a\x09\x09 */\x0a\x09\x09preparePlacement: function( placement ) {\x0a\x09\x09\x09$( placement.container ).addClass( \x27customize-partial-refreshing\x27 );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Reference to the pending promise returned from self.requestPartial().\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 * @private\x0a\x09\x09 */\x0a\x09\x09_pendingRefreshPromise: null,\x0a\x0a\x09\x09/**\x0a\x09\x09 * Request the new partial and render it into the placements.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @this {wp.customize.selectiveRefresh.Partial}\x0a\x09\x09 * @return {jQuery.Promise}\x0a\x09\x09 */\x0a\x09\x09refresh: function() {\x0a\x09\x09\x09var partial = this, refreshPromise;\x0a\x0a\x09\x09\x09refreshPromise = self.requestPartial( partial );\x0a\x0a\x09\x09\x09if ( ! partial._pendingRefreshPromise ) {\x0a\x09\x09\x09\x09_.each( partial.placements(), function( placement ) {\x0a\x09\x09\x09\x09\x09partial.preparePlacement( placement );\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09refreshPromise.done( function( placements ) {\x0a\x09\x09\x09\x09\x09_.each( placements, function( placement ) {\x0a\x09\x09\x09\x09\x09\x09partial.renderContent( placement );\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09refreshPromise.fail( function( data, placements ) {\x0a\x09\x09\x09\x09\x09partial.fallback( data, placements );\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09// Allow new request when this one finishes.\x0a\x09\x09\x09\x09partial._pendingRefreshPromise = refreshPromise;\x0a\x09\x09\x09\x09refreshPromise.always( function() {\x0a\x09\x09\x09\x09\x09partial._pendingRefreshPromise = null;\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09return refreshPromise;\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Apply the addedContent in the placement to the document.\x0a\x09\x09 *\x0a\x09\x09 * Note the placement object will have its container and removedNodes\x0a\x09\x09 * properties updated.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @param {Placement}             placement\x0a\x09\x09 * @param {Element|jQuery}        [placement.container]  - This param will be empty if there was no element matching the selector.\x0a\x09\x09 * @param {string|object|boolean} placement.addedContent - Rendered HTML content, a data object for JS templates to render, or false if no render.\x0a\x09\x09 * @param {object}                [placement.context]    - Optional context information about the container.\x0a\x09\x09 * @returns {boolean} Whether the rendering was successful and the fallback was not invoked.\x0a\x09\x09 */\x0a\x09\x09renderContent: function( placement ) {\x0a\x09\x09\x09var partial = this, content, newContainerElement;\x0a\x09\x09\x09if ( ! placement.container ) {\x0a\x09\x09\x09\x09partial.fallback( new Error( \x27no_container\x27 ), [ placement ] );\x0a\x09\x09\x09\x09return false;\x0a\x09\x09\x09}\x0a\x09\x09\x09placement.container = $( placement.container );\x0a\x09\x09\x09if ( false === placement.addedContent ) {\x0a\x09\x09\x09\x09partial.fallback( new Error( \x27missing_render\x27 ), [ placement ] );\x0a\x09\x09\x09\x09return false;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Currently a subclass needs to override renderContent to handle partials returning data object.\x0a\x09\x09\x09if ( ! _.isString( placement.addedContent ) ) {\x0a\x09\x09\x09\x09partial.fallback( new Error( \x27non_string_content\x27 ), [ placement ] );\x0a\x09\x09\x09\x09return false;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09/* jshint ignore:start */\x0a\x09\x09\x09self.orginalDocumentWrite = document.write;\x0a\x09\x09\x09document.write = function() {\x0a\x09\x09\x09\x09throw new Error( self.data.l10n.badDocumentWrite );\x0a\x09\x09\x09};\x0a\x09\x09\x09/* jshint ignore:end */\x0a\x09\x09\x09try {\x0a\x09\x09\x09\x09content = placement.addedContent;\x0a\x09\x09\x09\x09if ( wp.emoji && wp.emoji.parse && ! $.contains( document.head, placement.container[0] ) ) {\x0a\x09\x09\x09\x09\x09content = wp.emoji.parse( content );\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09if ( partial.params.containerInclusive ) {\x0a\x0a\x09\x09\x09\x09\x09// Note that content may be an empty string, and in this case jQuery will just remove the oldContainer\x0a\x09\x09\x09\x09\x09newContainerElement = $( content );\x0a\x0a\x09\x09\x09\x09\x09// Merge the new context on top of the old context.\x0a\x09\x09\x09\x09\x09placement.context = _.extend(\x0a\x09\x09\x09\x09\x09\x09placement.context,\x0a\x09\x09\x09\x09\x09\x09newContainerElement.data( \x27customize-partial-placement-context\x27 ) || {}\x0a\x09\x09\x09\x09\x09);\x0a\x09\x09\x09\x09\x09newContainerElement.data( \x27customize-partial-placement-context\x27, placement.context );\x0a\x0a\x09\x09\x09\x09\x09placement.removedNodes = placement.container;\x0a\x09\x09\x09\x09\x09placement.container = newContainerElement;\x0a\x09\x09\x09\x09\x09placement.removedNodes.replaceWith( placement.container );\x0a\x09\x09\x09\x09\x09placement.container.attr( \x27title\x27, self.data.l10n.shiftClickToEdit );\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09placement.removedNodes = document.createDocumentFragment();\x0a\x09\x09\x09\x09\x09while ( placement.container[0].firstChild ) {\x0a\x09\x09\x09\x09\x09\x09placement.removedNodes.appendChild( placement.container[0].firstChild );\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09placement.container.html( content );\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09placement.container.removeClass( \x27customize-render-content-error\x27 );\x0a\x09\x09\x09} catch ( error ) {\x0a\x09\x09\x09\x09if ( \x27undefined\x27 !== typeof console && console.error ) {\x0a\x09\x09\x09\x09\x09console.error( partial.id, error );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09partial.fallback( error, [ placement ] );\x0a\x09\x09\x09}\x0a\x09\x09\x09/* jshint ignore:start */\x0a\x09\x09\x09document.write = self.orginalDocumentWrite;\x0a\x09\x09\x09self.orginalDocumentWrite = null;\x0a\x09\x09\x09/* jshint ignore:end */\x0a\x0a\x09\x09\x09partial.createEditShortcutForPlacement( placement );\x0a\x09\x09\x09placement.container.removeClass( \x27customize-partial-refreshing\x27 );\x0a\x0a\x09\x09\x09// Prevent placement container from being re-triggered as being rendered among nested partials.\x0a\x09\x09\x09placement.container.data( \x27customize-partial-content-rendered\x27, true );\x0a\x0a\x09\x09\x09/*\x0a\x09\x09\x09 * Note that the \x27wp_audio_shortcode_library\x27 and \x27wp_video_shortcode_library\x27 filters\x0a\x09\x09\x09 * will determine whether or not wp.mediaelement is loaded and whether it will\x0a\x09\x09\x09 * initialize audio and video respectively. See also https://core.trac.wordpress.org/ticket/40144\x0a\x09\x09\x09 */\x0a\x09\x09\x09if ( wp.mediaelement ) {\x0a\x09\x09\x09\x09wp.mediaelement.initialize();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if ( wp.playlist ) {\x0a\x09\x09\x09\x09wp.playlist.initialize();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Announce when a partial\x27s placement has been rendered so that dynamic elements can be re-built.\x0a\x09\x09\x09 */\x0a\x09\x09\x09self.trigger( \x27partial-content-rendered\x27, placement );\x0a\x09\x09\x09return true;\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Handle fail to render partial.\x0a\x09\x09 *\x0a\x09\x09 * The first argument is either the failing jqXHR or an Error object, and the second argument is the array of containers.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 */\x0a\x09\x09fallback: function() {\x0a\x09\x09\x09var partial = this;\x0a\x09\x09\x09if ( partial.params.fallbackRefresh ) {\x0a\x09\x09\x09\x09self.requestFullRefresh();\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09} );\x0a\x0a\x09/**\x0a\x09 * A Placement for a Partial.\x0a\x09 *\x0a\x09 * A partial placement is the actual physical representation of a partial for a given context.\x0a\x09 * It also may have information in relation to how a placement may have just changed.\x0a\x09 * The placement is conceptually similar to a DOM Range or MutationRecord.\x0a\x09 *\x0a\x09 * @memberOf wp.customize.selectiveRefresh\x0a\x09 *\x0a\x09 * @class Placement\x0a\x09 * @augments wp.customize.Class\x0a\x09 * @since 4.5.0\x0a\x09 */\x0a\x09self.Placement = Placement = api.Class.extend(/** @lends wp.customize.selectiveRefresh.prototype */{\x0a\x0a\x09\x09/**\x0a\x09\x09 * The partial with which the container is associated.\x0a\x09\x09 *\x0a\x09\x09 * @param {wp.customize.selectiveRefresh.Partial}\x0a\x09\x09 */\x0a\x09\x09partial: null,\x0a\x0a\x09\x09/**\x0a\x09\x09 * DOM element which contains the placement\x27s contents.\x0a\x09\x09 *\x0a\x09\x09 * This will be null if the startNode and endNode do not point to the same\x0a\x09\x09 * DOM element, such as in the case of a sidebar partial.\x0a\x09\x09 * This container element itself will be replaced for partials that\x0a\x09\x09 * have containerInclusive param defined as true.\x0a\x09\x09 */\x0a\x09\x09container: null,\x0a\x0a\x09\x09/**\x0a\x09\x09 * DOM node for the initial boundary of the placement.\x0a\x09\x09 *\x0a\x09\x09 * This will normally be the same as endNode since most placements appear as elements.\x0a\x09\x09 * This is primarily useful for widget sidebars which do not have intrinsic containers, but\x0a\x09\x09 * for which an HTML comment is output before to mark the starting position.\x0a\x09\x09 */\x0a\x09\x09startNode: null,\x0a\x0a\x09\x09/**\x0a\x09\x09 * DOM node for the terminal boundary of the placement.\x0a\x09\x09 *\x0a\x09\x09 * This will normally be the same as startNode since most placements appear as elements.\x0a\x09\x09 * This is primarily useful for widget sidebars which do not have intrinsic containers, but\x0a\x09\x09 * for which an HTML comment is output before to mark the ending position.\x0a\x09\x09 */\x0a\x09\x09endNode: null,\x0a\x0a\x09\x09/**\x0a\x09\x09 * Context data.\x0a\x09\x09 *\x0a\x09\x09 * This provides information about the placement which is included in the request\x0a\x09\x09 * in order to render the partial properly.\x0a\x09\x09 *\x0a\x09\x09 * @param {object}\x0a\x09\x09 */\x0a\x09\x09context: null,\x0a\x0a\x09\x09/**\x0a\x09\x09 * The content for the partial when refreshed.\x0a\x09\x09 *\x0a\x09\x09 * @param {string}\x0a\x09\x09 */\x0a\x09\x09addedContent: null,\x0a\x0a\x09\x09/**\x0a\x09\x09 * DOM node(s) removed when the partial is refreshed.\x0a\x09\x09 *\x0a\x09\x09 * If the partial is containerInclusive, then the removedNodes will be\x0a\x09\x09 * the single Element that was the partial\x27s former placement. If the\x0a\x09\x09 * partial is not containerInclusive, then the removedNodes will be a\x0a\x09\x09 * documentFragment containing the nodes removed.\x0a\x09\x09 *\x0a\x09\x09 * @param {Element|DocumentFragment}\x0a\x09\x09 */\x0a\x09\x09removedNodes: null,\x0a\x0a\x09\x09/**\x0a\x09\x09 * Constructor.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @param {object}                   args\x0a\x09\x09 * @param {Partial}                  args.partial\x0a\x09\x09 * @param {jQuery|Element}           [args.container]\x0a\x09\x09 * @param {Node}                     [args.startNode]\x0a\x09\x09 * @param {Node}                     [args.endNode]\x0a\x09\x09 * @param {object}                   [args.context]\x0a\x09\x09 * @param {string}                   [args.addedContent]\x0a\x09\x09 * @param {jQuery|DocumentFragment}  [args.removedNodes]\x0a\x09\x09 */\x0a\x09\x09initialize: function( args ) {\x0a\x09\x09\x09var placement = this;\x0a\x0a\x09\x09\x09args = _.extend( {}, args || {} );\x0a\x09\x09\x09if ( ! args.partial || ! args.partial.extended( Partial ) ) {\x0a\x09\x09\x09\x09throw new Error( \x27Missing partial\x27 );\x0a\x09\x09\x09}\x0a\x09\x09\x09args.context = args.context || {};\x0a\x09\x09\x09if ( args.container ) {\x0a\x09\x09\x09\x09args.container = $( args.container );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09_.extend( placement, args );\x0a\x09\x09}\x0a\x0a\x09});\x0a\x0a\x09/**\x0a\x09 * Mapping of type names to Partial constructor subclasses.\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 *\x0a\x09 * @type {Object.\x3cstring, wp.customize.selectiveRefresh.Partial\x3e}\x0a\x09 */\x0a\x09self.partialConstructor = {};\x0a\x0a\x09self.partial = new api.Values({ defaultConstructor: Partial });\x0a\x0a\x09/**\x0a\x09 * Get the POST vars for a Customizer preview request.\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 * @see wp.customize.previewer.query()\x0a\x09 *\x0a\x09 * @return {object}\x0a\x09 */\x0a\x09self.getCustomizeQuery = function() {\x0a\x09\x09var dirtyCustomized = {};\x0a\x09\x09api.each( function( value, key ) {\x0a\x09\x09\x09if ( value._dirty ) {\x0a\x09\x09\x09\x09dirtyCustomized[ key ] = value();\x0a\x09\x09\x09}\x0a\x09\x09} );\x0a\x0a\x09\x09return {\x0a\x09\x09\x09wp_customize: \x27on\x27,\x0a\x09\x09\x09nonce: api.settings.nonce.preview,\x0a\x09\x09\x09customize_theme: api.settings.theme.stylesheet,\x0a\x09\x09\x09customized: JSON.stringify( dirtyCustomized ),\x0a\x09\x09\x09customize_changeset_uuid: api.settings.changeset.uuid\x0a\x09\x09};\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Currently-requested partials and their associated deferreds.\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 * @type {Object\x3cstring, { deferred: jQuery.Promise, partial: wp.customize.selectiveRefresh.Partial }\x3e}\x0a\x09 */\x0a\x09self._pendingPartialRequests = {};\x0a\x0a\x09/**\x0a\x09 * Timeout ID for the current requesr, or null if no request is current.\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 * @type {number|null}\x0a\x09 * @private\x0a\x09 */\x0a\x09self._debouncedTimeoutId = null;\x0a\x0a\x09/**\x0a\x09 * Current jqXHR for the request to the partials.\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 * @type {jQuery.jqXHR|null}\x0a\x09 * @private\x0a\x09 */\x0a\x09self._currentRequest = null;\x0a\x0a\x09/**\x0a\x09 * Request full page refresh.\x0a\x09 *\x0a\x09 * When selective refresh is embedded in the context of front-end editing, this request\x0a\x09 * must fail or else changes will be lost, unless transactions are implemented.\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 */\x0a\x09self.requestFullRefresh = function() {\x0a\x09\x09api.preview.send( \x27refresh\x27 );\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Request a re-rendering of a partial.\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 *\x0a\x09 * @param {wp.customize.selectiveRefresh.Partial} partial\x0a\x09 * @return {jQuery.Promise}\x0a\x09 */\x0a\x09self.requestPartial = function( partial ) {\x0a\x09\x09var partialRequest;\x0a\x0a\x09\x09if ( self._debouncedTimeoutId ) {\x0a\x09\x09\x09clearTimeout( self._debouncedTimeoutId );\x0a\x09\x09\x09self._debouncedTimeoutId = null;\x0a\x09\x09}\x0a\x09\x09if ( self._currentRequest ) {\x0a\x09\x09\x09self._currentRequest.abort();\x0a\x09\x09\x09self._currentRequest = null;\x0a\x09\x09}\x0a\x0a\x09\x09partialRequest = self._pendingPartialRequests[ partial.id ];\x0a\x09\x09if ( ! partialRequest || \x27pending\x27 !== partialRequest.deferred.state() ) {\x0a\x09\x09\x09partialRequest = {\x0a\x09\x09\x09\x09deferred: $.Deferred(),\x0a\x09\x09\x09\x09partial: partial\x0a\x09\x09\x09};\x0a\x09\x09\x09self._pendingPartialRequests[ partial.id ] = partialRequest;\x0a\x09\x09}\x0a\x0a\x09\x09// Prevent leaking partial into debounced timeout callback.\x0a\x09\x09partial = null;\x0a\x0a\x09\x09self._debouncedTimeoutId = setTimeout(\x0a\x09\x09\x09function() {\x0a\x09\x09\x09\x09var data, partialPlacementContexts, partialsPlacements, request;\x0a\x0a\x09\x09\x09\x09self._debouncedTimeoutId = null;\x0a\x09\x09\x09\x09data = self.getCustomizeQuery();\x0a\x0a\x09\x09\x09\x09/*\x0a\x09\x09\x09\x09 * It is key that the containers be fetched exactly at the point of the request being\x0a\x09\x09\x09\x09 * made, because the containers need to be mapped to responses by array indices.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09partialsPlacements = {};\x0a\x0a\x09\x09\x09\x09partialPlacementContexts = {};\x0a\x0a\x09\x09\x09\x09_.each( self._pendingPartialRequests, function( pending, partialId ) {\x0a\x09\x09\x09\x09\x09partialsPlacements[ partialId ] = pending.partial.placements();\x0a\x09\x09\x09\x09\x09if ( ! self.partial.has( partialId ) ) {\x0a\x09\x09\x09\x09\x09\x09pending.deferred.rejectWith( pending.partial, [ new Error( \x27partial_removed\x27 ), partialsPlacements[ partialId ] ] );\x0a\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09/*\x0a\x09\x09\x09\x09\x09\x09 * Note that this may in fact be an empty array. In that case, it is the responsibility\x0a\x09\x09\x09\x09\x09\x09 * of the Partial subclass instance to know where to inject the response, or else to\x0a\x09\x09\x09\x09\x09\x09 * just issue a refresh (default behavior). The data being returned with each container\x0a\x09\x09\x09\x09\x09\x09 * is the context information that may be needed to render certain partials, such as\x0a\x09\x09\x09\x09\x09\x09 * the contained sidebar for rendering widgets or what the nav menu args are for a menu.\x0a\x09\x09\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09\x09\x09partialPlacementContexts[ partialId ] = _.map( partialsPlacements[ partialId ], function( placement ) {\x0a\x09\x09\x09\x09\x09\x09\x09return placement.context || {};\x0a\x09\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09data.partials = JSON.stringify( partialPlacementContexts );\x0a\x09\x09\x09\x09data[ self.data.renderQueryVar ] = \x271\x27;\x0a\x0a\x09\x09\x09\x09request = self._currentRequest = wp.ajax.send( null, {\x0a\x09\x09\x09\x09\x09data: data,\x0a\x09\x09\x09\x09\x09url: api.settings.url.self\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09request.done( function( data ) {\x0a\x0a\x09\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09\x09 * Announce the data returned from a request to render partials.\x0a\x09\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09\x09 * The data is filtered on the server via customize_render_partials_response\x0a\x09\x09\x09\x09\x09 * so plugins can inject data from the server to be utilized\x0a\x09\x09\x09\x09\x09 * on the client via this event. Plugins may use this filter\x0a\x09\x09\x09\x09\x09 * to communicate script and style dependencies that need to get\x0a\x09\x09\x09\x09\x09 * injected into the page to support the rendered partials.\x0a\x09\x09\x09\x09\x09 * This is similar to the \x27saved\x27 event.\x0a\x09\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09\x09self.trigger( \x27render-partials-response\x27, data );\x0a\x0a\x09\x09\x09\x09\x09// Relay errors (warnings) captured during rendering and relay to console.\x0a\x09\x09\x09\x09\x09if ( data.errors && \x27undefined\x27 !== typeof console && console.warn ) {\x0a\x09\x09\x09\x09\x09\x09_.each( data.errors, function( error ) {\x0a\x09\x09\x09\x09\x09\x09\x09console.warn( error );\x0a\x09\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09/*\x0a\x09\x09\x09\x09\x09 * Note that data is an array of items that correspond to the array of\x0a\x09\x09\x09\x09\x09 * containers that were submitted in the request. So we zip up the\x0a\x09\x09\x09\x09\x09 * array of containers with the array of contents for those containers,\x0a\x09\x09\x09\x09\x09 * and send them into .\x0a\x09\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09\x09_.each( self._pendingPartialRequests, function( pending, partialId ) {\x0a\x09\x09\x09\x09\x09\x09var placementsContents;\x0a\x09\x09\x09\x09\x09\x09if ( ! _.isArray( data.contents[ partialId ] ) ) {\x0a\x09\x09\x09\x09\x09\x09\x09pending.deferred.rejectWith( pending.partial, [ new Error( \x27unrecognized_partial\x27 ), partialsPlacements[ partialId ] ] );\x0a\x09\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09\x09placementsContents = _.map( data.contents[ partialId ], function( content, i ) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09var partialPlacement = partialsPlacements[ partialId ][ i ];\x0a\x09\x09\x09\x09\x09\x09\x09\x09if ( partialPlacement ) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09partialPlacement.addedContent = content;\x0a\x09\x09\x09\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09partialPlacement = new Placement( {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09\x09partial: pending.partial,\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09\x09addedContent: content\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09\x09\x09return partialPlacement;\x0a\x09\x09\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09\x09\x09\x09pending.deferred.resolveWith( pending.partial, [ placementsContents ] );\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09\x09self._pendingPartialRequests = {};\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09request.fail( function( data, statusText ) {\x0a\x0a\x09\x09\x09\x09\x09/*\x0a\x09\x09\x09\x09\x09 * Ignore failures caused by partial.currentRequest.abort()\x0a\x09\x09\x09\x09\x09 * The pending deferreds will remain in self._pendingPartialRequests\x0a\x09\x09\x09\x09\x09 * for re-use with the next request.\x0a\x09\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09\x09if ( \x27abort\x27 === statusText ) {\x0a\x09\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09_.each( self._pendingPartialRequests, function( pending, partialId ) {\x0a\x09\x09\x09\x09\x09\x09pending.deferred.rejectWith( pending.partial, [ data, partialsPlacements[ partialId ] ] );\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09\x09self._pendingPartialRequests = {};\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09},\x0a\x09\x09\x09api.settings.timeouts.selectiveRefresh\x0a\x09\x09);\x0a\x0a\x09\x09return partialRequest.deferred.promise();\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Add partials for any nav menu container elements in the document.\x0a\x09 *\x0a\x09 * This method may be called multiple times. Containers that already have been\x0a\x09 * seen will be skipped.\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 *\x0a\x09 * @param {jQuery|HTMLElement} [rootElement]\x0a\x09 * @param {object}             [options]\x0a\x09 * @param {boolean=true}       [options.triggerRendered]\x0a\x09 */\x0a\x09self.addPartials = function( rootElement, options ) {\x0a\x09\x09var containerElements;\x0a\x09\x09if ( ! rootElement ) {\x0a\x09\x09\x09rootElement = document.documentElement;\x0a\x09\x09}\x0a\x09\x09rootElement = $( rootElement );\x0a\x09\x09options = _.extend(\x0a\x09\x09\x09{\x0a\x09\x09\x09\x09triggerRendered: true\x0a\x09\x09\x09},\x0a\x09\x09\x09options || {}\x0a\x09\x09);\x0a\x0a\x09\x09containerElements = rootElement.find( \x27[data-customize-partial-id]\x27 );\x0a\x09\x09if ( rootElement.is( \x27[data-customize-partial-id]\x27 ) ) {\x0a\x09\x09\x09containerElements = containerElements.add( rootElement );\x0a\x09\x09}\x0a\x09\x09containerElements.each( function() {\x0a\x09\x09\x09var containerElement = $( this ), partial, placement, id, Constructor, partialOptions, containerContext;\x0a\x09\x09\x09id = containerElement.data( \x27customize-partial-id\x27 );\x0a\x09\x09\x09if ( ! id ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x09\x09\x09containerContext = containerElement.data( \x27customize-partial-placement-context\x27 ) || {};\x0a\x0a\x09\x09\x09partial = self.partial( id );\x0a\x09\x09\x09if ( ! partial ) {\x0a\x09\x09\x09\x09partialOptions = containerElement.data( \x27customize-partial-options\x27 ) || {};\x0a\x09\x09\x09\x09partialOptions.constructingContainerContext = containerElement.data( \x27customize-partial-placement-context\x27 ) || {};\x0a\x09\x09\x09\x09Constructor = self.partialConstructor[ containerElement.data( \x27customize-partial-type\x27 ) ] || self.Partial;\x0a\x09\x09\x09\x09partial = new Constructor( id, partialOptions );\x0a\x09\x09\x09\x09self.partial.add( partial );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09/*\x0a\x09\x09\x09 * Only trigger renders on (nested) partials that have been not been\x0a\x09\x09\x09 * handled yet. An example where this would apply is a nav menu\x0a\x09\x09\x09 * embedded inside of a navigation menu widget. When the widget\x27s title\x0a\x09\x09\x09 * is updated, the entire widget will re-render and then the event\x0a\x09\x09\x09 * will be triggered for the nested nav menu to do any initialization.\x0a\x09\x09\x09 */\x0a\x09\x09\x09if ( options.triggerRendered && ! containerElement.data( \x27customize-partial-content-rendered\x27 ) ) {\x0a\x0a\x09\x09\x09\x09placement = new Placement( {\x0a\x09\x09\x09\x09\x09partial: partial,\x0a\x09\x09\x09\x09\x09context: containerContext,\x0a\x09\x09\x09\x09\x09container: containerElement\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09$( placement.container ).attr( \x27title\x27, self.data.l10n.shiftClickToEdit );\x0a\x09\x09\x09\x09partial.createEditShortcutForPlacement( placement );\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Announce when a partial\x27s nested placement has been re-rendered.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09self.trigger( \x27partial-content-rendered\x27, placement );\x0a\x09\x09\x09}\x0a\x09\x09\x09containerElement.data( \x27customize-partial-content-rendered\x27, true );\x0a\x09\x09} );\x0a\x09};\x0a\x0a\x09api.bind( \x27preview-ready\x27, function() {\x0a\x09\x09var handleSettingChange, watchSettingChange, unwatchSettingChange;\x0a\x0a\x09\x09_.extend( self.data, _customizePartialRefreshExports );\x0a\x0a\x09\x09// Create the partial JS models.\x0a\x09\x09_.each( self.data.partials, function( data, id ) {\x0a\x09\x09\x09var Constructor, partial = self.partial( id );\x0a\x09\x09\x09if ( ! partial ) {\x0a\x09\x09\x09\x09Constructor = self.partialConstructor[ data.type ] || self.Partial;\x0a\x09\x09\x09\x09partial = new Constructor(\x0a\x09\x09\x09\x09\x09id,\x0a\x09\x09\x09\x09\x09_.extend( { params: data }, data ) // Inclusion of params alias is for back-compat for custom partials that expect to augment this property.\x0a\x09\x09\x09\x09);\x0a\x09\x09\x09\x09self.partial.add( partial );\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09_.extend( partial.params, data );\x0a\x09\x09\x09}\x0a\x09\x09} );\x0a\x0a\x09\x09/**\x0a\x09\x09 * Handle change to a setting.\x0a\x09\x09 *\x0a\x09\x09 * Note this is largely needed because adding a \x27change\x27 event handler to wp.customize\x0a\x09\x09 * will only include the changed setting object as an argument, not including the\x0a\x09\x09 * new value or the old value.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 * @this {wp.customize.Setting}\x0a\x09\x09 *\x0a\x09\x09 * @param {*|null} newValue New value, or null if the setting was just removed.\x0a\x09\x09 * @param {*|null} oldValue Old value, or null if the setting was just added.\x0a\x09\x09 */\x0a\x09\x09handleSettingChange = function( newValue, oldValue ) {\x0a\x09\x09\x09var setting = this;\x0a\x09\x09\x09self.partial.each( function( partial ) {\x0a\x09\x09\x09\x09if ( partial.isRelatedSetting( setting, newValue, oldValue ) ) {\x0a\x09\x09\x09\x09\x09partial.refresh();\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09} );\x0a\x09\x09};\x0a\x0a\x09\x09/**\x0a\x09\x09 * Trigger the initial change for the added setting, and watch for changes.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 * @this {wp.customize.Values}\x0a\x09\x09 *\x0a\x09\x09 * @param {wp.customize.Setting} setting\x0a\x09\x09 */\x0a\x09\x09watchSettingChange = function( setting ) {\x0a\x09\x09\x09handleSettingChange.call( setting, setting(), null );\x0a\x09\x09\x09setting.bind( handleSettingChange );\x0a\x09\x09};\x0a\x0a\x09\x09/**\x0a\x09\x09 * Trigger the final change for the removed setting, and unwatch for changes.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 * @this {wp.customize.Values}\x0a\x09\x09 *\x0a\x09\x09 * @param {wp.customize.Setting} setting\x0a\x09\x09 */\x0a\x09\x09unwatchSettingChange = function( setting ) {\x0a\x09\x09\x09handleSettingChange.call( setting, null, setting() );\x0a\x09\x09\x09setting.unbind( handleSettingChange );\x0a\x09\x09};\x0a\x0a\x09\x09api.bind( \x27add\x27, watchSettingChange );\x0a\x09\x09api.bind( \x27remove\x27, unwatchSettingChange );\x0a\x09\x09api.each( function( setting ) {\x0a\x09\x09\x09setting.bind( handleSettingChange );\x0a\x09\x09} );\x0a\x0a\x09\x09// Add (dynamic) initial partials that are declared via data-* attributes.\x0a\x09\x09self.addPartials( document.documentElement, {\x0a\x09\x09\x09triggerRendered: false\x0a\x09\x09} );\x0a\x0a\x09\x09// Add new dynamic partials when the document changes.\x0a\x09\x09if ( \x27undefined\x27 !== typeof MutationObserver ) {\x0a\x09\x09\x09self.mutationObserver = new MutationObserver( function( mutations ) {\x0a\x09\x09\x09\x09_.each( mutations, function( mutation ) {\x0a\x09\x09\x09\x09\x09self.addPartials( $( mutation.target ) );\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09} );\x0a\x09\x09\x09self.mutationObserver.observe( document.documentElement, {\x0a\x09\x09\x09\x09childList: true,\x0a\x09\x09\x09\x09subtree: true\x0a\x09\x09\x09} );\x0a\x09\x09}\x0a\x0a\x09\x09/**\x0a\x09\x09 * Handle rendering of partials.\x0a\x09\x09 *\x0a\x09\x09 * @param {api.selectiveRefresh.Placement} placement\x0a\x09\x09 */\x0a\x09\x09api.selectiveRefresh.bind( \x27partial-content-rendered\x27, function( placement ) {\x0a\x09\x09\x09if ( placement.container ) {\x0a\x09\x09\x09\x09self.addPartials( placement.container );\x0a\x09\x09\x09}\x0a\x09\x09} );\x0a\x0a\x09\x09/**\x0a\x09\x09 * Handle setting validities in partial refresh response.\x0a\x09\x09 *\x0a\x09\x09 * @param {object} data Response data.\x0a\x09\x09 * @param {object} data.setting_validities Setting validities.\x0a\x09\x09 */\x0a\x09\x09api.selectiveRefresh.bind( \x27render-partials-response\x27, function handleSettingValiditiesResponse( data ) {\x0a\x09\x09\x09if ( data.setting_validities ) {\x0a\x09\x09\x09\x09api.preview.send( \x27selective-refresh-setting-validities\x27, data.setting_validities );\x0a\x09\x09\x09}\x0a\x09\x09} );\x0a\x0a\x09\x09api.preview.bind( \x27edit-shortcut-visibility\x27, function( visibility ) {\x0a\x09\x09\x09api.selectiveRefresh.editShortcutVisibility.set( visibility );\x0a\x09\x09} );\x0a\x09\x09api.selectiveRefresh.editShortcutVisibility.bind( function( visibility ) {\x0a\x09\x09\x09var body = $( document.body ), shouldAnimateHide;\x0a\x0a\x09\x09\x09shouldAnimateHide = ( \x27hidden\x27 === visibility && body.hasClass( \x27customize-partial-edit-shortcuts-shown\x27 ) && ! body.hasClass( \x27customize-partial-edit-shortcuts-hidden\x27 ) );\x0a\x09\x09\x09body.toggleClass( \x27customize-partial-edit-shortcuts-hidden\x27, shouldAnimateHide );\x0a\x09\x09\x09body.toggleClass( \x27customize-partial-edit-shortcuts-shown\x27, \x27visible\x27 === visibility );\x0a\x09\x09} );\x0a\x0a\x09\x09api.preview.bind( \x27active\x27, function() {\x0a\x0a\x09\x09\x09// Make all partials ready.\x0a\x09\x09\x09self.partial.each( function( partial ) {\x0a\x09\x09\x09\x09partial.deferred.ready.resolve();\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09// Make all partials added henceforth as ready upon add.\x0a\x09\x09\x09self.partial.bind( \x27add\x27, function( partial ) {\x0a\x09\x09\x09\x09partial.deferred.ready.resolve();\x0a\x09\x09\x09} );\x0a\x09\x09} );\x0a\x0a\x09} );\x0a\x0a\x09return self;\x0a}( jQuery, wp.customize ) );\x0a'}