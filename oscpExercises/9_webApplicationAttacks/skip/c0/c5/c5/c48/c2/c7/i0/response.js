var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:12:22 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Tue, 23 Jan 2018 01:29:32 GMT\x0aETag: \x224520d-563677a86f700-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-44179/44180\x0aContent-Length: 44180\x0aKeep-Alive: timeout=5, max=97\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a(function webpackUniversalModuleDefinition(root, factory) {\x0a/* istanbul ignore next */\x0a\x09if(typeof exports === \x27object\x27 && typeof module === \x27object\x27)\x0a\x09\x09module.exports = factory();\x0a\x09else if(typeof define === \x27function\x27 && define.amd)\x0a\x09\x09define([], factory);\x0a/* istanbul ignore next */\x0a\x09else if(typeof exports === \x27object\x27)\x0a\x09\x09exports[\x22esprima\x22] = factory();\x0a\x09else\x0a\x09\x09root[\x22esprima\x22] = factory();\x0a})(this, function() {\x0areturn /******/ (function(modules) { // webpackBootstrap\x0a/******/ \x09// The module cache\x0a/******/ \x09var installedModules = {};\x0a\x0a/******/ \x09// The require function\x0a/******/ \x09function __webpack_require__(moduleId) {\x0a\x0a/******/ \x09\x09// Check if module is in cache\x0a/* istanbul ignore if */\x0a/******/ \x09\x09if(installedModules[moduleId])\x0a/******/ \x09\x09\x09return installedModules[moduleId].exports;\x0a\x0a/******/ \x09\x09// Create a new module (and put it into the cache)\x0a/******/ \x09\x09var module = installedModules[moduleId] = {\x0a/******/ \x09\x09\x09exports: {},\x0a/******/ \x09\x09\x09id: moduleId,\x0a/******/ \x09\x09\x09loaded: false\x0a/******/ \x09\x09};\x0a\x0a/******/ \x09\x09// Execute the module function\x0a/******/ \x09\x09modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\x0a\x0a/******/ \x09\x09// Flag the module as loaded\x0a/******/ \x09\x09module.loaded = true;\x0a\x0a/******/ \x09\x09// Return the exports of the module\x0a/******/ \x09\x09return module.exports;\x0a/******/ \x09}\x0a\x0a\x0a/******/ \x09// expose the modules object (__webpack_modules__)\x0a/******/ \x09__webpack_require__.m = modules;\x0a\x0a/******/ \x09// expose the module cache\x0a/******/ \x09__webpack_require__.c = installedModules;\x0a\x0a/******/ \x09// __webpack_public_path__\x0a/******/ \x09__webpack_require__.p = \x22\x22;\x0a\x0a/******/ \x09// Load entry module and return exports\x0a/******/ \x09return __webpack_require__(0);\x0a/******/ })\x0a/************************************************************************/\x0a/******/ ([\x0a/* 0 */\x0a/***/ function(module, exports, __webpack_require__) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09/*\x0a\x09  Copyright JS Foundation and other contributors, https://js.foundation/\x0a\x0a\x09  Redistribution and use in source and binary forms, with or without\x0a\x09  modification, are permitted provided that the following conditions are met:\x0a\x0a\x09    * Redistributions of source code must retain the above copyright\x0a\x09      notice, this list of conditions and the following disclaimer.\x0a\x09    * Redistributions in binary form must reproduce the above copyright\x0a\x09      notice, this list of conditions and the following disclaimer in the\x0a\x09      documentation and/or other materials provided with the distribution.\x0a\x0a\x09  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \x22AS IS\x22\x0a\x09  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\x0a\x09  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\x0a\x09  ARE DISCLAIMED. IN NO EVENT SHALL \x3cCOPYRIGHT HOLDER\x3e BE LIABLE FOR ANY\x0a\x09  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\x0a\x09  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\x0a\x09  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\x0a\x09  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\x0a\x09  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\x0a\x09  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\x0a\x09*/\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09var comment_handler_1 = __webpack_require__(1);\x0a\x09var jsx_parser_1 = __webpack_require__(3);\x0a\x09var parser_1 = __webpack_require__(8);\x0a\x09var tokenizer_1 = __webpack_require__(15);\x0a\x09function parse(code, options, delegate) {\x0a\x09    var commentHandler = null;\x0a\x09    var proxyDelegate = function (node, metadata) {\x0a\x09        if (delegate) {\x0a\x09            delegate(node, metadata);\x0a\x09        }\x0a\x09        if (commentHandler) {\x0a\x09            commentHandler.visit(node, metadata);\x0a\x09        }\x0a\x09    };\x0a\x09    var parserDelegate = (typeof delegate === \x27function\x27) ? proxyDelegate : null;\x0a\x09    var collectComment = false;\x0a\x09    if (options) {\x0a\x09        collectComment = (typeof options.comment === \x27boolean\x27 && options.comment);\x0a\x09        var attachComment = (typeof options.attachComment === \x27boolean\x27 && options.attachComment);\x0a\x09        if (collectComment || attachComment) {\x0a\x09            commentHandler = new comment_handler_1.CommentHandler();\x0a\x09            commentHandler.attach = attachComment;\x0a\x09            options.comment = true;\x0a\x09            parserDelegate = proxyDelegate;\x0a\x09        }\x0a\x09    }\x0a\x09    var isModule = false;\x0a\x09    if (options && typeof options.sourceType === \x27string\x27) {\x0a\x09        isModule = (options.sourceType === \x27module\x27);\x0a\x09    }\x0a\x09    var parser;\x0a\x09    if (options && typeof options.jsx === \x27boolean\x27 && options.jsx) {\x0a\x09        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);\x0a\x09    }\x0a\x09    else {\x0a\x09        parser = new parser_1.Parser(code, options, parserDelegate);\x0a\x09    }\x0a\x09    var program = isModule ? parser.parseModule() : parser.parseScript();\x0a\x09    var ast = program;\x0a\x09    if (collectComment && commentHandler) {\x0a\x09        ast.comments = commentHandler.comments;\x0a\x09    }\x0a\x09    if (parser.config.tokens) {\x0a\x09        ast.tokens = parser.tokens;\x0a\x09    }\x0a\x09    if (parser.config.tolerant) {\x0a\x09        ast.errors = parser.errorHandler.errors;\x0a\x09    }\x0a\x09    return ast;\x0a\x09}\x0a\x09exports.parse = parse;\x0a\x09function parseModule(code, options, delegate) {\x0a\x09    var parsingOptions = options || {};\x0a\x09    parsingOptions.sourceType = \x27module\x27;\x0a\x09    return parse(code, parsingOptions, delegate);\x0a\x09}\x0a\x09exports.parseModule = parseModule;\x0a\x09function parseScript(code, options, delegate) {\x0a\x09    var parsingOptions = options || {};\x0a\x09    parsingOptions.sourceType = \x27script\x27;\x0a\x09    return parse(code, parsingOptions, delegate);\x0a\x09}\x0a\x09exports.parseScript = parseScript;\x0a\x09function tokenize(code, options, delegate) {\x0a\x09    var tokenizer = new tokenizer_1.Tokenizer(code, options);\x0a\x09    var tokens;\x0a\x09    tokens = [];\x0a\x09    try {\x0a\x09        while (true) {\x0a\x09            var token = tokenizer.getNextToken();\x0a\x09            if (!token) {\x0a\x09                break;\x0a\x09            }\x0a\x09            if (delegate) {\x0a\x09                token = delegate(token);\x0a\x09            }\x0a\x09            tokens.push(token);\x0a\x09        }\x0a\x09    }\x0a\x09    catch (e) {\x0a\x09        tokenizer.errorHandler.tolerate(e);\x0a\x09    }\x0a\x09    if (tokenizer.errorHandler.tolerant) {\x0a\x09        tokens.errors = tokenizer.errors();\x0a\x09    }\x0a\x09    return tokens;\x0a\x09}\x0a\x09exports.tokenize = tokenize;\x0a\x09var syntax_1 = __webpack_require__(2);\x0a\x09exports.Syntax = syntax_1.Syntax;\x0a\x09// Sync with *.json manifests.\x0a\x09exports.version = \x274.0.0\x27;\x0a\x0a\x0a/***/ },\x0a/* 1 */\x0a/***/ function(module, exports, __webpack_require__) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09var syntax_1 = __webpack_require__(2);\x0a\x09var CommentHandler = (function () {\x0a\x09    function CommentHandler() {\x0a\x09        this.attach = false;\x0a\x09        this.comments = [];\x0a\x09        this.stack = [];\x0a\x09        this.leading = [];\x0a\x09        this.trailing = [];\x0a\x09    }\x0a\x09    CommentHandler.prototype.insertInnerComments = function (node, metadata) {\x0a\x09        //  innnerComments for properties empty block\x0a\x09        //  `function a() {/** comments **\x5c/}`\x0a\x09        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {\x0a\x09            var innerComments = [];\x0a\x09            for (var i = this.leading.length - 1; i \x3e= 0; --i) {\x0a\x09                var entry = this.leading[i];\x0a\x09                if (metadata.end.offset \x3e= entry.start) {\x0a\x09                    innerComments.unshift(entry.comment);\x0a\x09                    this.leading.splice(i, 1);\x0a\x09                    this.trailing.splice(i, 1);\x0a\x09                }\x0a\x09            }\x0a\x09            if (innerComments.length) {\x0a\x09                node.innerComments = innerComments;\x0a\x09            }\x0a\x09        }\x0a\x09    };\x0a\x09    CommentHandler.prototype.findTrailingComments = function (metadata) {\x0a\x09        var trailingComments = [];\x0a\x09        if (this.trailing.length \x3e 0) {\x0a\x09            for (var i = this.trailing.length - 1; i \x3e= 0; --i) {\x0a\x09                var entry_1 = this.trailing[i];\x0a\x09                if (entry_1.start \x3e= metadata.end.offset) {\x0a\x09                    trailingComments.unshift(entry_1.comment);\x0a\x09                }\x0a\x09            }\x0a\x09            this.trailing.length = 0;\x0a\x09            return trailingComments;\x0a\x09        }\x0a\x09        var entry = this.stack[this.stack.length - 1];\x0a\x09        if (entry && entry.node.trailingComments) {\x0a\x09            var firstComment = entry.node.trailingComments[0];\x0a\x09            if (firstComment && firstComment.range[0] \x3e= metadata.end.offset) {\x0a\x09                trailingComments = entry.node.trailingComments;\x0a\x09                delete entry.node.trailingComments;\x0a\x09            }\x0a\x09        }\x0a\x09        return trailingComments;\x0a\x09    };\x0a\x09    CommentHandler.prototype.findLeadingComments = function (metadata) {\x0a\x09        var leadingComments = [];\x0a\x09        var target;\x0a\x09        while (this.stack.length \x3e 0) {\x0a\x09            var entry = this.stack[this.stack.length - 1];\x0a\x09            if (entry && entry.start \x3e= metadata.start.offset) {\x0a\x09                target = entry.node;\x0a\x09                this.stack.pop();\x0a\x09            }\x0a\x09            else {\x0a\x09                break;\x0a\x09            }\x0a\x09        }\x0a\x09        if (target) {\x0a\x09            var count = target.leadingComments ? target.leadingComments.length : 0;\x0a\x09            for (var i = count - 1; i \x3e= 0; --i) {\x0a\x09                var comment = target.leadingComments[i];\x0a\x09                if (comment.range[1] \x3c= metadata.start.offset) {\x0a\x09                    leadingComments.unshift(comment);\x0a\x09                    target.leadingComments.splice(i, 1);\x0a\x09                }\x0a\x09            }\x0a\x09            if (target.leadingComments && target.leadingComments.length === 0) {\x0a\x09                delete target.leadingComments;\x0a\x09            }\x0a\x09            return leadingComments;\x0a\x09        }\x0a\x09        for (var i = this.leading.length - 1; i \x3e= 0; --i) {\x0a\x09            var entry = this.leading[i];\x0a\x09            if (entry.start \x3c= metadata.start.offset) {\x0a\x09                leadingComments.unshift(entry.comment);\x0a\x09                this.leading.splice(i, 1);\x0a\x09            }\x0a\x09        }\x0a\x09        return leadingComments;\x0a\x09    };\x0a\x09    CommentHandler.prototype.visitNode = function (node, metadata) {\x0a\x09        if (node.type === syntax_1.Syntax.Program && node.body.length \x3e 0) {\x0a\x09            return;\x0a\x09        }\x0a\x09        this.insertInnerComments(node, metadata);\x0a\x09        var trailingComments = this.findTrailingComments(metadata);\x0a\x09        var leadingComments = this.findLeadingComments(metadata);\x0a\x09        if (leadingComments.length \x3e 0) {\x0a\x09            node.leadingComments = leadingComments;\x0a\x09        }\x0a\x09        if (trailingComments.length \x3e 0) {\x0a\x09            node.trailingComments = trailingComments;\x0a\x09        }\x0a\x09        this.stack.push({\x0a\x09            node: node,\x0a\x09            start: metadata.start.offset\x0a\x09        });\x0a\x09    };\x0a\x09    CommentHandler.prototype.visitComment = function (node, metadata) {\x0a\x09        var type = (node.type[0] === \x27L\x27) ? \x27Line\x27 : \x27Block\x27;\x0a\x09        var comment = {\x0a\x09            type: type,\x0a\x09            value: node.value\x0a\x09        };\x0a\x09        if (node.range) {\x0a\x09            comment.range = node.range;\x0a\x09        }\x0a\x09        if (node.loc) {\x0a\x09            comment.loc = node.loc;\x0a\x09        }\x0a\x09        this.comments.push(comment);\x0a\x09        if (this.attach) {\x0a\x09            var entry = {\x0a\x09                comment: {\x0a\x09                    type: type,\x0a\x09                    value: node.value,\x0a\x09                    range: [metadata.start.offset, metadata.end.offset]\x0a\x09                },\x0a\x09                start: metadata.start.offset\x0a\x09            };\x0a\x09            if (node.loc) {\x0a\x09                entry.comment.loc = node.loc;\x0a\x09            }\x0a\x09            node.type = type;\x0a\x09            this.leading.push(entry);\x0a\x09            this.trailing.push(entry);\x0a\x09        }\x0a\x09    };\x0a\x09    CommentHandler.prototype.visit = function (node, metadata) {\x0a\x09        if (node.type === \x27LineComment\x27) {\x0a\x09            this.visitComment(node, metadata);\x0a\x09        }\x0a\x09        else if (node.type === \x27BlockComment\x27) {\x0a\x09            this.visitComment(node, metadata);\x0a\x09        }\x0a\x09        else if (this.attach) {\x0a\x09            this.visitNode(node, metadata);\x0a\x09        }\x0a\x09    };\x0a\x09    return CommentHandler;\x0a\x09}());\x0a\x09exports.CommentHandler = CommentHandler;\x0a\x0a\x0a/***/ },\x0a/* 2 */\x0a/***/ function(module, exports) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09exports.Syntax = {\x0a\x09    AssignmentExpression: \x27AssignmentExpression\x27,\x0a\x09    AssignmentPattern: \x27AssignmentPattern\x27,\x0a\x09    ArrayExpression: \x27ArrayExpression\x27,\x0a\x09    ArrayPattern: \x27ArrayPattern\x27,\x0a\x09    ArrowFunctionExpression: \x27ArrowFunctionExpression\x27,\x0a\x09    AwaitExpression: \x27AwaitExpression\x27,\x0a\x09    BlockStatement: \x27BlockStatement\x27,\x0a\x09    BinaryExpression: \x27BinaryExpression\x27,\x0a\x09    BreakStatement: \x27BreakStatement\x27,\x0a\x09    CallExpression: \x27CallExpression\x27,\x0a\x09    CatchClause: \x27CatchClause\x27,\x0a\x09    ClassBody: \x27ClassBody\x27,\x0a\x09    ClassDeclaration: \x27ClassDeclaration\x27,\x0a\x09    ClassExpression: \x27ClassExpression\x27,\x0a\x09    ConditionalExpression: \x27ConditionalExpression\x27,\x0a\x09    ContinueStatement: \x27ContinueStatement\x27,\x0a\x09    DoWhileStatement: \x27DoWhileStatement\x27,\x0a\x09    DebuggerStatement: \x27DebuggerStatement\x27,\x0a\x09    EmptyStatement: \x27EmptyStatement\x27,\x0a\x09    ExportAllDeclaration: \x27ExportAllDeclaration\x27,\x0a\x09    ExportDefaultDeclaration: \x27ExportDefaultDeclaration\x27,\x0a\x09    ExportNamedDeclaration: \x27ExportNamedDeclaration\x27,\x0a\x09    ExportSpecifier: \x27ExportSpecifier\x27,\x0a\x09    ExpressionStatement: \x27ExpressionStatement\x27,\x0a\x09    ForStatement: \x27ForStatement\x27,\x0a\x09    ForOfStatement: \x27ForOfStatement\x27,\x0a\x09    ForInStatement: \x27ForInStatement\x27,\x0a\x09    FunctionDeclaration: \x27FunctionDeclaration\x27,\x0a\x09    FunctionExpression: \x27FunctionExpression\x27,\x0a\x09    Identifier: \x27Identifier\x27,\x0a\x09    IfStatement: \x27IfStatement\x27,\x0a\x09    ImportDeclaration: \x27ImportDeclaration\x27,\x0a\x09    ImportDefaultSpecifier: \x27ImportDefaultSpecifier\x27,\x0a\x09    ImportNamespaceSpecifier: \x27ImportNamespaceSpecifier\x27,\x0a\x09    ImportSpecifier: \x27ImportSpecifier\x27,\x0a\x09    Literal: \x27Literal\x27,\x0a\x09    LabeledStatement: \x27LabeledStatement\x27,\x0a\x09    LogicalExpression: \x27LogicalExpression\x27,\x0a\x09    MemberExpression: \x27MemberExpression\x27,\x0a\x09    MetaProperty: \x27MetaProperty\x27,\x0a\x09    MethodDefinition: \x27MethodDefinition\x27,\x0a\x09    NewExpression: \x27NewExpression\x27,\x0a\x09    ObjectExpression: \x27ObjectExpression\x27,\x0a\x09    ObjectPattern: \x27ObjectPattern\x27,\x0a\x09    Program: \x27Program\x27,\x0a\x09    Property: \x27Property\x27,\x0a\x09    RestElement: \x27RestElement\x27,\x0a\x09    ReturnStatement: \x27ReturnStatement\x27,\x0a\x09    SequenceExpression: \x27SequenceExpression\x27,\x0a\x09    SpreadElement: \x27SpreadElement\x27,\x0a\x09    Super: \x27Super\x27,\x0a\x09    SwitchCase: \x27SwitchCase\x27,\x0a\x09    SwitchStatement: \x27SwitchStatement\x27,\x0a\x09    TaggedTemplateExpression: \x27TaggedTemplateExpression\x27,\x0a\x09    TemplateElement: \x27TemplateElement\x27,\x0a\x09    TemplateLiteral: \x27TemplateLiteral\x27,\x0a\x09    ThisExpression: \x27ThisExpression\x27,\x0a\x09    ThrowStatement: \x27ThrowStatement\x27,\x0a\x09    TryStatement: \x27TryStatement\x27,\x0a\x09    UnaryExpression: \x27UnaryExpression\x27,\x0a\x09    UpdateExpression: \x27UpdateExpression\x27,\x0a\x09    VariableDeclaration: \x27VariableDeclaration\x27,\x0a\x09    VariableDeclarator: \x27VariableDeclarator\x27,\x0a\x09    WhileStatement: \x27WhileStatement\x27,\x0a\x09    WithStatement: \x27WithStatement\x27,\x0a\x09    YieldExpression: \x27YieldExpression\x27\x0a\x09};\x0a\x0a\x0a/***/ },\x0a/* 3 */\x0a/***/ function(module, exports, __webpack_require__) {\x0a\x0a\x09\x22use strict\x22;\x0a/* istanbul ignore next */\x0a\x09var __extends = (this && this.__extends) || (function () {\x0a\x09    var extendStatics = Object.setPrototypeOf ||\x0a\x09        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\x0a\x09        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\x0a\x09    return function (d, b) {\x0a\x09        extendStatics(d, b);\x0a\x09        function __() { this.constructor = d; }\x0a\x09        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\x0a\x09    };\x0a\x09})();\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09var character_1 = __webpack_require__(4);\x0a\x09var JSXNode = __webpack_require__(5);\x0a\x09var jsx_syntax_1 = __webpack_require__(6);\x0a\x09var Node = __webpack_require__(7);\x0a\x09var parser_1 = __webpack_require__(8);\x0a\x09var token_1 = __webpack_require__(13);\x0a\x09var xhtml_entities_1 = __webpack_require__(14);\x0a\x09token_1.TokenName[100 /* Identifier */] = \x27JSXIdentifier\x27;\x0a\x09token_1.TokenName[101 /* Text */] = \x27JSXText\x27;\x0a\x09// Fully qualified element name, e.g. \x3csvg:path\x3e returns \x22svg:path\x22\x0a\x09function getQualifiedElementName(elementName) {\x0a\x09    var qualifiedName;\x0a\x09    switch (elementName.type) {\x0a\x09        case jsx_syntax_1.JSXSyntax.JSXIdentifier:\x0a\x09            var id = elementName;\x0a\x09            qualifiedName = id.name;\x0a\x09            break;\x0a\x09        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:\x0a\x09            var ns = elementName;\x0a\x09            qualifiedName = getQualifiedElementName(ns.namespace) + \x27:\x27 +\x0a\x09                getQualifiedElementName(ns.name);\x0a\x09            break;\x0a\x09        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:\x0a\x09            var expr = elementName;\x0a\x09            qualifiedName = getQualifiedElementName(expr.object) + \x27.\x27 +\x0a\x09                getQualifiedElementName(expr.property);\x0a\x09            break;\x0a\x09        /* istanbul ignore next */\x0a\x09        default:\x0a\x09            break;\x0a\x09    }\x0a\x09    return qualifiedName;\x0a\x09}\x0a\x09var JSXParser = (function (_super) {\x0a\x09    __extends(JSXParser, _super);\x0a\x09    function JSXParser(code, options, delegate) {\x0a\x09        return _super.call(this, code, options, delegate) || this;\x0a\x09    }\x0a\x09    JSXParser.prototype.parsePrimaryExpression = function () {\x0a\x09        return this.match(\x27\x3c\x27) ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);\x0a\x09    };\x0a\x09    JSXParser.prototype.startJSX = function () {\x0a\x09        // Unwind the scanner before the lookahead token.\x0a\x09        this.scanner.index = this.startMarker.index;\x0a\x09        this.scanner.lineNumber = this.startMarker.line;\x0a\x09        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;\x0a\x09    };\x0a\x09    JSXParser.prototype.finishJSX = function () {\x0a\x09        // Prime the next lookahead.\x0a\x09        this.nextToken();\x0a\x09    };\x0a\x09    JSXParser.prototype.reenterJSX = function () {\x0a\x09        this.startJSX();\x0a\x09        this.expectJSX(\x27}\x27);\x0a\x09        // Pop the closing \x27}\x27 added from the lookahead.\x0a\x09        if (this.config.tokens) {\x0a\x09            this.tokens.pop();\x0a\x09        }\x0a\x09    };\x0a\x09    JSXParser.prototype.createJSXNode = function () {\x0a\x09        this.collectComments();\x0a\x09        return {\x0a\x09            index: this.scanner.index,\x0a\x09            line: this.scanner.lineNumber,\x0a\x09            column: this.scanner.index - this.scanner.lineStart\x0a\x09        };\x0a\x09    };\x0a\x09    JSXParser.prototype.createJSXChildNode = function () {\x0a\x09        return {\x0a\x09            index: this.scanner.index,\x0a\x09            line: this.scanner.lineNumber,\x0a\x09            column: this.scanner.index - this.scanner.lineStart\x0a\x09        };\x0a\x09    };\x0a\x09    JSXParser.prototype.scanXHTMLEntity = function (quote) {\x0a\x09        var result = \x27&\x27;\x0a\x09        var valid = true;\x0a\x09        var terminated = false;\x0a\x09        var numeric = false;\x0a\x09        var hex = false;\x0a\x09        while (!this.scanner.eof() && valid && !terminated) {\x0a\x09            var ch = this.scanner.source[this.scanner.index];\x0a\x09            if (ch === quote) {\x0a\x09                break;\x0a\x09            }\x0a\x09            terminated = (ch === \x27;\x27);\x0a\x09            result += ch;\x0a\x09            ++this.scanner.index;\x0a\x09            if (!terminated) {\x0a\x09                switch (result.length) {\x0a\x09                    case 2:\x0a\x09                        // e.g. \x27&#123;\x27\x0a\x09                        numeric = (ch === \x27#\x27);\x0a\x09                        break;\x0a\x09                    case 3:\x0a\x09                        if (numeric) {\x0a\x09                            // e.g. \x27&#x41;\x27\x0a\x09                            hex = (ch === \x27x\x27);\x0a\x09                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));\x0a\x09                            numeric = numeric && !hex;\x0a\x09                        }\x0a\x09                        break;\x0a\x09                    default:\x0a\x09                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));\x0a\x09                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));\x0a\x09                        break;\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        if (valid && terminated && result.length \x3e 2) {\x0a\x09            // e.g. \x27&#x41;\x27 becomes just \x27#x41\x27\x0a\x09            var str = result.substr(1, result.length - 2);\x0a\x09            if (numeric && str.length \x3e 1) {\x0a\x09                result = String.fromCharCode(parseInt(str.substr(1), 10));\x0a\x09            }\x0a\x09            else if (hex && str.length \x3e 2) {\x0a\x09                result = String.fromCharCode(parseInt(\x270\x27 + str.substr(1), 16));\x0a\x09            }\x0a\x09            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {\x0a\x09                result = xhtml_entities_1.XHTMLEntities[str];\x0a\x09            }\x0a\x09        }\x0a\x09        return result;\x0a\x09    };\x0a\x09    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.\x0a\x09    JSXParser.prototype.lexJSX = function () {\x0a\x09        var cp = this.scanner.source.charCodeAt(this.scanner.index);\x0a\x09        // \x3c \x3e / : = { }\x0a\x09        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {\x0a\x09            var value = this.scanner.source[this.scanner.index++];\x0a\x09            return {\x0a\x09                type: 7 /* Punctuator */,\x0a\x09                value: value,\x0a\x09                lineNumber: this.scanner.lineNumber,\x0a\x09                lineStart: this.scanner.lineStart,\x0a\x09                start: this.scanner.index - 1,\x0a\x09                end: this.scanner.index\x0a\x09            };\x0a\x09        }\x0a\x09        // \x22 \x27\x0a\x09        if (cp === 34 || cp === 39) {\x0a\x09            var start = this.scanner.index;\x0a\x09            var quote = this.scanner.source[this.scanner.index++];\x0a\x09            var str = \x27\x27;\x0a\x09            while (!this.scanner.eof()) {\x0a\x09                var ch = this.scanner.source[this.scanner.index++];\x0a\x09                if (ch === quote) {\x0a\x09                    break;\x0a\x09                }\x0a\x09                else if (ch === \x27&\x27) {\x0a\x09                    str += this.scanXHTMLEntity(quote);\x0a\x09                }\x0a\x09                else {\x0a\x09                    str += ch;\x0a\x09                }\x0a\x09            }\x0a\x09            return {\x0a\x09                type: 8 /* StringLiteral */,\x0a\x09                value: str,\x0a\x09                lineNumber: this.scanner.lineNumber,\x0a\x09                lineStart: this.scanner.lineStart,\x0a\x09                start: start,\x0a\x09                end: this.scanner.index\x0a\x09            };\x0a\x09        }\x0a\x09        // ... or .\x0a\x09        if (cp === 46) {\x0a\x09            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);\x0a\x09            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);\x0a\x09            var value = (n1 === 46 && n2 === 46) ? \x27...\x27 : \x27.\x27;\x0a\x09            var start = this.scanner.index;\x0a\x09            this.scanner.index += value.length;\x0a\x09            return {\x0a\x09                type: 7 /* Punctuator */,\x0a\x09                value: value,\x0a\x09                lineNumber: this.scanner.lineNumber,\x0a\x09                lineStart: this.scanner.lineStart,\x0a\x09                start: start,\x0a\x09                end: this.scanner.index\x0a\x09            };\x0a\x09        }\x0a\x09        // `\x0a\x09        if (cp === 96) {\x0a\x09            // Only placeholder, since it will be rescanned as a real assignment expression.\x0a\x09            return {\x0a\x09                type: 10 /* Template */,\x0a\x09                value: \x27\x27,\x0a\x09                lineNumber: this.scanner.lineNumber,\x0a\x09                lineStart: this.scanner.lineStart,\x0a\x09                start: this.scanner.index,\x0a\x09                end: this.scanner.index\x0a\x09            };\x0a\x09        }\x0a\x09        // Identifer can not contain backslash (char code 92).\x0a\x09        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {\x0a\x09            var start = this.scanner.index;\x0a\x09            ++this.scanner.index;\x0a\x09            while (!this.scanner.eof()) {\x0a\x09                var ch = this.scanner.source.charCodeAt(this.scanner.index);\x0a\x09                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {\x0a\x09                    ++this.scanner.index;\x0a\x09                }\x0a\x09                else if (ch === 45) {\x0a\x09                    // Hyphen (char code 45) can be part of an identifier.\x0a\x09                    ++this.scanner.index;\x0a\x09                }\x0a\x09                else {\x0a\x09                    break;\x0a\x09                }\x0a\x09            }\x0a\x09            var id = this.scanner.source.slice(start, this.scanner.index);\x0a\x09            return {\x0a\x09                type: 100 /* Identifier */,\x0a\x09                value: id,\x0a\x09                lineNumber: this.scanner.lineNumber,\x0a\x09                lineStart: this.scanner.lineStart,\x0a\x09                start: start,\x0a\x09                end: this.scanner.index\x0a\x09            };\x0a\x09        }\x0a\x09        return this.scanner.lex();\x0a\x09    };\x0a\x09    JSXParser.prototype.nextJSXToken = function () {\x0a\x09        this.collectComments();\x0a\x09        this.startMarker.index = this.scanner.index;\x0a\x09        this.startMarker.line = this.scanner.lineNumber;\x0a\x09        this.startMarker.column = this.scanner.index - this.scanner.lineStart;\x0a\x09        var token = this.lexJSX();\x0a\x09        this.lastMarker.index = this.scanner.index;\x0a\x09        this.lastMarker.line = this.scanner.lineNumber;\x0a\x09        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\x0a\x09        if (this.config.tokens) {\x0a\x09            this.tokens.push(this.convertToken(token));\x0a\x09        }\x0a\x09        return token;\x0a\x09    };\x0a\x09    JSXParser.prototype.nextJSXText = function () {\x0a\x09        this.startMarker.index = this.scanner.index;\x0a\x09        this.startMarker.line = this.scanner.lineNumber;\x0a\x09        this.startMarker.column = this.scanner.index - this.scanner.lineStart;\x0a\x09        var start = this.scanner.index;\x0a\x09        var text = \x27\x27;\x0a\x09        while (!this.scanner.eof()) {\x0a\x09            var ch = this.scanner.source[this.scanner.index];\x0a\x09            if (ch === \x27{\x27 || ch === \x27\x3c\x27) {\x0a\x09                break;\x0a\x09            }\x0a\x09            ++this.scanner.index;\x0a\x09            text += ch;\x0a\x09            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\x0a\x09                ++this.scanner.lineNumber;\x0a\x09                if (ch === \x27\x5cr\x27 && this.scanner.source[this.scanner.index] === \x27\x5cn\x27) {\x0a\x09                    ++this.scanner.index;\x0a\x09                }\x0a\x09                this.scanner.lineStart = this.scanner.index;\x0a\x09            }\x0a\x09        }\x0a\x09        this.lastMarker.index = this.scanner.index;\x0a\x09        this.lastMarker.line = this.scanner.lineNumber;\x0a\x09        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\x0a\x09        var token = {\x0a\x09            type: 101 /* Text */,\x0a\x09            value: text,\x0a\x09            lineNumber: this.scanner.lineNumber,\x0a\x09            lineStart: this.scanner.lineStart,\x0a\x09            start: start,\x0a\x09            end: this.scanner.index\x0a\x09        };\x0a\x09        if ((text.length \x3e 0) && this.config.tokens) {\x0a\x09            this.tokens.push(this.convertToken(token));\x0a\x09        }\x0a\x09        return token;\x0a\x09    };\x0a\x09    JSXParser.prototype.peekJSXToken = function () {\x0a\x09        var state = this.scanner.saveState();\x0a\x09        this.scanner.scanComments();\x0a\x09        var next = this.lexJSX();\x0a\x09        this.scanner.restoreState(state);\x0a\x09        return next;\x0a\x09    };\x0a\x09    // Expect the next JSX token to match the specified punctuator.\x0a\x09    // If not, an exception will be thrown.\x0a\x09    JSXParser.prototype.expectJSX = function (value) {\x0a\x09        var token = this.nextJSXToken();\x0a\x09        if (token.type !== 7 /* Punctuator */ || token.value !== value) {\x0a\x09            this.throwUnexpectedToken(token);\x0a\x09        }\x0a\x09    };\x0a\x09    // Return true if the next JSX token matches the specified punctuator.\x0a\x09    JSXParser.prototype.matchJSX = function (value) {\x0a\x09        var next = this.peekJSXToken();\x0a\x09        return next.type === 7 /* Punctuator */ && next.value === value;\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXIdentifier = function () {\x0a\x09        var node = this.createJSXNode();\x0a\x09        var token = this.nextJSXToken();\x0a\x09        if (token.type !== 100 /* Identifier */) {\x0a\x09            this.throwUnexpectedToken(token);\x0a\x09        }\x0a\x09        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXElementName = function () {\x0a\x09        var node = this.createJSXNode();\x0a\x09        var elementName = this.parseJSXIdentifier();\x0a\x09        if (this.matchJSX(\x27:\x27)) {\x0a\x09            var namespace = elementName;\x0a\x09            this.expectJSX(\x27:\x27);\x0a\x09            var name_1 = this.parseJSXIdentifier();\x0a\x09            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));\x0a\x09        }\x0a\x09        else if (this.matchJSX(\x27.\x27)) {\x0a\x09            while (this.matchJSX(\x27.\x27)) {\x0a\x09                var object = elementName;\x0a\x09                this.expectJSX(\x27.\x27);\x0a\x09                var property = this.parseJSXIdentifier();\x0a\x09                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));\x0a\x09            }\x0a\x09        }\x0a\x09        return elementName;\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXAttributeName = function () {\x0a\x09        var node = this.createJSXNode();\x0a\x09        var attributeName;\x0a\x09        var identifier = this.parseJSXIdentifier();\x0a\x09        if (this.matchJSX(\x27:\x27)) {\x0a\x09            var namespace = identifier;\x0a\x09            this.expectJSX(\x27:\x27);\x0a\x09            var name_2 = this.parseJSXIdentifier();\x0a\x09            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));\x0a\x09        }\x0a\x09        else {\x0a\x09            attributeName = identifier;\x0a\x09        }\x0a\x09        return attributeName;\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {\x0a\x09        var node = this.createJSXNode();\x0a\x09        var token = this.nextJSXToken();\x0a\x09        if (token.type !== 8 /* StringLiteral */) {\x0a\x09            this.throwUnexpectedToken(token);\x0a\x09        }\x0a\x09        var raw = this.getTokenRaw(token);\x0a\x09        return this.finalize(node, new Node.Literal(token.value, raw));\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXExpressionAttribute = function () {\x0a\x09        var node = this.createJSXNode();\x0a\x09        this.expectJSX(\x27{\x27);\x0a\x09        this.finishJSX();\x0a\x09        if (this.match(\x27}\x27)) {\x0a\x09            this.tolerateError(\x27JSX attributes must only be assigned a non-empty expression\x27);\x0a\x09        }\x0a\x09        var expression = this.parseAssignmentExpression();\x0a\x09        this.reenterJSX();\x0a\x09        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXAttributeValue = function () {\x0a\x09        return this.matchJSX(\x27{\x27) ? this.parseJSXExpressionAttribute() :\x0a\x09            this.matchJSX(\x27\x3c\x27) ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXNameValueAttribute = function () {\x0a\x09        var node = this.createJSXNode();\x0a\x09        var name = this.parseJSXAttributeName();\x0a\x09        var value = null;\x0a\x09        if (this.matchJSX(\x27=\x27)) {\x0a\x09            this.expectJSX(\x27=\x27);\x0a\x09            value = this.parseJSXAttributeValue();\x0a\x09        }\x0a\x09        return this.finalize(node, new JSXNode.JSXAttribute(name, value));\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXSpreadAttribute = function () {\x0a\x09        var node = this.createJSXNode();\x0a\x09        this.expectJSX(\x27{\x27);\x0a\x09        this.expectJSX(\x27...\x27);\x0a\x09        this.finishJSX();\x0a\x09        var argument = this.parseAssignmentExpression();\x0a\x09        this.reenterJSX();\x0a\x09        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXAttributes = function () {\x0a\x09        var attributes = [];\x0a\x09        while (!this.matchJSX(\x27/\x27) && !this.matchJSX(\x27\x3e\x27)) {\x0a\x09            var attribute = this.matchJSX(\x27{\x27) ? this.parseJSXSpreadAttribute() :\x0a\x09                this.parseJSXNameValueAttribute();\x0a\x09            attributes.push(attribute);\x0a\x09        }\x0a\x09        return attributes;\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXOpeningElement = function () {\x0a\x09        var node = this.createJSXNode();\x0a\x09        this.expectJSX(\x27\x3c\x27);\x0a\x09        var name = this.parseJSXElementName();\x0a\x09        var attributes = this.parseJSXAttributes();\x0a\x09        var selfClosing = this.matchJSX(\x27/\x27);\x0a\x09        if (selfClosing) {\x0a\x09            this.expectJSX(\x27/\x27);\x0a\x09        }\x0a\x09        this.expectJSX(\x27\x3e\x27);\x0a\x09        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXBoundaryElement = function () {\x0a\x09        var node = this.createJSXNode();\x0a\x09        this.expectJSX(\x27\x3c\x27);\x0a\x09        if (this.matchJSX(\x27/\x27)) {\x0a\x09            this.expectJSX(\x27/\x27);\x0a\x09            var name_3 = this.parseJSXElementName();\x0a\x09            this.expectJSX(\x27\x3e\x27);\x0a\x09            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));\x0a\x09        }\x0a\x09        var name = this.parseJSXElementName();\x0a\x09        var attributes = this.parseJSXAttributes();\x0a\x09        var selfClosing = this.matchJSX(\x27/\x27);\x0a\x09        if (selfClosing) {\x0a\x09            this.expectJSX(\x27/\x27);\x0a\x09        }\x0a\x09        this.expectJSX(\x27\x3e\x27);\x0a\x09        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXEmptyExpression = function () {\x0a\x09        var node = this.createJSXChildNode();\x0a\x09        this.collectComments();\x0a\x09        this.lastMarker.index = this.scanner.index;\x0a\x09        this.lastMarker.line = this.scanner.lineNumber;\x0a\x09        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\x0a\x09        return this.finalize(node, new JSXNode.JSXEmptyExpression());\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXExpressionContainer = function () {\x0a\x09        var node = this.createJSXNode();\x0a\x09        this.expectJSX(\x27{\x27);\x0a\x09        var expression;\x0a\x09        if (this.matchJSX(\x27}\x27)) {\x0a\x09            expression = this.parseJSXEmptyExpression();\x0a\x09            this.expectJSX(\x27}\x27);\x0a\x09        }\x0a\x09        else {\x0a\x09            this.finishJSX();\x0a\x09            expression = this.parseAssignmentExpression();\x0a\x09            this.reenterJSX();\x0a\x09        }\x0a\x09        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXChildren = function () {\x0a\x09        var children = [];\x0a\x09        while (!this.scanner.eof()) {\x0a\x09            var node = this.createJSXChildNode();\x0a\x09            var token = this.nextJSXText();\x0a\x09            if (token.start \x3c token.end) {\x0a\x09                var raw = this.getTokenRaw(token);\x0a\x09                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));\x0a\x09                children.push(child);\x0a\x09            }\x0a\x09            if (this.scanner.source[this.scanner.index] === \x27{\x27) {\x0a\x09                var container = this.parseJSXExpressionContainer();\x0a\x09                children.push(container);\x0a\x09            }\x0a\x09            else {\x0a\x09                break;\x0a\x09            }\x0a\x09        }\x0a\x09        return children;\x0a\x09    };\x0a\x09    JSXParser.prototype.parseComplexJSXElement = function (el) {\x0a\x09        var stack = [];\x0a\x09        while (!this.scanner.eof()) {\x0a\x09            el.children = el.children.concat(this.parseJSXChildren());\x0a\x09            var node = this.createJSXChildNode();\x0a\x09            var element = this.parseJSXBoundaryElement();\x0a\x09            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {\x0a\x09                var opening = element;\x0a\x09                if (opening.selfClosing) {\x0a\x09                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));\x0a\x09                    el.children.push(child);\x0a\x09                }\x0a\x09                else {\x0a\x09                    stack.push(el);\x0a\x09                    el = { node: node, opening: opening, closing: null, children: [] };\x0a\x09                }\x0a\x09            }\x0a\x09            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {\x0a\x09                el.closing = element;\x0a\x09                var open_1 = getQualifiedElementName(el.opening.name);\x0a\x09                var close_1 = getQualifiedElementName(el.closing.name);\x0a\x09                if (open_1 !== close_1) {\x0a\x09                    this.tolerateError(\x27Expected corresponding JSX closing tag for %0\x27, open_1);\x0a\x09                }\x0a\x09                if (stack.length \x3e 0) {\x0a\x09                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));\x0a\x09                    el = stack[stack.length - 1];\x0a\x09                    el.children.push(child);\x0a\x09                    stack.pop();\x0a\x09                }\x0a\x09                else {\x0a\x09                    break;\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        return el;\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXElement = function () {\x0a\x09        var node = this.createJSXNode();\x0a\x09        var opening = this.parseJSXOpeningElement();\x0a\x09        var children = [];\x0a\x09        var closing = null;\x0a\x09        if (!opening.selfClosing) {\x0a\x09            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });\x0a\x09            children = el.children;\x0a\x09            closing = el.closing;\x0a\x09        }\x0a\x09        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));\x0a\x09    };\x0a\x09    JSXParser.prototype.parseJSXRoot = function () {\x0a\x09        // Pop the opening \x27\x3c\x27 added from the lookahead.\x0a\x09        if (this.config.tokens) {\x0a\x09            this.tokens.pop();\x0a\x09        }\x0a\x09        this.startJSX();\x0a\x09        var element = this.parseJSXElement();\x0a\x09        this.finishJSX();\x0a\x09        return element;\x0a\x09    };\x0a\x09    JSXParser.prototype.isStartOfExpression = function () {\x0a\x09        return _super.prototype.isStartOfExpression.call(this) || this.match(\x27\x3c\x27);\x0a\x09    };\x0a\x09    return JSXParser;\x0a\x09}(parser_1.Parser));\x0a\x09exports.JSXParser = JSXParser;\x0a\x0a\x0a/***/ },\x0a/* 4 */\x0a/***/ function(module, exports) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09// See also tools/generate-unicode-regex.js.\x0a\x09var Regex = {\x0a\x09    // Unicode v8.0.0 NonAsciiIdentifierStart:\x0a\x09    NonAsciiIdentifierStart: /[\x5cxAA\x5cxB5\x5cxBA\x5cxC0-\x5cxD6\x5cxD8-\x5cxF6\x5cxF8-\x5cu02C1\x5cu02C6-\x5cu02D1\x5cu02E0-\x5cu02E4\x5cu02EC\x5cu02EE\x5cu0370-\x5cu0374\x5cu0376\x5cu0377\x5cu037A-\x5cu037D\x5cu037F\x5cu0386\x5cu0388-\x5cu038A\x5cu038C\x5cu038E-\x5cu03A1\x5cu03A3-\x5cu03F5\x5cu03F7-\x5cu0481\x5cu048A-\x5cu052F\x5cu0531-\x5cu0556\x5cu0559\x5cu0561-\x5cu0587\x5cu05D0-\x5cu05EA\x5cu05F0-\x5cu05F2\x5cu0620-\x5cu064A\x5cu066E\x5cu066F\x5cu0671-\x5cu06D3\x5cu06D5\x5cu06E5\x5cu06E6\x5cu06EE\x5cu06EF\x5cu06FA-\x5cu06FC\x5cu06FF\x5cu0710\x5cu0712-\x5cu072F\x5cu074D-\x5cu07A5\x5cu07B1\x5cu07CA-\x5cu07EA\x5cu07F4\x5cu07F5\x5cu07FA\x5cu0800-\x5cu0815\x5cu081A\x5cu0824\x5cu0828\x5cu0840-\x5cu0858\x5cu08A0-\x5cu08B4\x5cu0904-\x5cu0939\x5cu093D\x5cu0950\x5cu0958-\x5cu0961\x5cu0971-\x5cu0980\x5cu0985-\x5cu098C\x5cu098F\x5cu0990\x5cu0993-\x5cu09A8\x5cu09AA-\x5cu09B0\x5cu09B2\x5cu09B6-\x5cu09B9\x5cu09BD\x5cu09CE\x5cu09DC\x5cu09DD\x5cu09DF-\x5cu09E1\x5cu09F0\x5cu09F1\x5cu0A05-\x5cu0A0A\x5cu0A0F\x5cu0A10\x5cu0A13-\x5cu0A28\x5cu0A2A-\x5cu0A30\x5cu0A32\x5cu0A33\x5cu0A35\x5cu0A36\x5cu0A38\x5cu0A39\x5cu0A59-\x5cu0A5C\x5cu0A5E\x5cu0A72-\x5cu0A74\x5cu0A85-\x5cu0A8D\x5cu0A8F-\x5cu0A91\x5cu0A93-\x5cu0AA8\x5cu0AAA-\x5cu0AB0\x5cu0AB2\x5cu0AB3\x5cu0AB5-\x5cu0AB9\x5cu0ABD\x5cu0AD0\x5cu0AE0\x5cu0AE1\x5cu0AF9\x5cu0B05-\x5cu0B0C\x5cu0B0F\x5cu0B10\x5cu0B13-\x5cu0B28\x5cu0B2A-\x5cu0B30\x5cu0B32\x5cu0B33\x5cu0B35-\x5cu0B39\x5cu0B3D\x5cu0B5C\x5cu0B5D\x5cu0B5F-\x5cu0B61\x5cu0B71\x5cu0B83\x5cu0B85-\x5cu0B8A\x5cu0B8E-\x5cu0B90\x5cu0B92-\x5cu0B95\x5cu0B99\x5cu0B9A\x5cu0B9C\x5cu0B9E\x5cu0B9F\x5cu0BA3\x5cu0BA4\x5cu0BA8-\x5cu0BAA\x5cu0BAE-\x5cu0BB9\x5cu0BD0\x5cu0C05-\x5cu0C0C\x5cu0C0E-\x5cu0C10\x5cu0C12-\x5cu0C28\x5cu0C2A-\x5cu0C39\x5cu0C3D\x5cu0C58-\x5cu0C5A\x5cu0C60\x5cu0C61\x5cu0C85-\x5cu0C8C\x5cu0C8E-\x5cu0C90\x5cu0C92-\x5cu0CA8\x5cu0CAA-\x5cu0CB3\x5cu0CB5-\x5cu0CB9\x5cu0CBD\x5cu0CDE\x5cu0CE0\x5cu0CE1\x5cu0CF1\x5cu0CF2\x5cu0D05-\x5cu0D0C\x5cu0D0E-\x5cu0D10\x5cu0D12-\x5cu0D3A\x5cu0D3D\x5cu0D4E\x5cu0D5F-\x5cu0D61\x5cu0D7A-\x5cu0D7F\x5cu0D85-\x5cu0D96\x5cu0D9A-\x5cu0DB1\x5cu0DB3-\x5cu0DBB\x5cu0DBD\x5cu0DC0-\x5cu0DC6\x5cu0E01-\x5cu0E30\x5cu0E32\x5cu0E33\x5cu0E40-\x5cu0E46\x5cu0E81\x5cu0E82\x5cu0E84\x5cu0E87\x5cu0E88\x5cu0E8A\x5cu0E8D\x5cu0E94-\x5cu0E97\x5cu0E99-\x5cu0E9F\x5cu0EA1-\x5cu0EA3\x5cu0EA5\x5cu0EA7\x5cu0EAA\x5cu0EAB\x5cu0EAD-\x5cu0EB0\x5cu0EB2\x5cu0EB3\x5cu0EBD\x5cu0EC0-\x5cu0EC4\x5cu0EC6\x5cu0EDC-\x5cu0EDF\x5cu0F00\x5cu0F40-\x5cu0F47\x5cu0F49-\x5cu0F6C\x5cu0F88-\x5cu0F8C\x5cu1000-\x5cu102A\x5cu103F\x5cu1050-\x5cu1055\x5cu105A-\x5cu105D\x5cu1061\x5cu1065\x5cu1066\x5cu106E-\x5cu1070\x5cu1075-\x5cu1081\x5cu108E\x5cu10A0-\x5cu10C5\x5cu10C7\x5cu10CD\x5cu10D0-\x5cu10FA\x5cu10FC-\x5cu1248\x5cu124A-\x5cu124D\x5cu1250-\x5cu1256\x5cu1258\x5cu125A-\x5cu125D\x5cu1260-\x5cu1288\x5cu128A-\x5cu128D\x5cu1290-\x5cu12B0\x5cu12B2-\x5cu12B5\x5cu12B8-\x5cu12BE\x5cu12C0\x5cu12C2-\x5cu12C5\x5cu12C8-\x5cu12D6\x5cu12D8-\x5cu1310\x5cu1312-\x5cu1315\x5cu1318-\x5cu135A\x5cu1380-\x5cu138F\x5cu13A0-\x5cu13F5\x5cu13F8-\x5cu13FD\x5cu1401-\x5cu166C\x5cu166F-\x5cu167F\x5cu1681-\x5cu169A\x5cu16A0-\x5cu16EA\x5cu16EE-\x5cu16F8\x5cu1700-\x5cu170C\x5cu170E-\x5cu1711\x5cu1720-\x5cu1731\x5cu1740-\x5cu1751\x5cu1760-\x5cu176C\x5cu176E-\x5cu1770\x5cu1780-\x5cu17B3\x5cu17D7\x5cu17DC\x5cu1820-\x5cu1877\x5cu1880-\x5cu18A8\x5cu18AA\x5cu18B0-\x5cu18F5\x5cu1900-\x5cu191E\x5cu1950-\x5cu196D\x5cu1970-\x5cu1974\x5cu1980-\x5cu19AB\x5cu19B0-\x5cu19C9\x5cu1A00-\x5cu1A16\x5cu1A20-\x5cu1A54\x5cu1AA7\x5cu1B05-\x5cu1B33\x5cu1B45-\x5cu1B4B\x5cu1B83-\x5cu1BA0\x5cu1BAE\x5cu1BAF\x5cu1BBA-\x5cu1BE5\x5cu1C00-\x5cu1C23\x5cu1C4D-\x5cu1C4F\x5cu1C5A-\x5cu1C7D\x5cu1CE9-\x5cu1CEC\x5cu1CEE-\x5cu1CF1\x5cu1CF5\x5cu1CF6\x5cu1D00-\x5cu1DBF\x5cu1E00-\x5cu1F15\x5cu1F18-\x5cu1F1D\x5cu1F20-\x5cu1F45\x5cu1F48-\x5cu1F4D\x5cu1F50-\x5cu1F57\x5cu1F59\x5cu1F5B\x5cu1F5D\x5cu1F5F-\x5cu1F7D\x5cu1F80-\x5cu1FB4\x5cu1FB6-\x5cu1FBC\x5cu1FBE\x5cu1FC2-\x5cu1FC4\x5cu1FC6-\x5cu1FCC\x5cu1FD0-\x5cu1FD3\x5cu1FD6-\x5cu1FDB\x5cu1FE0-\x5cu1FEC\x5cu1FF2-\x5cu1FF4\x5cu1FF6-\x5cu1FFC\x5cu2071\x5cu207F\x5cu2090-\x5cu209C\x5cu2102\x5cu2107\x5cu210A-\x5cu2113\x5cu2115\x5cu2118-\x5cu211D\x5cu2124\x5cu2126\x5cu2128\x5cu212A-\x5cu2139\x5cu213C-\x5cu213F\x5cu2145-\x5cu2149\x5cu214E\x5cu2160-\x5cu2188\x5cu2C00-\x5cu2C2E\x5cu2C30-\x5cu2C5E\x5cu2C60-\x5cu2CE4\x5cu2CEB-\x5cu2CEE\x5cu2CF2\x5cu2CF3\x5cu2D00-\x5cu2D25\x5cu2D27\x5cu2D2D\x5cu2D30-\x5cu2D67\x5cu2D6F\x5cu2D80-\x5cu2D96\x5cu2DA0-\x5cu2DA6\x5cu2DA8-\x5cu2DAE\x5cu2DB0-\x5cu2DB6\x5cu2DB8-\x5cu2DBE\x5cu2DC0-\x5cu2DC6\x5cu2DC8-\x5cu2DCE\x5cu2DD0-\x5cu2DD6\x5cu2DD8-\x5cu2DDE\x5cu3005-\x5cu3007\x5cu3021-\x5cu3029\x5cu3031-\x5cu3035\x5cu3038-\x5cu303C\x5cu3041-\x5cu3096\x5cu309B-\x5cu309F\x5cu30A1-\x5cu30FA\x5cu30FC-\x5cu30FF\x5cu3105-\x5cu312D\x5cu3131-\x5cu318E\x5cu31A0-\x5cu31BA\x5cu31F0-\x5cu31FF\x5cu3400-\x5cu4DB5\x5cu4E00-\x5cu9FD5\x5cuA000-\x5cuA48C\x5cuA4D0-\x5cuA4FD\x5cuA500-\x5cuA60C\x5cuA610-\x5cuA61F\x5cuA62A\x5cuA62B\x5cuA640-\x5cuA66E\x5cuA67F-\x5cuA69D\x5cuA6A0-\x5cuA6EF\x5cuA717-\x5cuA71F\x5cuA722-\x5cuA788\x5cuA78B-\x5cuA7AD\x5cuA7B0-\x5cuA7B7\x5cuA7F7-\x5cuA801\x5cuA803-\x5cuA805\x5cuA807-\x5cuA80A\x5cuA80C-\x5cuA822\x5cuA840-\x5cuA873\x5cuA882-\x5cuA8B3\x5cuA8F2-\x5cuA8F7\x5cuA8FB\x5cuA8FD\x5cuA90A-\x5cuA925\x5cuA930-\x5cuA946\x5cuA960-\x5cuA97C\x5cuA984-\x5cuA9B2\x5cuA9CF\x5cuA9E0-\x5cuA9E4\x5cuA9E6-\x5cuA9EF\x5cuA9FA-\x5cuA9FE\x5cuAA00-\x5cuAA28\x5cuAA40-\x5cuAA42\x5cuAA44-\x5cuAA4B\x5cuAA60-\x5cuAA76\x5cuAA7A\x5cuAA7E-\x5cuAAAF\x5cuAAB1\x5cuAAB5\x5cuAAB6\x5cuAAB9-\x5cuAABD\x5cuAAC0\x5cuAAC2\x5cuAADB-\x5cuAADD\x5cuAAE0-\x5cuAAEA\x5cuAAF2-\x5cuAAF4\x5cuAB01-\x5cuAB06\x5cuAB09-\x5cuAB0E\x5cuAB11-\x5cuAB16\x5cuAB20-\x5cuAB26\x5cuAB28-\x5cuAB2E\x5cuAB30-\x5cuAB5A\x5cuAB5C-\x5cuAB65\x5cuAB70-\x5cuABE2\x5cuAC00-\x5cuD7A3\x5cuD7B0-\x5cuD7C6\x5cuD7CB-\x5cuD7FB\x5cuF900-\x5cuFA6D\x5cuFA70-\x5cuFAD9\x5cuFB00-\x5cuFB06\x5cuFB13-\x5cuFB17\x5cuFB1D\x5cuFB1F-\x5cuFB28\x5cuFB2A-\x5cuFB36\x5cuFB38-\x5cuFB3C\x5cuFB3E\x5cuFB40\x5cuFB41\x5cuFB43\x5cuFB44\x5cuFB46-\x5cuFBB1\x5cuFBD3-\x5cuFD3D\x5cuFD50-\x5cuFD8F\x5cuFD92-\x5cuFDC7\x5cuFDF0-\x5cuFDFB\x5cuFE70-\x5cuFE74\x5cuFE76-\x5cuFEFC\x5cuFF21-\x5cuFF3A\x5cuFF41-\x5cuFF5A\x5cuFF66-\x5cuFFBE\x5cuFFC2-\x5cuFFC7\x5cuFFCA-\x5cuFFCF\x5cuFFD2-\x5cuFFD7\x5cuFFDA-\x5cuFFDC]|\x5cuD800[\x5cuDC00-\x5cuDC0B\x5cuDC0D-\x5cuDC26\x5cuDC28-\x5cuDC3A\x5cuDC3C\x5cuDC3D\x5cuDC3F-\x5cuDC4D\x5cuDC50-\x5cuDC5D\x5cuDC80-\x5cuDCFA\x5cuDD40-\x5cuDD74\x5cuDE80-\x5cuDE9C\x5cuDEA0-\x5cuDED0\x5cuDF00-\x5cuDF1F\x5cuDF30-\x5cuDF4A\x5cuDF50-\x5cuDF75\x5cuDF80-\x5cuDF9D\x5cuDFA0-\x5cuDFC3\x5cuDFC8-\x5cuDFCF\x5cuDFD1-\x5cuDFD5]|\x5cuD801[\x5cuDC00-\x5cuDC9D\x5cuDD00-\x5cuDD27\x5cuDD30-\x5cuDD63\x5cuDE00-\x5cuDF36\x5cuDF40-\x5cuDF55\x5cuDF60-\x5cuDF67]|\x5cuD802[\x5cuDC00-\x5cuDC05\x5cuDC08\x5cuDC0A-\x5cuDC35\x5cuDC37\x5cuDC38\x5cuDC3C\x5cuDC3F-\x5cuDC55\x5cuDC60-\x5cuDC76\x5cuDC80-\x5cuDC9E\x5cuDCE0-\x5cuDCF2\x5cuDCF4\x5cuDCF5\x5cuDD00-\x5cuDD15\x5cuDD20-\x5cuDD39\x5cuDD80-\x5cuDDB7\x5cuDDBE\x5cuDDBF\x5cuDE00\x5cuDE10-\x5cuDE13\x5cuDE15-\x5cuDE17\x5cuDE19-\x5cuDE33\x5cuDE60-\x5cuDE7C\x5cuDE80-\x5cuDE9C\x5cuDEC0-\x5cuDEC7\x5cuDEC9-\x5cuDEE4\x5cuDF00-\x5cuDF35\x5cuDF40-\x5cuDF55\x5cuDF60-\x5cuDF72\x5cuDF80-\x5cuDF91]|\x5cuD803[\x5cuDC00-\x5cuDC48\x5cuDC80-\x5cuDCB2\x5cuDCC0-\x5cuDCF2]|\x5cuD804[\x5cuDC03-\x5cuDC37\x5cuDC83-\x5cuDCAF\x5cuDCD0-\x5cuDCE8\x5cuDD03-\x5cuDD26\x5cuDD50-\x5cuDD72\x5cuDD76\x5cuDD83-\x5cuDDB2\x5cuDDC1-\x5cuDDC4\x5cuDDDA\x5cuDDDC\x5cuDE00-\x5cuDE11\x5cuDE13-\x5cuDE2B\x5cuDE80-\x5cuDE86\x5cuDE88\x5cuDE8A-\x5cuDE8D\x5cuDE8F-\x5cuDE9D\x5cuDE9F-\x5cuDEA8\x5cuDEB0-\x5cuDEDE\x5cuDF05-\x5cuDF0C\x5cuDF0F\x5cuDF10\x5cuDF13-\x5cuDF28\x5cuDF2A-\x5cuDF30\x5cuDF32\x5cuDF33\x5cuDF35-\x5cuDF39\x5cuDF3D\x5cuDF50\x5cuDF5D-\x5cuDF61]|\x5cuD805[\x5cuDC80-\x5cuDCAF\x5cuDCC4\x5cuDCC5\x5cuDCC7\x5cuDD80-\x5cuDDAE\x5cuDDD8-\x5cuDDDB\x5cuDE00-\x5cuDE2F\x5cuDE44\x5cuDE80-\x5cuDEAA\x5cuDF00-\x5cuDF19]|\x5cuD806[\x5cuDCA0-\x5cuDCDF\x5cuDCFF\x5cuDEC0-\x5cuDEF8]|\x5cuD808[\x5cuDC00-\x5cuDF99]|\x5cuD809[\x5cuDC00-\x5cuDC6E\x5cuDC80-\x5cuDD43]|[\x5cuD80C\x5cuD840-\x5cuD868\x5cuD86A-\x5cuD86C\x5cuD86F-\x5cuD872][\x5cuDC00-\x5cuDFFF]|\x5cuD80D[\x5cuDC00-\x5cuDC2E]|\x5cuD811[\x5cuDC00-\x5cuDE46]|\x5cuD81A[\x5cuDC00-\x5cuDE38\x5cuDE40-\x5cuDE5E\x5cuDED0-\x5cuDEED\x5cuDF00-\x5cuDF2F\x5cuDF40-\x5cuDF43\x5cuDF63-\x5cuDF77\x5cuDF7D-\x5cuDF8F]|\x5cuD81B[\x5cuDF00-\x5cuDF44\x5cuDF50\x5cuDF93-\x5cuDF9F]|\x5cuD82C[\x5cuDC00\x5cuDC01]|\x5cuD82F[\x5cuDC00-\x5cuDC6A\x5cuDC70-\x5cuDC7C\x5cuDC80-\x5cuDC88\x5cuDC90-\x5cuDC99]|\x5cuD835[\x5cuDC00-\x5cuDC54\x5cuDC56-\x5cuDC9C\x5cuDC9E\x5cuDC9F\x5cuDCA2\x5cuDCA5\x5cuDCA6\x5cuDCA9-\x5cuDCAC\x5cuDCAE-\x5cuDCB9\x5cuDCBB\x5cuDCBD-\x5cuDCC3\x5cuDCC5-\x5cuDD05\x5cuDD07-\x5cuDD0A\x5cuDD0D-\x5cuDD14\x5cuDD16-\x5cuDD1C\x5cuDD1E-\x5cuDD39\x5cuDD3B-\x5cuDD3E\x5cuDD40-\x5cuDD44\x5cuDD46\x5cuDD4A-\x5cuDD50\x5cuDD52-\x5cuDEA5\x5cuDEA8-\x5cuDEC0\x5cuDEC2-\x5cuDEDA\x5cuDEDC-\x5cuDEFA\x5cuDEFC-\x5cuDF14\x5cuDF16-\x5cuDF34\x5cuDF36-\x5cuDF4E\x5cuDF50-\x5cuDF6E\x5cuDF70-\x5cuDF88\x5cuDF8A-\x5cuDFA8\x5cuDFAA-\x5cuDFC2\x5cuDFC4-\x5cuDFCB]|\x5cuD83A[\x5cuDC00-\x5cuDCC4]|\x5cuD83B[\x5cuDE00-\x5cuDE03\x5cuDE05-\x5cuDE1F\x5cuDE21\x5cuDE22\x5cuDE24\x5cuDE27\x5cuDE29-\x5cuDE32\x5cuDE34-\x5cuDE37\x5cuDE39\x5cuDE3B\x5cuDE42\x5cuDE47\x5cuDE49\x5cuDE4B\x5cuDE4D-\x5cuDE4F\x5cuDE51\x5cuDE52\x5cuDE54\x5cuDE57\x5cuDE59\x5cuDE5B\x5cuDE5D\x5cuDE5F\x5cuDE61\x5cuDE62\x5cuDE64\x5cuDE67-\x5cuDE6A\x5cuDE6C-\x5cuDE72\x5cuDE74-\x5cuDE77\x5cuDE79-\x5cuDE7C\x5cuDE7E\x5cuDE80-\x5cuDE89\x5cuDE8B-\x5cuDE9B\x5cuDEA1-\x5cuDEA3\x5cuDEA5-\x5cuDEA9\x5cuDEAB-\x5cuDEBB]|\x5cuD869[\x5cuDC00-\x5cuDED6\x5cuDF00-\x5cuDFFF]|\x5cuD86D[\x5cuDC00-\x5cuDF34\x5cuDF40-\x5cuDFFF]|\x5cuD86E[\x5cuDC00-\x5cuDC1D\x5cuDC20-\x5cuDFFF]|\x5cuD873[\x5cuDC00-\x5cuDEA1]|\x5cuD87E[\x5cuDC00-\x5cuDE1D]/,\x0a\x09    // Unicode v8.0.0 NonAsciiIdentifierPart:\x0a\x09    NonAsciiIdentifierPart: /[\x5cxAA\x5cxB5\x5cxB7\x5cxBA\x5cxC0-\x5cxD6\x5cxD8-\x5cxF6\x5cxF8-\x5cu02C1\x5cu02C6-\x5cu02D1\x5cu02E0-\x5cu02E4\x5cu02EC\x5cu02EE\x5cu0300-\x5cu0374\x5cu0376\x5cu0377\x5cu037A-\x5cu037D\x5cu037F\x5cu0386-\x5cu038A\x5cu038C\x5cu038E-\x5cu03A1\x5cu03A3-\x5cu03F5\x5cu03F7-\x5cu0481\x5cu0483-\x5cu0487\x5cu048A-\x5cu052F\x5cu0531-\x5cu0556\x5cu0559\x5cu0561-\x5cu0587\x5cu0591-\x5cu05BD\x5cu05BF\x5cu05C1\x5cu05C2\x5cu05C4\x5cu05C5\x5cu05C7\x5cu05D0-\x5cu05EA\x5cu05F0-\x5cu05F2\x5cu0610-\x5cu061A\x5cu0620-\x5cu0669\x5cu066E-\x5cu06D3\x5cu06D5-\x5cu06DC\x5cu06DF-\x5cu06E8\x5cu06EA-\x5cu06FC\x5cu06FF\x5cu0710-\x5cu074A\x5cu074D-\x5cu07B1\x5cu07C0-\x5cu07F5\x5cu07FA\x5cu0800-\x5cu082D\x5cu0840-\x5cu085B\x5cu08A0-\x5cu08B4\x5cu08E3-\x5cu0963\x5cu0966-\x5cu096F\x5cu0971-\x5cu0983\x5cu0985-\x5cu098C\x5cu098F\x5cu0990\x5cu0993-\x5cu09A8\x5cu09AA-\x5cu09B0\x5cu09B2\x5cu09B6-\x5cu09B9\x5cu09BC-\x5cu09C4\x5cu09C7\x5cu09C8\x5cu09CB-\x5cu09CE\x5cu09D7\x5cu09DC\x5cu09DD\x5cu09DF-\x5cu09E3\x5cu09E6-\x5cu09F1\x5cu0A01-\x5cu0A03\x5cu0A05-\x5cu0A0A\x5cu0A0F\x5cu0A10\x5cu0A13-\x5cu0A28\x5cu0A2A-\x5cu0A30\x5cu0A32\x5cu0A33\x5cu0A35\x5cu0A36\x5cu0A38\x5cu0A39\x5cu0A3C\x5cu0A3E-\x5cu0A42\x5cu0A47\x5cu0A48\x5cu0A4B-\x5cu0A4D\x5cu0A51\x5cu0A59-\x5cu0A5C\x5cu0A5E\x5cu0A66-\x5cu0A75\x5cu0A81-\x5cu0A83\x5cu0A85-\x5cu0A8D\x5cu0A8F-\x5cu0A91\x5cu0A93-\x5cu0AA8\x5cu0AAA-\x5cu0AB0\x5cu0AB2\x5cu0AB3\x5cu0AB5-\x5cu0AB9\x5cu0ABC-\x5cu0AC5\x5cu0AC7-\x5cu0AC9\x5cu0ACB-\x5cu0ACD\x5cu0AD0\x5cu0AE0-\x5cu0AE3\x5cu0AE6-\x5cu0AEF\x5cu0AF9\x5cu0B01-\x5cu0B03\x5cu0B05-\x5cu0B0C\x5cu0B0F\x5cu0B10\x5cu0B13-\x5cu0B28\x5cu0B2A-\x5cu0B30\x5cu0B32\x5cu0B33\x5cu0B35-\x5cu0B39\x5cu0B3C-\x5cu0B44\x5cu0B47\x5cu0B48\x5cu0B4B-\x5cu0B4D\x5cu0B56\x5cu0B57\x5cu0B5C\x5cu0B5D\x5cu0B5F-\x5cu0B63\x5cu0B66-\x5cu0B6F\x5cu0B71\x5cu0B82\x5cu0B83\x5cu0B85-\x5cu0B8A\x5cu0B8E-\x5cu0B90\x5cu0B92-\x5cu0B95\x5cu0B99\x5cu0B9A\x5cu0B9C\x5cu0B9E\x5cu0B9F\x5cu0BA3\x5cu0BA4\x5cu0BA8-\x5cu0BAA\x5cu0BAE-\x5cu0BB9\x5cu0BBE-\x5cu0BC2\x5cu0BC6-\x5cu0BC8\x5cu0BCA-\x5cu0BCD\x5cu0BD0\x5cu0BD7\x5cu0BE6-\x5cu0BEF\x5cu0C00-\x5cu0C03\x5cu0C05-\x5cu0C0C\x5cu0C0E-\x5cu0C10\x5cu0C12-\x5cu0C28\x5cu0C2A-\x5cu0C39\x5cu0C3D-\x5cu0C44\x5cu0C46-\x5cu0C48\x5cu0C4A-\x5cu0C4D\x5cu0C55\x5cu0C56\x5cu0C58-\x5cu0C5A\x5cu0C60-\x5cu0C63\x5cu0C66-\x5cu0C6F\x5cu0C81-\x5cu0C83\x5cu0C85-\x5cu0C8C\x5cu0C8E-\x5cu0C90\x5cu0C92-\x5cu0CA8\x5cu0CAA-\x5cu0CB3\x5cu0CB5-\x5cu0CB9\x5cu0CBC-\x5cu0CC4\x5cu0CC6-\x5cu0CC8\x5cu0CCA-\x5cu0CCD\x5cu0CD5\x5cu0CD6\x5cu0CDE\x5cu0CE0-\x5cu0CE3\x5cu0CE6-\x5cu0CEF\x5cu0CF1\x5cu0CF2\x5cu0D01-\x5cu0D03\x5cu0D05-\x5cu0D0C\x5cu0D0E-\x5cu0D10\x5cu0D12-\x5cu0D3A\x5cu0D3D-\x5cu0D44\x5cu0D46-\x5cu0D48\x5cu0D4A-\x5cu0D4E\x5cu0D57\x5cu0D5F-\x5cu0D63\x5cu0D66-\x5cu0D6F\x5cu0D7A-\x5cu0D7F\x5cu0D82\x5cu0D83\x5cu0D85-\x5cu0D96\x5cu0D9A-\x5cu0DB1\x5cu0DB3-\x5cu0DBB\x5cu0DBD\x5cu0DC0-\x5cu0DC6\x5cu0DCA\x5cu0DCF-\x5cu0DD4\x5cu0DD6\x5cu0DD8-\x5cu0DDF\x5cu0DE6-\x5cu0DEF\x5cu0DF2\x5cu0DF3\x5cu0E01-\x5cu0E3A\x5cu0E40-\x5cu0E4E\x5cu0E50-\x5cu0E59\x5cu0E81\x5cu0E82\x5cu0E84\x5cu0E87\x5cu0E88\x5cu0E8A\x5cu0E8D\x5cu0E94-\x5cu0E97\x5cu0E99-\x5cu0E9F\x5cu0EA1-\x5cu0EA3\x5cu0EA5\x5cu0EA7\x5cu0EAA\x5cu0EAB\x5cu0EAD-\x5cu0EB9\x5cu0EBB-\x5cu0EBD\x5cu0EC0-\x5cu0EC4\x5cu0EC6\x5cu0EC8-\x5cu0ECD\x5cu0ED0-\x5cu0ED9\x5cu0EDC-\x5cu0EDF\x5cu0F00\x5cu0F18\x5cu0F19\x5cu0F20-\x5cu0F29\x5cu0F35\x5cu0F37\x5cu0F39\x5cu0F3E-\x5cu0F47\x5cu0F49-\x5cu0F6C\x5cu0F71-\x5cu0F84\x5cu0F86-\x5cu0F97\x5cu0F99-\x5cu0FBC\x5cu0FC6\x5cu1000-\x5cu1049\x5cu1050-\x5cu109D\x5cu10A0-\x5cu10C5\x5cu10C7\x5cu10CD\x5cu10D0-\x5cu10FA\x5cu10FC-\x5cu1248\x5cu124A-\x5cu124D\x5cu1250-\x5cu1256\x5cu1258\x5cu125A-\x5cu125D\x5cu1260-\x5cu1288\x5cu128A-\x5cu128D\x5cu1290-\x5cu12B0\x5cu12B2-\x5cu12B5\x5cu12B8-\x5cu12BE\x5cu12C0\x5cu12C2-\x5cu12C5\x5cu12C8-\x5cu12D6\x5cu12D8-\x5cu1310\x5cu1312-\x5cu1315\x5cu1318-\x5cu135A\x5cu135D-\x5cu135F\x5cu1369-\x5cu1371\x5cu1380-\x5cu138F\x5cu13A0-\x5cu13F5\x5cu13F8-\x5cu13FD\x5cu1401-\x5cu166C\x5cu166F-\x5cu167F\x5cu1681-\x5cu169A\x5cu16A0-\x5cu16EA\x5cu16EE-\x5cu16F8\x5cu1700-\x5cu170C\x5cu170E-\x5cu1714\x5cu1720-\x5cu1734\x5cu1740-\x5cu1753\x5cu1760-\x5cu176C\x5cu176E-\x5cu1770\x5cu1772\x5cu1773\x5cu1780-\x5cu17D3\x5cu17D7\x5cu17DC\x5cu17DD\x5cu17E0-\x5cu17E9\x5cu180B-\x5cu180D\x5cu1810-\x5cu1819\x5cu1820-\x5cu1877\x5cu1880-\x5cu18AA\x5cu18B0-\x5cu18F5\x5cu1900-\x5cu191E\x5cu1920-\x5cu192B\x5cu1930-\x5cu193B\x5cu1946-\x5cu196D\x5cu1970-\x5cu1974\x5cu1980-\x5cu19AB\x5cu19B0-\x5cu19C9\x5cu19D0-\x5cu19DA\x5cu1A00-\x5cu1A1B\x5cu1A20-\x5cu1A5E\x5cu1A60-\x5cu1A7C\x5cu1A7F-\x5cu1A89\x5cu1A90-\x5cu1A99\x5cu1AA7\x5cu1AB0-\x5cu1ABD\x5cu1B00-\x5cu1B4B\x5cu1B50-\x5cu1B59\x5cu1B6B-\x5cu1B73\x5cu1B80-\x5cu1BF3\x5cu1C00-\x5cu1C37\x5cu1C40-\x5cu1C49\x5cu1C4D-\x5cu1C7D\x5cu1CD0-\x5cu1CD2\x5cu1CD4-\x5cu1CF6\x5cu1CF8\x5cu1CF9\x5cu1D00-\x5cu1DF5\x5cu1DFC-\x5cu1F15\x5cu1F18-\x5cu1F1D\x5cu1F20-\x5cu1F45\x5cu1F48-\x5cu1F4D\x5cu1F50-\x5cu1F57\x5cu1F59\x5cu1F5B\x5cu1F5D\x5cu1F5F-\x5cu1F7D\x5cu1F80-\x5cu1FB4\x5cu1FB6-\x5cu1FBC\x5cu1FBE\x5cu1FC2-\x5cu1FC4\x5cu1FC6-\x5cu1FCC\x5cu1FD0-\x5cu1FD3\x5cu1FD6-\x5cu1FDB\x5cu1FE0-\x5cu1FEC\x5cu1FF2-\x5cu1FF4\x5cu1FF6-\x5cu1FFC\x5cu200C\x5cu200D\x5cu203F\x5cu2040\x5cu2054\x5cu2071\x5cu207F\x5cu2090-\x5cu209C\x5cu20D0-\x5cu20DC\x5cu20E1\x5cu20E5-\x5cu20F0\x5cu2102\x5cu2107\x5cu210A-\x5cu2113\x5cu2115\x5cu2118-\x5cu211D\x5cu2124\x5cu2126\x5cu2128\x5cu212A-\x5cu2139\x5cu213C-\x5cu213F\x5cu2145-\x5cu2149\x5cu214E\x5cu2160-\x5cu2188\x5cu2C00-\x5cu2C2E\x5cu2C30-\x5cu2C5E\x5cu2C60-\x5cu2CE4\x5cu2CEB-\x5cu2CF3\x5cu2D00-\x5cu2D25\x5cu2D27\x5cu2D2D\x5cu2D30-\x5cu2D67\x5cu2D6F\x5cu2D7F-\x5cu2D96\x5cu2DA0-\x5cu2DA6\x5cu2DA8-\x5cu2DAE\x5cu2DB0-\x5cu2DB6\x5cu2DB8-\x5cu2DBE\x5cu2DC0-\x5cu2DC6\x5cu2DC8-\x5cu2DCE\x5cu2DD0-\x5cu2DD6\x5cu2DD8-\x5cu2DDE\x5cu2DE0-\x5cu2DFF\x5cu3005-\x5cu3007\x5cu3021-\x5cu302F\x5cu3031-\x5cu3035\x5cu3038-\x5cu303C\x5cu3041-\x5cu3096\x5cu3099-\x5cu309F\x5cu30A1-\x5cu30FA\x5cu30FC-\x5cu30FF\x5cu3105-\x5cu312D\x5cu3131-\x5cu318E\x5cu31A0-\x5cu31BA\x5cu31F0-\x5cu31FF\x5cu3400-\x5cu4DB5\x5cu4E00-\x5cu9FD5\x5cuA000-\x5cuA48C\x5cuA4D0-\x5cuA4FD\x5cuA500-\x5cuA60C\x5cuA610-\x5cuA62B\x5cuA640-\x5cuA66F\x5cuA674-\x5cuA67D\x5cuA67F-\x5cuA6F1\x5cuA717-\x5cuA71F\x5cuA722-\x5cuA788\x5cuA78B-\x5cuA7AD\x5cuA7B0-\x5cuA7B7\x5cuA7F7-\x5cuA827\x5cuA840-\x5cuA873\x5cuA880-\x5cuA8C4\x5cuA8D0-\x5cuA8D9\x5cuA8E0-\x5cuA8F7\x5cuA8FB\x5cuA8FD\x5cuA900-\x5cuA92D\x5cuA930-\x5cuA953\x5cuA960-\x5cuA97C\x5cuA980-\x5cuA9C0\x5cuA9CF-\x5cuA9D9\x5cuA9E0-\x5cuA9FE\x5cuAA00-\x5cuAA36\x5cuAA40-\x5cuAA4D\x5cuAA50-\x5cuAA59\x5cuAA60-\x5cuAA76\x5cuAA7A-\x5cuAAC2\x5cuAADB-\x5cuAADD\x5cuAAE0-\x5cuAAEF\x5cuAAF2-\x5cuAAF6\x5cuAB01-\x5cuAB06\x5cuAB09-\x5cuAB0E\x5cuAB11-\x5cuAB16\x5cuAB20-\x5cuAB26\x5cuAB28-\x5cuAB2E\x5cuAB30-\x5cuAB5A\x5cuAB5C-\x5cuAB65\x5cuAB70-\x5cuABEA\x5cuABEC\x5cuABED\x5cuABF0-\x5cuABF9\x5cuAC00-\x5cuD7A3\x5cuD7B0-\x5cuD7C6\x5cuD7CB-\x5cuD7FB\x5cuF900-\x5cuFA6D\x5cuFA70-\x5cuFAD9\x5cuFB00-\x5cuFB06\x5cuFB13-\x5cuFB17\x5cuFB1D-\x5cuFB28\x5cuFB2A-\x5cuFB36\x5cuFB38-\x5cuFB3C\x5cuFB3E\x5cuFB40\x5cuFB41\x5cuFB43\x5cuFB44\x5cuFB46-\x5cuFBB1\x5cuFBD3-\x5cuFD3D\x5cuFD50-\x5cuFD8F\x5cuFD92-\x5cuFDC7\x5cuFDF0-\x5cuFDFB\x5cuFE00-\x5cuFE0F\x5cuFE20-\x5cuFE2F\x5cuFE33\x5cuFE34\x5cuFE4D-\x5cuFE4F\x5cuFE70-\x5cuFE74\x5cuFE76-\x5cuFEFC\x5cuFF10-\x5cuFF19\x5cuFF21-\x5cuFF3A\x5cuFF3F\x5cuFF41-\x5cuFF5A\x5cuFF66-\x5cuFFBE\x5cuFFC2-\x5cuFFC7\x5cuFFCA-\x5cuFFCF\x5cuFFD2-\x5cuFFD7\x5cuFFDA-\x5cuFFDC]|\x5cuD800[\x5cuDC00-\x5cuDC0B\x5cuDC0D-\x5cuDC26\x5cuDC28-\x5cuDC3A\x5cuDC3C\x5cuDC3D\x5cuDC3F-\x5cuDC4D\x5cuDC50-\x5cuDC5D\x5cuDC80-\x5cuDCFA\x5cuDD40-\x5cuDD74\x5cuDDFD\x5cuDE80-\x5cuDE9C\x5cuDEA0-\x5cuDED0\x5cuDEE0\x5cuDF00-\x5cuDF1F\x5cuDF30-\x5cuDF4A\x5cuDF50-\x5cuDF7A\x5cuDF80-\x5cuDF9D\x5cuDFA0-\x5cuDFC3\x5cuDFC8-\x5cuDFCF\x5cuDFD1-\x5cuDFD5]|\x5cuD801[\x5cuDC00-\x5cuDC9D\x5cuDCA0-\x5cuDCA9\x5cuDD00-\x5cuDD27\x5cuDD30-\x5cuDD63\x5cuDE00-\x5cuDF36\x5cuDF40-\x5cuDF55\x5cuDF60-\x5cuDF67]|\x5cuD802[\x5cuDC00-\x5cuDC05\x5cuDC08\x5cuDC0A-\x5cuDC35\x5cuDC37\x5cuDC38\x5cuDC3C\x5cuDC3F-\x5cuDC55\x5cuDC60-\x5cuDC76\x5cuDC80-\x5cuDC9E\x5cuDCE0-\x5cuDCF2\x5cuDCF4\x5cuDCF5\x5cuDD00-\x5cuDD15\x5cuDD20-\x5cuDD39\x5cuDD80-\x5cuDDB7\x5cuDDBE\x5cuDDBF\x5cuDE00-\x5cuDE03\x5cuDE05\x5cuDE06\x5cuDE0C-\x5cuDE13\x5cuDE15-\x5cuDE17\x5cuDE19-\x5cuDE33\x5cuDE38-\x5cuDE3A\x5cuDE3F\x5cuDE60-\x5cuDE7C\x5cuDE80-\x5cuDE9C\x5cuDEC0-\x5cuDEC7\x5cuDEC9-\x5cuDEE6\x5cuDF00-\x5cuDF35\x5cuDF40-\x5cuDF55\x5cuDF60-\x5cuDF72\x5cuDF80-\x5cuDF91]|\x5cuD803[\x5cuDC00-\x5cuDC48\x5cuDC80-\x5cuDCB2\x5cuDCC0-\x5cuDCF2]|\x5cuD804[\x5cuDC00-\x5cuDC46\x5cuDC66-\x5cuDC6F\x5cuDC7F-\x5cuDCBA\x5cuDCD0-\x5cuDCE8\x5cuDCF0-\x5cuDCF9\x5cuDD00-\x5cuDD34\x5cuDD36-\x5cuDD3F\x5cuDD50-\x5cuDD73\x5cuDD76\x5cuDD80-\x5cuDDC4\x5cuDDCA-\x5cuDDCC\x5cuDDD0-\x5cuDDDA\x5cuDDDC\x5cuDE00-\x5cuDE11\x5cuDE13-\x5cuDE37\x5cuDE80-\x5cuDE86\x5cuDE88\x5cuDE8A-\x5cuDE8D\x5cuDE8F-\x5cuDE9D\x5cuDE9F-\x5cuDEA8\x5cuDEB0-\x5cuDEEA\x5cuDEF0-\x5cuDEF9\x5cuDF00-\x5cuDF03\x5cuDF05-\x5cuDF0C\x5cuDF0F\x5cuDF10\x5cuDF13-\x5cuDF28\x5cuDF2A-\x5cuDF30\x5cuDF32\x5cuDF33\x5cuDF35-\x5cuDF39\x5cuDF3C-\x5cuDF44\x5cuDF47\x5cuDF48\x5cuDF4B-\x5cuDF4D\x5cuDF50\x5cuDF57\x5cuDF5D-\x5cuDF63\x5cuDF66-\x5cuDF6C\x5cuDF70-\x5cuDF74]|\x5cuD805[\x5cuDC80-\x5cuDCC5\x5cuDCC7\x5cuDCD0-\x5cuDCD9\x5cuDD80-\x5cuDDB5\x5cuDDB8-\x5cuDDC0\x5cuDDD8-\x5cuDDDD\x5cuDE00-\x5cuDE40\x5cuDE44\x5cuDE50-\x5cuDE59\x5cuDE80-\x5cuDEB7\x5cuDEC0-\x5cuDEC9\x5cuDF00-\x5cuDF19\x5cuDF1D-\x5cuDF2B\x5cuDF30-\x5cuDF39]|\x5cuD806[\x5cuDCA0-\x5cuDCE9\x5cuDCFF\x5cuDEC0-\x5cuDEF8]|\x5cuD808[\x5cuDC00-\x5cuDF99]|\x5cuD809[\x5cuDC00-\x5cuDC6E\x5cuDC80-\x5cuDD43]|[\x5cuD80C\x5cuD840-\x5cuD868\x5cuD86A-\x5cuD86C\x5cuD86F-\x5cuD872][\x5cuDC00-\x5cuDFFF]|\x5cuD80D[\x5cuDC00-\x5cuDC2E]|\x5cuD811[\x5cuDC00-\x5cuDE46]|\x5cuD81A[\x5cuDC00-\x5cuDE38\x5cuDE40-\x5cuDE5E\x5cuDE60-\x5cuDE69\x5cuDED0-\x5cuDEED\x5cuDEF0-\x5cuDEF4\x5cuDF00-\x5cuDF36\x5cuDF40-\x5cuDF43\x5cuDF50-\x5cuDF59\x5cuDF63-\x5cuDF77\x5cuDF7D-\x5cuDF8F]|\x5cuD81B[\x5cuDF00-\x5cuDF44\x5cuDF50-\x5cuDF7E\x5cuDF8F-\x5cuDF9F]|\x5cuD82C[\x5cuDC00\x5cuDC01]|\x5cuD82F[\x5cuDC00-\x5cuDC6A\x5cuDC70-\x5cuDC7C\x5cuDC80-\x5cuDC88\x5cuDC90-\x5cuDC99\x5cuDC9D\x5cuDC9E]|\x5cuD834[\x5cuDD65-\x5cuDD69\x5cuDD6D-\x5cuDD72\x5cuDD7B-\x5cuDD82\x5cuDD85-\x5cuDD8B\x5cuDDAA-\x5cuDDAD\x5cuDE42-\x5cuDE44]|\x5cuD835[\x5cuDC00-\x5cuDC54\x5cuDC56-\x5cuDC9C\x5cuDC9E\x5cuDC9F\x5cuDCA2\x5cuDCA5\x5cuDCA6\x5cuDCA9-\x5cuDCAC\x5cuDCAE-\x5cuDCB9\x5cuDCBB\x5cuDCBD-\x5cuDCC3\x5cuDCC5-\x5cuDD05\x5cuDD07-\x5cuDD0A\x5cuDD0D-\x5cuDD14\x5cuDD16-\x5cuDD1C\x5cuDD1E-\x5cuDD39\x5cuDD3B-\x5cuDD3E\x5cuDD40-\x5cuDD44\x5cuDD46\x5cuDD4A-\x5cuDD50\x5cuDD52-\x5cuDEA5\x5cuDEA8-\x5cuDEC0\x5cuDEC2-\x5cuDEDA\x5cuDEDC-\x5cuDEFA\x5cuDEFC-\x5cuDF14\x5cuDF16-\x5cuDF34\x5cuDF36-\x5cuDF4E\x5cuDF50-\x5cuDF6E\x5cuDF70-\x5cuDF88\x5cuDF8A-\x5cuDFA8\x5cuDFAA-\x5cuDFC2\x5cuDFC4-\x5cuDFCB\x5cuDFCE-\x5cuDFFF]|\x5cuD836[\x5cuDE00-\x5cuDE36\x5cuDE3B-\x5cuDE6C\x5cuDE75\x5cuDE84\x5cuDE9B-\x5cuDE9F\x5cuDEA1-\x5cuDEAF]|\x5cuD83A[\x5cuDC00-\x5cuDCC4\x5cuDCD0-\x5cuDCD6]|\x5cuD83B[\x5cuDE00-\x5cuDE03\x5cuDE05-\x5cuDE1F\x5cuDE21\x5cuDE22\x5cuDE24\x5cuDE27\x5cuDE29-\x5cuDE32\x5cuDE34-\x5cuDE37\x5cuDE39\x5cuDE3B\x5cuDE42\x5cuDE47\x5cuDE49\x5cuDE4B\x5cuDE4D-\x5cuDE4F\x5cuDE51\x5cuDE52\x5cuDE54\x5cuDE57\x5cuDE59\x5cuDE5B\x5cuDE5D\x5cuDE5F\x5cuDE61\x5cuDE62\x5cuDE64\x5cuDE67-\x5cuDE6A\x5cuDE6C-\x5cuDE72\x5cuDE74-\x5cuDE77\x5cuDE79-\x5cuDE7C\x5cuDE7E\x5cuDE80-\x5cuDE89\x5cuDE8B-\x5cuDE9B\x5cuDEA1-\x5cuDEA3\x5cuDEA5-\x5cuDEA9\x5cuDEAB-\x5cuDEBB]|\x5cuD869[\x5cuDC00-\x5cuDED6\x5cuDF00-\x5cuDFFF]|\x5cuD86D[\x5cuDC00-\x5cuDF34\x5cuDF40-\x5cuDFFF]|\x5cuD86E[\x5cuDC00-\x5cuDC1D\x5cuDC20-\x5cuDFFF]|\x5cuD873[\x5cuDC00-\x5cuDEA1]|\x5cuD87E[\x5cuDC00-\x5cuDE1D]|\x5cuDB40[\x5cuDD00-\x5cuDDEF]/\x0a\x09};\x0a\x09exports.Character = {\x0a\x09    /* tslint:disable:no-bitwise */\x0a\x09    fromCodePoint: function (cp) {\x0a\x09        return (cp \x3c 0x10000) ? String.fromCharCode(cp) :\x0a\x09            String.fromCharCode(0xD800 + ((cp - 0x10000) \x3e\x3e 10)) +\x0a\x09                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));\x0a\x09    },\x0a\x09    // https://tc39.github.io/ecma262/#sec-white-space\x0a\x09    isWhiteSpace: function (cp) {\x0a\x09        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||\x0a\x09            (cp \x3e= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) \x3e= 0);\x0a\x09    },\x0a\x09    // https://tc39.github.io/ecma262/#sec-line-terminators\x0a\x09    isLineTerminator: function (cp) {\x0a\x09        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);\x0a\x09    },\x0a\x09    // https://tc39.github.io/ecma262/#sec-names-and-keywords\x0a\x09    isIdentifierStart: function (cp) {\x0a\x09        return (cp === 0x24) || (cp === 0x5F) ||\x0a\x09            (cp \x3e= 0x41 && cp \x3c= 0x5A) ||\x0a\x09            (cp \x3e= 0x61 && cp \x3c= 0x7A) ||\x0a\x09            (cp === 0x5C) ||\x0a\x09            ((cp \x3e= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));\x0a\x09    },\x0a\x09    isIdentifierPart: function (cp) {\x0a\x09        return (cp === 0x24) || (cp === 0x5F) ||\x0a\x09            (cp \x3e= 0x41 && cp \x3c= 0x5A) ||\x0a\x09            (cp \x3e= 0x61 && cp \x3c= 0x7A) ||\x0a\x09            (cp \x3e= 0x30 && cp \x3c= 0x39) ||\x0a\x09            (cp === 0x5C) ||\x0a\x09            ((cp \x3e= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));\x0a\x09    },\x0a\x09    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals\x0a\x09    isDecimalDigit: function (cp) {\x0a\x09        return (cp \x3e= 0x30 && cp \x3c= 0x39); // 0..9\x0a\x09    },\x0a\x09    isHexDigit: function (cp) {\x0a\x09        return (cp \x3e= 0x30 && cp \x3c= 0x39) ||\x0a\x09            (cp \x3e= 0x41 && cp \x3c= 0x46) ||\x0a\x09            (cp \x3e= 0x61 && cp \x3c= 0x66); // a..f\x0a\x09    },\x0a\x09    isOctalDigit: function (cp) {\x0a\x09        return (cp \x3e= 0x30 && cp \x3c= 0x37); // 0..7\x0a\x09    }\x0a\x09};\x0a\x0a\x0a/***/ },\x0a/* 5 */\x0a/***/ function(module, exports, __webpack_require__) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09var jsx_syntax_1 = __webpack_require__(6);\x0a\x09/* tslint:disable:max-classes-per-file */\x0a\x09var JSXClosingElement = (function () {\x0a\x09    function JSXClosingElement(name) {\x0a\x09        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;\x0a\x09        this.name = name;\x0a\x09    }\x0a\x09    return JSXClosingElement;\x0a\x09}());\x0a\x09exports.JSXClosingElement = JSXClosingElement;\x0a\x09var JSXElement = (function () {\x0a\x09    function JSXElement(openingElement, children, closingElement) {\x0a\x09        this.type = jsx_syntax_1.JSXSyntax.JSXElement;\x0a\x09        this.openingElement = openingElement;\x0a\x09        this.children = children;\x0a\x09        this.closingElement = closingElement;\x0a\x09    }\x0a\x09    return JSXElement;\x0a\x09}());\x0a\x09exports.JSXElement = JSXElement;\x0a\x09var JSXEmptyExpression = (function () {\x0a\x09    function JSXEmptyExpression() {\x0a\x09        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;\x0a\x09    }\x0a\x09    return JSXEmptyExpression;\x0a\x09}());\x0a\x09exports.JSXEmptyExpression = JSXEmptyExpression;\x0a\x09var JSXExpressionContainer = (function () {\x0a\x09    function JSXExpressionContainer(expression) {\x0a\x09        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;\x0a\x09        this.expression = expression;\x0a\x09    }\x0a\x09    return JSXExpressionContainer;\x0a\x09}());\x0a\x09exports.JSXExpressionContainer = JSXExpressionContainer;\x0a\x09var JSXIdentifier = (function () {\x0a\x09    function JSXIdentifier(name) {\x0a\x09        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;\x0a\x09        this.name = name;\x0a\x09    }\x0a\x09    return JSXIdentifier;\x0a\x09}());\x0a\x09exports.JSXIdentifier = JSXIdentifier;\x0a\x09var JSXMemberExpression = (function () {\x0a\x09    function JSXMemberExpression(object, property) {\x0a\x09        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;\x0a\x09        this.object = object;\x0a\x09        this.property = property;\x0a\x09    }\x0a\x09    return JSXMemberExpression;\x0a\x09}());\x0a\x09exports.JSXMemberExpression = JSXMemberExpression;\x0a\x09var JSXAttribute = (function () {\x0a\x09    function JSXAttribute(name, value) {\x0a\x09        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;\x0a\x09        this.name = name;\x0a\x09        this.value = value;\x0a\x09    }\x0a\x09    return JSXAttribute;\x0a\x09}());\x0a\x09exports.JSXAttribute = JSXAttribute;\x0a\x09var JSXNamespacedName = (function () {\x0a\x09    function JSXNamespacedName(namespace, name) {\x0a\x09        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;\x0a\x09        this.namespace = namespace;\x0a\x09        this.name = name;\x0a\x09    }\x0a\x09    return JSXNamespacedName;\x0a\x09}());\x0a\x09exports.JSXNamespacedName = JSXNamespacedName;\x0a\x09var JSXOpeningElement = (function () {\x0a\x09    function JSXOpeningElement(name, selfClosing, attributes) {\x0a\x09        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;\x0a\x09        this.name = name;\x0a\x09        this.selfClosing = selfClosing;\x0a\x09        this.attributes = attributes;\x0a\x09    }\x0a\x09    return JSXOpeningElement;\x0a\x09}());\x0a\x09exports.JSXOpeningElement = JSXOpeningElement;\x0a\x09var JSXSpreadAttribute = (function () {\x0a\x09    function JSXSpreadAttribute(argument) {\x0a\x09        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;\x0a\x09        this.argument = argument;\x0a\x09    }\x0a\x09    return JSXSpreadAttribute;\x0a\x09}());\x0a\x09exports.JSXSpreadAttribute = JSXSpreadAttribute;\x0a\x09var JSXText = (function () {\x0a\x09    function JSXText(value, raw) {\x0a\x09        this.type = jsx_syntax_1.JSXSyntax.JSXText;\x0a\x09        this.value = value;\x0a\x09        this.raw = raw;\x0a\x09    }\x0a\x09    return JSXText;\x0a\x09}());\x0a\x09exports.JSXText = JSXText;\x0a\x0a\x0a/***/ },\x0a/* 6 */\x0a/***/ function(module, exports) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09exports.JSXSyntax = {\x0a\x09    JSXAttribute: \x27JSXAttribute\x27,\x0a\x09    JSXClosingElement: \x27JSXClosingElement\x27,\x0a\x09    JSXElement: \x27JSXElement\x27,\x0a\x09    JSXEmptyExpression: \x27JSXEmptyExpression\x27,\x0a\x09    JSXExpressionContainer: \x27JSXExpressionContainer\x27,\x0a\x09    JSXIdentifier: \x27JSXIdentifier\x27,\x0a\x09    JSXMemberExpression: \x27JSXMemberExpression\x27,\x0a\x09    JSXNamespacedName: \x27JSXNamespacedName\x27,\x0a\x09    JSXOpeningElement: \x27JSXOpeningElement\x27,\x0a\x09    JSXSpreadAttribute: \x27JSXSpreadAttribute\x27,\x0a\x09    JSXText: \x27JSXText\x27\x0a\x09};\x0a\x0a\x0a/***/ },\x0a/* 7 */\x0a/***/ function(module, exports, __webpack_require__) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09var syntax_1 = __webpack_require__(2);\x0a\x09/* tslint:disable:max-classes-per-file */\x0a\x09var ArrayExpression = (function () {\x0a\x09    function ArrayExpression(elements) {\x0a\x09        this.type = syntax_1.Syntax.ArrayExpression;\x0a\x09        this.elements = elements;\x0a\x09    }\x0a\x09    return ArrayExpression;\x0a\x09}());\x0a\x09exports.ArrayExpression = ArrayExpression;\x0a\x09var ArrayPattern = (function () {\x0a\x09    function ArrayPattern(elements) {\x0a\x09        this.type = syntax_1.Syntax.ArrayPattern;\x0a\x09        this.elements = elements;\x0a\x09    }\x0a\x09    return ArrayPattern;\x0a\x09}());\x0a\x09exports.ArrayPattern = ArrayPattern;\x0a\x09var ArrowFunctionExpression = (function () {\x0a\x09    function ArrowFunctionExpression(params, body, expression) {\x0a\x09        this.type = syntax_1.Syntax.ArrowFunctionExpression;\x0a\x09        this.id = null;\x0a\x09        this.params = params;\x0a\x09        this.body = body;\x0a\x09        this.generator = false;\x0a\x09        this.expression = expression;\x0a\x09        this.async = false;\x0a\x09    }\x0a\x09    return ArrowFunctionExpression;\x0a\x09}());\x0a\x09exports.ArrowFunctionExpression = ArrowFunctionExpression;\x0a\x09var AssignmentExpression = (function () {\x0a\x09    function AssignmentExpression(operator, left, right) {\x0a\x09        this.type = syntax_1.Syntax.AssignmentExpression;\x0a\x09        this.operator = operator;\x0a\x09        this.left = left;\x0a\x09        this.right = right;\x0a\x09    }\x0a\x09    return AssignmentExpression;\x0a\x09}());\x0a\x09exports.AssignmentExpression = AssignmentExpression;\x0a\x09var AssignmentPattern = (function () {\x0a\x09    function AssignmentPattern(left, right) {\x0a\x09        this.type = syntax_1.Syntax.AssignmentPattern;\x0a\x09        this.left = left;\x0a\x09        this.right = right;\x0a\x09    }\x0a\x09    return AssignmentPattern;\x0a\x09}());\x0a\x09exports.AssignmentPattern = AssignmentPattern;\x0a\x09var AsyncArrowFunctionExpression = (function () {\x0a\x09    function AsyncArrowFunctionExpression(params, body, expression) {\x0a\x09        this.type = syntax_1.Syntax.ArrowFunctionExpression;\x0a\x09        this.id = null;\x0a\x09        this.params = params;\x0a\x09        this.body = body;\x0a\x09        this.generator = false;\x0a\x09        this.expression = expression;\x0a\x09        this.async = true;\x0a\x09    }\x0a\x09    return AsyncArrowFunctionExpression;\x0a\x09}());\x0a\x09exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;\x0a\x09var AsyncFunctionDeclaration = (function () {\x0a\x09    function AsyncFunctionDeclaration(id, params, body) {\x0a\x09        this.type = syntax_1.Syntax.FunctionDeclaration;\x0a\x09        this.id = id;\x0a\x09        this.params = params;\x0a\x09        this.body = body;\x0a\x09        this.generator = false;\x0a\x09        this.expression = false;\x0a\x09        this.async = true;\x0a\x09    }\x0a\x09    return AsyncFunctionDeclaration;\x0a\x09}());\x0a\x09exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;\x0a\x09var AsyncFunctionExpression = (function () {\x0a\x09    function AsyncFunctionExpression(id, params, body) {\x0a\x09        this.type = syntax_1.Syntax.FunctionExpression;\x0a\x09        this.id = id;\x0a\x09        this.params = params;\x0a\x09        this.body = body;\x0a\x09        this.generator = false;\x0a\x09        this.expression = false;\x0a\x09        this.async = true;\x0a\x09    }\x0a\x09    return AsyncFunctionExpression;\x0a\x09}());\x0a\x09exports.AsyncFunctionExpression = AsyncFunctionExpression;\x0a\x09var AwaitExpression = (function () {\x0a\x09    function AwaitExpression(argument) {\x0a\x09        this.type = syntax_1.Syntax.AwaitExpression;\x0a\x09        this.argument = argument;\x0a\x09    }\x0a\x09    return AwaitExpression;\x0a\x09}());\x0a\x09exports.AwaitExpression = AwaitExpression;\x0a\x09var BinaryExpression = (function () {\x0a\x09    function BinaryExpression(operator, left, right) {\x0a\x09        var logical = (operator === \x27||\x27 || operator === \x27&&\x27);\x0a\x09        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;\x0a\x09        this.operator = operator;\x0a\x09        this.left = left;\x0a\x09        this.right = right;\x0a\x09    }\x0a\x09    return BinaryExpression;\x0a\x09}());\x0a\x09exports.BinaryExpression = BinaryExpression;\x0a\x09var BlockStatement = (function () {\x0a\x09    function BlockStatement(body) {\x0a\x09        this.type = syntax_1.Syntax.BlockStatement;\x0a\x09        this.body = body;\x0a\x09    }\x0a\x09    return BlockStatement;\x0a\x09}());\x0a\x09exports.BlockStatement = BlockStatement;\x0a\x09var BreakStatement = (function () {\x0a\x09    function BreakStatement(label) {\x0a\x09        this.type = syntax_1.Syntax.BreakStatement;\x0a\x09        this.label = label;\x0a\x09    }\x0a\x09    return BreakStatement;\x0a\x09}());\x0a\x09exports.BreakStatement = BreakStatement;\x0a\x09var CallExpression = (function () {\x0a\x09    function CallExpression(callee, args) {\x0a\x09        this.type = syntax_1.Syntax.CallExpression;\x0a\x09        this.callee = callee;\x0a\x09        this.arguments = args;\x0a\x09    }\x0a\x09    return CallExpression;\x0a\x09}());\x0a\x09exports.CallExpression = CallExpression;\x0a\x09var CatchClause = (function () {\x0a\x09    function CatchClause(param, body) {\x0a\x09        this.type = syntax_1.Syntax.CatchClause;\x0a\x09        this.param = param;\x0a\x09        this.body = body;\x0a\x09    }\x0a\x09    return CatchClause;\x0a\x09}());\x0a\x09exports.CatchClause = CatchClause;\x0a\x09var ClassBody = (function () {\x0a\x09    function ClassBody(body) {\x0a\x09        this.type = syntax_1.Syntax.ClassBody;\x0a\x09        this.body = body;\x0a\x09    }\x0a\x09    return ClassBody;\x0a\x09}());\x0a\x09exports.ClassBody = ClassBody;\x0a\x09var ClassDeclaration = (function () {\x0a\x09    function ClassDeclaration(id, superClass, body) {\x0a\x09        this.type = syntax_1.Syntax.ClassDeclaration;\x0a\x09        this.id = id;\x0a\x09        this.superClass = superClass;\x0a\x09        this.body = body;\x0a\x09    }\x0a\x09    return ClassDeclaration;\x0a\x09}());\x0a\x09exports.ClassDeclaration = ClassDeclaration;\x0a\x09var ClassExpression = (function () {\x0a\x09    function ClassExpression(id, superClass, body) {\x0a\x09        this.type = syntax_1.Syntax.ClassExpression;\x0a\x09        this.id = id;\x0a\x09        this.superClass = superClass;\x0a\x09        this.body = body;\x0a\x09    }\x0a\x09    return ClassExpression;\x0a\x09}());\x0a\x09exports.ClassExpression = ClassExpression;\x0a\x09var ComputedMemberExpression = (function () {\x0a\x09    function ComputedMemberExpression(object, property) {\x0a\x09        this.type = syntax_1.Syntax.MemberExpression;\x0a\x09        this.computed = true;\x0a\x09        this.object = object;\x0a\x09        this.property = property;\x0a\x09    }\x0a\x09    return ComputedMemberExpression;\x0a\x09}());\x0a\x09exports.ComputedMemberExpression = ComputedMemberExpression;\x0a\x09var ConditionalExpression = (function () {\x0a\x09    function ConditionalExpression(test, consequent, alternate) {\x0a\x09        this.type = syntax_1.Syntax.ConditionalExpression;\x0a\x09        this.test = test;\x0a\x09        this.consequent = consequent;\x0a\x09        this.alternate = alternate;\x0a\x09    }\x0a\x09    return ConditionalExpression;\x0a\x09}());\x0a\x09exports.ConditionalExpression = ConditionalExpression;\x0a\x09var ContinueStatement = (function () {\x0a\x09    function ContinueStatement(label) {\x0a\x09        this.type = syntax_1.Syntax.ContinueStatement;\x0a\x09        this.label = label;\x0a\x09    }\x0a\x09    return ContinueStatement;\x0a\x09}());\x0a\x09exports.ContinueStatement = ContinueStatement;\x0a\x09var DebuggerStatement = (function () {\x0a\x09    function DebuggerStatement() {\x0a\x09        this.type = syntax_1.Syntax.DebuggerStatement;\x0a\x09    }\x0a\x09    return DebuggerStatement;\x0a\x09}());\x0a\x09exports.DebuggerStatement = DebuggerStatement;\x0a\x09var Directive = (function () {\x0a\x09    function Directive(expression, directive) {\x0a\x09        this.type = syntax_1.Syntax.ExpressionStatement;\x0a\x09        this.expression = expression;\x0a\x09        this.directive = directive;\x0a\x09    }\x0a\x09    return Directive;\x0a\x09}());\x0a\x09exports.Directive = Directive;\x0a\x09var DoWhileStatement = (function () {\x0a\x09    function DoWhileStatement(body, test) {\x0a\x09        this.type = syntax_1.Syntax.DoWhileStatement;\x0a\x09        this.body = body;\x0a\x09        this.test = test;\x0a\x09    }\x0a\x09    return DoWhileStatement;\x0a\x09}());\x0a\x09exports.DoWhileStatement = DoWhileStatement;\x0a\x09var EmptyStatement = (function () {\x0a\x09    function EmptyStatement() {\x0a\x09        this.type = syntax_1.Syntax.EmptyStatement;\x0a\x09    }\x0a\x09    return EmptyStatement;\x0a\x09}());\x0a\x09exports.EmptyStatement = EmptyStatement;\x0a\x09var ExportAllDeclaration = (function () {\x0a\x09    function ExportAllDeclaration(source) {\x0a\x09        this.type = syntax_1.Syntax.ExportAllDeclaration;\x0a\x09        this.source = source;\x0a\x09    }\x0a\x09    return ExportAllDeclaration;\x0a\x09}());\x0a\x09exports.ExportAllDeclaration = ExportAllDeclaration;\x0a\x09var ExportDefaultDeclaration = (function () {\x0a\x09    function ExportDefaultDeclaration(declaration) {\x0a\x09        this.type = syntax_1.Syntax.ExportDefaultDeclaration;\x0a\x09        this.declaration = declaration;\x0a\x09    }\x0a\x09    return ExportDefaultDeclaration;\x0a\x09}());\x0a\x09exports.ExportDefaultDeclaration = ExportDefaultDeclaration;\x0a\x09var ExportNamedDeclaration = (function () {\x0a\x09    function ExportNamedDeclaration(declaration, specifiers, source) {\x0a\x09        this.type = syntax_1.Syntax.ExportNamedDeclaration;\x0a\x09        this.declaration = declaration;\x0a\x09        this.specifiers = specifiers;\x0a\x09        this.source = source;\x0a\x09    }\x0a\x09    return ExportNamedDeclaration;\x0a\x09}());\x0a\x09exports.ExportNamedDeclaration = ExportNamedDeclaration;\x0a\x09var ExportSpecifier = (function () {\x0a\x09    function ExportSpecifier(local, exported) {\x0a\x09        this.type = syntax_1.Syntax.ExportSpecifier;\x0a\x09        this.exported = exported;\x0a\x09        this.local = local;\x0a\x09    }\x0a\x09    return ExportSpecifier;\x0a\x09}());\x0a\x09exports.ExportSpecifier = ExportSpecifier;\x0a\x09var ExpressionStatement = (function () {\x0a\x09    function ExpressionStatement(expression) {\x0a\x09        this.type = syntax_1.Syntax.ExpressionStatement;\x0a\x09        this.expression = expression;\x0a\x09    }\x0a\x09    return ExpressionStatement;\x0a\x09}());\x0a\x09exports.ExpressionStatement = ExpressionStatement;\x0a\x09var ForInStatement = (function () {\x0a\x09    function ForInStatement(left, right, body) {\x0a\x09        this.type = syntax_1.Syntax.ForInStatement;\x0a\x09        this.left = left;\x0a\x09        this.right = right;\x0a\x09        this.body = body;\x0a\x09        this.each = false;\x0a\x09    }\x0a\x09    return ForInStatement;\x0a\x09}());\x0a\x09exports.ForInStatement = ForInStatement;\x0a\x09var ForOfStatement = (function () {\x0a\x09    function ForOfStatement(left, right, body) {\x0a\x09        this.type = syntax_1.Syntax.ForOfStatement;\x0a\x09        this.left = left;\x0a\x09        this.right = right;\x0a\x09        this.body = body;\x0a\x09    }\x0a\x09    return ForOfStatement;\x0a\x09}());\x0a\x09exports.ForOfStatement = ForOfStatement;\x0a\x09var ForStatement = (function () {\x0a\x09    function ForStatement(init, test, update, body) {\x0a\x09        this.type = syntax_1.Syntax.ForStatement;\x0a\x09        this.init = init;\x0a\x09        this.test = test;\x0a\x09        this.update = update;\x0a\x09        this.body = body;\x0a\x09    }\x0a\x09    return ForStatement;\x0a\x09}());\x0a\x09exports.ForStatement = ForStatement;\x0a\x09var FunctionDeclaration = (function () {\x0a\x09    function FunctionDeclaration(id, params, body, generator) {\x0a\x09        this.type = syntax_1.Syntax.FunctionDeclaration;\x0a\x09        this.id = id;\x0a\x09        this.params = params;\x0a\x09        this.body = body;\x0a\x09        this.generator = generator;\x0a\x09        this.expression = false;\x0a\x09        this.async = false;\x0a\x09    }\x0a\x09    return FunctionDeclaration;\x0a\x09}());\x0a\x09exports.FunctionDeclaration = FunctionDeclaration;\x0a\x09var FunctionExpression = (function () {\x0a\x09    function FunctionExpression(id, params, body, generator) {\x0a\x09        this.type = syntax_1.Syntax.FunctionExpression;\x0a\x09        this.id = id;\x0a\x09        this.params = params;\x0a\x09        this.body = body;\x0a\x09        this.generator = generator;\x0a\x09        this.expression = false;\x0a\x09        this.async = false;\x0a\x09    }\x0a\x09    return FunctionExpression;\x0a\x09}());\x0a\x09exports.FunctionExpression = FunctionExpression;\x0a\x09var Identifier = (function () {\x0a\x09    function Identifier(name) {\x0a\x09        this.type = syntax_1.Syntax.Identifier;\x0a\x09        this.name = name;\x0a\x09    }\x0a\x09    return Identifier;\x0a\x09}());\x0a\x09exports.Identifier = Identifier;\x0a\x09var IfStatement = (function () {\x0a\x09    function IfStatement(test, consequent, alternate) {\x0a\x09        this.type = syntax_1.Syntax.IfStatement;\x0a\x09        this.test = test;\x0a\x09        this.consequent = consequent;\x0a\x09        this.alternate = alternate;\x0a\x09    }\x0a\x09    return IfStatement;\x0a\x09}());\x0a\x09exports.IfStatement = IfStatement;\x0a\x09var ImportDeclaration = (function () {\x0a\x09    function ImportDeclaration(specifiers, source) {\x0a\x09        this.type = syntax_1.Syntax.ImportDeclaration;\x0a\x09        this.specifiers = specifiers;\x0a\x09        this.source = source;\x0a\x09    }\x0a\x09    return ImportDeclaration;\x0a\x09}());\x0a\x09exports.ImportDeclaration = ImportDeclaration;\x0a\x09var ImportDefaultSpecifier = (function () {\x0a\x09    function ImportDefaultSpecifier(local) {\x0a\x09        this.type = syntax_1.Syntax.ImportDefaultSpecifier;\x0a\x09        this.local = local;\x0a\x09    }\x0a\x09    return ImportDefaultSpecifier;\x0a\x09}());\x0a\x09exports.ImportDefaultSpecifier = ImportDefaultSpecifier;\x0a\x09var ImportNamespaceSpecifier = (function () {\x0a\x09    function ImportNamespaceSpecifier(local) {\x0a\x09        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;\x0a\x09        this.local = local;\x0a\x09    }\x0a\x09    return ImportNamespaceSpecifier;\x0a\x09}());\x0a\x09exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\x0a\x09var ImportSpecifier = (function () {\x0a\x09    function ImportSpecifier(local, imported) {\x0a\x09        this.type = syntax_1.Syntax.ImportSpecifier;\x0a\x09        this.local = local;\x0a\x09        this.imported = imported;\x0a\x09    }\x0a\x09    return ImportSpecifier;\x0a\x09}());\x0a\x09exports.ImportSpecifier = ImportSpecifier;\x0a\x09var LabeledStatement = (function () {\x0a\x09    function LabeledStatement(label, body) {\x0a\x09        this.type = syntax_1.Syntax.LabeledStatement;\x0a\x09        this.label = label;\x0a\x09        this.body = body;\x0a\x09    }\x0a\x09    return LabeledStatement;\x0a\x09}());\x0a\x09exports.LabeledStatement = LabeledStatement;\x0a\x09var Literal = (function () {\x0a\x09    function Literal(value, raw) {\x0a\x09        this.type = syntax_1.Syntax.Literal;\x0a\x09        this.value = value;\x0a\x09        this.raw = raw;\x0a\x09    }\x0a\x09    return Literal;\x0a\x09}());\x0a\x09exports.Literal = Literal;\x0a\x09var MetaProperty = (function () {\x0a\x09    function MetaProperty(meta, property) {\x0a\x09        this.type = syntax_1.Syntax.MetaProperty;\x0a\x09        this.meta = meta;\x0a\x09        this.property = property;\x0a\x09    }\x0a\x09    return MetaProperty;\x0a\x09}());\x0a\x09exports.MetaProperty = MetaProperty;\x0a\x09var MethodDefinition = (function () {\x0a\x09    function MethodDefinition(key, computed, value, kind, isStatic) {\x0a\x09        this.type = syntax_1.Syntax.MethodDefinition;\x0a\x09        this.key = key;\x0a\x09        this.computed = computed;\x0a\x09        this.value = value;\x0a\x09        this.kind = kind;\x0a\x09        this.static = isStatic;\x0a\x09    }\x0a\x09    return MethodDefinition;\x0a\x09}());\x0a\x09exports.MethodDefinition = MethodDefinition;\x0a\x09var Module = (function () {\x0a\x09    function Module(body) {\x0a\x09        this.type = syntax_1.Syntax.Program;\x0a\x09        this.body = body;\x0a\x09        this.sourceType = \x27module\x27;\x0a\x09    }\x0a\x09    return Module;\x0a\x09}());\x0a\x09exports.Module = Module;\x0a\x09var NewExpression = (function () {\x0a\x09    function NewExpression(callee, args) {\x0a\x09        this.type = syntax_1.Syntax.NewExpression;\x0a\x09        this.callee = callee;\x0a\x09        this.arguments = args;\x0a\x09    }\x0a\x09    return NewExpression;\x0a\x09}());\x0a\x09exports.NewExpression = NewExpression;\x0a\x09var ObjectExpression = (function () {\x0a\x09    function ObjectExpression(properties) {\x0a\x09        this.type = syntax_1.Syntax.ObjectExpression;\x0a\x09        this.properties = properties;\x0a\x09    }\x0a\x09    return ObjectExpression;\x0a\x09}());\x0a\x09exports.ObjectExpression = ObjectExpression;\x0a\x09var ObjectPattern = (function () {\x0a\x09    function ObjectPattern(properties) {\x0a\x09        this.type = syntax_1.Syntax.ObjectPattern;\x0a\x09        this.properties = properties;\x0a\x09    }\x0a\x09    return ObjectPattern;\x0a\x09}());\x0a\x09exports.ObjectPattern = ObjectPattern;\x0a\x09var Property = (function () {\x0a\x09    function Property(kind, key, computed, value, method, shorthand) {\x0a\x09        this.type = syntax_1.Syntax.Property;\x0a\x09        this.key = key;\x0a\x09        this.computed = computed;\x0a\x09        this.value = value;\x0a\x09        this.kind = kind;\x0a\x09        this.method = method;\x0a\x09        this.shorthand = shorthand;\x0a\x09    }\x0a\x09    return Property;\x0a\x09}());\x0a\x09exports.Property = Property;\x0a\x09var RegexLiteral = (function () {\x0a\x09    function RegexLiteral(value, raw, pattern, flags) {\x0a\x09        this.type = syntax_1.Syntax.Literal;\x0a\x09        this.value = value;\x0a\x09        this.raw = raw;\x0a\x09        this.regex = { pattern: pattern, flags: flags };\x0a\x09    }\x0a\x09    return RegexLiteral;\x0a\x09}());\x0a\x09exports.RegexLiteral = RegexLiteral;\x0a\x09var RestElement = (function () {\x0a\x09    function RestElement(argument) {\x0a\x09        this.type = syntax_1.Syntax.RestElement;\x0a\x09        this.argument = argument;\x0a\x09    }\x0a\x09    return RestElement;\x0a\x09}());\x0a\x09exports.RestElement = RestElement;\x0a\x09var ReturnStatement = (function () {\x0a\x09    function ReturnStatement(argument) {\x0a\x09        this.type = syntax_1.Syntax.ReturnStatement;\x0a\x09        this.argument = argument;\x0a\x09    }\x0a\x09    return ReturnStatement;\x0a\x09}());\x0a\x09exports.ReturnStatement = ReturnStatement;\x0a\x09var Script = (function () {\x0a\x09    function Script(body) {\x0a\x09        this.type = syntax_1.Syntax.Program;\x0a\x09        this.body = body;\x0a\x09        this.sourceType = \x27script\x27;\x0a\x09    }\x0a\x09    return Script;\x0a\x09}());\x0a\x09exports.Script = Script;\x0a\x09var SequenceExpression = (function () {\x0a\x09    function SequenceExpression(expressions) {\x0a\x09        this.type = syntax_1.Syntax.SequenceExpression;\x0a\x09        this.expressions = expressions;\x0a\x09    }\x0a\x09    return SequenceExpression;\x0a\x09}());\x0a\x09exports.SequenceExpression = SequenceExpression;\x0a\x09var SpreadElement = (function () {\x0a\x09    function SpreadElement(argument) {\x0a\x09        this.type = syntax_1.Syntax.SpreadElement;\x0a\x09        this.argument = argument;\x0a\x09    }\x0a\x09    return SpreadElement;\x0a\x09}());\x0a\x09exports.SpreadElement = SpreadElement;\x0a\x09var StaticMemberExpression = (function () {\x0a\x09    function StaticMemberExpression(object, property) {\x0a\x09        this.type = syntax_1.Syntax.MemberExpression;\x0a\x09        this.computed = false;\x0a\x09        this.object = object;\x0a\x09        this.property = property;\x0a\x09    }\x0a\x09    return StaticMemberExpression;\x0a\x09}());\x0a\x09exports.StaticMemberExpression = StaticMemberExpression;\x0a\x09var Super = (function () {\x0a\x09    function Super() {\x0a\x09        this.type = syntax_1.Syntax.Super;\x0a\x09    }\x0a\x09    return Super;\x0a\x09}());\x0a\x09exports.Super = Super;\x0a\x09var SwitchCase = (function () {\x0a\x09    function SwitchCase(test, consequent) {\x0a\x09        this.type = syntax_1.Syntax.SwitchCase;\x0a\x09        this.test = test;\x0a\x09        this.consequent = consequent;\x0a\x09    }\x0a\x09    return SwitchCase;\x0a\x09}());\x0a\x09exports.SwitchCase = SwitchCase;\x0a\x09var SwitchStatement = (function () {\x0a\x09    function SwitchStatement(discriminant, cases) {\x0a\x09        this.type = syntax_1.Syntax.SwitchStatement;\x0a\x09        this.discriminant = discriminant;\x0a\x09        this.cases = cases;\x0a\x09    }\x0a\x09    return SwitchStatement;\x0a\x09}());\x0a\x09exports.SwitchStatement = SwitchStatement;\x0a\x09var TaggedTemplateExpression = (function () {\x0a\x09    function TaggedTemplateExpression(tag, quasi) {\x0a\x09        this.type = syntax_1.Syntax.TaggedTemplateExpression;\x0a\x09        this.tag = tag;\x0a\x09        this.quasi = quasi;\x0a\x09    }\x0a\x09    return TaggedTemplateExpression;\x0a\x09}());\x0a\x09exports.TaggedTemplateExpression = TaggedTemplateExpression;\x0a\x09var TemplateElement = (function () {\x0a\x09    function TemplateElement(value, tail) {\x0a\x09        this.type = syntax_1.Syntax.TemplateElement;\x0a\x09        this.value = value;\x0a\x09        this.tail = tail;\x0a\x09    }\x0a\x09    return TemplateElement;\x0a\x09}());\x0a\x09exports.TemplateElement = TemplateElement;\x0a\x09var TemplateLiteral = (function () {\x0a\x09    function TemplateLiteral(quasis, expressions) {\x0a\x09        this.type = syntax_1.Syntax.TemplateLiteral;\x0a\x09        this.quasis = quasis;\x0a\x09        this.expressions = expressions;\x0a\x09    }\x0a\x09    return TemplateLiteral;\x0a\x09}());\x0a\x09exports.TemplateLiteral = TemplateLiteral;\x0a\x09var ThisExpression = (function () {\x0a\x09    function ThisExpression() {\x0a\x09        this.type = syntax_1.Syntax.ThisExpression;\x0a\x09    }\x0a\x09    return ThisExpression;\x0a\x09}());\x0a\x09exports.ThisExpression = ThisExpression;\x0a\x09var ThrowStatement = (function () {\x0a\x09    function ThrowStatement(argument) {\x0a\x09        this.type = syntax_1.Syntax.ThrowStatement;\x0a\x09        this.argument = argument;\x0a\x09    }\x0a\x09    return ThrowStatement;\x0a\x09}());\x0a\x09exports.ThrowStatement = ThrowStatement;\x0a\x09var TryStatement = (function () {\x0a\x09    function TryStatement(block, handler, finalizer) {\x0a\x09        this.type = syntax_1.Syntax.TryStatement;\x0a\x09        this.block = block;\x0a\x09        this.handler = handler;\x0a\x09        this.finalizer = finalizer;\x0a\x09    }\x0a\x09    return TryStatement;\x0a\x09}());\x0a\x09exports.TryStatement = TryStatement;\x0a\x09var UnaryExpression = (function () {\x0a\x09    function UnaryExpression(operator, argument) {\x0a\x09        this.type = syntax_1.Syntax.UnaryExpression;\x0a\x09        this.operator = operator;\x0a\x09        this.argument = argument;\x0a\x09        this.prefix = true;\x0a\x09    }\x0a\x09    return UnaryExpression;\x0a\x09}());\x0a\x09exports.UnaryExpression = UnaryExpression;\x0a\x09var UpdateExpression = (function () {\x0a\x09    function UpdateExpression(operator, argument, prefix) {\x0a\x09        this.type = syntax_1.Syntax.UpdateExpression;\x0a\x09        this.operator = operator;\x0a\x09        this.argument = argument;\x0a\x09        this.prefix = prefix;\x0a\x09    }\x0a\x09    return UpdateExpression;\x0a\x09}());\x0a\x09exports.UpdateExpression = UpdateExpression;\x0a\x09var VariableDeclaration = (function () {\x0a\x09    function VariableDeclaration(declarations, kind) {\x0a\x09        this.type = syntax_1.Syntax.VariableDeclaration;\x0a\x09        this.declarations = declarations;\x0a\x09        this.kind = kind;\x0a\x09    }\x0a\x09    return VariableDeclaration;\x0a\x09}());\x0a\x09exports.VariableDeclaration = VariableDeclaration;\x0a\x09var VariableDeclarator = (function () {\x0a\x09    function VariableDeclarator(id, init) {\x0a\x09        this.type = syntax_1.Syntax.VariableDeclarator;\x0a\x09        this.id = id;\x0a\x09        this.init = init;\x0a\x09    }\x0a\x09    return VariableDeclarator;\x0a\x09}());\x0a\x09exports.VariableDeclarator = VariableDeclarator;\x0a\x09var WhileStatement = (function () {\x0a\x09    function WhileStatement(test, body) {\x0a\x09        this.type = syntax_1.Syntax.WhileStatement;\x0a\x09        this.test = test;\x0a\x09        this.body = body;\x0a\x09    }\x0a\x09    return WhileStatement;\x0a\x09}());\x0a\x09exports.WhileStatement = WhileStatement;\x0a\x09var WithStatement = (function () {\x0a\x09    function WithStatement(object, body) {\x0a\x09        this.type = syntax_1.Syntax.WithStatement;\x0a\x09        this.object = object;\x0a\x09        this.body = body;\x0a\x09    }\x0a\x09    return WithStatement;\x0a\x09}());\x0a\x09exports.WithStatement = WithStatement;\x0a\x09var YieldExpression = (function () {\x0a\x09    function YieldExpression(argument, delegate) {\x0a\x09        this.type = syntax_1.Syntax.YieldExpression;\x0a\x09        this.argument = argument;\x0a\x09        this.delegate = delegate;\x0a\x09    }\x0a\x09    return YieldExpression;\x0a\x09}());\x0a\x09exports.YieldExpression = YieldExpression;\x0a\x0a\x0a/***/ },\x0a/* 8 */\x0a/***/ function(module, exports, __webpack_require__) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09var assert_1 = __webpack_require__(9);\x0a\x09var error_handler_1 = __webpack_require__(10);\x0a\x09var messages_1 = __webpack_require__(11);\x0a\x09var Node = __webpack_require__(7);\x0a\x09var scanner_1 = __webpack_require__(12);\x0a\x09var syntax_1 = __webpack_require__(2);\x0a\x09var token_1 = __webpack_require__(13);\x0a\x09var ArrowParameterPlaceHolder = \x27ArrowParameterPlaceHolder\x27;\x0a\x09var Parser = (function () {\x0a\x09    function Parser(code, options, delegate) {\x0a\x09        if (options === void 0) { options = {}; }\x0a\x09        this.config = {\x0a\x09            range: (typeof options.range === \x27boolean\x27) && options.range,\x0a\x09            loc: (typeof options.loc === \x27boolean\x27) && options.loc,\x0a\x09            source: null,\x0a\x09            tokens: (typeof options.tokens === \x27boolean\x27) && options.tokens,\x0a\x09            comment: (typeof options.comment === \x27boolean\x27) && options.comment,\x0a\x09            tolerant: (typeof options.tolerant === \x27boolean\x27) && options.tolerant\x0a\x09        };\x0a\x09        if (this.config.loc && options.source && options.source !== null) {\x0a\x09            this.config.source = String(options.source);\x0a\x09        }\x0a\x09        this.delegate = delegate;\x0a\x09        this.errorHandler = new error_handler_1.ErrorHandler();\x0a\x09        this.errorHandler.tolerant = this.config.tolerant;\x0a\x09        this.scanner = new scanner_1.Scanner(code, this.errorHandler);\x0a\x09        this.scanner.trackComment = this.config.comment;\x0a\x09        this.operatorPrecedence = {\x0a\x09            \x27)\x27: 0,\x0a\x09            \x27;\x27: 0,\x0a\x09            \x27,\x27: 0,\x0a\x09            \x27=\x27: 0,\x0a\x09            \x27]\x27: 0,\x0a\x09            \x27||\x27: 1,\x0a\x09            \x27&&\x27: 2,\x0a\x09            \x27|\x27: 3,\x0a\x09            \x27^\x27: 4,\x0a\x09            \x27&\x27: 5,\x0a\x09            \x27==\x27: 6,\x0a\x09            \x27!=\x27: 6,\x0a\x09            \x27===\x27: 6,\x0a\x09            \x27!==\x27: 6,\x0a\x09            \x27\x3c\x27: 7,\x0a\x09            \x27\x3e\x27: 7,\x0a\x09            \x27\x3c=\x27: 7,\x0a\x09            \x27\x3e=\x27: 7,\x0a\x09            \x27\x3c\x3c\x27: 8,\x0a\x09            \x27\x3e\x3e\x27: 8,\x0a\x09            \x27\x3e\x3e\x3e\x27: 8,\x0a\x09            \x27+\x27: 9,\x0a\x09            \x27-\x27: 9,\x0a\x09            \x27*\x27: 11,\x0a\x09            \x27/\x27: 11,\x0a\x09            \x27%\x27: 11\x0a\x09        };\x0a\x09        this.lookahead = {\x0a\x09            type: 2 /* EOF */,\x0a\x09            value: \x27\x27,\x0a\x09            lineNumber: this.scanner.lineNumber,\x0a\x09            lineStart: 0,\x0a\x09            start: 0,\x0a\x09            end: 0\x0a\x09        };\x0a\x09        this.hasLineTerminator = false;\x0a\x09        this.context = {\x0a\x09            isModule: false,\x0a\x09            await: false,\x0a\x09            allowIn: true,\x0a\x09            allowStrictDirective: true,\x0a\x09            allowYield: true,\x0a\x09            firstCoverInitializedNameError: null,\x0a\x09            isAssignmentTarget: false,\x0a\x09            isBindingElement: false,\x0a\x09            inFunctionBody: false,\x0a\x09            inIteration: false,\x0a\x09            inSwitch: false,\x0a\x09            labelSet: {},\x0a\x09            strict: false\x0a\x09        };\x0a\x09        this.tokens = [];\x0a\x09        this.startMarker = {\x0a\x09            index: 0,\x0a\x09            line: this.scanner.lineNumber,\x0a\x09            column: 0\x0a\x09        };\x0a\x09        this.lastMarker = {\x0a\x09            index: 0,\x0a\x09            line: this.scanner.lineNumber,\x0a\x09            column: 0\x0a\x09        };\x0a\x09        this.nextToken();\x0a\x09        this.lastMarker = {\x0a\x09            index: this.scanner.index,\x0a\x09            line: this.scanner.lineNumber,\x0a\x09            column: this.scanner.index - this.scanner.lineStart\x0a\x09        };\x0a\x09    }\x0a\x09    Parser.prototype.throwError = function (messageFormat) {\x0a\x09        var values = [];\x0a\x09        for (var _i = 1; _i \x3c arguments.length; _i++) {\x0a\x09            values[_i - 1] = arguments[_i];\x0a\x09        }\x0a\x09        var args = Array.prototype.slice.call(arguments, 1);\x0a\x09        var msg = messageFormat.replace(/%(\x5cd)/g, function (whole, idx) {\x0a\x09            assert_1.assert(idx \x3c args.length, \x27Message reference must be in range\x27);\x0a\x09            return args[idx];\x0a\x09        });\x0a\x09        var index = this.lastMarker.index;\x0a\x09        var line = this.lastMarker.line;\x0a\x09        var column = this.lastMarker.column + 1;\x0a\x09        throw this.errorHandler.createError(index, line, column, msg);\x0a\x09    };\x0a\x09    Parser.prototype.tolerateError = function (messageFormat) {\x0a\x09        var values = [];\x0a\x09        for (var _i = 1; _i \x3c arguments.length; _i++) {\x0a\x09            values[_i - 1] = arguments[_i];\x0a\x09        }\x0a\x09        var args = Array.prototype.slice.call(arguments, 1);\x0a\x09        var msg = messageFormat.replace(/%(\x5cd)/g, function (whole, idx) {\x0a\x09            assert_1.assert(idx \x3c args.length, \x27Message reference must be in range\x27);\x0a\x09            return args[idx];\x0a\x09        });\x0a\x09        var index = this.lastMarker.index;\x0a\x09        var line = this.scanner.lineNumber;\x0a\x09        var column = this.lastMarker.column + 1;\x0a\x09        this.errorHandler.tolerateError(index, line, column, msg);\x0a\x09    };\x0a\x09    // Throw an exception because of the token.\x0a\x09    Parser.prototype.unexpectedTokenError = function (token, message) {\x0a\x09        var msg = message || messages_1.Messages.UnexpectedToken;\x0a\x09        var value;\x0a\x09        if (token) {\x0a\x09            if (!message) {\x0a\x09                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :\x0a\x09                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :\x0a\x09                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :\x0a\x09                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :\x0a\x09                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :\x0a\x09                                    messages_1.Messages.UnexpectedToken;\x0a\x09                if (token.type === 4 /* Keyword */) {\x0a\x09                    if (this.scanner.isFutureReservedWord(token.value)) {\x0a\x09                        msg = messages_1.Messages.UnexpectedReserved;\x0a\x09                    }\x0a\x09                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {\x0a\x09                        msg = messages_1.Messages.StrictReservedWord;\x0a\x09                    }\x0a\x09                }\x0a\x09            }\x0a\x09            value = token.value;\x0a\x09        }\x0a\x09        else {\x0a\x09            value = \x27ILLEGAL\x27;\x0a\x09        }\x0a\x09        msg = msg.replace(\x27%0\x27, value);\x0a\x09        if (token && typeof token.lineNumber === \x27number\x27) {\x0a\x09            var index = token.start;\x0a\x09            var line = token.lineNumber;\x0a\x09            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;\x0a\x09            var column = token.start - lastMarkerLineStart + 1;\x0a\x09            return this.errorHandler.createError(index, line, column, msg);\x0a\x09        }\x0a\x09        else {\x0a\x09            var index = this.lastMarker.index;\x0a\x09            var line = this.lastMarker.line;\x0a\x09            var column = this.lastMarker.column + 1;\x0a\x09            return this.errorHandler.createError(index, line, column, msg);\x0a\x09        }\x0a\x09    };\x0a\x09    Parser.prototype.throwUnexpectedToken = function (token, message) {\x0a\x09        throw this.unexpectedTokenError(token, message);\x0a\x09    };\x0a\x09    Parser.prototype.tolerateUnexpectedToken = function (token, message) {\x0a\x09        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));\x0a\x09    };\x0a\x09    Parser.prototype.collectComments = function () {\x0a\x09        if (!this.config.comment) {\x0a\x09            this.scanner.scanComments();\x0a\x09        }\x0a\x09        else {\x0a\x09            var comments = this.scanner.scanComments();\x0a\x09            if (comments.length \x3e 0 && this.delegate) {\x0a\x09                for (var i = 0; i \x3c comments.length; ++i) {\x0a\x09                    var e = comments[i];\x0a\x09                    var node = void 0;\x0a\x09                    node = {\x0a\x09                        type: e.multiLine ? \x27BlockComment\x27 : \x27LineComment\x27,\x0a\x09                        value: this.scanner.source.slice(e.slice[0], e.slice[1])\x0a\x09                    };\x0a\x09                    if (this.config.range) {\x0a\x09                        node.range = e.range;\x0a\x09                    }\x0a\x09                    if (this.config.loc) {\x0a\x09                        node.loc = e.loc;\x0a\x09                    }\x0a\x09                    var metadata = {\x0a\x09                        start: {\x0a\x09                            line: e.loc.start.line,\x0a\x09                            column: e.loc.start.column,\x0a\x09                            offset: e.range[0]\x0a\x09                        },\x0a\x09                        end: {\x0a\x09                            line: e.loc.end.line,\x0a\x09                            column: e.loc.end.column,\x0a\x09                            offset: e.range[1]\x0a\x09                        }\x0a\x09                    };\x0a\x09                    this.delegate(node, metadata);\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09    };\x0a\x09    // From internal representation to an external structure\x0a\x09    Parser.prototype.getTokenRaw = function (token) {\x0a\x09        return this.scanner.source.slice(token.start, token.end);\x0a\x09    };\x0a\x09    Parser.prototype.convertToken = function (token) {\x0a\x09        var t = {\x0a\x09            type: token_1.TokenName[token.type],\x0a\x09            value: this.getTokenRaw(token)\x0a\x09        };\x0a\x09        if (this.config.range) {\x0a\x09            t.range = [token.start, token.end];\x0a\x09        }\x0a\x09        if (this.config.loc) {\x0a\x09            t.loc = {\x0a\x09                start: {\x0a\x09                    line: this.startMarker.line,\x0a\x09                    column: this.startMarker.column\x0a\x09                },\x0a\x09                end: {\x0a\x09                    line: this.scanner.lineNumber,\x0a\x09                    column: this.scanner.index - this.scanner.lineStart\x0a\x09                }\x0a\x09            };\x0a\x09        }\x0a\x09        if (token.type === 9 /* RegularExpression */) {\x0a\x09            var pattern = token.pattern;\x0a\x09            var flags = token.flags;\x0a\x09            t.regex = { pattern: pattern, flags: flags };\x0a\x09        }\x0a\x09        return t;\x0a\x09    };\x0a\x09    Parser.prototype.nextToken = function () {\x0a\x09        var token = this.lookahead;\x0a\x09        this.lastMarker.index = this.scanner.index;\x0a\x09        this.lastMarker.line = this.scanner.lineNumber;\x0a\x09        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;\x0a\x09        this.collectComments();\x0a\x09        if (this.scanner.index !== this.startMarker.index) {\x0a\x09            this.startMarker.index = this.scanner.index;\x0a\x09            this.startMarker.line = this.scanner.lineNumber;\x0a\x09            this.startMarker.column = this.scanner.index - this.scanner.lineStart;\x0a\x09        }\x0a\x09        var next = this.scanner.lex();\x0a\x09        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);\x0a\x09        if (next && this.context.strict && next.type === 3 /* Identifier */) {\x0a\x09            if (this.scanner.isStrictModeReservedWord(next.value)) {\x0a\x09                next.type = 4 /* Keyword */;\x0a\x09            }\x0a\x09        }\x0a\x09        this.lookahead = next;\x0a\x09        if (this.config.tokens && next.type !== 2 /* EOF */) {\x0a\x09            this.tokens.push(this.convertToken(next));\x0a\x09        }\x0a\x09        return token;\x0a\x09    };\x0a\x09    Parser.prototype.nextRegexToken = function () {\x0a\x09        this.collectComments();\x0a\x09        var token = this.scanner.scanRegExp();\x0a\x09        if (this.config.tokens) {\x0a\x09            // Pop the previous token, \x27/\x27 or \x27/=\x27\x0a\x09            // This is added from the lookahead token.\x0a\x09            this.tokens.pop();\x0a\x09            this.tokens.push(this.convertToken(token));\x0a\x09        }\x0a\x09        // Prime the next lookahead.\x0a\x09        this.lookahead = token;\x0a\x09        this.nextToken();\x0a\x09        return token;\x0a\x09    };\x0a\x09    Parser.prototype.createNode = function () {\x0a\x09        return {\x0a\x09            index: this.startMarker.index,\x0a\x09            line: this.startMarker.line,\x0a\x09            column: this.startMarker.column\x0a\x09        };\x0a\x09    };\x0a\x09    Parser.prototype.startNode = function (token) {\x0a\x09        return {\x0a\x09            index: token.start,\x0a\x09            line: token.lineNumber,\x0a\x09            column: token.start - token.lineStart\x0a\x09        };\x0a\x09    };\x0a\x09    Parser.prototype.finalize = function (marker, node) {\x0a\x09        if (this.config.range) {\x0a\x09            node.range = [marker.index, this.lastMarker.index];\x0a\x09        }\x0a\x09        if (this.config.loc) {\x0a\x09            node.loc = {\x0a\x09                start: {\x0a\x09                    line: marker.line,\x0a\x09                    column: marker.column,\x0a\x09                },\x0a\x09                end: {\x0a\x09                    line: this.lastMarker.line,\x0a\x09                    column: this.lastMarker.column\x0a\x09                }\x0a\x09            };\x0a\x09            if (this.config.source) {\x0a\x09                node.loc.source = this.config.source;\x0a\x09            }\x0a\x09        }\x0a\x09        if (this.delegate) {\x0a\x09            var metadata = {\x0a\x09                start: {\x0a\x09                    line: marker.line,\x0a\x09                    column: marker.column,\x0a\x09                    offset: marker.index\x0a\x09                },\x0a\x09                end: {\x0a\x09                    line: this.lastMarker.line,\x0a\x09                    column: this.lastMarker.column,\x0a\x09                    offset: this.lastMarker.index\x0a\x09                }\x0a\x09            };\x0a\x09            this.delegate(node, metadata);\x0a\x09        }\x0a\x09        return node;\x0a\x09    };\x0a\x09    // Expect the next token to match the specified punctuator.\x0a\x09    // If not, an exception will be thrown.\x0a\x09    Parser.prototype.expect = function (value) {\x0a\x09        var token = this.nextToken();\x0a\x09        if (token.type !== 7 /* Punctuator */ || token.value !== value) {\x0a\x09            this.throwUnexpectedToken(token);\x0a\x09        }\x0a\x09    };\x0a\x09    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().\x0a\x09    Parser.prototype.expectCommaSeparator = function () {\x0a\x09        if (this.config.tolerant) {\x0a\x09            var token = this.lookahead;\x0a\x09            if (token.type === 7 /* Punctuator */ && token.value === \x27,\x27) {\x0a\x09                this.nextToken();\x0a\x09            }\x0a\x09            else if (token.type === 7 /* Punctuator */ && token.value === \x27;\x27) {\x0a\x09                this.nextToken();\x0a\x09                this.tolerateUnexpectedToken(token);\x0a\x09            }\x0a\x09            else {\x0a\x09                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);\x0a\x09            }\x0a\x09        }\x0a\x09        else {\x0a\x09            this.expect(\x27,\x27);\x0a\x09        }\x0a\x09    };\x0a\x09    // Expect the next token to match the specified keyword.\x0a\x09    // If not, an exception will be thrown.\x0a\x09    Parser.prototype.expectKeyword = function (keyword) {\x0a\x09        var token = this.nextToken();\x0a\x09        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {\x0a\x09            this.throwUnexpectedToken(token);\x0a\x09        }\x0a\x09    };\x0a\x09    // Return true if the next token matches the specified punctuator.\x0a\x09    Parser.prototype.match = function (value) {\x0a\x09        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;\x0a\x09    };\x0a\x09    // Return true if the next token matches the specified keyword\x0a\x09    Parser.prototype.matchKeyword = function (keyword) {\x0a\x09        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;\x0a\x09    };\x0a\x09    // Return true if the next token matches the specified contextual keyword\x0a\x09    // (where an identifier is sometimes a keyword depending on the context)\x0a\x09    Parser.prototype.matchContextualKeyword = function (keyword) {\x0a\x09        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;\x0a\x09    };\x0a\x09    // Return true if the next token is an assignment operator\x0a\x09    Parser.prototype.matchAssign = function () {\x0a\x09        if (this.lookahead.type !== 7 /* Punctuator */) {\x0a\x09            return false;\x0a\x09        }\x0a\x09        var op = this.lookahead.value;\x0a\x09        return op === \x27=\x27 ||\x0a\x09            op === \x27*=\x27 ||\x0a\x09            op === \x27**=\x27 ||\x0a\x09            op === \x27/=\x27 ||\x0a\x09            op === \x27%=\x27 ||\x0a\x09            op === \x27+=\x27 ||\x0a\x09            op === \x27-=\x27 ||\x0a\x09            op === \x27\x3c\x3c=\x27 ||\x0a\x09            op === \x27\x3e\x3e=\x27 ||\x0a\x09            op === \x27\x3e\x3e\x3e=\x27 ||\x0a\x09            op === \x27&=\x27 ||\x0a\x09            op === \x27^=\x27 ||\x0a\x09            op === \x27|=\x27;\x0a\x09    };\x0a\x09    // Cover grammar support.\x0a\x09    //\x0a\x09    // When an assignment expression position starts with an left parenthesis, the determination of the type\x0a\x09    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\x0a\x09    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\x0a\x09    //\x0a\x09    // There are three productions that can be parsed in a parentheses pair that needs to be determined\x0a\x09    // after the outermost pair is closed. They are:\x0a\x09    //\x0a\x09    //   1. AssignmentExpression\x0a\x09    //   2. BindingElements\x0a\x09    //   3. AssignmentTargets\x0a\x09    //\x0a\x09    // In order to avoid exponential backtracking, we use two flags to denote if the production can be\x0a\x09    // binding element or assignment target.\x0a\x09    //\x0a\x09    // The three productions have the relationship:\x0a\x09    //\x0a\x09    //   BindingElements \xe2\x8a\x86 AssignmentTargets \xe2\x8a\x86 AssignmentExpression\x0a\x09    //\x0a\x09    // with a single exception that CoverInitializedName when used directly in an Expression, generates\x0a\x09    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\x0a\x09    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\x0a\x09    //\x0a\x09    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\x0a\x09    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\x0a\x09    // the CoverInitializedName check is conducted.\x0a\x09    //\x0a\x09    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\x0a\x09    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\x0a\x09    // pattern. The CoverInitializedName check is deferred.\x0a\x09    Parser.prototype.isolateCoverGrammar = function (parseFunction) {\x0a\x09        var previousIsBindingElement = this.context.isBindingElement;\x0a\x09        var previousIsAssignmentTarget = this.context.isAssignmentTarget;\x0a\x09        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;\x0a\x09        this.context.isBindingElement = true;\x0a\x09        this.context.isAssignmentTarget = true;\x0a\x09        this.context.firstCoverInitializedNameError = null;\x0a\x09        var result = parseFunction.call(this);\x0a\x09        if (this.context.firstCoverInitializedNameError !== null) {\x0a\x09            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);\x0a\x09        }\x0a\x09        this.context.isBindingElement = previousIsBindingElement;\x0a\x09        this.context.isAssignmentTarget = previousIsAssignmentTarget;\x0a\x09        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;\x0a\x09        return result;\x0a\x09    };\x0a\x09    Parser.prototype.inheritCoverGrammar = function (parseFunction) {\x0a\x09        var previousIsBindingElement = this.context.isBindingElement;\x0a\x09        var previousIsAssignmentTarget = this.context.isAssignmentTarget;\x0a\x09        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;\x0a\x09        this.context.isBindingElement = true;\x0a\x09        this.context.isAssignmentTarget = true;\x0a\x09        this.context.firstCoverInitializedNameError = null;\x0a\x09        var result = parseFunction.call(this);\x0a\x09        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;\x0a\x09        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;\x0a\x09        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;\x0a\x09        return result;\x0a\x09    };\x0a\x09    Parser.prototype.consumeSemicolon = function () {\x0a\x09        if (this.match(\x27;\x27)) {\x0a\x09            this.nextToken();\x0a\x09        }\x0a\x09        else if (!this.hasLineTerminator) {\x0a\x09            if (this.lookahead.type !== 2 /* EOF */ && !this.match(\x27}\x27)) {\x0a\x09                this.throwUnexpectedToken(this.lookahead);\x0a\x09            }\x0a\x09            this.lastMarker.index = this.startMarker.index;\x0a\x09            this.lastMarker.line = this.startMarker.line;\x0a\x09            this.lastMarker.column = this.startMarker.column;\x0a\x09        }\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-primary-expression\x0a\x09    Parser.prototype.parsePrimaryExpression = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var expr;\x0a\x09        var token, raw;\x0a\x09        switch (this.lookahead.type) {\x0a\x09            case 3 /* Identifier */:\x0a\x09                if ((this.context.isModule || this.context.await) && this.lookahead.value === \x27await\x27) {\x0a\x09                    this.tolerateUnexpectedToken(this.lookahead);\x0a\x09                }\x0a\x09                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));\x0a\x09                break;\x0a\x09            case 6 /* NumericLiteral */:\x0a\x09            case 8 /* StringLiteral */:\x0a\x09                if (this.context.strict && this.lookahead.octal) {\x0a\x09                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);\x0a\x09                }\x0a\x09                this.context.isAssignmentTarget = false;\x0a\x09                this.context.isBindingElement = false;\x0a\x09                token = this.nextToken();\x0a\x09                raw = this.getTokenRaw(token);\x0a\x09                expr = this.finalize(node, new Node.Literal(token.value, raw));\x0a\x09                break;\x0a\x09            case 1 /* BooleanLiteral */:\x0a\x09                this.context.isAssignmentTarget = false;\x0a\x09                this.context.isBindingElement = false;\x0a\x09                token = this.nextToken();\x0a\x09                raw = this.getTokenRaw(token);\x0a\x09                expr = this.finalize(node, new Node.Literal(token.value === \x27true\x27, raw));\x0a\x09                break;\x0a\x09            case 5 /* NullLiteral */:\x0a\x09                this.context.isAssignmentTarget = false;\x0a\x09                this.context.isBindingElement = false;\x0a\x09                token = this.nextToken();\x0a\x09                raw = this.getTokenRaw(token);\x0a\x09                expr = this.finalize(node, new Node.Literal(null, raw));\x0a\x09                break;\x0a\x09            case 10 /* Template */:\x0a\x09                expr = this.parseTemplateLiteral();\x0a\x09                break;\x0a\x09            case 7 /* Punctuator */:\x0a\x09                switch (this.lookahead.value) {\x0a\x09                    case \x27(\x27:\x0a\x09                        this.context.isBindingElement = false;\x0a\x09                        expr = this.inheritCoverGrammar(this.parseGroupExpression);\x0a\x09                        break;\x0a\x09                    case \x27[\x27:\x0a\x09                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);\x0a\x09                        break;\x0a\x09                    case \x27{\x27:\x0a\x09                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);\x0a\x09                        break;\x0a\x09                    case \x27/\x27:\x0a\x09                    case \x27/=\x27:\x0a\x09                        this.context.isAssignmentTarget = false;\x0a\x09                        this.context.isBindingElement = false;\x0a\x09                        this.scanner.index = this.startMarker.index;\x0a\x09                        token = this.nextRegexToken();\x0a\x09                        raw = this.getTokenRaw(token);\x0a\x09                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));\x0a\x09                        break;\x0a\x09                    default:\x0a\x09                        expr = this.throwUnexpectedToken(this.nextToken());\x0a\x09                }\x0a\x09                break;\x0a\x09            case 4 /* Keyword */:\x0a\x09                if (!this.context.strict && this.context.allowYield && this.matchKeyword(\x27yield\x27)) {\x0a\x09                    expr = this.parseIdentifierName();\x0a\x09                }\x0a\x09                else if (!this.context.strict && this.matchKeyword(\x27let\x27)) {\x0a\x09                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));\x0a\x09                }\x0a\x09                else {\x0a\x09                    this.context.isAssignmentTarget = false;\x0a\x09                    this.context.isBindingElement = false;\x0a\x09                    if (this.matchKeyword(\x27function\x27)) {\x0a\x09                        expr = this.parseFunctionExpression();\x0a\x09                    }\x0a\x09                    else if (this.matchKeyword(\x27this\x27)) {\x0a\x09                        this.nextToken();\x0a\x09                        expr = this.finalize(node, new Node.ThisExpression());\x0a\x09                    }\x0a\x09                    else if (this.matchKeyword(\x27class\x27)) {\x0a\x09                        expr = this.parseClassExpression();\x0a\x09                    }\x0a\x09                    else {\x0a\x09                        expr = this.throwUnexpectedToken(this.nextToken());\x0a\x09                    }\x0a\x09                }\x0a\x09                break;\x0a\x09            default:\x0a\x09                expr = this.throwUnexpectedToken(this.nextToken());\x0a\x09        }\x0a\x09        return expr;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-array-initializer\x0a\x09    Parser.prototype.parseSpreadElement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expect(\x27...\x27);\x0a\x09        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);\x0a\x09        return this.finalize(node, new Node.SpreadElement(arg));\x0a\x09    };\x0a\x09    Parser.prototype.parseArrayInitializer = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var elements = [];\x0a\x09        this.expect(\x27[\x27);\x0a\x09        while (!this.match(\x27]\x27)) {\x0a\x09            if (this.match(\x27,\x27)) {\x0a\x09                this.nextToken();\x0a\x09                elements.push(null);\x0a\x09            }\x0a\x09            else if (this.match(\x27...\x27)) {\x0a\x09                var element = this.parseSpreadElement();\x0a\x09                if (!this.match(\x27]\x27)) {\x0a\x09                    this.context.isAssignmentTarget = false;\x0a\x09                    this.context.isBindingElement = false;\x0a\x09                    this.expect(\x27,\x27);\x0a\x09                }\x0a\x09                elements.push(element);\x0a\x09            }\x0a\x09            else {\x0a\x09                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));\x0a\x09                if (!this.match(\x27]\x27)) {\x0a\x09                    this.expect(\x27,\x27);\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        this.expect(\x27]\x27);\x0a\x09        return this.finalize(node, new Node.ArrayExpression(elements));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-object-initializer\x0a\x09    Parser.prototype.parsePropertyMethod = function (params) {\x0a\x09        this.context.isAssignmentTarget = false;\x0a\x09        this.context.isBindingElement = false;\x0a\x09        var previousStrict = this.context.strict;\x0a\x09        var previousAllowStrictDirective = this.context.allowStrictDirective;\x0a\x09        this.context.allowStrictDirective = params.simple;\x0a\x09        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);\x0a\x09        if (this.context.strict && params.firstRestricted) {\x0a\x09            this.tolerateUnexpectedToken(params.firstRestricted, params.message);\x0a\x09        }\x0a\x09        if (this.context.strict && params.stricted) {\x0a\x09            this.tolerateUnexpectedToken(params.stricted, params.message);\x0a\x09        }\x0a\x09        this.context.strict = previousStrict;\x0a\x09        this.context.allowStrictDirective = previousAllowStrictDirective;\x0a\x09        return body;\x0a\x09    };\x0a\x09    Parser.prototype.parsePropertyMethodFunction = function () {\x0a\x09        var isGenerator = false;\x0a\x09        var node = this.createNode();\x0a\x09        var previousAllowYield = this.context.allowYield;\x0a\x09        this.context.allowYield = false;\x0a\x09        var params = this.parseFormalParameters();\x0a\x09        var method = this.parsePropertyMethod(params);\x0a\x09        this.context.allowYield = previousAllowYield;\x0a\x09        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));\x0a\x09    };\x0a\x09    Parser.prototype.parsePropertyMethodAsyncFunction = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var previousAllowYield = this.context.allowYield;\x0a\x09        var previousAwait = this.context.await;\x0a\x09        this.context.allowYield = false;\x0a\x09        this.context.await = true;\x0a\x09        var params = this.parseFormalParameters();\x0a\x09        var method = this.parsePropertyMethod(params);\x0a\x09        this.context.allowYield = previousAllowYield;\x0a\x09        this.context.await = previousAwait;\x0a\x09        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));\x0a\x09    };\x0a\x09    Parser.prototype.parseObjectPropertyKey = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var token = this.nextToken();\x0a\x09        var key;\x0a\x09        switch (token.type) {\x0a\x09            case 8 /* StringLiteral */:\x0a\x09            case 6 /* NumericLiteral */:\x0a\x09                if (this.context.strict && token.octal) {\x0a\x09                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);\x0a\x09                }\x0a\x09                var raw = this.getTokenRaw(token);\x0a\x09                key = this.finalize(node, new Node.Literal(token.value, raw));\x0a\x09                break;\x0a\x09            case 3 /* Identifier */:\x0a\x09            case 1 /* BooleanLiteral */:\x0a\x09            case 5 /* NullLiteral */:\x0a\x09            case 4 /* Keyword */:\x0a\x09                key = this.finalize(node, new Node.Identifier(token.value));\x0a\x09                break;\x0a\x09            case 7 /* Punctuator */:\x0a\x09                if (token.value === \x27[\x27) {\x0a\x09                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09                    this.expect(\x27]\x27);\x0a\x09                }\x0a\x09                else {\x0a\x09                    key = this.throwUnexpectedToken(token);\x0a\x09                }\x0a\x09                break;\x0a\x09            default:\x0a\x09                key = this.throwUnexpectedToken(token);\x0a\x09        }\x0a\x09        return key;\x0a\x09    };\x0a\x09    Parser.prototype.isPropertyKey = function (key, value) {\x0a\x09        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||\x0a\x09            (key.type === syntax_1.Syntax.Literal && key.value === value);\x0a\x09    };\x0a\x09    Parser.prototype.parseObjectProperty = function (hasProto) {\x0a\x09        var node = this.createNode();\x0a\x09        var token = this.lookahead;\x0a\x09        var kind;\x0a\x09        var key = null;\x0a\x09        var value = null;\x0a\x09        var computed = false;\x0a\x09        var method = false;\x0a\x09        var shorthand = false;\x0a\x09        var isAsync = false;\x0a\x09        if (token.type === 3 /* Identifier */) {\x0a\x09            var id = token.value;\x0a\x09            this.nextToken();\x0a\x09            computed = this.match(\x27[\x27);\x0a\x09            isAsync = !this.hasLineTerminator && (id === \x27async\x27) &&\x0a\x09                !this.match(\x27:\x27) && !this.match(\x27(\x27) && !this.match(\x27*\x27);\x0a\x09            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));\x0a\x09        }\x0a\x09        else if (this.match(\x27*\x27)) {\x0a\x09            this.nextToken();\x0a\x09        }\x0a\x09        else {\x0a\x09            computed = this.match(\x27[\x27);\x0a\x09            key = this.parseObjectPropertyKey();\x0a\x09        }\x0a\x09        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);\x0a\x09        if (token.type === 3 /* Identifier */ && !isAsync && token.value === \x27get\x27 && lookaheadPropertyKey) {\x0a\x09            kind = \x27get\x27;\x0a\x09            computed = this.match(\x27[\x27);\x0a\x09            key = this.parseObjectPropertyKey();\x0a\x09            this.context.allowYield = false;\x0a\x09            value = this.parseGetterMethod();\x0a\x09        }\x0a\x09        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === \x27set\x27 && lookaheadPropertyKey) {\x0a\x09            kind = \x27set\x27;\x0a\x09            computed = this.match(\x27[\x27);\x0a\x09            key = this.parseObjectPropertyKey();\x0a\x09            value = this.parseSetterMethod();\x0a\x09        }\x0a\x09        else if (token.type === 7 /* Punctuator */ && token.value === \x27*\x27 && lookaheadPropertyKey) {\x0a\x09            kind = \x27init\x27;\x0a\x09            computed = this.match(\x27[\x27);\x0a\x09            key = this.parseObjectPropertyKey();\x0a\x09            value = this.parseGeneratorMethod();\x0a\x09            method = true;\x0a\x09        }\x0a\x09        else {\x0a\x09            if (!key) {\x0a\x09                this.throwUnexpectedToken(this.lookahead);\x0a\x09            }\x0a\x09            kind = \x27init\x27;\x0a\x09            if (this.match(\x27:\x27) && !isAsync) {\x0a\x09                if (!computed && this.isPropertyKey(key, \x27__proto__\x27)) {\x0a\x09                    if (hasProto.value) {\x0a\x09                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);\x0a\x09                    }\x0a\x09                    hasProto.value = true;\x0a\x09                }\x0a\x09                this.nextToken();\x0a\x09                value = this.inheritCoverGrammar(this.parseAssignmentExpression);\x0a\x09            }\x0a\x09            else if (this.match(\x27(\x27)) {\x0a\x09                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();\x0a\x09                method = true;\x0a\x09            }\x0a\x09            else if (token.type === 3 /* Identifier */) {\x0a\x09                var id = this.finalize(node, new Node.Identifier(token.value));\x0a\x09                if (this.match(\x27=\x27)) {\x0a\x09                    this.context.firstCoverInitializedNameError = this.lookahead;\x0a\x09                    this.nextToken();\x0a\x09                    shorthand = true;\x0a\x09                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09                    value = this.finalize(node, new Node.AssignmentPattern(id, init));\x0a\x09                }\x0a\x09                else {\x0a\x09                    shorthand = true;\x0a\x09                    value = id;\x0a\x09                }\x0a\x09            }\x0a\x09            else {\x0a\x09                this.throwUnexpectedToken(this.nextToken());\x0a\x09            }\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));\x0a\x09    };\x0a\x09    Parser.prototype.parseObjectInitializer = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expect(\x27{\x27);\x0a\x09        var properties = [];\x0a\x09        var hasProto = { value: false };\x0a\x09        while (!this.match(\x27}\x27)) {\x0a\x09            properties.push(this.parseObjectProperty(hasProto));\x0a\x09            if (!this.match(\x27}\x27)) {\x0a\x09                this.expectCommaSeparator();\x0a\x09            }\x0a\x09        }\x0a\x09        this.expect(\x27}\x27);\x0a\x09        return this.finalize(node, new Node.ObjectExpression(properties));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-template-literals\x0a\x09    Parser.prototype.parseTemplateHead = function () {\x0a\x09        assert_1.assert(this.lookahead.head, \x27Template literal must start with a template head\x27);\x0a\x09        var node = this.createNode();\x0a\x09        var token = this.nextToken();\x0a\x09        var raw = token.value;\x0a\x09        var cooked = token.cooked;\x0a\x09        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));\x0a\x09    };\x0a\x09    Parser.prototype.parseTemplateElement = function () {\x0a\x09        if (this.lookahead.type !== 10 /* Template */) {\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        var node = this.createNode();\x0a\x09        var token = this.nextToken();\x0a\x09        var raw = token.value;\x0a\x09        var cooked = token.cooked;\x0a\x09        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));\x0a\x09    };\x0a\x09    Parser.prototype.parseTemplateLiteral = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var expressions = [];\x0a\x09        var quasis = [];\x0a\x09        var quasi = this.parseTemplateHead();\x0a\x09        quasis.push(quasi);\x0a\x09        while (!quasi.tail) {\x0a\x09            expressions.push(this.parseExpression());\x0a\x09            quasi = this.parseTemplateElement();\x0a\x09            quasis.push(quasi);\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-grouping-operator\x0a\x09    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {\x0a\x09        switch (expr.type) {\x0a\x09            case syntax_1.Syntax.Identifier:\x0a\x09            case syntax_1.Syntax.MemberExpression:\x0a\x09            case syntax_1.Syntax.RestElement:\x0a\x09            case syntax_1.Syntax.AssignmentPattern:\x0a\x09                break;\x0a\x09            case syntax_1.Syntax.SpreadElement:\x0a\x09                expr.type = syntax_1.Syntax.RestElement;\x0a\x09                this.reinterpretExpressionAsPattern(expr.argument);\x0a\x09                break;\x0a\x09            case syntax_1.Syntax.ArrayExpression:\x0a\x09                expr.type = syntax_1.Syntax.ArrayPattern;\x0a\x09                for (var i = 0; i \x3c expr.elements.length; i++) {\x0a\x09                    if (expr.elements[i] !== null) {\x0a\x09                        this.reinterpretExpressionAsPattern(expr.elements[i]);\x0a\x09                    }\x0a\x09                }\x0a\x09                break;\x0a\x09            case syntax_1.Syntax.ObjectExpression:\x0a\x09                expr.type = syntax_1.Syntax.ObjectPattern;\x0a\x09                for (var i = 0; i \x3c expr.properties.length; i++) {\x0a\x09                    this.reinterpretExpressionAsPattern(expr.properties[i].value);\x0a\x09                }\x0a\x09                break;\x0a\x09            case syntax_1.Syntax.AssignmentExpression:\x0a\x09                expr.type = syntax_1.Syntax.AssignmentPattern;\x0a\x09                delete expr.operator;\x0a\x09                this.reinterpretExpressionAsPattern(expr.left);\x0a\x09                break;\x0a\x09            default:\x0a\x09                // Allow other node type for tolerant parsing.\x0a\x09                break;\x0a\x09        }\x0a\x09    };\x0a\x09    Parser.prototype.parseGroupExpression = function () {\x0a\x09        var expr;\x0a\x09        this.expect(\x27(\x27);\x0a\x09        if (this.match(\x27)\x27)) {\x0a\x09            this.nextToken();\x0a\x09            if (!this.match(\x27=\x3e\x27)) {\x0a\x09                this.expect(\x27=\x3e\x27);\x0a\x09            }\x0a\x09            expr = {\x0a\x09                type: ArrowParameterPlaceHolder,\x0a\x09                params: [],\x0a\x09                async: false\x0a\x09            };\x0a\x09        }\x0a\x09        else {\x0a\x09            var startToken = this.lookahead;\x0a\x09            var params = [];\x0a\x09            if (this.match(\x27...\x27)) {\x0a\x09                expr = this.parseRestElement(params);\x0a\x09                this.expect(\x27)\x27);\x0a\x09                if (!this.match(\x27=\x3e\x27)) {\x0a\x09                    this.expect(\x27=\x3e\x27);\x0a\x09                }\x0a\x09                expr = {\x0a\x09                    type: ArrowParameterPlaceHolder,\x0a\x09                    params: [expr],\x0a\x09                    async: false\x0a\x09                };\x0a\x09            }\x0a\x09            else {\x0a\x09                var arrow = false;\x0a\x09                this.context.isBindingElement = true;\x0a\x09                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);\x0a\x09                if (this.match(\x27,\x27)) {\x0a\x09                    var expressions = [];\x0a\x09                    this.context.isAssignmentTarget = false;\x0a\x09                    expressions.push(expr);\x0a\x09                    while (this.lookahead.type !== 2 /* EOF */) {\x0a\x09                        if (!this.match(\x27,\x27)) {\x0a\x09                            break;\x0a\x09                        }\x0a\x09                        this.nextToken();\x0a\x09                        if (this.match(\x27)\x27)) {\x0a\x09                            this.nextToken();\x0a\x09                            for (var i = 0; i \x3c expressions.length; i++) {\x0a\x09                                this.reinterpretExpressionAsPattern(expressions[i]);\x0a\x09                            }\x0a\x09                            arrow = true;\x0a\x09                            expr = {\x0a\x09                                type: ArrowParameterPlaceHolder,\x0a\x09                                params: expressions,\x0a\x09                                async: false\x0a\x09                            };\x0a\x09                        }\x0a\x09                        else if (this.match(\x27...\x27)) {\x0a\x09                            if (!this.context.isBindingElement) {\x0a\x09                                this.throwUnexpectedToken(this.lookahead);\x0a\x09                            }\x0a\x09                            expressions.push(this.parseRestElement(params));\x0a\x09                            this.expect(\x27)\x27);\x0a\x09                            if (!this.match(\x27=\x3e\x27)) {\x0a\x09                                this.expect(\x27=\x3e\x27);\x0a\x09                            }\x0a\x09                            this.context.isBindingElement = false;\x0a\x09                            for (var i = 0; i \x3c expressions.length; i++) {\x0a\x09                                this.reinterpretExpressionAsPattern(expressions[i]);\x0a\x09                            }\x0a\x09                            arrow = true;\x0a\x09                            expr = {\x0a\x09                                type: ArrowParameterPlaceHolder,\x0a\x09                                params: expressions,\x0a\x09                                async: false\x0a\x09                            };\x0a\x09                        }\x0a\x09                        else {\x0a\x09                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));\x0a\x09                        }\x0a\x09                        if (arrow) {\x0a\x09                            break;\x0a\x09                        }\x0a\x09                    }\x0a\x09                    if (!arrow) {\x0a\x09                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));\x0a\x09                    }\x0a\x09                }\x0a\x09                if (!arrow) {\x0a\x09                    this.expect(\x27)\x27);\x0a\x09                    if (this.match(\x27=\x3e\x27)) {\x0a\x09                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === \x27yield\x27) {\x0a\x09                            arrow = true;\x0a\x09                            expr = {\x0a\x09                                type: ArrowParameterPlaceHolder,\x0a\x09                                params: [expr],\x0a\x09                                async: false\x0a\x09                            };\x0a\x09                        }\x0a\x09                        if (!arrow) {\x0a\x09                            if (!this.context.isBindingElement) {\x0a\x09                                this.throwUnexpectedToken(this.lookahead);\x0a\x09                            }\x0a\x09                            if (expr.type === syntax_1.Syntax.SequenceExpression) {\x0a\x09                                for (var i = 0; i \x3c expr.expressions.length; i++) {\x0a\x09                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);\x0a\x09                                }\x0a\x09                            }\x0a\x09                            else {\x0a\x09                                this.reinterpretExpressionAsPattern(expr);\x0a\x09                            }\x0a\x09                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);\x0a\x09                            expr = {\x0a\x09                                type: ArrowParameterPlaceHolder,\x0a\x09                                params: parameters,\x0a\x09                                async: false\x0a\x09                            };\x0a\x09                        }\x0a\x09                    }\x0a\x09                    this.context.isBindingElement = false;\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        return expr;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions\x0a\x09    Parser.prototype.parseArguments = function () {\x0a\x09        this.expect(\x27(\x27);\x0a\x09        var args = [];\x0a\x09        if (!this.match(\x27)\x27)) {\x0a\x09            while (true) {\x0a\x09                var expr = this.match(\x27...\x27) ? this.parseSpreadElement() :\x0a\x09                    this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09                args.push(expr);\x0a\x09                if (this.match(\x27)\x27)) {\x0a\x09                    break;\x0a\x09                }\x0a\x09                this.expectCommaSeparator();\x0a\x09                if (this.match(\x27)\x27)) {\x0a\x09                    break;\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        this.expect(\x27)\x27);\x0a\x09        return args;\x0a\x09    };\x0a\x09    Parser.prototype.isIdentifierName = function (token) {\x0a\x09        return token.type === 3 /* Identifier */ ||\x0a\x09            token.type === 4 /* Keyword */ ||\x0a\x09            token.type === 1 /* BooleanLiteral */ ||\x0a\x09            token.type === 5 /* NullLiteral */;\x0a\x09    };\x0a\x09    Parser.prototype.parseIdentifierName = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var token = this.nextToken();\x0a\x09        if (!this.isIdentifierName(token)) {\x0a\x09            this.throwUnexpectedToken(token);\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.Identifier(token.value));\x0a\x09    };\x0a\x09    Parser.prototype.parseNewExpression = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var id = this.parseIdentifierName();\x0a\x09        assert_1.assert(id.name === \x27new\x27, \x27New expression must start with `new`\x27);\x0a\x09        var expr;\x0a\x09        if (this.match(\x27.\x27)) {\x0a\x09            this.nextToken();\x0a\x09            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === \x27target\x27) {\x0a\x09                var property = this.parseIdentifierName();\x0a\x09                expr = new Node.MetaProperty(id, property);\x0a\x09            }\x0a\x09            else {\x0a\x09                this.throwUnexpectedToken(this.lookahead);\x0a\x09            }\x0a\x09        }\x0a\x09        else {\x0a\x09            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);\x0a\x09            var args = this.match(\x27(\x27) ? this.parseArguments() : [];\x0a\x09            expr = new Node.NewExpression(callee, args);\x0a\x09            this.context.isAssignmentTarget = false;\x0a\x09            this.context.isBindingElement = false;\x0a\x09        }\x0a\x09        return this.finalize(node, expr);\x0a\x09    };\x0a\x09    Parser.prototype.parseAsyncArgument = function () {\x0a\x09        var arg = this.parseAssignmentExpression();\x0a\x09        this.context.firstCoverInitializedNameError = null;\x0a\x09        return arg;\x0a\x09    };\x0a\x09    Parser.prototype.parseAsyncArguments = function () {\x0a\x09        this.expect(\x27(\x27);\x0a\x09        var args = [];\x0a\x09        if (!this.match(\x27)\x27)) {\x0a\x09            while (true) {\x0a\x09                var expr = this.match(\x27...\x27) ? this.parseSpreadElement() :\x0a\x09                    this.isolateCoverGrammar(this.parseAsyncArgument);\x0a\x09                args.push(expr);\x0a\x09                if (this.match(\x27)\x27)) {\x0a\x09                    break;\x0a\x09                }\x0a\x09                this.expectCommaSeparator();\x0a\x09                if (this.match(\x27)\x27)) {\x0a\x09                    break;\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        this.expect(\x27)\x27);\x0a\x09        return args;\x0a\x09    };\x0a\x09    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {\x0a\x09        var startToken = this.lookahead;\x0a\x09        var maybeAsync = this.matchContextualKeyword(\x27async\x27);\x0a\x09        var previousAllowIn = this.context.allowIn;\x0a\x09        this.context.allowIn = true;\x0a\x09        var expr;\x0a\x09        if (this.matchKeyword(\x27super\x27) && this.context.inFunctionBody) {\x0a\x09            expr = this.createNode();\x0a\x09            this.nextToken();\x0a\x09            expr = this.finalize(expr, new Node.Super());\x0a\x09            if (!this.match(\x27(\x27) && !this.match(\x27.\x27) && !this.match(\x27[\x27)) {\x0a\x09                this.throwUnexpectedToken(this.lookahead);\x0a\x09            }\x0a\x09        }\x0a\x09        else {\x0a\x09            expr = this.inheritCoverGrammar(this.matchKeyword(\x27new\x27) ? this.parseNewExpression : this.parsePrimaryExpression);\x0a\x09        }\x0a\x09        while (true) {\x0a\x09            if (this.match(\x27.\x27)) {\x0a\x09                this.context.isBindingElement = false;\x0a\x09                this.context.isAssignmentTarget = true;\x0a\x09                this.expect(\x27.\x27);\x0a\x09                var property = this.parseIdentifierName();\x0a\x09                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));\x0a\x09            }\x0a\x09            else if (this.match(\x27(\x27)) {\x0a\x09                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);\x0a\x09                this.context.isBindingElement = false;\x0a\x09                this.context.isAssignmentTarget = false;\x0a\x09                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();\x0a\x09                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));\x0a\x09                if (asyncArrow && this.match(\x27=\x3e\x27)) {\x0a\x09                    for (var i = 0; i \x3c args.length; ++i) {\x0a\x09                        this.reinterpretExpressionAsPattern(args[i]);\x0a\x09                    }\x0a\x09                    expr = {\x0a\x09                        type: ArrowParameterPlaceHolder,\x0a\x09                        params: args,\x0a\x09                        async: true\x0a\x09                    };\x0a\x09                }\x0a\x09            }\x0a\x09            else if (this.match(\x27[\x27)) {\x0a\x09                this.context.isBindingElement = false;\x0a\x09                this.context.isAssignmentTarget = true;\x0a\x09                this.expect(\x27[\x27);\x0a\x09                var property = this.isolateCoverGrammar(this.parseExpression);\x0a\x09                this.expect(\x27]\x27);\x0a\x09                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));\x0a\x09            }\x0a\x09            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {\x0a\x09                var quasi = this.parseTemplateLiteral();\x0a\x09                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));\x0a\x09            }\x0a\x09            else {\x0a\x09                break;\x0a\x09            }\x0a\x09        }\x0a\x09        this.context.allowIn = previousAllowIn;\x0a\x09        return expr;\x0a\x09    };\x0a\x09    Parser.prototype.parseSuper = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27super\x27);\x0a\x09        if (!this.match(\x27[\x27) && !this.match(\x27.\x27)) {\x0a\x09            this.throwUnexpectedToken(this.lookahead);\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.Super());\x0a\x09    };\x0a\x09    Parser.prototype.parseLeftHandSideExpression = function () {\x0a\x09        assert_1.assert(this.context.allowIn, \x27callee of new expression always allow in keyword.\x27);\x0a\x09        var node = this.startNode(this.lookahead);\x0a\x09        var expr = (this.matchKeyword(\x27super\x27) && this.context.inFunctionBody) ? this.parseSuper() :\x0a\x09            this.inheritCoverGrammar(this.matchKeyword(\x27new\x27) ? this.parseNewExpression : this.parsePrimaryExpression);\x0a\x09        while (true) {\x0a\x09            if (this.match(\x27[\x27)) {\x0a\x09                this.context.isBindingElement = false;\x0a\x09                this.context.isAssignmentTarget = true;\x0a\x09                this.expect(\x27[\x27);\x0a\x09                var property = this.isolateCoverGrammar(this.parseExpression);\x0a\x09                this.expect(\x27]\x27);\x0a\x09                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));\x0a\x09            }\x0a\x09            else if (this.match(\x27.\x27)) {\x0a\x09                this.context.isBindingElement = false;\x0a\x09                this.context.isAssignmentTarget = true;\x0a\x09                this.expect(\x27.\x27);\x0a\x09                var property = this.parseIdentifierName();\x0a\x09                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));\x0a\x09            }\x0a\x09            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {\x0a\x09                var quasi = this.parseTemplateLiteral();\x0a\x09                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));\x0a\x09            }\x0a\x09            else {\x0a\x09                break;\x0a\x09            }\x0a\x09        }\x0a\x09        return expr;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-update-expressions\x0a\x09    Parser.prototype.parseUpdateExpression = function () {\x0a\x09        var expr;\x0a\x09        var startToken = this.lookahead;\x0a\x09        if (this.match(\x27++\x27) || this.match(\x27--\x27)) {\x0a\x09            var node = this.startNode(startToken);\x0a\x09            var token = this.nextToken();\x0a\x09            expr = this.inheritCoverGrammar(this.parseUnaryExpression);\x0a\x09            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {\x0a\x09                this.tolerateError(messages_1.Messages.StrictLHSPrefix);\x0a\x09            }\x0a\x09            if (!this.context.isAssignmentTarget) {\x0a\x09                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);\x0a\x09            }\x0a\x09            var prefix = true;\x0a\x09            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));\x0a\x09            this.context.isAssignmentTarget = false;\x0a\x09            this.context.isBindingElement = false;\x0a\x09        }\x0a\x09        else {\x0a\x09            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\x0a\x09            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {\x0a\x09                if (this.match(\x27++\x27) || this.match(\x27--\x27)) {\x0a\x09                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {\x0a\x09                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);\x0a\x09                    }\x0a\x09                    if (!this.context.isAssignmentTarget) {\x0a\x09                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);\x0a\x09                    }\x0a\x09                    this.context.isAssignmentTarget = false;\x0a\x09                    this.context.isBindingElement = false;\x0a\x09                    var operator = this.nextToken().value;\x0a\x09                    var prefix = false;\x0a\x09                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        return expr;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-unary-operators\x0a\x09    Parser.prototype.parseAwaitExpression = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.nextToken();\x0a\x09        var argument = this.parseUnaryExpression();\x0a\x09        return this.finalize(node, new Node.AwaitExpression(argument));\x0a\x09    };\x0a\x09    Parser.prototype.parseUnaryExpression = function () {\x0a\x09        var expr;\x0a\x09        if (this.match(\x27+\x27) || this.match(\x27-\x27) || this.match(\x27~\x27) || this.match(\x27!\x27) ||\x0a\x09            this.matchKeyword(\x27delete\x27) || this.matchKeyword(\x27void\x27) || this.matchKeyword(\x27typeof\x27)) {\x0a\x09            var node = this.startNode(this.lookahead);\x0a\x09            var token = this.nextToken();\x0a\x09            expr = this.inheritCoverGrammar(this.parseUnaryExpression);\x0a\x09            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));\x0a\x09            if (this.context.strict && expr.operator === \x27delete\x27 && expr.argument.type === syntax_1.Syntax.Identifier) {\x0a\x09                this.tolerateError(messages_1.Messages.StrictDelete);\x0a\x09            }\x0a\x09            this.context.isAssignmentTarget = false;\x0a\x09            this.context.isBindingElement = false;\x0a\x09        }\x0a\x09        else if (this.context.await && this.matchContextualKeyword(\x27await\x27)) {\x0a\x09            expr = this.parseAwaitExpression();\x0a\x09        }\x0a\x09        else {\x0a\x09            expr = this.parseUpdateExpression();\x0a\x09        }\x0a\x09        return expr;\x0a\x09    };\x0a\x09    Parser.prototype.parseExponentiationExpression = function () {\x0a\x09        var startToken = this.lookahead;\x0a\x09        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);\x0a\x09        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match(\x27**\x27)) {\x0a\x09            this.nextToken();\x0a\x09            this.context.isAssignmentTarget = false;\x0a\x09            this.context.isBindingElement = false;\x0a\x09            var left = expr;\x0a\x09            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);\x0a\x09            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression(\x27**\x27, left, right));\x0a\x09        }\x0a\x09        return expr;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-exp-operator\x0a\x09    // https://tc39.github.io/ecma262/#sec-multiplicative-operators\x0a\x09    // https://tc39.github.io/ecma262/#sec-additive-operators\x0a\x09    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators\x0a\x09    // https://tc39.github.io/ecma262/#sec-relational-operators\x0a\x09    // https://tc39.github.io/ecma262/#sec-equality-operators\x0a\x09    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators\x0a\x09    // https://tc39.github.io/ecma262/#sec-binary-logical-operators\x0a\x09    Parser.prototype.binaryPrecedence = function (token) {\x0a\x09        var op = token.value;\x0a\x09        var precedence;\x0a\x09        if (token.type === 7 /* Punctuator */) {\x0a\x09            precedence = this.operatorPrecedence[op] || 0;\x0a\x09        }\x0a\x09        else if (token.type === 4 /* Keyword */) {\x0a\x09            precedence = (op === \x27instanceof\x27 || (this.context.allowIn && op === \x27in\x27)) ? 7 : 0;\x0a\x09        }\x0a\x09        else {\x0a\x09            precedence = 0;\x0a\x09        }\x0a\x09        return precedence;\x0a\x09    };\x0a\x09    Parser.prototype.parseBinaryExpression = function () {\x0a\x09        var startToken = this.lookahead;\x0a\x09        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);\x0a\x09        var token = this.lookahead;\x0a\x09        var prec = this.binaryPrecedence(token);\x0a\x09        if (prec \x3e 0) {\x0a\x09            this.nextToken();\x0a\x09            this.context.isAssignmentTarget = false;\x0a\x09            this.context.isBindingElement = false;\x0a\x09            var markers = [startToken, this.lookahead];\x0a\x09            var left = expr;\x0a\x09            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);\x0a\x09            var stack = [left, token.value, right];\x0a\x09            var precedences = [prec];\x0a\x09            while (true) {\x0a\x09                prec = this.binaryPrecedence(this.lookahead);\x0a\x09                if (prec \x3c= 0) {\x0a\x09                    break;\x0a\x09                }\x0a\x09                // Reduce: make a binary expression from the three topmost entries.\x0a\x09                while ((stack.length \x3e 2) && (prec \x3c= precedences[precedences.length - 1])) {\x0a\x09                    right = stack.pop();\x0a\x09                    var operator = stack.pop();\x0a\x09                    precedences.pop();\x0a\x09                    left = stack.pop();\x0a\x09                    markers.pop();\x0a\x09                    var node = this.startNode(markers[markers.length - 1]);\x0a\x09                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));\x0a\x09                }\x0a\x09                // Shift.\x0a\x09                stack.push(this.nextToken().value);\x0a\x09                precedences.push(prec);\x0a\x09                markers.push(this.lookahead);\x0a\x09                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));\x0a\x09            }\x0a\x09            // Final reduce to clean-up the stack.\x0a\x09            var i = stack.length - 1;\x0a\x09            expr = stack[i];\x0a\x09            markers.pop();\x0a\x09            while (i \x3e 1) {\x0a\x09                var node = this.startNode(markers.pop());\x0a\x09                var operator = stack[i - 1];\x0a\x09                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));\x0a\x09                i -= 2;\x0a\x09            }\x0a\x09        }\x0a\x09        return expr;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-conditional-operator\x0a\x09    Parser.prototype.parseConditionalExpression = function () {\x0a\x09        var startToken = this.lookahead;\x0a\x09        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);\x0a\x09        if (this.match(\x27?\x27)) {\x0a\x09            this.nextToken();\x0a\x09            var previousAllowIn = this.context.allowIn;\x0a\x09            this.context.allowIn = true;\x0a\x09            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09            this.context.allowIn = previousAllowIn;\x0a\x09            this.expect(\x27:\x27);\x0a\x09            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));\x0a\x09            this.context.isAssignmentTarget = false;\x0a\x09            this.context.isBindingElement = false;\x0a\x09        }\x0a\x09        return expr;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-assignment-operators\x0a\x09    Parser.prototype.checkPatternParam = function (options, param) {\x0a\x09        switch (param.type) {\x0a\x09            case syntax_1.Syntax.Identifier:\x0a\x09                this.validateParam(options, param, param.name);\x0a\x09                break;\x0a\x09            case syntax_1.Syntax.RestElement:\x0a\x09                this.checkPatternParam(options, param.argument);\x0a\x09                break;\x0a\x09            case syntax_1.Syntax.AssignmentPattern:\x0a\x09                this.checkPatternParam(options, param.left);\x0a\x09                break;\x0a\x09            case syntax_1.Syntax.ArrayPattern:\x0a\x09                for (var i = 0; i \x3c param.elements.length; i++) {\x0a\x09                    if (param.elements[i] !== null) {\x0a\x09                        this.checkPatternParam(options, param.elements[i]);\x0a\x09                    }\x0a\x09                }\x0a\x09                break;\x0a\x09            case syntax_1.Syntax.ObjectPattern:\x0a\x09                for (var i = 0; i \x3c param.properties.length; i++) {\x0a\x09                    this.checkPatternParam(options, param.properties[i].value);\x0a\x09                }\x0a\x09                break;\x0a\x09            default:\x0a\x09                break;\x0a\x09        }\x0a\x09        options.simple = options.simple && (param instanceof Node.Identifier);\x0a\x09    };\x0a\x09    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {\x0a\x09        var params = [expr];\x0a\x09        var options;\x0a\x09        var asyncArrow = false;\x0a\x09        switch (expr.type) {\x0a\x09            case syntax_1.Syntax.Identifier:\x0a\x09                break;\x0a\x09            case ArrowParameterPlaceHolder:\x0a\x09                params = expr.params;\x0a\x09                asyncArrow = expr.async;\x0a\x09                break;\x0a\x09            default:\x0a\x09                return null;\x0a\x09        }\x0a\x09        options = {\x0a\x09            simple: true,\x0a\x09            paramSet: {}\x0a\x09        };\x0a\x09        for (var i = 0; i \x3c params.length; ++i) {\x0a\x09            var param = params[i];\x0a\x09            if (param.type === syntax_1.Syntax.AssignmentPattern) {\x0a\x09                if (param.right.type === syntax_1.Syntax.YieldExpression) {\x0a\x09                    if (param.right.argument) {\x0a\x09                        this.throwUnexpectedToken(this.lookahead);\x0a\x09                    }\x0a\x09                    param.right.type = syntax_1.Syntax.Identifier;\x0a\x09                    param.right.name = \x27yield\x27;\x0a\x09                    delete param.right.argument;\x0a\x09                    delete param.right.delegate;\x0a\x09                }\x0a\x09            }\x0a\x09            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === \x27await\x27) {\x0a\x09                this.throwUnexpectedToken(this.lookahead);\x0a\x09            }\x0a\x09            this.checkPatternParam(options, param);\x0a\x09            params[i] = param;\x0a\x09        }\x0a\x09        if (this.context.strict || !this.context.allowYield) {\x0a\x09            for (var i = 0; i \x3c params.length; ++i) {\x0a\x09                var param = params[i];\x0a\x09                if (param.type === syntax_1.Syntax.YieldExpression) {\x0a\x09                    this.throwUnexpectedToken(this.lookahead);\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        if (options.message === messages_1.Messages.StrictParamDupe) {\x0a\x09            var token = this.context.strict ? options.stricted : options.firstRestricted;\x0a\x09            this.throwUnexpectedToken(token, options.message);\x0a\x09        }\x0a\x09        return {\x0a\x09            simple: options.simple,\x0a\x09            params: params,\x0a\x09            stricted: options.stricted,\x0a\x09            firstRestricted: options.firstRestricted,\x0a\x09            message: options.message\x0a\x09        };\x0a\x09    };\x0a\x09    Parser.prototype.parseAssignmentExpression = function () {\x0a\x09        var expr;\x0a\x09        if (!this.context.allowYield && this.matchKeyword(\x27yield\x27)) {\x0a\x09            expr = this.parseYieldExpression();\x0a\x09        }\x0a\x09        else {\x0a\x09            var startToken = this.lookahead;\x0a\x09            var token = startToken;\x0a\x09            expr = this.parseConditionalExpression();\x0a\x09            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === \x27async\x27) {\x0a\x09                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword(\x27yield\x27)) {\x0a\x09                    var arg = this.parsePrimaryExpression();\x0a\x09                    this.reinterpretExpressionAsPattern(arg);\x0a\x09                    expr = {\x0a\x09                        type: ArrowParameterPlaceHolder,\x0a\x09                        params: [arg],\x0a\x09                        async: true\x0a\x09                    };\x0a\x09                }\x0a\x09            }\x0a\x09            if (expr.type === ArrowParameterPlaceHolder || this.match(\x27=\x3e\x27)) {\x0a\x09                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions\x0a\x09                this.context.isAssignmentTarget = false;\x0a\x09                this.context.isBindingElement = false;\x0a\x09                var isAsync = expr.async;\x0a\x09                var list = this.reinterpretAsCoverFormalsList(expr);\x0a\x09                if (list) {\x0a\x09                    if (this.hasLineTerminator) {\x0a\x09                        this.tolerateUnexpectedToken(this.lookahead);\x0a\x09                    }\x0a\x09                    this.context.firstCoverInitializedNameError = null;\x0a\x09                    var previousStrict = this.context.strict;\x0a\x09                    var previousAllowStrictDirective = this.context.allowStrictDirective;\x0a\x09                    this.context.allowStrictDirective = list.simple;\x0a\x09                    var previousAllowYield = this.context.allowYield;\x0a\x09                    var previousAwait = this.context.await;\x0a\x09                    this.context.allowYield = true;\x0a\x09                    this.context.await = isAsync;\x0a\x09                    var node = this.startNode(startToken);\x0a\x09                    this.expect(\x27=\x3e\x27);\x0a\x09                    var body = void 0;\x0a\x09                    if (this.match(\x27{\x27)) {\x0a\x09                        var previousAllowIn = this.context.allowIn;\x0a\x09                        this.context.allowIn = true;\x0a\x09                        body = this.parseFunctionSourceElements();\x0a\x09                        this.context.allowIn = previousAllowIn;\x0a\x09                    }\x0a\x09                    else {\x0a\x09                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09                    }\x0a\x09                    var expression = body.type !== syntax_1.Syntax.BlockStatement;\x0a\x09                    if (this.context.strict && list.firstRestricted) {\x0a\x09                        this.throwUnexpectedToken(list.firstRestricted, list.message);\x0a\x09                    }\x0a\x09                    if (this.context.strict && list.stricted) {\x0a\x09                        this.tolerateUnexpectedToken(list.stricted, list.message);\x0a\x09                    }\x0a\x09                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :\x0a\x09                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));\x0a\x09                    this.context.strict = previousStrict;\x0a\x09                    this.context.allowStrictDirective = previousAllowStrictDirective;\x0a\x09                    this.context.allowYield = previousAllowYield;\x0a\x09                    this.context.await = previousAwait;\x0a\x09                }\x0a\x09            }\x0a\x09            else {\x0a\x09                if (this.matchAssign()) {\x0a\x09                    if (!this.context.isAssignmentTarget) {\x0a\x09                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);\x0a\x09                    }\x0a\x09                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {\x0a\x09                        var id = expr;\x0a\x09                        if (this.scanner.isRestrictedWord(id.name)) {\x0a\x09                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);\x0a\x09                        }\x0a\x09                        if (this.scanner.isStrictModeReservedWord(id.name)) {\x0a\x09                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);\x0a\x09                        }\x0a\x09                    }\x0a\x09                    if (!this.match(\x27=\x27)) {\x0a\x09                        this.context.isAssignmentTarget = false;\x0a\x09                        this.context.isBindingElement = false;\x0a\x09                    }\x0a\x09                    else {\x0a\x09                        this.reinterpretExpressionAsPattern(expr);\x0a\x09                    }\x0a\x09                    token = this.nextToken();\x0a\x09                    var operator = token.value;\x0a\x09                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));\x0a\x09                    this.context.firstCoverInitializedNameError = null;\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        return expr;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-comma-operator\x0a\x09    Parser.prototype.parseExpression = function () {\x0a\x09        var startToken = this.lookahead;\x0a\x09        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09        if (this.match(\x27,\x27)) {\x0a\x09            var expressions = [];\x0a\x09            expressions.push(expr);\x0a\x09            while (this.lookahead.type !== 2 /* EOF */) {\x0a\x09                if (!this.match(\x27,\x27)) {\x0a\x09                    break;\x0a\x09                }\x0a\x09                this.nextToken();\x0a\x09                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));\x0a\x09            }\x0a\x09            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));\x0a\x09        }\x0a\x09        return expr;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-block\x0a\x09    Parser.prototype.parseStatementListItem = function () {\x0a\x09        var statement;\x0a\x09        this.context.isAssignmentTarget = true;\x0a\x09        this.context.isBindingElement = true;\x0a\x09        if (this.lookahead.type === 4 /* Keyword */) {\x0a\x09            switch (this.lookahead.value) {\x0a\x09                case \x27export\x27:\x0a\x09                    if (!this.context.isModule) {\x0a\x09                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);\x0a\x09                    }\x0a\x09                    statement = this.parseExportDeclaration();\x0a\x09                    break;\x0a\x09                case \x27import\x27:\x0a\x09                    if (!this.context.isModule) {\x0a\x09                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);\x0a\x09                    }\x0a\x09                    statement = this.parseImportDeclaration();\x0a\x09                    break;\x0a\x09                case \x27const\x27:\x0a\x09                    statement = this.parseLexicalDeclaration({ inFor: false });\x0a\x09                    break;\x0a\x09                case \x27function\x27:\x0a\x09                    statement = this.parseFunctionDeclaration();\x0a\x09                    break;\x0a\x09                case \x27class\x27:\x0a\x09                    statement = this.parseClassDeclaration();\x0a\x09                    break;\x0a\x09                case \x27let\x27:\x0a\x09                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();\x0a\x09                    break;\x0a\x09                default:\x0a\x09                    statement = this.parseStatement();\x0a\x09                    break;\x0a\x09            }\x0a\x09        }\x0a\x09        else {\x0a\x09            statement = this.parseStatement();\x0a\x09        }\x0a\x09        return statement;\x0a\x09    };\x0a\x09    Parser.prototype.parseBlock = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expect(\x27{\x27);\x0a\x09        var block = [];\x0a\x09        while (true) {\x0a\x09            if (this.match(\x27}\x27)) {\x0a\x09                break;\x0a\x09            }\x0a\x09            block.push(this.parseStatementListItem());\x0a\x09        }\x0a\x09        this.expect(\x27}\x27);\x0a\x09        return this.finalize(node, new Node.BlockStatement(block));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations\x0a\x09    Parser.prototype.parseLexicalBinding = function (kind, options) {\x0a\x09        var node = this.createNode();\x0a\x09        var params = [];\x0a\x09        var id = this.parsePattern(params, kind);\x0a\x09        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {\x0a\x09            if (this.scanner.isRestrictedWord(id.name)) {\x0a\x09                this.tolerateError(messages_1.Messages.StrictVarName);\x0a\x09            }\x0a\x09        }\x0a\x09        var init = null;\x0a\x09        if (kind === \x27const\x27) {\x0a\x09            if (!this.matchKeyword(\x27in\x27) && !this.matchContextualKeyword(\x27of\x27)) {\x0a\x09                if (this.match(\x27=\x27)) {\x0a\x09                    this.nextToken();\x0a\x09                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09                }\x0a\x09                else {\x0a\x09                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, \x27const\x27);\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match(\x27=\x27)) {\x0a\x09            this.expect(\x27=\x27);\x0a\x09            init = this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.VariableDeclarator(id, init));\x0a\x09    };\x0a\x09    Parser.prototype.parseBindingList = function (kind, options) {\x0a\x09        var list = [this.parseLexicalBinding(kind, options)];\x0a\x09        while (this.match(\x27,\x27)) {\x0a\x09            this.nextToken();\x0a\x09            list.push(this.parseLexicalBinding(kind, options));\x0a\x09        }\x0a\x09        return list;\x0a\x09    };\x0a\x09    Parser.prototype.isLexicalDeclaration = function () {\x0a\x09        var state = this.scanner.saveState();\x0a\x09        this.scanner.scanComments();\x0a\x09        var next = this.scanner.lex();\x0a\x09        this.scanner.restoreState(state);\x0a\x09        return (next.type === 3 /* Identifier */) ||\x0a\x09            (next.type === 7 /* Punctuator */ && next.value === \x27[\x27) ||\x0a\x09            (next.type === 7 /* Punctuator */ && next.value === \x27{\x27) ||\x0a\x09            (next.type === 4 /* Keyword */ && next.value === \x27let\x27) ||\x0a\x09            (next.type === 4 /* Keyword */ && next.value === \x27yield\x27);\x0a\x09    };\x0a\x09    Parser.prototype.parseLexicalDeclaration = function (options) {\x0a\x09        var node = this.createNode();\x0a\x09        var kind = this.nextToken().value;\x0a\x09        assert_1.assert(kind === \x27let\x27 || kind === \x27const\x27, \x27Lexical declaration must be either let or const\x27);\x0a\x09        var declarations = this.parseBindingList(kind, options);\x0a\x09        this.consumeSemicolon();\x0a\x09        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns\x0a\x09    Parser.prototype.parseBindingRestElement = function (params, kind) {\x0a\x09        var node = this.createNode();\x0a\x09        this.expect(\x27...\x27);\x0a\x09        var arg = this.parsePattern(params, kind);\x0a\x09        return this.finalize(node, new Node.RestElement(arg));\x0a\x09    };\x0a\x09    Parser.prototype.parseArrayPattern = function (params, kind) {\x0a\x09        var node = this.createNode();\x0a\x09        this.expect(\x27[\x27);\x0a\x09        var elements = [];\x0a\x09        while (!this.match(\x27]\x27)) {\x0a\x09            if (this.match(\x27,\x27)) {\x0a\x09                this.nextToken();\x0a\x09                elements.push(null);\x0a\x09            }\x0a\x09            else {\x0a\x09                if (this.match(\x27...\x27)) {\x0a\x09                    elements.push(this.parseBindingRestElement(params, kind));\x0a\x09                    break;\x0a\x09                }\x0a\x09                else {\x0a\x09                    elements.push(this.parsePatternWithDefault(params, kind));\x0a\x09                }\x0a\x09                if (!this.match(\x27]\x27)) {\x0a\x09                    this.expect(\x27,\x27);\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        this.expect(\x27]\x27);\x0a\x09        return this.finalize(node, new Node.ArrayPattern(elements));\x0a\x09    };\x0a\x09    Parser.prototype.parsePropertyPattern = function (params, kind) {\x0a\x09        var node = this.createNode();\x0a\x09        var computed = false;\x0a\x09        var shorthand = false;\x0a\x09        var method = false;\x0a\x09        var key;\x0a\x09        var value;\x0a\x09        if (this.lookahead.type === 3 /* Identifier */) {\x0a\x09            var keyToken = this.lookahead;\x0a\x09            key = this.parseVariableIdentifier();\x0a\x09            var init = this.finalize(node, new Node.Identifier(keyToken.value));\x0a\x09            if (this.match(\x27=\x27)) {\x0a\x09                params.push(keyToken);\x0a\x09                shorthand = true;\x0a\x09                this.nextToken();\x0a\x09                var expr = this.parseAssignmentExpression();\x0a\x09                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));\x0a\x09            }\x0a\x09            else if (!this.match(\x27:\x27)) {\x0a\x09                params.push(keyToken);\x0a\x09                shorthand = true;\x0a\x09                value = init;\x0a\x09            }\x0a\x09            else {\x0a\x09                this.expect(\x27:\x27);\x0a\x09                value = this.parsePatternWithDefault(params, kind);\x0a\x09            }\x0a\x09        }\x0a\x09        else {\x0a\x09            computed = this.match(\x27[\x27);\x0a\x09            key = this.parseObjectPropertyKey();\x0a\x09            this.expect(\x27:\x27);\x0a\x09            value = this.parsePatternWithDefault(params, kind);\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.Property(\x27init\x27, key, computed, value, method, shorthand));\x0a\x09    };\x0a\x09    Parser.prototype.parseObjectPattern = function (params, kind) {\x0a\x09        var node = this.createNode();\x0a\x09        var properties = [];\x0a\x09        this.expect(\x27{\x27);\x0a\x09        while (!this.match(\x27}\x27)) {\x0a\x09            properties.push(this.parsePropertyPattern(params, kind));\x0a\x09            if (!this.match(\x27}\x27)) {\x0a\x09                this.expect(\x27,\x27);\x0a\x09            }\x0a\x09        }\x0a\x09        this.expect(\x27}\x27);\x0a\x09        return this.finalize(node, new Node.ObjectPattern(properties));\x0a\x09    };\x0a\x09    Parser.prototype.parsePattern = function (params, kind) {\x0a\x09        var pattern;\x0a\x09        if (this.match(\x27[\x27)) {\x0a\x09            pattern = this.parseArrayPattern(params, kind);\x0a\x09        }\x0a\x09        else if (this.match(\x27{\x27)) {\x0a\x09            pattern = this.parseObjectPattern(params, kind);\x0a\x09        }\x0a\x09        else {\x0a\x09            if (this.matchKeyword(\x27let\x27) && (kind === \x27const\x27 || kind === \x27let\x27)) {\x0a\x09                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);\x0a\x09            }\x0a\x09            params.push(this.lookahead);\x0a\x09            pattern = this.parseVariableIdentifier(kind);\x0a\x09        }\x0a\x09        return pattern;\x0a\x09    };\x0a\x09    Parser.prototype.parsePatternWithDefault = function (params, kind) {\x0a\x09        var startToken = this.lookahead;\x0a\x09        var pattern = this.parsePattern(params, kind);\x0a\x09        if (this.match(\x27=\x27)) {\x0a\x09            this.nextToken();\x0a\x09            var previousAllowYield = this.context.allowYield;\x0a\x09            this.context.allowYield = true;\x0a\x09            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09            this.context.allowYield = previousAllowYield;\x0a\x09            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));\x0a\x09        }\x0a\x09        return pattern;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-variable-statement\x0a\x09    Parser.prototype.parseVariableIdentifier = function (kind) {\x0a\x09        var node = this.createNode();\x0a\x09        var token = this.nextToken();\x0a\x09        if (token.type === 4 /* Keyword */ && token.value === \x27yield\x27) {\x0a\x09            if (this.context.strict) {\x0a\x09                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);\x0a\x09            }\x0a\x09            else if (!this.context.allowYield) {\x0a\x09                this.throwUnexpectedToken(token);\x0a\x09            }\x0a\x09        }\x0a\x09        else if (token.type !== 3 /* Identifier */) {\x0a\x09            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {\x0a\x09                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);\x0a\x09            }\x0a\x09            else {\x0a\x09                if (this.context.strict || token.value !== \x27let\x27 || kind !== \x27var\x27) {\x0a\x09                    this.throwUnexpectedToken(token);\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === \x27await\x27) {\x0a\x09            this.tolerateUnexpectedToken(token);\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.Identifier(token.value));\x0a\x09    };\x0a\x09    Parser.prototype.parseVariableDeclaration = function (options) {\x0a\x09        var node = this.createNode();\x0a\x09        var params = [];\x0a\x09        var id = this.parsePattern(params, \x27var\x27);\x0a\x09        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {\x0a\x09            if (this.scanner.isRestrictedWord(id.name)) {\x0a\x09                this.tolerateError(messages_1.Messages.StrictVarName);\x0a\x09            }\x0a\x09        }\x0a\x09        var init = null;\x0a\x09        if (this.match(\x27=\x27)) {\x0a\x09            this.nextToken();\x0a\x09            init = this.isolateCoverGrammar(this.parseAssignmentExpression);\x0a\x09        }\x0a\x09        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {\x0a\x09            this.expect(\x27=\x27);\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.VariableDeclarator(id, init));\x0a\x09    };\x0a\x09    Parser.prototype.parseVariableDeclarationList = function (options) {\x0a\x09        var opt = { inFor: options.inFor };\x0a\x09        var list = [];\x0a\x09        list.push(this.parseVariableDeclaration(opt));\x0a\x09        while (this.match(\x27,\x27)) {\x0a\x09            this.nextToken();\x0a\x09            list.push(this.parseVariableDeclaration(opt));\x0a\x09        }\x0a\x09        return list;\x0a\x09    };\x0a\x09    Parser.prototype.parseVariableStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27var\x27);\x0a\x09        var declarations = this.parseVariableDeclarationList({ inFor: false });\x0a\x09        this.consumeSemicolon();\x0a\x09        return this.finalize(node, new Node.VariableDeclaration(declarations, \x27var\x27));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-empty-statement\x0a\x09    Parser.prototype.parseEmptyStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expect(\x27;\x27);\x0a\x09        return this.finalize(node, new Node.EmptyStatement());\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-expression-statement\x0a\x09    Parser.prototype.parseExpressionStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var expr = this.parseExpression();\x0a\x09        this.consumeSemicolon();\x0a\x09        return this.finalize(node, new Node.ExpressionStatement(expr));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-if-statement\x0a\x09    Parser.prototype.parseIfClause = function () {\x0a\x09        if (this.context.strict && this.matchKeyword(\x27function\x27)) {\x0a\x09            this.tolerateError(messages_1.Messages.StrictFunction);\x0a\x09        }\x0a\x09        return this.parseStatement();\x0a\x09    };\x0a\x09    Parser.prototype.parseIfStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var consequent;\x0a\x09        var alternate = null;\x0a\x09        this.expectKeyword(\x27if\x27);\x0a\x09        this.expect(\x27(\x27);\x0a\x09        var test = this.parseExpression();\x0a\x09        if (!this.match(\x27)\x27) && this.config.tolerant) {\x0a\x09            this.tolerateUnexpectedToken(this.nextToken());\x0a\x09            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());\x0a\x09        }\x0a\x09        else {\x0a\x09            this.expect(\x27)\x27);\x0a\x09            consequent = this.parseIfClause();\x0a\x09            if (this.matchKeyword(\x27else\x27)) {\x0a\x09                this.nextToken();\x0a\x09                alternate = this.parseIfClause();\x0a\x09            }\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-do-while-statement\x0a\x09    Parser.prototype.parseDoWhileStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27do\x27);\x0a\x09        var previousInIteration = this.context.inIteration;\x0a\x09        this.context.inIteration = true;\x0a\x09        var body = this.parseStatement();\x0a\x09        this.context.inIteration = previousInIteration;\x0a\x09        this.expectKeyword(\x27while\x27);\x0a\x09        this.expect(\x27(\x27);\x0a\x09        var test = this.parseExpression();\x0a\x09        if (!this.match(\x27)\x27) && this.config.tolerant) {\x0a\x09            this.tolerateUnexpectedToken(this.nextToken());\x0a\x09        }\x0a\x09        else {\x0a\x09            this.expect(\x27)\x27);\x0a\x09            if (this.match(\x27;\x27)) {\x0a\x09                this.nextToken();\x0a\x09            }\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.DoWhileStatement(body, test));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-while-statement\x0a\x09    Parser.prototype.parseWhileStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var body;\x0a\x09        this.expectKeyword(\x27while\x27);\x0a\x09        this.expect(\x27(\x27);\x0a\x09        var test = this.parseExpression();\x0a\x09        if (!this.match(\x27)\x27) && this.config.tolerant) {\x0a\x09            this.tolerateUnexpectedToken(this.nextToken());\x0a\x09            body = this.finalize(this.createNode(), new Node.EmptyStatement());\x0a\x09        }\x0a\x09        else {\x0a\x09            this.expect(\x27)\x27);\x0a\x09            var previousInIteration = this.context.inIteration;\x0a\x09            this.context.inIteration = true;\x0a\x09            body = this.parseStatement();\x0a\x09            this.context.inIteration = previousInIteration;\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.WhileStatement(test, body));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-for-statement\x0a\x09    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\x0a\x09    Parser.prototype.parseForStatement = function () {\x0a\x09        var init = null;\x0a\x09        var test = null;\x0a\x09        var update = null;\x0a\x09        var forIn = true;\x0a\x09        var left, right;\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27for\x27);\x0a\x09        this.expect(\x27(\x27);\x0a\x09        if (this.match(\x27;\x27)) {\x0a\x09            this.nextToken();\x0a\x09        }\x0a\x09        else {\x0a\x09            if (this.matchKeyword(\x27var\x27)) {\x0a\x09                init = this.createNode();\x0a\x09                this.nextToken();\x0a\x09                var previousAllowIn = this.context.allowIn;\x0a\x09                this.context.allowIn = false;\x0a\x09                var declarations = this.parseVariableDeclarationList({ inFor: true });\x0a\x09                this.context.allowIn = previousAllowIn;\x0a\x09                if (declarations.length === 1 && this.matchKeyword(\x27in\x27)) {\x0a\x09                    var decl = declarations[0];\x0a\x09                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {\x0a\x09                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, \x27for-in\x27);\x0a\x09                    }\x0a\x09                    init = this.finalize(init, new Node.VariableDeclaration(declarations, \x27var\x27));\x0a\x09                    this.nextToken();\x0a\x09                    left = init;\x0a\x09                    right = this.parseExpression();\x0a\x09                    init = null;\x0a\x09                }\x0a\x09                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword(\x27of\x27)) {\x0a\x09                    init = this.finalize(init, new Node.VariableDeclaration(declarations, \x27var\x27));\x0a\x09                    this.nextToken();\x0a\x09                    left = init;\x0a\x09                    right = this.parseAssignmentExpression();\x0a\x09                    init = null;\x0a\x09                    forIn = false;\x0a\x09                }\x0a\x09                else {\x0a\x09                    init = this.finalize(init, new Node.VariableDeclaration(declarations, \x27var\x27));\x0a\x09                    this.expect(\x27;\x27);\x0a\x09                }\x0a\x09            }\x0a\x09            else if (this.matchKeyword(\x27const\x27) || this.matchKeyword(\x27let\x27)) {\x0a\x09                init = this.createNode();\x0a\x09                var kind = this.nextToken().value;\x0a\x09                if (!this.context.strict && this.lookahead.value === \x27in\x27) {\x0a\x09                    init = this.finalize(init, new Node.Identifier(kind));\x0a\x09                    this.nextToken();\x0a\x09                    left = init;\x0a\x09                    right = this.parseExpression();\x0a\x09                    init = null;\x0a\x09                }\x0a\x09                else {\x0a\x09                    var previousAllowIn = this.context.allowIn;\x0a\x09                    this.context.allowIn = false;\x0a\x09                    var declarations = this.parseBindingList(kind, { inFor: true });\x0a\x09                    this.context.allowIn = previousAllowIn;\x0a\x09                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword(\x27in\x27)) {\x0a\x09                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));\x0a\x09                        this.nextToken();\x0a\x09                        left = init;\x0a\x09                        right = this.parseExpression();\x0a\x09                        init = null;\x0a\x09                    }\x0a\x09                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword(\x27of\x27)) {\x0a\x09                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));\x0a\x09                        this.nextToken();\x0a\x09                        left = init;\x0a\x09                        right = this.parseAssignmentExpression();\x0a\x09                        init = null;\x0a\x09                        forIn = false;\x0a\x09                    }\x0a\x09                    else {\x0a\x09                        this.consumeSemicolon();\x0a\x09                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));\x0a\x09                    }\x0a\x09                }\x0a\x09            }\x0a\x09            else {\x0a\x09                var initStartToken = this.lookahead;\x0a\x09                var previousAllowIn = this.context.allowIn;\x0a\x09                this.context.allowIn = false;\x0a\x09                init = this.inheritCoverGrammar(this.parseAssignmentExpression);\x0a\x09                this.context.allowIn = previousAllowIn;\x0a\x09                if (this.matchKeyword(\x27in\x27)) {\x0a\x09                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {\x0a\x09                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);\x0a\x09                    }\x0a\x09                    this.nextToken();\x0a\x09                    this.reinterpretExpressionAsPattern(init);\x0a\x09                    left = init;\x0a\x09                    right = this.parseExpression();\x0a\x09                    init = null;\x0a\x09                }\x0a\x09                else if (this.matchContextualKeyword(\x27of\x27)) {\x0a\x09                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {\x0a\x09                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);\x0a\x09                    }\x0a\x09                    this.nextToken();\x0a\x09                    this.reinterpretExpressionAsPattern(init);\x0a\x09                    left = init;\x0a\x09                    right = this.parseAssignmentExpression();\x0a\x09                    init = null;\x0a\x09                    forIn = false;\x0a\x09                }\x0a\x09                else {\x0a\x09                    if (this.match(\x27,\x27)) {\x0a\x09                        var initSeq = [init];\x0a\x09                        while (this.match(\x27,\x27)) {\x0a\x09                            this.nextToken();\x0a\x09                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));\x0a\x09                        }\x0a\x09                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));\x0a\x09                    }\x0a\x09                    this.expect(\x27;\x27);\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        if (typeof left === \x27undefined\x27) {\x0a\x09            if (!this.match(\x27;\x27)) {\x0a\x09                test = this.parseExpression();\x0a\x09            }\x0a\x09            this.expect(\x27;\x27);\x0a\x09            if (!this.match(\x27)\x27)) {\x0a\x09                update = this.parseExpression();\x0a\x09            }\x0a\x09        }\x0a\x09        var body;\x0a\x09        if (!this.match(\x27)\x27) && this.config.tolerant) {\x0a\x09            this.tolerateUnexpectedToken(this.nextToken());\x0a\x09            body = this.finalize(this.createNode(), new Node.EmptyStatement());\x0a\x09        }\x0a\x09        else {\x0a\x09            this.expect(\x27)\x27);\x0a\x09            var previousInIteration = this.context.inIteration;\x0a\x09            this.context.inIteration = true;\x0a\x09            body = this.isolateCoverGrammar(this.parseStatement);\x0a\x09            this.context.inIteration = previousInIteration;\x0a\x09        }\x0a\x09        return (typeof left === \x27undefined\x27) ?\x0a\x09            this.finalize(node, new Node.ForStatement(init, test, update, body)) :\x0a\x09            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :\x0a\x09                this.finalize(node, new Node.ForOfStatement(left, right, body));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-continue-statement\x0a\x09    Parser.prototype.parseContinueStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27continue\x27);\x0a\x09        var label = null;\x0a\x09        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {\x0a\x09            var id = this.parseVariableIdentifier();\x0a\x09            label = id;\x0a\x09            var key = \x27$\x27 + id.name;\x0a\x09            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\x0a\x09                this.throwError(messages_1.Messages.UnknownLabel, id.name);\x0a\x09            }\x0a\x09        }\x0a\x09        this.consumeSemicolon();\x0a\x09        if (label === null && !this.context.inIteration) {\x0a\x09            this.throwError(messages_1.Messages.IllegalContinue);\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.ContinueStatement(label));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-break-statement\x0a\x09    Parser.prototype.parseBreakStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27break\x27);\x0a\x09        var label = null;\x0a\x09        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {\x0a\x09            var id = this.parseVariableIdentifier();\x0a\x09            var key = \x27$\x27 + id.name;\x0a\x09            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\x0a\x09                this.throwError(messages_1.Messages.UnknownLabel, id.name);\x0a\x09            }\x0a\x09            label = id;\x0a\x09        }\x0a\x09        this.consumeSemicolon();\x0a\x09        if (label === null && !this.context.inIteration && !this.context.inSwitch) {\x0a\x09            this.throwError(messages_1.Messages.IllegalBreak);\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.BreakStatement(label));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-return-statement\x0a\x09    Parser.prototype.parseReturnStatement = function () {\x0a\x09        if (!this.context.inFunctionBody) {\x0a\x09            this.tolerateError(messages_1.Messages.IllegalReturn);\x0a\x09        }\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27return\x27);\x0a\x09        var hasArgument = !this.match(\x27;\x27) && !this.match(\x27}\x27) &&\x0a\x09            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */;\x0a\x09        var argument = hasArgument ? this.parseExpression() : null;\x0a\x09        this.consumeSemicolon();\x0a\x09        return this.finalize(node, new Node.ReturnStatement(argument));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-with-statement\x0a\x09    Parser.prototype.parseWithStatement = function () {\x0a\x09        if (this.context.strict) {\x0a\x09            this.tolerateError(messages_1.Messages.StrictModeWith);\x0a\x09        }\x0a\x09        var node = this.createNode();\x0a\x09        var body;\x0a\x09        this.expectKeyword(\x27with\x27);\x0a\x09        this.expect(\x27(\x27);\x0a\x09        var object = this.parseExpression();\x0a\x09        if (!this.match(\x27)\x27) && this.config.tolerant) {\x0a\x09            this.tolerateUnexpectedToken(this.nextToken());\x0a\x09            body = this.finalize(this.createNode(), new Node.EmptyStatement());\x0a\x09        }\x0a\x09        else {\x0a\x09            this.expect(\x27)\x27);\x0a\x09            body = this.parseStatement();\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.WithStatement(object, body));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-switch-statement\x0a\x09    Parser.prototype.parseSwitchCase = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var test;\x0a\x09        if (this.matchKeyword(\x27default\x27)) {\x0a\x09            this.nextToken();\x0a\x09            test = null;\x0a\x09        }\x0a\x09        else {\x0a\x09            this.expectKeyword(\x27case\x27);\x0a\x09            test = this.parseExpression();\x0a\x09        }\x0a\x09        this.expect(\x27:\x27);\x0a\x09        var consequent = [];\x0a\x09        while (true) {\x0a\x09            if (this.match(\x27}\x27) || this.matchKeyword(\x27default\x27) || this.matchKeyword(\x27case\x27)) {\x0a\x09                break;\x0a\x09            }\x0a\x09            consequent.push(this.parseStatementListItem());\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.SwitchCase(test, consequent));\x0a\x09    };\x0a\x09    Parser.prototype.parseSwitchStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27switch\x27);\x0a\x09        this.expect(\x27(\x27);\x0a\x09        var discriminant = this.parseExpression();\x0a\x09        this.expect(\x27)\x27);\x0a\x09        var previousInSwitch = this.context.inSwitch;\x0a\x09        this.context.inSwitch = true;\x0a\x09        var cases = [];\x0a\x09        var defaultFound = false;\x0a\x09        this.expect(\x27{\x27);\x0a\x09        while (true) {\x0a\x09            if (this.match(\x27}\x27)) {\x0a\x09                break;\x0a\x09            }\x0a\x09            var clause = this.parseSwitchCase();\x0a\x09            if (clause.test === null) {\x0a\x09                if (defaultFound) {\x0a\x09                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);\x0a\x09                }\x0a\x09                defaultFound = true;\x0a\x09            }\x0a\x09            cases.push(clause);\x0a\x09        }\x0a\x09        this.expect(\x27}\x27);\x0a\x09        this.context.inSwitch = previousInSwitch;\x0a\x09        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-labelled-statements\x0a\x09    Parser.prototype.parseLabelledStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var expr = this.parseExpression();\x0a\x09        var statement;\x0a\x09        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(\x27:\x27)) {\x0a\x09            this.nextToken();\x0a\x09            var id = expr;\x0a\x09            var key = \x27$\x27 + id.name;\x0a\x09            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {\x0a\x09                this.throwError(messages_1.Messages.Redeclaration, \x27Label\x27, id.name);\x0a\x09            }\x0a\x09            this.context.labelSet[key] = true;\x0a\x09            var body = void 0;\x0a\x09            if (this.matchKeyword(\x27class\x27)) {\x0a\x09                this.tolerateUnexpectedToken(this.lookahead);\x0a\x09                body = this.parseClassDeclaration();\x0a\x09            }\x0a\x09            else if (this.matchKeyword(\x27function\x27)) {\x0a\x09                var token = this.lookahead;\x0a\x09                var declaration = this.parseFunctionDeclaration();\x0a\x09                if (this.context.strict) {\x0a\x09                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);\x0a\x09                }\x0a\x09                else if (declaration.generator) {\x0a\x09                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);\x0a\x09                }\x0a\x09                body = declaration;\x0a\x09            }\x0a\x09            else {\x0a\x09                body = this.parseStatement();\x0a\x09            }\x0a\x09            delete this.context.labelSet[key];\x0a\x09            statement = new Node.LabeledStatement(id, body);\x0a\x09        }\x0a\x09        else {\x0a\x09            this.consumeSemicolon();\x0a\x09            statement = new Node.ExpressionStatement(expr);\x0a\x09        }\x0a\x09        return this.finalize(node, statement);\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-throw-statement\x0a\x09    Parser.prototype.parseThrowStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27throw\x27);\x0a\x09        if (this.hasLineTerminator) {\x0a\x09            this.throwError(messages_1.Messages.NewlineAfterThrow);\x0a\x09        }\x0a\x09        var argument = this.parseExpression();\x0a\x09        this.consumeSemicolon();\x0a\x09        return this.finalize(node, new Node.ThrowStatement(argument));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-try-statement\x0a\x09    Parser.prototype.parseCatchClause = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27catch\x27);\x0a\x09        this.expect(\x27(\x27);\x0a\x09        if (this.match(\x27)\x27)) {\x0a\x09            this.throwUnexpectedToken(this.lookahead);\x0a\x09        }\x0a\x09        var params = [];\x0a\x09        var param = this.parsePattern(params);\x0a\x09        var paramMap = {};\x0a\x09        for (var i = 0; i \x3c params.length; i++) {\x0a\x09            var key = \x27$\x27 + params[i].value;\x0a\x09            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {\x0a\x09                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);\x0a\x09            }\x0a\x09            paramMap[key] = true;\x0a\x09        }\x0a\x09        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {\x0a\x09            if (this.scanner.isRestrictedWord(param.name)) {\x0a\x09                this.tolerateError(messages_1.Messages.StrictCatchVariable);\x0a\x09            }\x0a\x09        }\x0a\x09        this.expect(\x27)\x27);\x0a\x09        var body = this.parseBlock();\x0a\x09        return this.finalize(node, new Node.CatchClause(param, body));\x0a\x09    };\x0a\x09    Parser.prototype.parseFinallyClause = function () {\x0a\x09        this.expectKeyword(\x27finally\x27);\x0a\x09        return this.parseBlock();\x0a\x09    };\x0a\x09    Parser.prototype.parseTryStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27try\x27);\x0a\x09        var block = this.parseBlock();\x0a\x09        var handler = this.matchKeyword(\x27catch\x27) ? this.parseCatchClause() : null;\x0a\x09        var finalizer = this.matchKeyword(\x27finally\x27) ? this.parseFinallyClause() : null;\x0a\x09        if (!handler && !finalizer) {\x0a\x09            this.throwError(messages_1.Messages.NoCatchOrFinally);\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-debugger-statement\x0a\x09    Parser.prototype.parseDebuggerStatement = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27debugger\x27);\x0a\x09        this.consumeSemicolon();\x0a\x09        return this.finalize(node, new Node.DebuggerStatement());\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations\x0a\x09    Parser.prototype.parseStatement = function () {\x0a\x09        var statement;\x0a\x09        switch (this.lookahead.type) {\x0a\x09            case 1 /* BooleanLiteral */:\x0a\x09            case 5 /* NullLiteral */:\x0a\x09            case 6 /* NumericLiteral */:\x0a\x09            case 8 /* StringLiteral */:\x0a\x09            case 10 /* Template */:\x0a\x09            case 9 /* RegularExpression */:\x0a\x09                statement = this.parseExpressionStatement();\x0a\x09                break;\x0a\x09            case 7 /* Punctuator */:\x0a\x09                var value = this.lookahead.value;\x0a\x09                if (value === \x27{\x27) {\x0a\x09                    statement = this.parseBlock();\x0a\x09                }\x0a\x09                else if (value === \x27(\x27) {\x0a\x09                    statement = this.parseExpressionStatement();\x0a\x09                }\x0a\x09                else if (value === \x27;\x27) {\x0a\x09                    statement = this.parseEmptyStatement();\x0a\x09                }\x0a\x09                else {\x0a\x09                    statement = this.parseExpressionStatement();\x0a\x09                }\x0a\x09                break;\x0a\x09            case 3 /* Identifier */:\x0a\x09                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();\x0a\x09                break;\x0a\x09            case 4 /* Keyword */:\x0a\x09                switch (this.lookahead.value) {\x0a\x09                    case \x27break\x27:\x0a\x09                        statement = this.parseBreakStatement();\x0a\x09                        break;\x0a\x09                    case \x27continue\x27:\x0a\x09                        statement = this.parseContinueStatement();\x0a\x09                        break;\x0a\x09                    case \x27debugger\x27:\x0a\x09                        statement = this.parseDebuggerStatement();\x0a\x09                        break;\x0a\x09                    case \x27do\x27:\x0a\x09                        statement = this.parseDoWhileStatement();\x0a\x09                        break;\x0a\x09                    case \x27for\x27:\x0a\x09                        statement = this.parseForStatement();\x0a\x09                        break;\x0a\x09                    case \x27function\x27:\x0a\x09                        statement = this.parseFunctionDeclaration();\x0a\x09                        break;\x0a\x09                    case \x27if\x27:\x0a\x09                        statement = this.parseIfStatement();\x0a\x09                        break;\x0a\x09                    case \x27return\x27:\x0a\x09                        statement = this.parseReturnStatement();\x0a\x09                        break;\x0a\x09                    case \x27switch\x27:\x0a\x09                        statement = this.parseSwitchStatement();\x0a\x09                        break;\x0a\x09                    case \x27throw\x27:\x0a\x09                        statement = this.parseThrowStatement();\x0a\x09                        break;\x0a\x09                    case \x27try\x27:\x0a\x09                        statement = this.parseTryStatement();\x0a\x09                        break;\x0a\x09                    case \x27var\x27:\x0a\x09                        statement = this.parseVariableStatement();\x0a\x09                        break;\x0a\x09                    case \x27while\x27:\x0a\x09                        statement = this.parseWhileStatement();\x0a\x09                        break;\x0a\x09                    case \x27with\x27:\x0a\x09                        statement = this.parseWithStatement();\x0a\x09                        break;\x0a\x09                    default:\x0a\x09                        statement = this.parseExpressionStatement();\x0a\x09                        break;\x0a\x09                }\x0a\x09                break;\x0a\x09            default:\x0a\x09                statement = this.throwUnexpectedToken(this.lookahead);\x0a\x09        }\x0a\x09        return statement;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-function-definitions\x0a\x09    Parser.prototype.parseFunctionSourceElements = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expect(\x27{\x27);\x0a\x09        var body = this.parseDirectivePrologues();\x0a\x09        var previousLabelSet = this.context.labelSet;\x0a\x09        var previousInIteration = this.context.inIteration;\x0a\x09        var previousInSwitch = this.context.inSwitch;\x0a\x09        var previousInFunctionBody = this.context.inFunctionBody;\x0a\x09        this.context.labelSet = {};\x0a\x09        this.context.inIteration = false;\x0a\x09        this.context.inSwitch = false;\x0a\x09        this.context.inFunctionBody = true;\x0a\x09        while (this.lookahead.type !== 2 /* EOF */) {\x0a\x09            if (this.match(\x27}\x27)) {\x0a\x09                break;\x0a\x09            }\x0a\x09            body.push(this.parseStatementListItem());\x0a\x09        }\x0a\x09        this.expect(\x27}\x27);\x0a\x09        this.context.labelSet = previousLabelSet;\x0a\x09        this.context.inIteration = previousInIteration;\x0a\x09        this.context.inSwitch = previousInSwitch;\x0a\x09        this.context.inFunctionBody = previousInFunctionBody;\x0a\x09        return this.finalize(node, new Node.BlockStatement(body));\x0a\x09    };\x0a\x09    Parser.prototype.validateParam = function (options, param, name) {\x0a\x09        var key = \x27$\x27 + name;\x0a\x09        if (this.context.strict) {\x0a\x09            if (this.scanner.isRestrictedWord(name)) {\x0a\x09                options.stricted = param;\x0a\x09                options.message = messages_1.Messages.StrictParamName;\x0a\x09            }\x0a\x09            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\x0a\x09                options.stricted = param;\x0a\x09                options.message = messages_1.Messages.StrictParamDupe;\x0a\x09            }\x0a\x09        }\x0a\x09        else if (!options.firstRestricted) {\x0a\x09            if (this.scanner.isRestrictedWord(name)) {\x0a\x09                options.firstRestricted = param;\x0a\x09                options.message = messages_1.Messages.StrictParamName;\x0a\x09            }\x0a\x09            else if (this.scanner.isStrictModeReservedWord(name)) {\x0a\x09                options.firstRestricted = param;\x0a\x09                options.message = messages_1.Messages.StrictReservedWord;\x0a\x09            }\x0a\x09            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\x0a\x09                options.stricted = param;\x0a\x09                options.message = messages_1.Messages.StrictParamDupe;\x0a\x09            }\x0a\x09        }\x0a\x09        /* istanbul ignore next */\x0a\x09        if (typeof Object.defineProperty === \x27function\x27) {\x0a\x09            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });\x0a\x09        }\x0a\x09        else {\x0a\x09            options.paramSet[key] = true;\x0a\x09        }\x0a\x09    };\x0a\x09    Parser.prototype.parseRestElement = function (params) {\x0a\x09        var node = this.createNode();\x0a\x09        this.expect(\x27...\x27);\x0a\x09        var arg = this.parsePattern(params);\x0a\x09        if (this.match(\x27=\x27)) {\x0a\x09            this.throwError(messages_1.Messages.DefaultRestParameter);\x0a\x09        }\x0a\x09        if (!this.match(\x27)\x27)) {\x0a\x09            this.throwError(messages_1.Messages.ParameterAfterRestParameter);\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.RestElement(arg));\x0a\x09    };\x0a\x09    Parser.prototype.parseFormalParameter = function (options) {\x0a\x09        var params = [];\x0a\x09        var param = this.match(\x27...\x27) ? this.parseRestElement(params) : this.parsePatternWithDefault(params);\x0a\x09        for (var i = 0; i \x3c params.length; i++) {\x0a\x09            this.validateParam(options, params[i], params[i].value);\x0a\x09        }\x0a\x09        options.simple = options.simple && (param instanceof Node.Identifier);\x0a\x09        options.params.push(param);\x0a\x09    };\x0a\x09    Parser.prototype.parseFormalParameters = function (firstRestricted) {\x0a\x09        var options;\x0a\x09        options = {\x0a\x09            simple: true,\x0a\x09            params: [],\x0a\x09            firstRestricted: firstRestricted\x0a\x09        };\x0a\x09        this.expect(\x27(\x27);\x0a\x09        if (!this.match(\x27)\x27)) {\x0a\x09            options.paramSet = {};\x0a\x09            while (this.lookahead.type !== 2 /* EOF */) {\x0a\x09                this.parseFormalParameter(options);\x0a\x09                if (this.match(\x27)\x27)) {\x0a\x09                    break;\x0a\x09                }\x0a\x09                this.expect(\x27,\x27);\x0a\x09                if (this.match(\x27)\x27)) {\x0a\x09                    break;\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        this.expect(\x27)\x27);\x0a\x09        return {\x0a\x09            simple: options.simple,\x0a\x09            params: options.params,\x0a\x09            stricted: options.stricted,\x0a\x09            firstRestricted: options.firstRestricted,\x0a\x09            message: options.message\x0a\x09        };\x0a\x09    };\x0a\x09    Parser.prototype.matchAsyncFunction = function () {\x0a\x09        var match = this.matchContextualKeyword(\x27async\x27);\x0a\x09        if (match) {\x0a\x09            var state = this.scanner.saveState();\x0a\x09            this.scanner.scanComments();\x0a\x09            var next = this.scanner.lex();\x0a\x09            this.scanner.restoreState(state);\x0a\x09            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === \x27function\x27);\x0a\x09        }\x0a\x09        return match;\x0a\x09    };\x0a\x09    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {\x0a\x09        var node = this.createNode();\x0a\x09        var isAsync = this.matchContextualKeyword(\x27async\x27);\x0a\x09        if (isAsync) {\x0a\x09            this.nextToken();\x0a\x09        }\x0a\x09        this.expectKeyword(\x27function\x27);\x0a\x09        var isGenerator = isAsync ? false : this.match(\x27*\x27);\x0a\x09        if (isGenerator) {\x0a\x09            this.nextToken();\x0a\x09        }\x0a\x09        var message;\x0a\x09        var id = null;\x0a\x09        var firstRestricted = null;\x0a\x09        if (!identifierIsOptional || !this.match(\x27(\x27)) {\x0a\x09            var token = this.lookahead;\x0a\x09            id = this.parseVariableIdentifier();\x0a\x09            if (this.context.strict) {\x0a\x09                if (this.scanner.isRestrictedWord(token.value)) {\x0a\x09                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);\x0a\x09                }\x0a\x09            }\x0a\x09            else {\x0a\x09                if (this.scanner.isRestrictedWord(token.value)) {\x0a\x09                    firstRestricted = token;\x0a\x09                    message = messages_1.Messages.StrictFunctionName;\x0a\x09                }\x0a\x09                else if (this.scanner.isStrictModeReservedWord(token.value)) {\x0a\x09                    firstRestricted = token;\x0a\x09                    message = messages_1.Messages.StrictReservedWord;\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        var previousAllowAwait = this.context.await;\x0a\x09        var previousAllowYield = this.context.allowYield;\x0a\x09        this.context.await = isAsync;\x0a\x09        this.context.allowYield = !isGenerator;\x0a\x09        var formalParameters = this.parseFormalParameters(firstRestricted);\x0a\x09        var params = formalParameters.params;\x0a\x09        var stricted = formalParameters.stricted;\x0a\x09        firstRestricted = formalParameters.firstRestricted;\x0a\x09        if (formalParameters.message) {\x0a\x09            message = formalParameters.message;\x0a\x09        }\x0a\x09        var previousStrict = this.context.strict;\x0a\x09        var previousAllowStrictDirective = this.context.allowStrictDirective;\x0a\x09        this.context.allowStrictDirective = formalParameters.simple;\x0a\x09        var body = this.parseFunctionSourceElements();\x0a\x09        if (this.context.strict && firstRestricted) {\x0a\x09            this.throwUnexpectedToken(firstRestricted, message);\x0a\x09        }\x0a\x09        if (this.context.strict && stricted) {\x0a\x09            this.tolerateUnexpectedToken(stricted, message);\x0a\x09        }\x0a\x09        this.context.strict = previousStrict;\x0a\x09        this.context.allowStrictDirective = previousAllowStrictDirective;\x0a\x09        this.context.await = previousAllowAwait;\x0a\x09        this.context.allowYield = previousAllowYield;\x0a\x09        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :\x0a\x09            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));\x0a\x09    };\x0a\x09    Parser.prototype.parseFunctionExpression = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var isAsync = this.matchContextualKeyword(\x27async\x27);\x0a\x09        if (isAsync) {\x0a\x09            this.nextToken();\x0a\x09        }\x0a\x09        this.expectKeyword(\x27function\x27);\x0a\x09        var isGenerator = isAsync ? false : this.match(\x27*\x27);\x0a\x09        if (isGenerator) {\x0a\x09            this.nextToken();\x0a\x09        }\x0a\x09        var message;\x0a\x09        var id = null;\x0a\x09        var firstRestricted;\x0a\x09        var previousAllowAwait = this.context.await;\x0a\x09        var previousAllowYield = this.context.allowYield;\x0a\x09        this.context.await = isAsync;\x0a\x09        this.context.allowYield = !isGenerator;\x0a\x09        if (!this.match(\x27(\x27)) {\x0a\x09            var token = this.lookahead;\x0a\x09            id = (!this.context.strict && !isGenerator && this.matchKeyword(\x27yield\x27)) ? this.parseIdentifierName() : this.parseVariableIdentifier();\x0a\x09            if (this.context.strict) {\x0a\x09                if (this.scanner.isRestrictedWord(token.value)) {\x0a\x09                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);\x0a\x09                }\x0a\x09            }\x0a\x09            else {\x0a\x09                if (this.scanner.isRestrictedWord(token.value)) {\x0a\x09                    firstRestricted = token;\x0a\x09                    message = messages_1.Messages.StrictFunctionName;\x0a\x09                }\x0a\x09                else if (this.scanner.isStrictModeReservedWord(token.value)) {\x0a\x09                    firstRestricted = token;\x0a\x09                    message = messages_1.Messages.StrictReservedWord;\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        var formalParameters = this.parseFormalParameters(firstRestricted);\x0a\x09        var params = formalParameters.params;\x0a\x09        var stricted = formalParameters.stricted;\x0a\x09        firstRestricted = formalParameters.firstRestricted;\x0a\x09        if (formalParameters.message) {\x0a\x09            message = formalParameters.message;\x0a\x09        }\x0a\x09        var previousStrict = this.context.strict;\x0a\x09        var previousAllowStrictDirective = this.context.allowStrictDirective;\x0a\x09        this.context.allowStrictDirective = formalParameters.simple;\x0a\x09        var body = this.parseFunctionSourceElements();\x0a\x09        if (this.context.strict && firstRestricted) {\x0a\x09            this.throwUnexpectedToken(firstRestricted, message);\x0a\x09        }\x0a\x09        if (this.context.strict && stricted) {\x0a\x09            this.tolerateUnexpectedToken(stricted, message);\x0a\x09        }\x0a\x09        this.context.strict = previousStrict;\x0a\x09        this.context.allowStrictDirective = previousAllowStrictDirective;\x0a\x09        this.context.await = previousAllowAwait;\x0a\x09        this.context.allowYield = previousAllowYield;\x0a\x09        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :\x0a\x09            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive\x0a\x09    Parser.prototype.parseDirective = function () {\x0a\x09        var token = this.lookahead;\x0a\x09        var node = this.createNode();\x0a\x09        var expr = this.parseExpression();\x0a\x09        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;\x0a\x09        this.consumeSemicolon();\x0a\x09        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));\x0a\x09    };\x0a\x09    Parser.prototype.parseDirectivePrologues = function () {\x0a\x09        var firstRestricted = null;\x0a\x09        var body = [];\x0a\x09        while (true) {\x0a\x09            var token = this.lookahead;\x0a\x09            if (token.type !== 8 /* StringLiteral */) {\x0a\x09                break;\x0a\x09            }\x0a\x09            var statement = this.parseDirective();\x0a\x09            body.push(statement);\x0a\x09            var directive = statement.directive;\x0a\x09            if (typeof directive !== \x27string\x27) {\x0a\x09                break;\x0a\x09            }\x0a\x09            if (directive === \x27use strict\x27) {\x0a\x09                this.context.strict = true;\x0a\x09                if (firstRestricted) {\x0a\x09                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);\x0a\x09                }\x0a\x09                if (!this.context.allowStrictDirective) {\x0a\x09                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);\x0a\x09                }\x0a\x09            }\x0a\x09            else {\x0a\x09                if (!firstRestricted && token.octal) {\x0a\x09                    firstRestricted = token;\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        return body;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-method-definitions\x0a\x09    Parser.prototype.qualifiedPropertyName = function (token) {\x0a\x09        switch (token.type) {\x0a\x09            case 3 /* Identifier */:\x0a\x09            case 8 /* StringLiteral */:\x0a\x09            case 1 /* BooleanLiteral */:\x0a\x09            case 5 /* NullLiteral */:\x0a\x09            case 6 /* NumericLiteral */:\x0a\x09            case 4 /* Keyword */:\x0a\x09                return true;\x0a\x09            case 7 /* Punctuator */:\x0a\x09                return token.value === \x27[\x27;\x0a\x09            default:\x0a\x09                break;\x0a\x09        }\x0a\x09        return false;\x0a\x09    };\x0a\x09    Parser.prototype.parseGetterMethod = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var isGenerator = false;\x0a\x09        var previousAllowYield = this.context.allowYield;\x0a\x09        this.context.allowYield = false;\x0a\x09        var formalParameters = this.parseFormalParameters();\x0a\x09        if (formalParameters.params.length \x3e 0) {\x0a\x09            this.tolerateError(messages_1.Messages.BadGetterArity);\x0a\x09        }\x0a\x09        var method = this.parsePropertyMethod(formalParameters);\x0a\x09        this.context.allowYield = previousAllowYield;\x0a\x09        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));\x0a\x09    };\x0a\x09    Parser.prototype.parseSetterMethod = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var isGenerator = false;\x0a\x09        var previousAllowYield = this.context.allowYield;\x0a\x09        this.context.allowYield = false;\x0a\x09        var formalParameters = this.parseFormalParameters();\x0a\x09        if (formalParameters.params.length !== 1) {\x0a\x09            this.tolerateError(messages_1.Messages.BadSetterArity);\x0a\x09        }\x0a\x09        else if (formalParameters.params[0] instanceof Node.RestElement) {\x0a\x09            this.tolerateError(messages_1.Messages.BadSetterRestParameter);\x0a\x09        }\x0a\x09        var method = this.parsePropertyMethod(formalParameters);\x0a\x09        this.context.allowYield = previousAllowYield;\x0a\x09        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));\x0a\x09    };\x0a\x09    Parser.prototype.parseGeneratorMethod = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var isGenerator = true;\x0a\x09        var previousAllowYield = this.context.allowYield;\x0a\x09        this.context.allowYield = true;\x0a\x09        var params = this.parseFormalParameters();\x0a\x09        this.context.allowYield = false;\x0a\x09        var method = this.parsePropertyMethod(params);\x0a\x09        this.context.allowYield = previousAllowYield;\x0a\x09        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-generator-function-definitions\x0a\x09    Parser.prototype.isStartOfExpression = function () {\x0a\x09        var start = true;\x0a\x09        var value = this.lookahead.value;\x0a\x09        switch (this.lookahead.type) {\x0a\x09            case 7 /* Punctuator */:\x0a\x09                start = (value === \x27[\x27) || (value === \x27(\x27) || (value === \x27{\x27) ||\x0a\x09                    (value === \x27+\x27) || (value === \x27-\x27) ||\x0a\x09                    (value === \x27!\x27) || (value === \x27~\x27) ||\x0a\x09                    (value === \x27++\x27) || (value === \x27--\x27) ||\x0a\x09                    (value === \x27/\x27) || (value === \x27/=\x27); // regular expression literal\x0a\x09                break;\x0a\x09            case 4 /* Keyword */:\x0a\x09                start = (value === \x27class\x27) || (value === \x27delete\x27) ||\x0a\x09                    (value === \x27function\x27) || (value === \x27let\x27) || (value === \x27new\x27) ||\x0a\x09                    (value === \x27super\x27) || (value === \x27this\x27) || (value === \x27typeof\x27) ||\x0a\x09                    (value === \x27void\x27) || (value === \x27yield\x27);\x0a\x09                break;\x0a\x09            default:\x0a\x09                break;\x0a\x09        }\x0a\x09        return start;\x0a\x09    };\x0a\x09    Parser.prototype.parseYieldExpression = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27yield\x27);\x0a\x09        var argument = null;\x0a\x09        var delegate = false;\x0a\x09        if (!this.hasLineTerminator) {\x0a\x09            var previousAllowYield = this.context.allowYield;\x0a\x09            this.context.allowYield = false;\x0a\x09            delegate = this.match(\x27*\x27);\x0a\x09            if (delegate) {\x0a\x09                this.nextToken();\x0a\x09                argument = this.parseAssignmentExpression();\x0a\x09            }\x0a\x09            else if (this.isStartOfExpression()) {\x0a\x09                argument = this.parseAssignmentExpression();\x0a\x09            }\x0a\x09            this.context.allowYield = previousAllowYield;\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.YieldExpression(argument, delegate));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-class-definitions\x0a\x09    Parser.prototype.parseClassElement = function (hasConstructor) {\x0a\x09        var token = this.lookahead;\x0a\x09        var node = this.createNode();\x0a\x09        var kind = \x27\x27;\x0a\x09        var key = null;\x0a\x09        var value = null;\x0a\x09        var computed = false;\x0a\x09        var method = false;\x0a\x09        var isStatic = false;\x0a\x09        var isAsync = false;\x0a\x09        if (this.match(\x27*\x27)) {\x0a\x09            this.nextToken();\x0a\x09        }\x0a\x09        else {\x0a\x09            computed = this.match(\x27[\x27);\x0a\x09            key = this.parseObjectPropertyKey();\x0a\x09            var id = key;\x0a\x09            if (id.name === \x27static\x27 && (this.qualifiedPropertyName(this.lookahead) || this.match(\x27*\x27))) {\x0a\x09                token = this.lookahead;\x0a\x09                isStatic = true;\x0a\x09                computed = this.match(\x27[\x27);\x0a\x09                if (this.match(\x27*\x27)) {\x0a\x09                    this.nextToken();\x0a\x09                }\x0a\x09                else {\x0a\x09                    key = this.parseObjectPropertyKey();\x0a\x09                }\x0a\x09            }\x0a\x09            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === \x27async\x27)) {\x0a\x09                var punctuator = this.lookahead.value;\x0a\x09                if (punctuator !== \x27:\x27 && punctuator !== \x27(\x27 && punctuator !== \x27*\x27) {\x0a\x09                    isAsync = true;\x0a\x09                    token = this.lookahead;\x0a\x09                    key = this.parseObjectPropertyKey();\x0a\x09                    if (token.type === 3 /* Identifier */) {\x0a\x09                        if (token.value === \x27get\x27 || token.value === \x27set\x27) {\x0a\x09                            this.tolerateUnexpectedToken(token);\x0a\x09                        }\x0a\x09                        else if (token.value === \x27constructor\x27) {\x0a\x09                            this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);\x0a\x09                        }\x0a\x09                    }\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);\x0a\x09        if (token.type === 3 /* Identifier */) {\x0a\x09            if (token.value === \x27get\x27 && lookaheadPropertyKey) {\x0a\x09                kind = \x27get\x27;\x0a\x09                computed = this.match(\x27[\x27);\x0a\x09                key = this.parseObjectPropertyKey();\x0a\x09                this.context.allowYield = false;\x0a\x09                value = this.parseGetterMethod();\x0a\x09            }\x0a\x09            else if (token.value === \x27set\x27 && lookaheadPropertyKey) {\x0a\x09                kind = \x27set\x27;\x0a\x09                computed = this.match(\x27[\x27);\x0a\x09                key = this.parseObjectPropertyKey();\x0a\x09                value = this.parseSetterMethod();\x0a\x09            }\x0a\x09        }\x0a\x09        else if (token.type === 7 /* Punctuator */ && token.value === \x27*\x27 && lookaheadPropertyKey) {\x0a\x09            kind = \x27init\x27;\x0a\x09            computed = this.match(\x27[\x27);\x0a\x09            key = this.parseObjectPropertyKey();\x0a\x09            value = this.parseGeneratorMethod();\x0a\x09            method = true;\x0a\x09        }\x0a\x09        if (!kind && key && this.match(\x27(\x27)) {\x0a\x09            kind = \x27init\x27;\x0a\x09            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();\x0a\x09            method = true;\x0a\x09        }\x0a\x09        if (!kind) {\x0a\x09            this.throwUnexpectedToken(this.lookahead);\x0a\x09        }\x0a\x09        if (kind === \x27init\x27) {\x0a\x09            kind = \x27method\x27;\x0a\x09        }\x0a\x09        if (!computed) {\x0a\x09            if (isStatic && this.isPropertyKey(key, \x27prototype\x27)) {\x0a\x09                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);\x0a\x09            }\x0a\x09            if (!isStatic && this.isPropertyKey(key, \x27constructor\x27)) {\x0a\x09                if (kind !== \x27method\x27 || !method || (value && value.generator)) {\x0a\x09                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);\x0a\x09                }\x0a\x09                if (hasConstructor.value) {\x0a\x09                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);\x0a\x09                }\x0a\x09                else {\x0a\x09                    hasConstructor.value = true;\x0a\x09                }\x0a\x09                kind = \x27constructor\x27;\x0a\x09            }\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));\x0a\x09    };\x0a\x09    Parser.prototype.parseClassElementList = function () {\x0a\x09        var body = [];\x0a\x09        var hasConstructor = { value: false };\x0a\x09        this.expect(\x27{\x27);\x0a\x09        while (!this.match(\x27}\x27)) {\x0a\x09            if (this.match(\x27;\x27)) {\x0a\x09                this.nextToken();\x0a\x09            }\x0a\x09            else {\x0a\x09                body.push(this.parseClassElement(hasConstructor));\x0a\x09            }\x0a\x09        }\x0a\x09        this.expect(\x27}\x27);\x0a\x09        return body;\x0a\x09    };\x0a\x09    Parser.prototype.parseClassBody = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var elementList = this.parseClassElementList();\x0a\x09        return this.finalize(node, new Node.ClassBody(elementList));\x0a\x09    };\x0a\x09    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {\x0a\x09        var node = this.createNode();\x0a\x09        var previousStrict = this.context.strict;\x0a\x09        this.context.strict = true;\x0a\x09        this.expectKeyword(\x27class\x27);\x0a\x09        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();\x0a\x09        var superClass = null;\x0a\x09        if (this.matchKeyword(\x27extends\x27)) {\x0a\x09            this.nextToken();\x0a\x09            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\x0a\x09        }\x0a\x09        var classBody = this.parseClassBody();\x0a\x09        this.context.strict = previousStrict;\x0a\x09        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));\x0a\x09    };\x0a\x09    Parser.prototype.parseClassExpression = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var previousStrict = this.context.strict;\x0a\x09        this.context.strict = true;\x0a\x09        this.expectKeyword(\x27class\x27);\x0a\x09        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;\x0a\x09        var superClass = null;\x0a\x09        if (this.matchKeyword(\x27extends\x27)) {\x0a\x09            this.nextToken();\x0a\x09            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);\x0a\x09        }\x0a\x09        var classBody = this.parseClassBody();\x0a\x09        this.context.strict = previousStrict;\x0a\x09        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-scripts\x0a\x09    // https://tc39.github.io/ecma262/#sec-modules\x0a\x09    Parser.prototype.parseModule = function () {\x0a\x09        this.context.strict = true;\x0a\x09        this.context.isModule = true;\x0a\x09        var node = this.createNode();\x0a\x09        var body = this.parseDirectivePrologues();\x0a\x09        while (this.lookahead.type !== 2 /* EOF */) {\x0a\x09            body.push(this.parseStatementListItem());\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.Module(body));\x0a\x09    };\x0a\x09    Parser.prototype.parseScript = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var body = this.parseDirectivePrologues();\x0a\x09        while (this.lookahead.type !== 2 /* EOF */) {\x0a\x09            body.push(this.parseStatementListItem());\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.Script(body));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-imports\x0a\x09    Parser.prototype.parseModuleSpecifier = function () {\x0a\x09        var node = this.createNode();\x0a\x09        if (this.lookahead.type !== 8 /* StringLiteral */) {\x0a\x09            this.throwError(messages_1.Messages.InvalidModuleSpecifier);\x0a\x09        }\x0a\x09        var token = this.nextToken();\x0a\x09        var raw = this.getTokenRaw(token);\x0a\x09        return this.finalize(node, new Node.Literal(token.value, raw));\x0a\x09    };\x0a\x09    // import {\x3cfoo as bar\x3e} ...;\x0a\x09    Parser.prototype.parseImportSpecifier = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var imported;\x0a\x09        var local;\x0a\x09        if (this.lookahead.type === 3 /* Identifier */) {\x0a\x09            imported = this.parseVariableIdentifier();\x0a\x09            local = imported;\x0a\x09            if (this.matchContextualKeyword(\x27as\x27)) {\x0a\x09                this.nextToken();\x0a\x09                local = this.parseVariableIdentifier();\x0a\x09            }\x0a\x09        }\x0a\x09        else {\x0a\x09            imported = this.parseIdentifierName();\x0a\x09            local = imported;\x0a\x09            if (this.matchContextualKeyword(\x27as\x27)) {\x0a\x09                this.nextToken();\x0a\x09                local = this.parseVariableIdentifier();\x0a\x09            }\x0a\x09            else {\x0a\x09                this.throwUnexpectedToken(this.nextToken());\x0a\x09            }\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.ImportSpecifier(local, imported));\x0a\x09    };\x0a\x09    // {foo, bar as bas}\x0a\x09    Parser.prototype.parseNamedImports = function () {\x0a\x09        this.expect(\x27{\x27);\x0a\x09        var specifiers = [];\x0a\x09        while (!this.match(\x27}\x27)) {\x0a\x09            specifiers.push(this.parseImportSpecifier());\x0a\x09            if (!this.match(\x27}\x27)) {\x0a\x09                this.expect(\x27,\x27);\x0a\x09            }\x0a\x09        }\x0a\x09        this.expect(\x27}\x27);\x0a\x09        return specifiers;\x0a\x09    };\x0a\x09    // import \x3cfoo\x3e ...;\x0a\x09    Parser.prototype.parseImportDefaultSpecifier = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var local = this.parseIdentifierName();\x0a\x09        return this.finalize(node, new Node.ImportDefaultSpecifier(local));\x0a\x09    };\x0a\x09    // import \x3c* as foo\x3e ...;\x0a\x09    Parser.prototype.parseImportNamespaceSpecifier = function () {\x0a\x09        var node = this.createNode();\x0a\x09        this.expect(\x27*\x27);\x0a\x09        if (!this.matchContextualKeyword(\x27as\x27)) {\x0a\x09            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);\x0a\x09        }\x0a\x09        this.nextToken();\x0a\x09        var local = this.parseIdentifierName();\x0a\x09        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));\x0a\x09    };\x0a\x09    Parser.prototype.parseImportDeclaration = function () {\x0a\x09        if (this.context.inFunctionBody) {\x0a\x09            this.throwError(messages_1.Messages.IllegalImportDeclaration);\x0a\x09        }\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27import\x27);\x0a\x09        var src;\x0a\x09        var specifiers = [];\x0a\x09        if (this.lookahead.type === 8 /* StringLiteral */) {\x0a\x09            // import \x27foo\x27;\x0a\x09            src = this.parseModuleSpecifier();\x0a\x09        }\x0a\x09        else {\x0a\x09            if (this.match(\x27{\x27)) {\x0a\x09                // import {bar}\x0a\x09                specifiers = specifiers.concat(this.parseNamedImports());\x0a\x09            }\x0a\x09            else if (this.match(\x27*\x27)) {\x0a\x09                // import * as foo\x0a\x09                specifiers.push(this.parseImportNamespaceSpecifier());\x0a\x09            }\x0a\x09            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword(\x27default\x27)) {\x0a\x09                // import foo\x0a\x09                specifiers.push(this.parseImportDefaultSpecifier());\x0a\x09                if (this.match(\x27,\x27)) {\x0a\x09                    this.nextToken();\x0a\x09                    if (this.match(\x27*\x27)) {\x0a\x09                        // import foo, * as foo\x0a\x09                        specifiers.push(this.parseImportNamespaceSpecifier());\x0a\x09                    }\x0a\x09                    else if (this.match(\x27{\x27)) {\x0a\x09                        // import foo, {bar}\x0a\x09                        specifiers = specifiers.concat(this.parseNamedImports());\x0a\x09                    }\x0a\x09                    else {\x0a\x09                        this.throwUnexpectedToken(this.lookahead);\x0a\x09                    }\x0a\x09                }\x0a\x09            }\x0a\x09            else {\x0a\x09                this.throwUnexpectedToken(this.nextToken());\x0a\x09            }\x0a\x09            if (!this.matchContextualKeyword(\x27from\x27)) {\x0a\x09                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;\x0a\x09                this.throwError(message, this.lookahead.value);\x0a\x09            }\x0a\x09            this.nextToken();\x0a\x09            src = this.parseModuleSpecifier();\x0a\x09        }\x0a\x09        this.consumeSemicolon();\x0a\x09        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-exports\x0a\x09    Parser.prototype.parseExportSpecifier = function () {\x0a\x09        var node = this.createNode();\x0a\x09        var local = this.parseIdentifierName();\x0a\x09        var exported = local;\x0a\x09        if (this.matchContextualKeyword(\x27as\x27)) {\x0a\x09            this.nextToken();\x0a\x09            exported = this.parseIdentifierName();\x0a\x09        }\x0a\x09        return this.finalize(node, new Node.ExportSpecifier(local, exported));\x0a\x09    };\x0a\x09    Parser.prototype.parseExportDeclaration = function () {\x0a\x09        if (this.context.inFunctionBody) {\x0a\x09            this.throwError(messages_1.Messages.IllegalExportDeclaration);\x0a\x09        }\x0a\x09        var node = this.createNode();\x0a\x09        this.expectKeyword(\x27export\x27);\x0a\x09        var exportDeclaration;\x0a\x09        if (this.matchKeyword(\x27default\x27)) {\x0a\x09            // export default ...\x0a\x09            this.nextToken();\x0a\x09            if (this.matchKeyword(\x27function\x27)) {\x0a\x09                // export default function foo () {}\x0a\x09                // export default function () {}\x0a\x09                var declaration = this.parseFunctionDeclaration(true);\x0a\x09                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\x0a\x09            }\x0a\x09            else if (this.matchKeyword(\x27class\x27)) {\x0a\x09                // export default class foo {}\x0a\x09                var declaration = this.parseClassDeclaration(true);\x0a\x09                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\x0a\x09            }\x0a\x09            else if (this.matchContextualKeyword(\x27async\x27)) {\x0a\x09                // export default async function f () {}\x0a\x09                // export default async function () {}\x0a\x09                // export default async x =\x3e x\x0a\x09                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();\x0a\x09                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\x0a\x09            }\x0a\x09            else {\x0a\x09                if (this.matchContextualKeyword(\x27from\x27)) {\x0a\x09                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);\x0a\x09                }\x0a\x09                // export default {};\x0a\x09                // export default [];\x0a\x09                // export default (1 + 2);\x0a\x09                var declaration = this.match(\x27{\x27) ? this.parseObjectInitializer() :\x0a\x09                    this.match(\x27[\x27) ? this.parseArrayInitializer() : this.parseAssignmentExpression();\x0a\x09                this.consumeSemicolon();\x0a\x09                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));\x0a\x09            }\x0a\x09        }\x0a\x09        else if (this.match(\x27*\x27)) {\x0a\x09            // export * from \x27foo\x27;\x0a\x09            this.nextToken();\x0a\x09            if (!this.matchContextualKeyword(\x27from\x27)) {\x0a\x09                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;\x0a\x09                this.throwError(message, this.lookahead.value);\x0a\x09            }\x0a\x09            this.nextToken();\x0a\x09            var src = this.parseModuleSpecifier();\x0a\x09            this.consumeSemicolon();\x0a\x09            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));\x0a\x09        }\x0a\x09        else if (this.lookahead.type === 4 /* Keyword */) {\x0a\x09            // export var f = 1;\x0a\x09            var declaration = void 0;\x0a\x09            switch (this.lookahead.value) {\x0a\x09                case \x27let\x27:\x0a\x09                case \x27const\x27:\x0a\x09                    declaration = this.parseLexicalDeclaration({ inFor: false });\x0a\x09                    break;\x0a\x09                case \x27var\x27:\x0a\x09                case \x27class\x27:\x0a\x09                case \x27function\x27:\x0a\x09                    declaration = this.parseStatementListItem();\x0a\x09                    break;\x0a\x09                default:\x0a\x09                    this.throwUnexpectedToken(this.lookahead);\x0a\x09            }\x0a\x09            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));\x0a\x09        }\x0a\x09        else if (this.matchAsyncFunction()) {\x0a\x09            var declaration = this.parseFunctionDeclaration();\x0a\x09            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));\x0a\x09        }\x0a\x09        else {\x0a\x09            var specifiers = [];\x0a\x09            var source = null;\x0a\x09            var isExportFromIdentifier = false;\x0a\x09            this.expect(\x27{\x27);\x0a\x09            while (!this.match(\x27}\x27)) {\x0a\x09                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword(\x27default\x27);\x0a\x09                specifiers.push(this.parseExportSpecifier());\x0a\x09                if (!this.match(\x27}\x27)) {\x0a\x09                    this.expect(\x27,\x27);\x0a\x09                }\x0a\x09            }\x0a\x09            this.expect(\x27}\x27);\x0a\x09            if (this.matchContextualKeyword(\x27from\x27)) {\x0a\x09                // export {default} from \x27foo\x27;\x0a\x09                // export {foo} from \x27foo\x27;\x0a\x09                this.nextToken();\x0a\x09                source = this.parseModuleSpecifier();\x0a\x09                this.consumeSemicolon();\x0a\x09            }\x0a\x09            else if (isExportFromIdentifier) {\x0a\x09                // export {default}; // missing fromClause\x0a\x09                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;\x0a\x09                this.throwError(message, this.lookahead.value);\x0a\x09            }\x0a\x09            else {\x0a\x09                // export {foo};\x0a\x09                this.consumeSemicolon();\x0a\x09            }\x0a\x09            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));\x0a\x09        }\x0a\x09        return exportDeclaration;\x0a\x09    };\x0a\x09    return Parser;\x0a\x09}());\x0a\x09exports.Parser = Parser;\x0a\x0a\x0a/***/ },\x0a/* 9 */\x0a/***/ function(module, exports) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09// Ensure the condition is true, otherwise throw an error.\x0a\x09// This is only to have a better contract semantic, i.e. another safety net\x0a\x09// to catch a logic error. The condition shall be fulfilled in normal case.\x0a\x09// Do NOT use this to enforce a certain condition on any user input.\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09function assert(condition, message) {\x0a\x09    /* istanbul ignore if */\x0a\x09    if (!condition) {\x0a\x09        throw new Error(\x27ASSERT: \x27 + message);\x0a\x09    }\x0a\x09}\x0a\x09exports.assert = assert;\x0a\x0a\x0a/***/ },\x0a/* 10 */\x0a/***/ function(module, exports) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09/* tslint:disable:max-classes-per-file */\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09var ErrorHandler = (function () {\x0a\x09    function ErrorHandler() {\x0a\x09        this.errors = [];\x0a\x09        this.tolerant = false;\x0a\x09    }\x0a\x09    ErrorHandler.prototype.recordError = function (error) {\x0a\x09        this.errors.push(error);\x0a\x09    };\x0a\x09    ErrorHandler.prototype.tolerate = function (error) {\x0a\x09        if (this.tolerant) {\x0a\x09            this.recordError(error);\x0a\x09        }\x0a\x09        else {\x0a\x09            throw error;\x0a\x09        }\x0a\x09    };\x0a\x09    ErrorHandler.prototype.constructError = function (msg, column) {\x0a\x09        var error = new Error(msg);\x0a\x09        try {\x0a\x09            throw error;\x0a\x09        }\x0a\x09        catch (base) {\x0a\x09            /* istanbul ignore else */\x0a\x09            if (Object.create && Object.defineProperty) {\x0a\x09                error = Object.create(base);\x0a\x09                Object.defineProperty(error, \x27column\x27, { value: column });\x0a\x09            }\x0a\x09        }\x0a\x09        /* istanbul ignore next */\x0a\x09        return error;\x0a\x09    };\x0a\x09    ErrorHandler.prototype.createError = function (index, line, col, description) {\x0a\x09        var msg = \x27Line \x27 + line + \x27: \x27 + description;\x0a\x09        var error = this.constructError(msg, col);\x0a\x09        error.index = index;\x0a\x09        error.lineNumber = line;\x0a\x09        error.description = description;\x0a\x09        return error;\x0a\x09    };\x0a\x09    ErrorHandler.prototype.throwError = function (index, line, col, description) {\x0a\x09        throw this.createError(index, line, col, description);\x0a\x09    };\x0a\x09    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {\x0a\x09        var error = this.createError(index, line, col, description);\x0a\x09        if (this.tolerant) {\x0a\x09            this.recordError(error);\x0a\x09        }\x0a\x09        else {\x0a\x09            throw error;\x0a\x09        }\x0a\x09    };\x0a\x09    return ErrorHandler;\x0a\x09}());\x0a\x09exports.ErrorHandler = ErrorHandler;\x0a\x0a\x0a/***/ },\x0a/* 11 */\x0a/***/ function(module, exports) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09// Error messages should be identical to V8.\x0a\x09exports.Messages = {\x0a\x09    BadGetterArity: \x27Getter must not have any formal parameters\x27,\x0a\x09    BadSetterArity: \x27Setter must have exactly one formal parameter\x27,\x0a\x09    BadSetterRestParameter: \x27Setter function argument must not be a rest parameter\x27,\x0a\x09    ConstructorIsAsync: \x27Class constructor may not be an async method\x27,\x0a\x09    ConstructorSpecialMethod: \x27Class constructor may not be an accessor\x27,\x0a\x09    DeclarationMissingInitializer: \x27Missing initializer in %0 declaration\x27,\x0a\x09    DefaultRestParameter: \x27Unexpected token =\x27,\x0a\x09    DuplicateBinding: \x27Duplicate binding %0\x27,\x0a\x09    DuplicateConstructor: \x27A class may only have one constructor\x27,\x0a\x09    DuplicateProtoProperty: \x27Duplicate __proto__ fields are not allowed in object literals\x27,\x0a\x09    ForInOfLoopInitializer: \x27%0 loop variable declaration may not have an initializer\x27,\x0a\x09    GeneratorInLegacyContext: \x27Generator declarations are not allowed in legacy contexts\x27,\x0a\x09    IllegalBreak: \x27Illegal break statement\x27,\x0a\x09    IllegalContinue: \x27Illegal continue statement\x27,\x0a\x09    IllegalExportDeclaration: \x27Unexpected token\x27,\x0a\x09    IllegalImportDeclaration: \x27Unexpected token\x27,\x0a\x09    IllegalLanguageModeDirective: \x27Illegal \x5c\x27use strict\x5c\x27 directive in function with non-simple parameter list\x27,\x0a\x09    IllegalReturn: \x27Illegal return statement\x27,\x0a\x09    InvalidEscapedReservedWord: \x27Keyword must not contain escaped characters\x27,\x0a\x09    InvalidHexEscapeSequence: \x27Invalid hexadecimal escape sequence\x27,\x0a\x09    InvalidLHSInAssignment: \x27Invalid left-hand side in assignment\x27,\x0a\x09    InvalidLHSInForIn: \x27Invalid left-hand side in for-in\x27,\x0a\x09    InvalidLHSInForLoop: \x27Invalid left-hand side in for-loop\x27,\x0a\x09    InvalidModuleSpecifier: \x27Unexpected token\x27,\x0a\x09    InvalidRegExp: \x27Invalid regular expression\x27,\x0a\x09    LetInLexicalBinding: \x27let is disallowed as a lexically bound name\x27,\x0a\x09    MissingFromClause: \x27Unexpected token\x27,\x0a\x09    MultipleDefaultsInSwitch: \x27More than one default clause in switch statement\x27,\x0a\x09    NewlineAfterThrow: \x27Illegal newline after throw\x27,\x0a\x09    NoAsAfterImportNamespace: \x27Unexpected token\x27,\x0a\x09    NoCatchOrFinally: \x27Missing catch or finally after try\x27,\x0a\x09    ParameterAfterRestParameter: \x27Rest parameter must be last formal parameter\x27,\x0a\x09    Redeclaration: \x27%0 \x5c\x27%1\x5c\x27 has already been declared\x27,\x0a\x09    StaticPrototype: \x27Classes may not have static property named prototype\x27,\x0a\x09    StrictCatchVariable: \x27Catch variable may not be eval or arguments in strict mode\x27,\x0a\x09    StrictDelete: \x27Delete of an unqualified identifier in strict mode.\x27,\x0a\x09    StrictFunction: \x27In strict mode code, functions can only be declared at top level or inside a block\x27,\x0a\x09    StrictFunctionName: \x27Function name may not be eval or arguments in strict mode\x27,\x0a\x09    StrictLHSAssignment: \x27Assignment to eval or arguments is not allowed in strict mode\x27,\x0a\x09    StrictLHSPostfix: \x27Postfix increment/decrement may not have eval or arguments operand in strict mode\x27,\x0a\x09    StrictLHSPrefix: \x27Prefix increment/decrement may not have eval or arguments operand in strict mode\x27,\x0a\x09    StrictModeWith: \x27Strict mode code may not include a with statement\x27,\x0a\x09    StrictOctalLiteral: \x27Octal literals are not allowed in strict mode.\x27,\x0a\x09    StrictParamDupe: \x27Strict mode function may not have duplicate parameter names\x27,\x0a\x09    StrictParamName: \x27Parameter name eval or arguments is not allowed in strict mode\x27,\x0a\x09    StrictReservedWord: \x27Use of future reserved word in strict mode\x27,\x0a\x09    StrictVarName: \x27Variable name may not be eval or arguments in strict mode\x27,\x0a\x09    TemplateOctalLiteral: \x27Octal literals are not allowed in template strings.\x27,\x0a\x09    UnexpectedEOS: \x27Unexpected end of input\x27,\x0a\x09    UnexpectedIdentifier: \x27Unexpected identifier\x27,\x0a\x09    UnexpectedNumber: \x27Unexpected number\x27,\x0a\x09    UnexpectedReserved: \x27Unexpected reserved word\x27,\x0a\x09    UnexpectedString: \x27Unexpected string\x27,\x0a\x09    UnexpectedTemplate: \x27Unexpected quasi %0\x27,\x0a\x09    UnexpectedToken: \x27Unexpected token %0\x27,\x0a\x09    UnexpectedTokenIllegal: \x27Unexpected token ILLEGAL\x27,\x0a\x09    UnknownLabel: \x27Undefined label \x5c\x27%0\x5c\x27\x27,\x0a\x09    UnterminatedRegExp: \x27Invalid regular expression: missing /\x27\x0a\x09};\x0a\x0a\x0a/***/ },\x0a/* 12 */\x0a/***/ function(module, exports, __webpack_require__) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09var assert_1 = __webpack_require__(9);\x0a\x09var character_1 = __webpack_require__(4);\x0a\x09var messages_1 = __webpack_require__(11);\x0a\x09function hexValue(ch) {\x0a\x09    return \x270123456789abcdef\x27.indexOf(ch.toLowerCase());\x0a\x09}\x0a\x09function octalValue(ch) {\x0a\x09    return \x2701234567\x27.indexOf(ch);\x0a\x09}\x0a\x09var Scanner = (function () {\x0a\x09    function Scanner(code, handler) {\x0a\x09        this.source = code;\x0a\x09        this.errorHandler = handler;\x0a\x09        this.trackComment = false;\x0a\x09        this.length = code.length;\x0a\x09        this.index = 0;\x0a\x09        this.lineNumber = (code.length \x3e 0) ? 1 : 0;\x0a\x09        this.lineStart = 0;\x0a\x09        this.curlyStack = [];\x0a\x09    }\x0a\x09    Scanner.prototype.saveState = function () {\x0a\x09        return {\x0a\x09            index: this.index,\x0a\x09            lineNumber: this.lineNumber,\x0a\x09            lineStart: this.lineStart\x0a\x09        };\x0a\x09    };\x0a\x09    Scanner.prototype.restoreState = function (state) {\x0a\x09        this.index = state.index;\x0a\x09        this.lineNumber = state.lineNumber;\x0a\x09        this.lineStart = state.lineStart;\x0a\x09    };\x0a\x09    Scanner.prototype.eof = function () {\x0a\x09        return this.index \x3e= this.length;\x0a\x09    };\x0a\x09    Scanner.prototype.throwUnexpectedToken = function (message) {\x0a\x09        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }\x0a\x09        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);\x0a\x09    };\x0a\x09    Scanner.prototype.tolerateUnexpectedToken = function (message) {\x0a\x09        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }\x0a\x09        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-comments\x0a\x09    Scanner.prototype.skipSingleLineComment = function (offset) {\x0a\x09        var comments = [];\x0a\x09        var start, loc;\x0a\x09        if (this.trackComment) {\x0a\x09            comments = [];\x0a\x09            start = this.index - offset;\x0a\x09            loc = {\x0a\x09                start: {\x0a\x09                    line: this.lineNumber,\x0a\x09                    column: this.index - this.lineStart - offset\x0a\x09                },\x0a\x09                end: {}\x0a\x09            };\x0a\x09        }\x0a\x09        while (!this.eof()) {\x0a\x09            var ch = this.source.charCodeAt(this.index);\x0a\x09            ++this.index;\x0a\x09            if (character_1.Character.isLineTerminator(ch)) {\x0a\x09                if (this.trackComment) {\x0a\x09                    loc.end = {\x0a\x09                        line: this.lineNumber,\x0a\x09                        column: this.index - this.lineStart - 1\x0a\x09                    };\x0a\x09                    var entry = {\x0a\x09                        multiLine: false,\x0a\x09                        slice: [start + offset, this.index - 1],\x0a\x09                        range: [start, this.index - 1],\x0a\x09                        loc: loc\x0a\x09                    };\x0a\x09                    comments.push(entry);\x0a\x09                }\x0a\x09                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {\x0a\x09                    ++this.index;\x0a\x09                }\x0a\x09                ++this.lineNumber;\x0a\x09                this.lineStart = this.index;\x0a\x09                return comments;\x0a\x09            }\x0a\x09        }\x0a\x09        if (this.trackComment) {\x0a\x09            loc.end = {\x0a\x09                line: this.lineNumber,\x0a\x09                column: this.index - this.lineStart\x0a\x09            };\x0a\x09            var entry = {\x0a\x09                multiLine: false,\x0a\x09                slice: [start + offset, this.index],\x0a\x09                range: [start, this.index],\x0a\x09                loc: loc\x0a\x09            };\x0a\x09            comments.push(entry);\x0a\x09        }\x0a\x09        return comments;\x0a\x09    };\x0a\x09    Scanner.prototype.skipMultiLineComment = function () {\x0a\x09        var comments = [];\x0a\x09        var start, loc;\x0a\x09        if (this.trackComment) {\x0a\x09            comments = [];\x0a\x09            start = this.index - 2;\x0a\x09            loc = {\x0a\x09                start: {\x0a\x09                    line: this.lineNumber,\x0a\x09                    column: this.index - this.lineStart - 2\x0a\x09                },\x0a\x09                end: {}\x0a\x09            };\x0a\x09        }\x0a\x09        while (!this.eof()) {\x0a\x09            var ch = this.source.charCodeAt(this.index);\x0a\x09            if (character_1.Character.isLineTerminator(ch)) {\x0a\x09                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {\x0a\x09                    ++this.index;\x0a\x09                }\x0a\x09                ++this.lineNumber;\x0a\x09                ++this.index;\x0a\x09                this.lineStart = this.index;\x0a\x09            }\x0a\x09            else if (ch === 0x2A) {\x0a\x09                // Block comment ends with \x27*/\x27.\x0a\x09                if (this.source.charCodeAt(this.index + 1) === 0x2F) {\x0a\x09                    this.index += 2;\x0a\x09                    if (this.trackComment) {\x0a\x09                        loc.end = {\x0a\x09                            line: this.lineNumber,\x0a\x09                            column: this.index - this.lineStart\x0a\x09                        };\x0a\x09                        var entry = {\x0a\x09                            multiLine: true,\x0a\x09                            slice: [start + 2, this.index - 2],\x0a\x09                            range: [start, this.index],\x0a\x09                            loc: loc\x0a\x09                        };\x0a\x09                        comments.push(entry);\x0a\x09                    }\x0a\x09                    return comments;\x0a\x09                }\x0a\x09                ++this.index;\x0a\x09            }\x0a\x09            else {\x0a\x09                ++this.index;\x0a\x09            }\x0a\x09        }\x0a\x09        // Ran off the end of the file - the whole thing is a comment\x0a\x09        if (this.trackComment) {\x0a\x09            loc.end = {\x0a\x09                line: this.lineNumber,\x0a\x09                column: this.index - this.lineStart\x0a\x09            };\x0a\x09            var entry = {\x0a\x09                multiLine: true,\x0a\x09                slice: [start + 2, this.index],\x0a\x09                range: [start, this.index],\x0a\x09                loc: loc\x0a\x09            };\x0a\x09            comments.push(entry);\x0a\x09        }\x0a\x09        this.tolerateUnexpectedToken();\x0a\x09        return comments;\x0a\x09    };\x0a\x09    Scanner.prototype.scanComments = function () {\x0a\x09        var comments;\x0a\x09        if (this.trackComment) {\x0a\x09            comments = [];\x0a\x09        }\x0a\x09        var start = (this.index === 0);\x0a\x09        while (!this.eof()) {\x0a\x09            var ch = this.source.charCodeAt(this.index);\x0a\x09            if (character_1.Character.isWhiteSpace(ch)) {\x0a\x09                ++this.index;\x0a\x09            }\x0a\x09            else if (character_1.Character.isLineTerminator(ch)) {\x0a\x09                ++this.index;\x0a\x09                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {\x0a\x09                    ++this.index;\x0a\x09                }\x0a\x09                ++this.lineNumber;\x0a\x09                this.lineStart = this.index;\x0a\x09                start = true;\x0a\x09            }\x0a\x09            else if (ch === 0x2F) {\x0a\x09                ch = this.source.charCodeAt(this.index + 1);\x0a\x09                if (ch === 0x2F) {\x0a\x09                    this.index += 2;\x0a\x09                    var comment = this.skipSingleLineComment(2);\x0a\x09                    if (this.trackComment) {\x0a\x09                        comments = comments.concat(comment);\x0a\x09                    }\x0a\x09                    start = true;\x0a\x09                }\x0a\x09                else if (ch === 0x2A) {\x0a\x09                    this.index += 2;\x0a\x09                    var comment = this.skipMultiLineComment();\x0a\x09                    if (this.trackComment) {\x0a\x09                        comments = comments.concat(comment);\x0a\x09                    }\x0a\x09                }\x0a\x09                else {\x0a\x09                    break;\x0a\x09                }\x0a\x09            }\x0a\x09            else if (start && ch === 0x2D) {\x0a\x09                // U+003E is \x27\x3e\x27\x0a\x09                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {\x0a\x09                    // \x27--\x3e\x27 is a single-line comment\x0a\x09                    this.index += 3;\x0a\x09                    var comment = this.skipSingleLineComment(3);\x0a\x09                    if (this.trackComment) {\x0a\x09                        comments = comments.concat(comment);\x0a\x09                    }\x0a\x09                }\x0a\x09                else {\x0a\x09                    break;\x0a\x09                }\x0a\x09            }\x0a\x09            else if (ch === 0x3C) {\x0a\x09                if (this.source.slice(this.index + 1, this.index + 4) === \x27!--\x27) {\x0a\x09                    this.index += 4; // `\x3c!--`\x0a\x09                    var comment = this.skipSingleLineComment(4);\x0a\x09                    if (this.trackComment) {\x0a\x09                        comments = comments.concat(comment);\x0a\x09                    }\x0a\x09                }\x0a\x09                else {\x0a\x09                    break;\x0a\x09                }\x0a\x09            }\x0a\x09            else {\x0a\x09                break;\x0a\x09            }\x0a\x09        }\x0a\x09        return comments;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-future-reserved-words\x0a\x09    Scanner.prototype.isFutureReservedWord = function (id) {\x0a\x09        switch (id) {\x0a\x09            case \x27enum\x27:\x0a\x09            case \x27export\x27:\x0a\x09            case \x27import\x27:\x0a\x09            case \x27super\x27:\x0a\x09                return true;\x0a\x09            default:\x0a\x09                return false;\x0a\x09        }\x0a\x09    };\x0a\x09    Scanner.prototype.isStrictModeReservedWord = function (id) {\x0a\x09        switch (id) {\x0a\x09            case \x27implements\x27:\x0a\x09            case \x27interface\x27:\x0a\x09            case \x27package\x27:\x0a\x09            case \x27private\x27:\x0a\x09            case \x27protected\x27:\x0a\x09            case \x27public\x27:\x0a\x09            case \x27static\x27:\x0a\x09            case \x27yield\x27:\x0a\x09            case \x27let\x27:\x0a\x09                return true;\x0a\x09            default:\x0a\x09                return false;\x0a\x09        }\x0a\x09    };\x0a\x09    Scanner.prototype.isRestrictedWord = function (id) {\x0a\x09        return id === \x27eval\x27 || id === \x27arguments\x27;\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-keywords\x0a\x09    Scanner.prototype.isKeyword = function (id) {\x0a\x09        switch (id.length) {\x0a\x09            case 2:\x0a\x09                return (id === \x27if\x27) || (id === \x27in\x27) || (id === \x27do\x27);\x0a\x09            case 3:\x0a\x09                return (id === \x27var\x27) || (id === \x27for\x27) || (id === \x27new\x27) ||\x0a\x09                    (id === \x27try\x27) || (id === \x27let\x27);\x0a\x09            case 4:\x0a\x09                return (id === \x27this\x27) || (id === \x27else\x27) || (id === \x27case\x27) ||\x0a\x09                    (id === \x27void\x27) || (id === \x27with\x27) || (id === \x27enum\x27);\x0a\x09            case 5:\x0a\x09                return (id === \x27while\x27) || (id === \x27break\x27) || (id === \x27catch\x27) ||\x0a\x09                    (id === \x27throw\x27) || (id === \x27const\x27) || (id === \x27yield\x27) ||\x0a\x09                    (id === \x27class\x27) || (id === \x27super\x27);\x0a\x09            case 6:\x0a\x09                return (id === \x27return\x27) || (id === \x27typeof\x27) || (id === \x27delete\x27) ||\x0a\x09                    (id === \x27switch\x27) || (id === \x27export\x27) || (id === \x27import\x27);\x0a\x09            case 7:\x0a\x09                return (id === \x27default\x27) || (id === \x27finally\x27) || (id === \x27extends\x27);\x0a\x09            case 8:\x0a\x09                return (id === \x27function\x27) || (id === \x27continue\x27) || (id === \x27debugger\x27);\x0a\x09            case 10:\x0a\x09                return (id === \x27instanceof\x27);\x0a\x09            default:\x0a\x09                return false;\x0a\x09        }\x0a\x09    };\x0a\x09    Scanner.prototype.codePointAt = function (i) {\x0a\x09        var cp = this.source.charCodeAt(i);\x0a\x09        if (cp \x3e= 0xD800 && cp \x3c= 0xDBFF) {\x0a\x09            var second = this.source.charCodeAt(i + 1);\x0a\x09            if (second \x3e= 0xDC00 && second \x3c= 0xDFFF) {\x0a\x09                var first = cp;\x0a\x09                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\x0a\x09            }\x0a\x09        }\x0a\x09        return cp;\x0a\x09    };\x0a\x09    Scanner.prototype.scanHexEscape = function (prefix) {\x0a\x09        var len = (prefix === \x27u\x27) ? 4 : 2;\x0a\x09        var code = 0;\x0a\x09        for (var i = 0; i \x3c len; ++i) {\x0a\x09            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {\x0a\x09                code = code * 16 + hexValue(this.source[this.index++]);\x0a\x09            }\x0a\x09            else {\x0a\x09                return null;\x0a\x09            }\x0a\x09        }\x0a\x09        return String.fromCharCode(code);\x0a\x09    };\x0a\x09    Scanner.prototype.scanUnicodeCodePointEscape = function () {\x0a\x09        var ch = this.source[this.index];\x0a\x09        var code = 0;\x0a\x09        // At least, one hex digit is required.\x0a\x09        if (ch === \x27}\x27) {\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        while (!this.eof()) {\x0a\x09            ch = this.source[this.index++];\x0a\x09            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {\x0a\x09                break;\x0a\x09            }\x0a\x09            code = code * 16 + hexValue(ch);\x0a\x09        }\x0a\x09        if (code \x3e 0x10FFFF || ch !== \x27}\x27) {\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        return character_1.Character.fromCodePoint(code);\x0a\x09    };\x0a\x09    Scanner.prototype.getIdentifier = function () {\x0a\x09        var start = this.index++;\x0a\x09        while (!this.eof()) {\x0a\x09            var ch = this.source.charCodeAt(this.index);\x0a\x09            if (ch === 0x5C) {\x0a\x09                // Blackslash (U+005C) marks Unicode escape sequence.\x0a\x09                this.index = start;\x0a\x09                return this.getComplexIdentifier();\x0a\x09            }\x0a\x09            else if (ch \x3e= 0xD800 && ch \x3c 0xDFFF) {\x0a\x09                // Need to handle surrogate pairs.\x0a\x09                this.index = start;\x0a\x09                return this.getComplexIdentifier();\x0a\x09            }\x0a\x09            if (character_1.Character.isIdentifierPart(ch)) {\x0a\x09                ++this.index;\x0a\x09            }\x0a\x09            else {\x0a\x09                break;\x0a\x09            }\x0a\x09        }\x0a\x09        return this.source.slice(start, this.index);\x0a\x09    };\x0a\x09    Scanner.prototype.getComplexIdentifier = function () {\x0a\x09        var cp = this.codePointAt(this.index);\x0a\x09        var id = character_1.Character.fromCodePoint(cp);\x0a\x09        this.index += id.length;\x0a\x09        // \x27\x5cu\x27 (U+005C, U+0075) denotes an escaped character.\x0a\x09        var ch;\x0a\x09        if (cp === 0x5C) {\x0a\x09            if (this.source.charCodeAt(this.index) !== 0x75) {\x0a\x09                this.throwUnexpectedToken();\x0a\x09            }\x0a\x09            ++this.index;\x0a\x09            if (this.source[this.index] === \x27{\x27) {\x0a\x09                ++this.index;\x0a\x09                ch = this.scanUnicodeCodePointEscape();\x0a\x09            }\x0a\x09            else {\x0a\x09                ch = this.scanHexEscape(\x27u\x27);\x0a\x09                if (ch === null || ch === \x27\x5c\x5c\x27 || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {\x0a\x09                    this.throwUnexpectedToken();\x0a\x09                }\x0a\x09            }\x0a\x09            id = ch;\x0a\x09        }\x0a\x09        while (!this.eof()) {\x0a\x09            cp = this.codePointAt(this.index);\x0a\x09            if (!character_1.Character.isIdentifierPart(cp)) {\x0a\x09                break;\x0a\x09            }\x0a\x09            ch = character_1.Character.fromCodePoint(cp);\x0a\x09            id += ch;\x0a\x09            this.index += ch.length;\x0a\x09            // \x27\x5cu\x27 (U+005C, U+0075) denotes an escaped character.\x0a\x09            if (cp === 0x5C) {\x0a\x09                id = id.substr(0, id.length - 1);\x0a\x09                if (this.source.charCodeAt(this.index) !== 0x75) {\x0a\x09                    this.throwUnexpectedToken();\x0a\x09                }\x0a\x09                ++this.index;\x0a\x09                if (this.source[this.index] === \x27{\x27) {\x0a\x09                    ++this.index;\x0a\x09                    ch = this.scanUnicodeCodePointEscape();\x0a\x09                }\x0a\x09                else {\x0a\x09                    ch = this.scanHexEscape(\x27u\x27);\x0a\x09                    if (ch === null || ch === \x27\x5c\x5c\x27 || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {\x0a\x09                        this.throwUnexpectedToken();\x0a\x09                    }\x0a\x09                }\x0a\x09                id += ch;\x0a\x09            }\x0a\x09        }\x0a\x09        return id;\x0a\x09    };\x0a\x09    Scanner.prototype.octalToDecimal = function (ch) {\x0a\x09        // \x5c0 is not octal escape sequence\x0a\x09        var octal = (ch !== \x270\x27);\x0a\x09        var code = octalValue(ch);\x0a\x09        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {\x0a\x09            octal = true;\x0a\x09            code = code * 8 + octalValue(this.source[this.index++]);\x0a\x09            // 3 digits are only allowed when string starts\x0a\x09            // with 0, 1, 2, 3\x0a\x09            if (\x270123\x27.indexOf(ch) \x3e= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {\x0a\x09                code = code * 8 + octalValue(this.source[this.index++]);\x0a\x09            }\x0a\x09        }\x0a\x09        return {\x0a\x09            code: code,\x0a\x09            octal: octal\x0a\x09        };\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-names-and-keywords\x0a\x09    Scanner.prototype.scanIdentifier = function () {\x0a\x09        var type;\x0a\x09        var start = this.index;\x0a\x09        // Backslash (U+005C) starts an escaped character.\x0a\x09        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();\x0a\x09        // There is no keyword or literal with only one character.\x0a\x09        // Thus, it must be an identifier.\x0a\x09        if (id.length === 1) {\x0a\x09            type = 3 /* Identifier */;\x0a\x09        }\x0a\x09        else if (this.isKeyword(id)) {\x0a\x09            type = 4 /* Keyword */;\x0a\x09        }\x0a\x09        else if (id === \x27null\x27) {\x0a\x09            type = 5 /* NullLiteral */;\x0a\x09        }\x0a\x09        else if (id === \x27true\x27 || id === \x27false\x27) {\x0a\x09            type = 1 /* BooleanLiteral */;\x0a\x09        }\x0a\x09        else {\x0a\x09            type = 3 /* Identifier */;\x0a\x09        }\x0a\x09        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {\x0a\x09            var restore = this.index;\x0a\x09            this.index = start;\x0a\x09            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);\x0a\x09            this.index = restore;\x0a\x09        }\x0a\x09        return {\x0a\x09            type: type,\x0a\x09            value: id,\x0a\x09            lineNumber: this.lineNumber,\x0a\x09            lineStart: this.lineStart,\x0a\x09            start: start,\x0a\x09            end: this.index\x0a\x09        };\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-punctuators\x0a\x09    Scanner.prototype.scanPunctuator = function () {\x0a\x09        var start = this.index;\x0a\x09        // Check for most common single-character punctuators.\x0a\x09        var str = this.source[this.index];\x0a\x09        switch (str) {\x0a\x09            case \x27(\x27:\x0a\x09            case \x27{\x27:\x0a\x09                if (str === \x27{\x27) {\x0a\x09                    this.curlyStack.push(\x27{\x27);\x0a\x09                }\x0a\x09                ++this.index;\x0a\x09                break;\x0a\x09            case \x27.\x27:\x0a\x09                ++this.index;\x0a\x09                if (this.source[this.index] === \x27.\x27 && this.source[this.index + 1] === \x27.\x27) {\x0a\x09                    // Spread operator: ...\x0a\x09                    this.index += 2;\x0a\x09                    str = \x27...\x27;\x0a\x09                }\x0a\x09                break;\x0a\x09            case \x27}\x27:\x0a\x09                ++this.index;\x0a\x09                this.curlyStack.pop();\x0a\x09                break;\x0a\x09            case \x27)\x27:\x0a\x09            case \x27;\x27:\x0a\x09            case \x27,\x27:\x0a\x09            case \x27[\x27:\x0a\x09            case \x27]\x27:\x0a\x09            case \x27:\x27:\x0a\x09            case \x27?\x27:\x0a\x09            case \x27~\x27:\x0a\x09                ++this.index;\x0a\x09                break;\x0a\x09            default:\x0a\x09                // 4-character punctuator.\x0a\x09                str = this.source.substr(this.index, 4);\x0a\x09                if (str === \x27\x3e\x3e\x3e=\x27) {\x0a\x09                    this.index += 4;\x0a\x09                }\x0a\x09                else {\x0a\x09                    // 3-character punctuators.\x0a\x09                    str = str.substr(0, 3);\x0a\x09                    if (str === \x27===\x27 || str === \x27!==\x27 || str === \x27\x3e\x3e\x3e\x27 ||\x0a\x09                        str === \x27\x3c\x3c=\x27 || str === \x27\x3e\x3e=\x27 || str === \x27**=\x27) {\x0a\x09                        this.index += 3;\x0a\x09                    }\x0a\x09                    else {\x0a\x09                        // 2-character punctuators.\x0a\x09                        str = str.substr(0, 2);\x0a\x09                        if (str === \x27&&\x27 || str === \x27||\x27 || str === \x27==\x27 || str === \x27!=\x27 ||\x0a\x09                            str === \x27+=\x27 || str === \x27-=\x27 || str === \x27*=\x27 || str === \x27/=\x27 ||\x0a\x09                            str === \x27++\x27 || str === \x27--\x27 || str === \x27\x3c\x3c\x27 || str === \x27\x3e\x3e\x27 ||\x0a\x09                            str === \x27&=\x27 || str === \x27|=\x27 || str === \x27^=\x27 || str === \x27%=\x27 ||\x0a\x09                            str === \x27\x3c=\x27 || str === \x27\x3e=\x27 || str === \x27=\x3e\x27 || str === \x27**\x27) {\x0a\x09                            this.index += 2;\x0a\x09                        }\x0a\x09                        else {\x0a\x09                            // 1-character punctuators.\x0a\x09                            str = this.source[this.index];\x0a\x09                            if (\x27\x3c\x3e=!+-*%&|^/\x27.indexOf(str) \x3e= 0) {\x0a\x09                                ++this.index;\x0a\x09                            }\x0a\x09                        }\x0a\x09                    }\x0a\x09                }\x0a\x09        }\x0a\x09        if (this.index === start) {\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        return {\x0a\x09            type: 7 /* Punctuator */,\x0a\x09            value: str,\x0a\x09            lineNumber: this.lineNumber,\x0a\x09            lineStart: this.lineStart,\x0a\x09            start: start,\x0a\x09            end: this.index\x0a\x09        };\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals\x0a\x09    Scanner.prototype.scanHexLiteral = function (start) {\x0a\x09        var num = \x27\x27;\x0a\x09        while (!this.eof()) {\x0a\x09            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {\x0a\x09                break;\x0a\x09            }\x0a\x09            num += this.source[this.index++];\x0a\x09        }\x0a\x09        if (num.length === 0) {\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        return {\x0a\x09            type: 6 /* NumericLiteral */,\x0a\x09            value: parseInt(\x270x\x27 + num, 16),\x0a\x09            lineNumber: this.lineNumber,\x0a\x09            lineStart: this.lineStart,\x0a\x09            start: start,\x0a\x09            end: this.index\x0a\x09        };\x0a\x09    };\x0a\x09    Scanner.prototype.scanBinaryLiteral = function (start) {\x0a\x09        var num = \x27\x27;\x0a\x09        var ch;\x0a\x09        while (!this.eof()) {\x0a\x09            ch = this.source[this.index];\x0a\x09            if (ch !== \x270\x27 && ch !== \x271\x27) {\x0a\x09                break;\x0a\x09            }\x0a\x09            num += this.source[this.index++];\x0a\x09        }\x0a\x09        if (num.length === 0) {\x0a\x09            // only 0b or 0B\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        if (!this.eof()) {\x0a\x09            ch = this.source.charCodeAt(this.index);\x0a\x09            /* istanbul ignore else */\x0a\x09            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {\x0a\x09                this.throwUnexpectedToken();\x0a\x09            }\x0a\x09        }\x0a\x09        return {\x0a\x09            type: 6 /* NumericLiteral */,\x0a\x09            value: parseInt(num, 2),\x0a\x09            lineNumber: this.lineNumber,\x0a\x09            lineStart: this.lineStart,\x0a\x09            start: start,\x0a\x09            end: this.index\x0a\x09        };\x0a\x09    };\x0a\x09    Scanner.prototype.scanOctalLiteral = function (prefix, start) {\x0a\x09        var num = \x27\x27;\x0a\x09        var octal = false;\x0a\x09        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {\x0a\x09            octal = true;\x0a\x09            num = \x270\x27 + this.source[this.index++];\x0a\x09        }\x0a\x09        else {\x0a\x09            ++this.index;\x0a\x09        }\x0a\x09        while (!this.eof()) {\x0a\x09            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {\x0a\x09                break;\x0a\x09            }\x0a\x09            num += this.source[this.index++];\x0a\x09        }\x0a\x09        if (!octal && num.length === 0) {\x0a\x09            // only 0o or 0O\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        return {\x0a\x09            type: 6 /* NumericLiteral */,\x0a\x09            value: parseInt(num, 8),\x0a\x09            octal: octal,\x0a\x09            lineNumber: this.lineNumber,\x0a\x09            lineStart: this.lineStart,\x0a\x09            start: start,\x0a\x09            end: this.index\x0a\x09        };\x0a\x09    };\x0a\x09    Scanner.prototype.isImplicitOctalLiteral = function () {\x0a\x09        // Implicit octal, unless there is a non-octal digit.\x0a\x09        // (Annex B.1.1 on Numeric Literals)\x0a\x09        for (var i = this.index + 1; i \x3c this.length; ++i) {\x0a\x09            var ch = this.source[i];\x0a\x09            if (ch === \x278\x27 || ch === \x279\x27) {\x0a\x09                return false;\x0a\x09            }\x0a\x09            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {\x0a\x09                return true;\x0a\x09            }\x0a\x09        }\x0a\x09        return true;\x0a\x09    };\x0a\x09    Scanner.prototype.scanNumericLiteral = function () {\x0a\x09        var start = this.index;\x0a\x09        var ch = this.source[start];\x0a\x09        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === \x27.\x27), \x27Numeric literal must start with a decimal digit or a decimal point\x27);\x0a\x09        var num = \x27\x27;\x0a\x09        if (ch !== \x27.\x27) {\x0a\x09            num = this.source[this.index++];\x0a\x09            ch = this.source[this.index];\x0a\x09            // Hex number starts with \x270x\x27.\x0a\x09            // Octal number starts with \x270\x27.\x0a\x09            // Octal number in ES6 starts with \x270o\x27.\x0a\x09            // Binary number in ES6 starts with \x270b\x27.\x0a\x09            if (num === \x270\x27) {\x0a\x09                if (ch === \x27x\x27 || ch === \x27X\x27) {\x0a\x09                    ++this.index;\x0a\x09                    return this.scanHexLiteral(start);\x0a\x09                }\x0a\x09                if (ch === \x27b\x27 || ch === \x27B\x27) {\x0a\x09                    ++this.index;\x0a\x09                    return this.scanBinaryLiteral(start);\x0a\x09                }\x0a\x09                if (ch === \x27o\x27 || ch === \x27O\x27) {\x0a\x09                    return this.scanOctalLiteral(ch, start);\x0a\x09                }\x0a\x09                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {\x0a\x09                    if (this.isImplicitOctalLiteral()) {\x0a\x09                        return this.scanOctalLiteral(ch, start);\x0a\x09                    }\x0a\x09                }\x0a\x09            }\x0a\x09            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\x0a\x09                num += this.source[this.index++];\x0a\x09            }\x0a\x09            ch = this.source[this.index];\x0a\x09        }\x0a\x09        if (ch === \x27.\x27) {\x0a\x09            num += this.source[this.index++];\x0a\x09            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\x0a\x09                num += this.source[this.index++];\x0a\x09            }\x0a\x09            ch = this.source[this.index];\x0a\x09        }\x0a\x09        if (ch === \x27e\x27 || ch === \x27E\x27) {\x0a\x09            num += this.source[this.index++];\x0a\x09            ch = this.source[this.index];\x0a\x09            if (ch === \x27+\x27 || ch === \x27-\x27) {\x0a\x09                num += this.source[this.index++];\x0a\x09            }\x0a\x09            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\x0a\x09                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\x0a\x09                    num += this.source[this.index++];\x0a\x09                }\x0a\x09            }\x0a\x09            else {\x0a\x09                this.throwUnexpectedToken();\x0a\x09            }\x0a\x09        }\x0a\x09        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        return {\x0a\x09            type: 6 /* NumericLiteral */,\x0a\x09            value: parseFloat(num),\x0a\x09            lineNumber: this.lineNumber,\x0a\x09            lineStart: this.lineStart,\x0a\x09            start: start,\x0a\x09            end: this.index\x0a\x09        };\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-literals-string-literals\x0a\x09    Scanner.prototype.scanStringLiteral = function () {\x0a\x09        var start = this.index;\x0a\x09        var quote = this.source[start];\x0a\x09        assert_1.assert((quote === \x27\x5c\x27\x27 || quote === \x27\x22\x27), \x27String literal must starts with a quote\x27);\x0a\x09        ++this.index;\x0a\x09        var octal = false;\x0a\x09        var str = \x27\x27;\x0a\x09        while (!this.eof()) {\x0a\x09            var ch = this.source[this.index++];\x0a\x09            if (ch === quote) {\x0a\x09                quote = \x27\x27;\x0a\x09                break;\x0a\x09            }\x0a\x09            else if (ch === \x27\x5c\x5c\x27) {\x0a\x09                ch = this.source[this.index++];\x0a\x09                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\x0a\x09                    switch (ch) {\x0a\x09                        case \x27u\x27:\x0a\x09                            if (this.source[this.index] === \x27{\x27) {\x0a\x09                                ++this.index;\x0a\x09                                str += this.scanUnicodeCodePointEscape();\x0a\x09                            }\x0a\x09                            else {\x0a\x09                                var unescaped_1 = this.scanHexEscape(ch);\x0a\x09                                if (unescaped_1 === null) {\x0a\x09                                    this.throwUnexpectedToken();\x0a\x09                                }\x0a\x09                                str += unescaped_1;\x0a\x09                            }\x0a\x09                            break;\x0a\x09                        case \x27x\x27:\x0a\x09                            var unescaped = this.scanHexEscape(ch);\x0a\x09                            if (unescaped === null) {\x0a\x09                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);\x0a\x09                            }\x0a\x09                            str += unescaped;\x0a\x09                            break;\x0a\x09                        case \x27n\x27:\x0a\x09                            str += \x27\x5cn\x27;\x0a\x09                            break;\x0a\x09                        case \x27r\x27:\x0a\x09                            str += \x27\x5cr\x27;\x0a\x09                            break;\x0a\x09                        case \x27t\x27:\x0a\x09                            str += \x27\x5ct\x27;\x0a\x09                            break;\x0a\x09                        case \x27b\x27:\x0a\x09                            str += \x27\x5cb\x27;\x0a\x09                            break;\x0a\x09                        case \x27f\x27:\x0a\x09                            str += \x27\x5cf\x27;\x0a\x09                            break;\x0a\x09                        case \x27v\x27:\x0a\x09                            str += \x27\x5cx0B\x27;\x0a\x09                            break;\x0a\x09                        case \x278\x27:\x0a\x09                        case \x279\x27:\x0a\x09                            str += ch;\x0a\x09                            this.tolerateUnexpectedToken();\x0a\x09                            break;\x0a\x09                        default:\x0a\x09                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {\x0a\x09                                var octToDec = this.octalToDecimal(ch);\x0a\x09                                octal = octToDec.octal || octal;\x0a\x09                                str += String.fromCharCode(octToDec.code);\x0a\x09                            }\x0a\x09                            else {\x0a\x09                                str += ch;\x0a\x09                            }\x0a\x09                            break;\x0a\x09                    }\x0a\x09                }\x0a\x09                else {\x0a\x09                    ++this.lineNumber;\x0a\x09                    if (ch === \x27\x5cr\x27 && this.source[this.index] === \x27\x5cn\x27) {\x0a\x09                        ++this.index;\x0a\x09                    }\x0a\x09                    this.lineStart = this.index;\x0a\x09                }\x0a\x09            }\x0a\x09            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\x0a\x09                break;\x0a\x09            }\x0a\x09            else {\x0a\x09                str += ch;\x0a\x09            }\x0a\x09        }\x0a\x09        if (quote !== \x27\x27) {\x0a\x09            this.index = start;\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        return {\x0a\x09            type: 8 /* StringLiteral */,\x0a\x09            value: str,\x0a\x09            octal: octal,\x0a\x09            lineNumber: this.lineNumber,\x0a\x09            lineStart: this.lineStart,\x0a\x09            start: start,\x0a\x09            end: this.index\x0a\x09        };\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components\x0a\x09    Scanner.prototype.scanTemplate = function () {\x0a\x09        var cooked = \x27\x27;\x0a\x09        var terminated = false;\x0a\x09        var start = this.index;\x0a\x09        var head = (this.source[start] === \x27`\x27);\x0a\x09        var tail = false;\x0a\x09        var rawOffset = 2;\x0a\x09        ++this.index;\x0a\x09        while (!this.eof()) {\x0a\x09            var ch = this.source[this.index++];\x0a\x09            if (ch === \x27`\x27) {\x0a\x09                rawOffset = 1;\x0a\x09                tail = true;\x0a\x09                terminated = true;\x0a\x09                break;\x0a\x09            }\x0a\x09            else if (ch === \x27$\x27) {\x0a\x09                if (this.source[this.index] === \x27{\x27) {\x0a\x09                    this.curlyStack.push(\x27${\x27);\x0a\x09                    ++this.index;\x0a\x09                    terminated = true;\x0a\x09                    break;\x0a\x09                }\x0a\x09                cooked += ch;\x0a\x09            }\x0a\x09            else if (ch === \x27\x5c\x5c\x27) {\x0a\x09                ch = this.source[this.index++];\x0a\x09                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\x0a\x09                    switch (ch) {\x0a\x09                        case \x27n\x27:\x0a\x09                            cooked += \x27\x5cn\x27;\x0a\x09                            break;\x0a\x09                        case \x27r\x27:\x0a\x09                            cooked += \x27\x5cr\x27;\x0a\x09                            break;\x0a\x09                        case \x27t\x27:\x0a\x09                            cooked += \x27\x5ct\x27;\x0a\x09                            break;\x0a\x09                        case \x27u\x27:\x0a\x09                            if (this.source[this.index] === \x27{\x27) {\x0a\x09                                ++this.index;\x0a\x09                                cooked += this.scanUnicodeCodePointEscape();\x0a\x09                            }\x0a\x09                            else {\x0a\x09                                var restore = this.index;\x0a\x09                                var unescaped_2 = this.scanHexEscape(ch);\x0a\x09                                if (unescaped_2 !== null) {\x0a\x09                                    cooked += unescaped_2;\x0a\x09                                }\x0a\x09                                else {\x0a\x09                                    this.index = restore;\x0a\x09                                    cooked += ch;\x0a\x09                                }\x0a\x09                            }\x0a\x09                            break;\x0a\x09                        case \x27x\x27:\x0a\x09                            var unescaped = this.scanHexEscape(ch);\x0a\x09                            if (unescaped === null) {\x0a\x09                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);\x0a\x09                            }\x0a\x09                            cooked += unescaped;\x0a\x09                            break;\x0a\x09                        case \x27b\x27:\x0a\x09                            cooked += \x27\x5cb\x27;\x0a\x09                            break;\x0a\x09                        case \x27f\x27:\x0a\x09                            cooked += \x27\x5cf\x27;\x0a\x09                            break;\x0a\x09                        case \x27v\x27:\x0a\x09                            cooked += \x27\x5cv\x27;\x0a\x09                            break;\x0a\x09                        default:\x0a\x09                            if (ch === \x270\x27) {\x0a\x09                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {\x0a\x09                                    // Illegal: \x5c01 \x5c02 and so on\x0a\x09                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);\x0a\x09                                }\x0a\x09                                cooked += \x27\x5c0\x27;\x0a\x09                            }\x0a\x09                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {\x0a\x09                                // Illegal: \x5c1 \x5c2\x0a\x09                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);\x0a\x09                            }\x0a\x09                            else {\x0a\x09                                cooked += ch;\x0a\x09                            }\x0a\x09                            break;\x0a\x09                    }\x0a\x09                }\x0a\x09                else {\x0a\x09                    ++this.lineNumber;\x0a\x09                    if (ch === \x27\x5cr\x27 && this.source[this.index] === \x27\x5cn\x27) {\x0a\x09                        ++this.index;\x0a\x09                    }\x0a\x09                    this.lineStart = this.index;\x0a\x09                }\x0a\x09            }\x0a\x09            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\x0a\x09                ++this.lineNumber;\x0a\x09                if (ch === \x27\x5cr\x27 && this.source[this.index] === \x27\x5cn\x27) {\x0a\x09                    ++this.index;\x0a\x09                }\x0a\x09                this.lineStart = this.index;\x0a\x09                cooked += \x27\x5cn\x27;\x0a\x09            }\x0a\x09            else {\x0a\x09                cooked += ch;\x0a\x09            }\x0a\x09        }\x0a\x09        if (!terminated) {\x0a\x09            this.throwUnexpectedToken();\x0a\x09        }\x0a\x09        if (!head) {\x0a\x09            this.curlyStack.pop();\x0a\x09        }\x0a\x09        return {\x0a\x09            type: 10 /* Template */,\x0a\x09            value: this.source.slice(start + 1, this.index - rawOffset),\x0a\x09            cooked: cooked,\x0a\x09            head: head,\x0a\x09            tail: tail,\x0a\x09            lineNumber: this.lineNumber,\x0a\x09            lineStart: this.lineStart,\x0a\x09            start: start,\x0a\x09            end: this.index\x0a\x09        };\x0a\x09    };\x0a\x09    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals\x0a\x09    Scanner.prototype.testRegExp = function (pattern, flags) {\x0a\x09        // The BMP character to use as a replacement for astral symbols when\x0a\x09        // translating an ES6 \x22u\x22-flagged pattern to an ES5-compatible\x0a\x09        // approximation.\x0a\x09        // Note: replacing with \x27\x5cuFFFF\x27 enables false positives in unlikely\x0a\x09        // scenarios. For example, `[\x5cu{1044f}-\x5cu{10440}]` is an invalid\x0a\x09        // pattern that would not be detected by this substitution.\x0a\x09        var astralSubstitute = \x27\x5cuFFFF\x27;\x0a\x09        var tmp = pattern;\x0a\x09        var self = this;\x0a\x09        if (flags.indexOf(\x27u\x27) \x3e= 0) {\x0a\x09            tmp = tmp\x0a\x09                .replace(/\x5c\x5cu\x5c{([0-9a-fA-F]+)\x5c}|\x5c\x5cu([a-fA-F0-9]{4})/g, function ($0, $1, $2) {\x0a\x09                var codePoint = parseInt($1 || $2, 16);\x0a\x09                if (codePoint \x3e 0x10FFFF) {\x0a\x09                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);\x0a\x09                }\x0a\x09                if (codePoint \x3c= 0xFFFF) {\x0a\x09                    return String.fromCharCode(codePoint);\x0a\x09                }\x0a\x09                return astralSubstitute;\x0a\x09            })\x0a\x09                .replace(/[\x5cuD800-\x5cuDBFF][\x5cuDC00-\x5cuDFFF]/g, astralSubstitute);\x0a\x09        }\x0a\x09        // First, detect invalid regular expressions.\x0a\x09        try {\x0a\x09            RegExp(tmp);\x0a\x09        }\x0a\x09        catch (e) {\x0a\x09            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);\x0a\x09        }\x0a\x09        // Return a regular expression object for this pattern-flag pair, or\x0a\x09        // `null` in case the current environment doesn\x27t support the flags it\x0a\x09        // uses.\x0a\x09        try {\x0a\x09            return new RegExp(pattern, flags);\x0a\x09        }\x0a\x09        catch (exception) {\x0a\x09            /* istanbul ignore next */\x0a\x09            return null;\x0a\x09        }\x0a\x09    };\x0a\x09    Scanner.prototype.scanRegExpBody = function () {\x0a\x09        var ch = this.source[this.index];\x0a\x09        assert_1.assert(ch === \x27/\x27, \x27Regular expression literal must start with a slash\x27);\x0a\x09        var str = this.source[this.index++];\x0a\x09        var classMarker = false;\x0a\x09        var terminated = false;\x0a\x09        while (!this.eof()) {\x0a\x09            ch = this.source[this.index++];\x0a\x09            str += ch;\x0a\x09            if (ch === \x27\x5c\x5c\x27) {\x0a\x09                ch = this.source[this.index++];\x0a\x09                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals\x0a\x09                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\x0a\x09                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);\x0a\x09                }\x0a\x09                str += ch;\x0a\x09            }\x0a\x09            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {\x0a\x09                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);\x0a\x09            }\x0a\x09            else if (classMarker) {\x0a\x09                if (ch === \x27]\x27) {\x0a\x09                    classMarker = false;\x0a\x09                }\x0a\x09            }\x0a\x09            else {\x0a\x09                if (ch === \x27/\x27) {\x0a\x09                    terminated = true;\x0a\x09                    break;\x0a\x09                }\x0a\x09                else if (ch === \x27[\x27) {\x0a\x09                    classMarker = true;\x0a\x09                }\x0a\x09            }\x0a\x09        }\x0a\x09        if (!terminated) {\x0a\x09            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);\x0a\x09        }\x0a\x09        // Exclude leading and trailing slash.\x0a\x09        return str.substr(1, str.length - 2);\x0a\x09    };\x0a\x09    Scanner.prototype.scanRegExpFlags = function () {\x0a\x09        var str = \x27\x27;\x0a\x09        var flags = \x27\x27;\x0a\x09        while (!this.eof()) {\x0a\x09            var ch = this.source[this.index];\x0a\x09            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {\x0a\x09                break;\x0a\x09            }\x0a\x09            ++this.index;\x0a\x09            if (ch === \x27\x5c\x5c\x27 && !this.eof()) {\x0a\x09                ch = this.source[this.index];\x0a\x09                if (ch === \x27u\x27) {\x0a\x09                    ++this.index;\x0a\x09                    var restore = this.index;\x0a\x09                    var char = this.scanHexEscape(\x27u\x27);\x0a\x09                    if (char !== null) {\x0a\x09                        flags += char;\x0a\x09                        for (str += \x27\x5c\x5cu\x27; restore \x3c this.index; ++restore) {\x0a\x09                            str += this.source[restore];\x0a\x09                        }\x0a\x09                    }\x0a\x09                    else {\x0a\x09                        this.index = restore;\x0a\x09                        flags += \x27u\x27;\x0a\x09                        str += \x27\x5c\x5cu\x27;\x0a\x09                    }\x0a\x09                    this.tolerateUnexpectedToken();\x0a\x09                }\x0a\x09                else {\x0a\x09                    str += \x27\x5c\x5c\x27;\x0a\x09                    this.tolerateUnexpectedToken();\x0a\x09                }\x0a\x09            }\x0a\x09            else {\x0a\x09                flags += ch;\x0a\x09                str += ch;\x0a\x09            }\x0a\x09        }\x0a\x09        return flags;\x0a\x09    };\x0a\x09    Scanner.prototype.scanRegExp = function () {\x0a\x09        var start = this.index;\x0a\x09        var pattern = this.scanRegExpBody();\x0a\x09        var flags = this.scanRegExpFlags();\x0a\x09        var value = this.testRegExp(pattern, flags);\x0a\x09        return {\x0a\x09            type: 9 /* RegularExpression */,\x0a\x09            value: \x27\x27,\x0a\x09            pattern: pattern,\x0a\x09            flags: flags,\x0a\x09            regex: value,\x0a\x09            lineNumber: this.lineNumber,\x0a\x09            lineStart: this.lineStart,\x0a\x09            start: start,\x0a\x09            end: this.index\x0a\x09        };\x0a\x09    };\x0a\x09    Scanner.prototype.lex = function () {\x0a\x09        if (this.eof()) {\x0a\x09            return {\x0a\x09                type: 2 /* EOF */,\x0a\x09                value: \x27\x27,\x0a\x09                lineNumber: this.lineNumber,\x0a\x09                lineStart: this.lineStart,\x0a\x09                start: this.index,\x0a\x09                end: this.index\x0a\x09            };\x0a\x09        }\x0a\x09        var cp = this.source.charCodeAt(this.index);\x0a\x09        if (character_1.Character.isIdentifierStart(cp)) {\x0a\x09            return this.scanIdentifier();\x0a\x09        }\x0a\x09        // Very common: ( and ) and ;\x0a\x09        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {\x0a\x09            return this.scanPunctuator();\x0a\x09        }\x0a\x09        // String literal starts with single quote (U+0027) or double quote (U+0022).\x0a\x09        if (cp === 0x27 || cp === 0x22) {\x0a\x09            return this.scanStringLiteral();\x0a\x09        }\x0a\x09        // Dot (.) U+002E can also start a floating-point number, hence the need\x0a\x09        // to check the next character.\x0a\x09        if (cp === 0x2E) {\x0a\x09            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {\x0a\x09                return this.scanNumericLiteral();\x0a\x09            }\x0a\x09            return this.scanPunctuator();\x0a\x09        }\x0a\x09        if (character_1.Character.isDecimalDigit(cp)) {\x0a\x09            return this.scanNumericLiteral();\x0a\x09        }\x0a\x09        // Template literals start with ` (U+0060) for template head\x0a\x09        // or } (U+007D) for template middle or template tail.\x0a\x09        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === \x27${\x27)) {\x0a\x09            return this.scanTemplate();\x0a\x09        }\x0a\x09        // Possible identifier start in a surrogate pair.\x0a\x09        if (cp \x3e= 0xD800 && cp \x3c 0xDFFF) {\x0a\x09            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {\x0a\x09                return this.scanIdentifier();\x0a\x09            }\x0a\x09        }\x0a\x09        return this.scanPunctuator();\x0a\x09    };\x0a\x09    return Scanner;\x0a\x09}());\x0a\x09exports.Scanner = Scanner;\x0a\x0a\x0a/***/ },\x0a/* 13 */\x0a/***/ function(module, exports) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09exports.TokenName = {};\x0a\x09exports.TokenName[1 /* BooleanLiteral */] = \x27Boolean\x27;\x0a\x09exports.TokenName[2 /* EOF */] = \x27\x3cend\x3e\x27;\x0a\x09exports.TokenName[3 /* Identifier */] = \x27Identifier\x27;\x0a\x09exports.TokenName[4 /* Keyword */] = \x27Keyword\x27;\x0a\x09exports.TokenName[5 /* NullLiteral */] = \x27Null\x27;\x0a\x09exports.TokenName[6 /* NumericLiteral */] = \x27Numeric\x27;\x0a\x09exports.TokenName[7 /* Punctuator */] = \x27Punctuator\x27;\x0a\x09exports.TokenName[8 /* StringLiteral */] = \x27String\x27;\x0a\x09exports.TokenName[9 /* RegularExpression */] = \x27RegularExpression\x27;\x0a\x09exports.TokenName[10 /* Template */] = \x27Template\x27;\x0a\x0a\x0a/***/ },\x0a/* 14 */\x0a/***/ function(module, exports) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09// Generated by generate-xhtml-entities.js. DO NOT MODIFY!\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09exports.XHTMLEntities = {\x0a\x09    quot: \x27\x5cu0022\x27,\x0a\x09    amp: \x27\x5cu0026\x27,\x0a\x09    apos: \x27\x5cu0027\x27,\x0a\x09    gt: \x27\x5cu003E\x27,\x0a\x09    nbsp: \x27\x5cu00A0\x27,\x0a\x09    iexcl: \x27\x5cu00A1\x27,\x0a\x09    cent: \x27\x5cu00A2\x27,\x0a\x09    pound: \x27\x5cu00A3\x27,\x0a\x09    curren: \x27\x5cu00A4\x27,\x0a\x09    yen: \x27\x5cu00A5\x27,\x0a\x09    brvbar: \x27\x5cu00A6\x27,\x0a\x09    sect: \x27\x5cu00A7\x27,\x0a\x09    uml: \x27\x5cu00A8\x27,\x0a\x09    copy: \x27\x5cu00A9\x27,\x0a\x09    ordf: \x27\x5cu00AA\x27,\x0a\x09    laquo: \x27\x5cu00AB\x27,\x0a\x09    not: \x27\x5cu00AC\x27,\x0a\x09    shy: \x27\x5cu00AD\x27,\x0a\x09    reg: \x27\x5cu00AE\x27,\x0a\x09    macr: \x27\x5cu00AF\x27,\x0a\x09    deg: \x27\x5cu00B0\x27,\x0a\x09    plusmn: \x27\x5cu00B1\x27,\x0a\x09    sup2: \x27\x5cu00B2\x27,\x0a\x09    sup3: \x27\x5cu00B3\x27,\x0a\x09    acute: \x27\x5cu00B4\x27,\x0a\x09    micro: \x27\x5cu00B5\x27,\x0a\x09    para: \x27\x5cu00B6\x27,\x0a\x09    middot: \x27\x5cu00B7\x27,\x0a\x09    cedil: \x27\x5cu00B8\x27,\x0a\x09    sup1: \x27\x5cu00B9\x27,\x0a\x09    ordm: \x27\x5cu00BA\x27,\x0a\x09    raquo: \x27\x5cu00BB\x27,\x0a\x09    frac14: \x27\x5cu00BC\x27,\x0a\x09    frac12: \x27\x5cu00BD\x27,\x0a\x09    frac34: \x27\x5cu00BE\x27,\x0a\x09    iquest: \x27\x5cu00BF\x27,\x0a\x09    Agrave: \x27\x5cu00C0\x27,\x0a\x09    Aacute: \x27\x5cu00C1\x27,\x0a\x09    Acirc: \x27\x5cu00C2\x27,\x0a\x09    Atilde: \x27\x5cu00C3\x27,\x0a\x09    Auml: \x27\x5cu00C4\x27,\x0a\x09    Aring: \x27\x5cu00C5\x27,\x0a\x09    AElig: \x27\x5cu00C6\x27,\x0a\x09    Ccedil: \x27\x5cu00C7\x27,\x0a\x09    Egrave: \x27\x5cu00C8\x27,\x0a\x09    Eacute: \x27\x5cu00C9\x27,\x0a\x09    Ecirc: \x27\x5cu00CA\x27,\x0a\x09    Euml: \x27\x5cu00CB\x27,\x0a\x09    Igrave: \x27\x5cu00CC\x27,\x0a\x09    Iacute: \x27\x5cu00CD\x27,\x0a\x09    Icirc: \x27\x5cu00CE\x27,\x0a\x09    Iuml: \x27\x5cu00CF\x27,\x0a\x09    ETH: \x27\x5cu00D0\x27,\x0a\x09    Ntilde: \x27\x5cu00D1\x27,\x0a\x09    Ograve: \x27\x5cu00D2\x27,\x0a\x09    Oacute: \x27\x5cu00D3\x27,\x0a\x09    Ocirc: \x27\x5cu00D4\x27,\x0a\x09    Otilde: \x27\x5cu00D5\x27,\x0a\x09    Ouml: \x27\x5cu00D6\x27,\x0a\x09    times: \x27\x5cu00D7\x27,\x0a\x09    Oslash: \x27\x5cu00D8\x27,\x0a\x09    Ugrave: \x27\x5cu00D9\x27,\x0a\x09    Uacute: \x27\x5cu00DA\x27,\x0a\x09    Ucirc: \x27\x5cu00DB\x27,\x0a\x09    Uuml: \x27\x5cu00DC\x27,\x0a\x09    Yacute: \x27\x5cu00DD\x27,\x0a\x09    THORN: \x27\x5cu00DE\x27,\x0a\x09    szlig: \x27\x5cu00DF\x27,\x0a\x09    agrave: \x27\x5cu00E0\x27,\x0a\x09    aacute: \x27\x5cu00E1\x27,\x0a\x09    acirc: \x27\x5cu00E2\x27,\x0a\x09    atilde: \x27\x5cu00E3\x27,\x0a\x09    auml: \x27\x5cu00E4\x27,\x0a\x09    aring: \x27\x5cu00E5\x27,\x0a\x09    aelig: \x27\x5cu00E6\x27,\x0a\x09    ccedil: \x27\x5cu00E7\x27,\x0a\x09    egrave: \x27\x5cu00E8\x27,\x0a\x09    eacute: \x27\x5cu00E9\x27,\x0a\x09    ecirc: \x27\x5cu00EA\x27,\x0a\x09    euml: \x27\x5cu00EB\x27,\x0a\x09    igrave: \x27\x5cu00EC\x27,\x0a\x09    iacute: \x27\x5cu00ED\x27,\x0a\x09    icirc: \x27\x5cu00EE\x27,\x0a\x09    iuml: \x27\x5cu00EF\x27,\x0a\x09    eth: \x27\x5cu00F0\x27,\x0a\x09    ntilde: \x27\x5cu00F1\x27,\x0a\x09    ograve: \x27\x5cu00F2\x27,\x0a\x09    oacute: \x27\x5cu00F3\x27,\x0a\x09    ocirc: \x27\x5cu00F4\x27,\x0a\x09    otilde: \x27\x5cu00F5\x27,\x0a\x09    ouml: \x27\x5cu00F6\x27,\x0a\x09    divide: \x27\x5cu00F7\x27,\x0a\x09    oslash: \x27\x5cu00F8\x27,\x0a\x09    ugrave: \x27\x5cu00F9\x27,\x0a\x09    uacute: \x27\x5cu00FA\x27,\x0a\x09    ucirc: \x27\x5cu00FB\x27,\x0a\x09    uuml: \x27\x5cu00FC\x27,\x0a\x09    yacute: \x27\x5cu00FD\x27,\x0a\x09    thorn: \x27\x5cu00FE\x27,\x0a\x09    yuml: \x27\x5cu00FF\x27,\x0a\x09    OElig: \x27\x5cu0152\x27,\x0a\x09    oelig: \x27\x5cu0153\x27,\x0a\x09    Scaron: \x27\x5cu0160\x27,\x0a\x09    scaron: \x27\x5cu0161\x27,\x0a\x09    Yuml: \x27\x5cu0178\x27,\x0a\x09    fnof: \x27\x5cu0192\x27,\x0a\x09    circ: \x27\x5cu02C6\x27,\x0a\x09    tilde: \x27\x5cu02DC\x27,\x0a\x09    Alpha: \x27\x5cu0391\x27,\x0a\x09    Beta: \x27\x5cu0392\x27,\x0a\x09    Gamma: \x27\x5cu0393\x27,\x0a\x09    Delta: \x27\x5cu0394\x27,\x0a\x09    Epsilon: \x27\x5cu0395\x27,\x0a\x09    Zeta: \x27\x5cu0396\x27,\x0a\x09    Eta: \x27\x5cu0397\x27,\x0a\x09    Theta: \x27\x5cu0398\x27,\x0a\x09    Iota: \x27\x5cu0399\x27,\x0a\x09    Kappa: \x27\x5cu039A\x27,\x0a\x09    Lambda: \x27\x5cu039B\x27,\x0a\x09    Mu: \x27\x5cu039C\x27,\x0a\x09    Nu: \x27\x5cu039D\x27,\x0a\x09    Xi: \x27\x5cu039E\x27,\x0a\x09    Omicron: \x27\x5cu039F\x27,\x0a\x09    Pi: \x27\x5cu03A0\x27,\x0a\x09    Rho: \x27\x5cu03A1\x27,\x0a\x09    Sigma: \x27\x5cu03A3\x27,\x0a\x09    Tau: \x27\x5cu03A4\x27,\x0a\x09    Upsilon: \x27\x5cu03A5\x27,\x0a\x09    Phi: \x27\x5cu03A6\x27,\x0a\x09    Chi: \x27\x5cu03A7\x27,\x0a\x09    Psi: \x27\x5cu03A8\x27,\x0a\x09    Omega: \x27\x5cu03A9\x27,\x0a\x09    alpha: \x27\x5cu03B1\x27,\x0a\x09    beta: \x27\x5cu03B2\x27,\x0a\x09    gamma: \x27\x5cu03B3\x27,\x0a\x09    delta: \x27\x5cu03B4\x27,\x0a\x09    epsilon: \x27\x5cu03B5\x27,\x0a\x09    zeta: \x27\x5cu03B6\x27,\x0a\x09    eta: \x27\x5cu03B7\x27,\x0a\x09    theta: \x27\x5cu03B8\x27,\x0a\x09    iota: \x27\x5cu03B9\x27,\x0a\x09    kappa: \x27\x5cu03BA\x27,\x0a\x09    lambda: \x27\x5cu03BB\x27,\x0a\x09    mu: \x27\x5cu03BC\x27,\x0a\x09    nu: \x27\x5cu03BD\x27,\x0a\x09    xi: \x27\x5cu03BE\x27,\x0a\x09    omicron: \x27\x5cu03BF\x27,\x0a\x09    pi: \x27\x5cu03C0\x27,\x0a\x09    rho: \x27\x5cu03C1\x27,\x0a\x09    sigmaf: \x27\x5cu03C2\x27,\x0a\x09    sigma: \x27\x5cu03C3\x27,\x0a\x09    tau: \x27\x5cu03C4\x27,\x0a\x09    upsilon: \x27\x5cu03C5\x27,\x0a\x09    phi: \x27\x5cu03C6\x27,\x0a\x09    chi: \x27\x5cu03C7\x27,\x0a\x09    psi: \x27\x5cu03C8\x27,\x0a\x09    omega: \x27\x5cu03C9\x27,\x0a\x09    thetasym: \x27\x5cu03D1\x27,\x0a\x09    upsih: \x27\x5cu03D2\x27,\x0a\x09    piv: \x27\x5cu03D6\x27,\x0a\x09    ensp: \x27\x5cu2002\x27,\x0a\x09    emsp: \x27\x5cu2003\x27,\x0a\x09    thinsp: \x27\x5cu2009\x27,\x0a\x09    zwnj: \x27\x5cu200C\x27,\x0a\x09    zwj: \x27\x5cu200D\x27,\x0a\x09    lrm: \x27\x5cu200E\x27,\x0a\x09    rlm: \x27\x5cu200F\x27,\x0a\x09    ndash: \x27\x5cu2013\x27,\x0a\x09    mdash: \x27\x5cu2014\x27,\x0a\x09    lsquo: \x27\x5cu2018\x27,\x0a\x09    rsquo: \x27\x5cu2019\x27,\x0a\x09    sbquo: \x27\x5cu201A\x27,\x0a\x09    ldquo: \x27\x5cu201C\x27,\x0a\x09    rdquo: \x27\x5cu201D\x27,\x0a\x09    bdquo: \x27\x5cu201E\x27,\x0a\x09    dagger: \x27\x5cu2020\x27,\x0a\x09    Dagger: \x27\x5cu2021\x27,\x0a\x09    bull: \x27\x5cu2022\x27,\x0a\x09    hellip: \x27\x5cu2026\x27,\x0a\x09    permil: \x27\x5cu2030\x27,\x0a\x09    prime: \x27\x5cu2032\x27,\x0a\x09    Prime: \x27\x5cu2033\x27,\x0a\x09    lsaquo: \x27\x5cu2039\x27,\x0a\x09    rsaquo: \x27\x5cu203A\x27,\x0a\x09    oline: \x27\x5cu203E\x27,\x0a\x09    frasl: \x27\x5cu2044\x27,\x0a\x09    euro: \x27\x5cu20AC\x27,\x0a\x09    image: \x27\x5cu2111\x27,\x0a\x09    weierp: \x27\x5cu2118\x27,\x0a\x09    real: \x27\x5cu211C\x27,\x0a\x09    trade: \x27\x5cu2122\x27,\x0a\x09    alefsym: \x27\x5cu2135\x27,\x0a\x09    larr: \x27\x5cu2190\x27,\x0a\x09    uarr: \x27\x5cu2191\x27,\x0a\x09    rarr: \x27\x5cu2192\x27,\x0a\x09    darr: \x27\x5cu2193\x27,\x0a\x09    harr: \x27\x5cu2194\x27,\x0a\x09    crarr: \x27\x5cu21B5\x27,\x0a\x09    lArr: \x27\x5cu21D0\x27,\x0a\x09    uArr: \x27\x5cu21D1\x27,\x0a\x09    rArr: \x27\x5cu21D2\x27,\x0a\x09    dArr: \x27\x5cu21D3\x27,\x0a\x09    hArr: \x27\x5cu21D4\x27,\x0a\x09    forall: \x27\x5cu2200\x27,\x0a\x09    part: \x27\x5cu2202\x27,\x0a\x09    exist: \x27\x5cu2203\x27,\x0a\x09    empty: \x27\x5cu2205\x27,\x0a\x09    nabla: \x27\x5cu2207\x27,\x0a\x09    isin: \x27\x5cu2208\x27,\x0a\x09    notin: \x27\x5cu2209\x27,\x0a\x09    ni: \x27\x5cu220B\x27,\x0a\x09    prod: \x27\x5cu220F\x27,\x0a\x09    sum: \x27\x5cu2211\x27,\x0a\x09    minus: \x27\x5cu2212\x27,\x0a\x09    lowast: \x27\x5cu2217\x27,\x0a\x09    radic: \x27\x5cu221A\x27,\x0a\x09    prop: \x27\x5cu221D\x27,\x0a\x09    infin: \x27\x5cu221E\x27,\x0a\x09    ang: \x27\x5cu2220\x27,\x0a\x09    and: \x27\x5cu2227\x27,\x0a\x09    or: \x27\x5cu2228\x27,\x0a\x09    cap: \x27\x5cu2229\x27,\x0a\x09    cup: \x27\x5cu222A\x27,\x0a\x09    int: \x27\x5cu222B\x27,\x0a\x09    there4: \x27\x5cu2234\x27,\x0a\x09    sim: \x27\x5cu223C\x27,\x0a\x09    cong: \x27\x5cu2245\x27,\x0a\x09    asymp: \x27\x5cu2248\x27,\x0a\x09    ne: \x27\x5cu2260\x27,\x0a\x09    equiv: \x27\x5cu2261\x27,\x0a\x09    le: \x27\x5cu2264\x27,\x0a\x09    ge: \x27\x5cu2265\x27,\x0a\x09    sub: \x27\x5cu2282\x27,\x0a\x09    sup: \x27\x5cu2283\x27,\x0a\x09    nsub: \x27\x5cu2284\x27,\x0a\x09    sube: \x27\x5cu2286\x27,\x0a\x09    supe: \x27\x5cu2287\x27,\x0a\x09    oplus: \x27\x5cu2295\x27,\x0a\x09    otimes: \x27\x5cu2297\x27,\x0a\x09    perp: \x27\x5cu22A5\x27,\x0a\x09    sdot: \x27\x5cu22C5\x27,\x0a\x09    lceil: \x27\x5cu2308\x27,\x0a\x09    rceil: \x27\x5cu2309\x27,\x0a\x09    lfloor: \x27\x5cu230A\x27,\x0a\x09    rfloor: \x27\x5cu230B\x27,\x0a\x09    loz: \x27\x5cu25CA\x27,\x0a\x09    spades: \x27\x5cu2660\x27,\x0a\x09    clubs: \x27\x5cu2663\x27,\x0a\x09    hearts: \x27\x5cu2665\x27,\x0a\x09    diams: \x27\x5cu2666\x27,\x0a\x09    lang: \x27\x5cu27E8\x27,\x0a\x09    rang: \x27\x5cu27E9\x27\x0a\x09};\x0a\x0a\x0a/***/ },\x0a/* 15 */\x0a/***/ function(module, exports, __webpack_require__) {\x0a\x0a\x09\x22use strict\x22;\x0a\x09Object.defineProperty(exports, \x22__esModule\x22, { value: true });\x0a\x09var error_handler_1 = __webpack_require__(10);\x0a\x09var scanner_1 = __webpack_require__(12);\x0a\x09var token_1 = __webpack_require__(13);\x0a\x09var Reader = (function () {\x0a\x09    function Reader() {\x0a\x09        this.values = [];\x0a\x09        this.curly = this.paren = -1;\x0a\x09    }\x0a\x09    // A function following one of those tokens is an expression.\x0a\x09    Reader.prototype.beforeFunctionExpression = function (t) {\x0a\x09        return [\x27(\x27, \x27{\x27, \x27[\x27, \x27in\x27, \x27typeof\x27, \x27instanceof\x27, \x27new\x27,\x0a\x09            \x27return\x27, \x27case\x27, \x27delete\x27, \x27throw\x27, \x27void\x27,\x0a\x09            // assignment operators\x0a\x09            \x27=\x27, \x27+=\x27, \x27-=\x27, \x27*=\x27, \x27**=\x27, \x27/=\x27, \x27%=\x27, \x27\x3c\x3c=\x27, \x27\x3e\x3e=\x27, \x27\x3e\x3e\x3e=\x27,\x0a\x09            \x27&=\x27, \x27|=\x27, \x27^=\x27, \x27,\x27,\x0a\x09            // binary/unary operators\x0a\x09            \x27+\x27, \x27-\x27, \x27*\x27, \x27**\x27, \x27/\x27, \x27%\x27, \x27++\x27, \x27--\x27, \x27\x3c\x3c\x27, \x27\x3e\x3e\x27, \x27\x3e\x3e\x3e\x27, \x27&\x27,\x0a\x09            \x27|\x27, \x27^\x27, \x27!\x27, \x27~\x27, \x27&&\x27, \x27||\x27, \x27?\x27, \x27:\x27, \x27===\x27, \x27==\x27, \x27\x3e=\x27,\x0a\x09            \x27\x3c=\x27, \x27\x3c\x27, \x27\x3e\x27, \x27!=\x27, \x27!==\x27].indexOf(t) \x3e= 0;\x0a\x09    };\x0a\x09    // Determine if forward slash (/) is an operator or part of a regular expression\x0a\x09    // https://github.com/mozilla/sweet.js/wiki/design\x0a\x09    Reader.prototype.isRegexStart = function () {\x0a\x09        var previous = this.values[this.values.length - 1];\x0a\x09        var regex = (previous !== null);\x0a\x09        switch (previous) {\x0a\x09            case \x27this\x27:\x0a\x09            case \x27]\x27:\x0a\x09                regex = false;\x0a\x09                break;\x0a\x09            case \x27)\x27:\x0a\x09                var keyword = this.values[this.paren - 1];\x0a\x09                regex = (keyword === \x27if\x27 || keyword === \x27while\x27 || keyword === \x27for\x27 || keyword === \x27with\x27);\x0a\x09                break;\x0a\x09            case \x27}\x27:\x0a\x09                // Dividing a function by anything makes little sense,\x0a\x09                // but we have to check for that.\x0a\x09                regex = false;\x0a\x09                if (this.values[this.curly - 3] === \x27function\x27) {\x0a\x09                    // Anonymous function, e.g. function(){} /42\x0a\x09                    var check = this.values[this.curly - 4];\x0a\x09                    regex = check ? !this.beforeFunctionExpression(check) : false;\x0a\x09                }\x0a\x09                else if (this.values[this.curly - 4] === \x27function\x27) {\x0a\x09                    // Named function, e.g. function f(){} /42/\x0a\x09                    var check = this.values[this.curly - 5];\x0a\x09                    regex = check ? !this.beforeFunctionExpression(check) : true;\x0a\x09                }\x0a\x09                break;\x0a\x09            default:\x0a\x09                break;\x0a\x09        }\x0a\x09        return regex;\x0a\x09    };\x0a\x09    Reader.prototype.push = function (token) {\x0a\x09        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {\x0a\x09            if (token.value === \x27{\x27) {\x0a\x09                this.curly = this.values.length;\x0a\x09            }\x0a\x09            else if (token.value === \x27(\x27) {\x0a\x09                this.paren = this.values.length;\x0a\x09            }\x0a\x09            this.values.push(token.value);\x0a\x09        }\x0a\x09        else {\x0a\x09            this.values.push(null);\x0a\x09        }\x0a\x09    };\x0a\x09    return Reader;\x0a\x09}());\x0a\x09var Tokenizer = (function () {\x0a\x09    function Tokenizer(code, config) {\x0a\x09        this.errorHandler = new error_handler_1.ErrorHandler();\x0a\x09        this.errorHandler.tolerant = config ? (typeof config.tolerant === \x27boolean\x27 && config.tolerant) : false;\x0a\x09        this.scanner = new scanner_1.Scanner(code, this.errorHandler);\x0a\x09        this.scanner.trackComment = config ? (typeof config.comment === \x27boolean\x27 && config.comment) : false;\x0a\x09        this.trackRange = config ? (typeof config.range === \x27boolean\x27 && config.range) : false;\x0a\x09        this.trackLoc = config ? (typeof config.loc === \x27boolean\x27 && config.loc) : false;\x0a\x09        this.buffer = [];\x0a\x09        this.reader = new Reader();\x0a\x09    }\x0a\x09    Tokenizer.prototype.errors = function () {\x0a\x09        return this.errorHandler.errors;\x0a\x09    };\x0a\x09    Tokenizer.prototype.getNextToken = function () {\x0a\x09        if (this.buffer.length === 0) {\x0a\x09            var comments = this.scanner.scanComments();\x0a\x09            if (this.scanner.trackComment) {\x0a\x09                for (var i = 0; i \x3c comments.length; ++i) {\x0a\x09                    var e = comments[i];\x0a\x09                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);\x0a\x09                    var comment = {\x0a\x09                        type: e.multiLine ? \x27BlockComment\x27 : \x27LineComment\x27,\x0a\x09                        value: value\x0a\x09                    };\x0a\x09                    if (this.trackRange) {\x0a\x09                        comment.range = e.range;\x0a\x09                    }\x0a\x09                    if (this.trackLoc) {\x0a\x09                        comment.loc = e.loc;\x0a\x09                    }\x0a\x09                    this.buffer.push(comment);\x0a\x09                }\x0a\x09            }\x0a\x09            if (!this.scanner.eof()) {\x0a\x09                var loc = void 0;\x0a\x09                if (this.trackLoc) {\x0a\x09                    loc = {\x0a\x09                        start: {\x0a\x09                            line: this.scanner.lineNumber,\x0a\x09                            column: this.scanner.index - this.scanner.lineStart\x0a\x09                        },\x0a\x09                        end: {}\x0a\x09                    };\x0a\x09                }\x0a\x09                var startRegex = (this.scanner.source[this.scanner.index] === \x27/\x27) && this.reader.isRegexStart();\x0a\x09                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();\x0a\x09                this.reader.push(token);\x0a\x09                var entry = {\x0a\x09                    type: token_1.TokenName[token.type],\x0a\x09                    value: this.scanner.source.slice(token.start, token.end)\x0a\x09                };\x0a\x09                if (this.trackRange) {\x0a\x09                    entry.range = [token.start, token.end];\x0a\x09                }\x0a\x09                if (this.trackLoc) {\x0a\x09                    loc.end = {\x0a\x09                        line: this.scanner.lineNumber,\x0a\x09                        column: this.scanner.index - this.scanner.lineStart\x0a\x09                    };\x0a\x09                    entry.loc = loc;\x0a\x09                }\x0a\x09                if (token.type === 9 /* RegularExpression */) {\x0a\x09                    var pattern = token.pattern;\x0a\x09                    var flags = token.flags;\x0a\x09                    entry.regex = { pattern: pattern, flags: flags };\x0a\x09                }\x0a\x09                this.buffer.push(entry);\x0a\x09            }\x0a\x09        }\x0a\x09        return this.buffer.shift();\x0a\x09    };\x0a\x09    return Tokenizer;\x0a\x09}());\x0a\x09exports.Tokenizer = Tokenizer;\x0a\x0a\x0a/***/ }\x0a/******/ ])\x0a});\x0a;   * q\xa1'}