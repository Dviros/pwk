var res = {'data':'HTTP/1.1 200 OK\x0aDate: Sun, 20 Sep 2020 15:12:22 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 02 Nov 2017 22:31:47 GMT\x0aETag: \x225c31b-55d078db29ac0-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aKeep-Alive: timeout=5, max=89\x0aConnection: Keep-Alive\x0aTransfer-Encoding: chunked\x0aContent-Type: application/javascript\x0a\x0a/*!\x0d\x0aCSSLint v1.0.4\x0d\x0aCopyright (c) 2016 Nicole Sullivan and Nicholas C. Zakas. All rights reserved.\x0d\x0a\x0d\x0aPermission is hereby granted, free of charge, to any person obtaining a copy\x0d\x0aof this software and associated documentation files (the \x27Software\x27), to deal\x0d\x0ain the Software without restriction, including without limitation the rights\x0d\x0ato use, copy, modify, merge, publish, distribute, sublicense, and/or sell\x0d\x0acopies of the Software, and to permit persons to whom the Software is\x0d\x0afurnished to do so, subject to the following conditions:\x0d\x0a\x0d\x0aThe above copyright notice and this permission notice shall be included in\x0d\x0aall copies or substantial portions of the Software.\x0d\x0a\x0d\x0aTHE SOFTWARE IS PROVIDED \x27AS IS\x27, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\x0d\x0aIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\x0d\x0aFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\x0d\x0aAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\x0d\x0aLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\x0d\x0aOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\x0d\x0aTHE SOFTWARE.\x0d\x0a\x0d\x0a*/\x0d\x0a\x0d\x0avar CSSLint = (function(){\x0d\x0a  var module = module || {},\x0d\x0a      exports = exports || {};\x0d\x0a\x0d\x0a/*!\x0d\x0aParser-Lib\x0d\x0aCopyright (c) 2009-2016 Nicholas C. Zakas. All rights reserved.\x0d\x0a\x0d\x0aPermission is hereby granted, free of charge, to any person obtaining a copy\x0d\x0aof this software and associated documentation files (the \x22Software\x22), to deal\x0d\x0ain the Software without restriction, including without limitation the rights\x0d\x0ato use, copy, modify, merge, publish, distribute, sublicense, and/or sell\x0d\x0acopies of the Software, and to permit persons to whom the Software is\x0d\x0afurnished to do so, subject to the following conditions:\x0d\x0a\x0d\x0aThe above copyright notice and this permission notice shall be included in\x0d\x0aall copies or substantial portions of the Software.\x0d\x0a\x0d\x0aTHE SOFTWARE IS PROVIDED \x22AS IS\x22, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\x0d\x0aIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\x0d\x0aFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\x0d\x0aAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\x0d\x0aLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\x0d\x0aOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\x0d\x0aTHE SOFTWARE.\x0d\x0a*/\x0d\x0a/* Version v1.1.0, Build time: 6-December-2016 10:31:29 */\x0d\x0avar parserlib = (function () {\x0d\x0avar require;\x0d\x0arequire=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\x22function\x22&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\x22Cannot find module \x27\x22+o+\x22\x27\x22);throw f.code=\x22MODULE_NOT_FOUND\x22,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\x22function\x22&&require;for(var o=0;o\x3cr.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0a/* exported Colors */\x0d\x0a\x0d\x0avar Colors = module.exports = {\x0d\x0a    __proto__       :null,\x0d\x0a    aliceblue       :\x22#f0f8ff\x22,\x0d\x0a    antiquewhite    :\x22#faebd7\x22,\x0d\x0a    aqua            :\x22#00ffff\x22,\x0d\x0a    aquamarine      :\x22#7fffd4\x22,\x0d\x0a    azure           :\x22#f0ffff\x22,\x0d\x0a    beige           :\x22#f5f5dc\x22,\x0d\x0a    bisque          :\x22#ffe4c4\x22,\x0d\x0a    black           :\x22#000000\x22,\x0d\x0a    blanchedalmond  :\x22#ffebcd\x22,\x0d\x0a    blue            :\x22#0000ff\x22,\x0d\x0a    blueviolet      :\x22#8a2be2\x22,\x0d\x0a    brown           :\x22#a52a2a\x22,\x0d\x0a    burlywood       :\x22#deb887\x22,\x0d\x0a    cadetblue       :\x22#5f9ea0\x22,\x0d\x0a    chartreuse      :\x22#7fff00\x22,\x0d\x0a    chocolate       :\x22#d2691e\x22,\x0d\x0a    coral           :\x22#ff7f50\x22,\x0d\x0a    cornflowerblue  :\x22#6495ed\x22,\x0d\x0a    cornsilk        :\x22#fff8dc\x22,\x0d\x0a    crimson         :\x22#dc143c\x22,\x0d\x0a    cyan            :\x22#00ffff\x22,\x0d\x0a    darkblue        :\x22#00008b\x22,\x0d\x0a    darkcyan        :\x22#008b8b\x22,\x0d\x0a    darkgoldenrod   :\x22#b8860b\x22,\x0d\x0a    darkgray        :\x22#a9a9a9\x22,\x0d\x0a    darkgrey        :\x22#a9a9a9\x22,\x0d\x0a    darkgreen       :\x22#006400\x22,\x0d\x0a    darkkhaki       :\x22#bdb76b\x22,\x0d\x0a    darkmagenta     :\x22#8b008b\x22,\x0d\x0a    darkolivegreen  :\x22#556b2f\x22,\x0d\x0a    darkorange      :\x22#ff8c00\x22,\x0d\x0a    darkorchid      :\x22#9932cc\x22,\x0d\x0a    darkred         :\x22#8b0000\x22,\x0d\x0a    darksalmon      :\x22#e9967a\x22,\x0d\x0a    darkseagreen    :\x22#8fbc8f\x22,\x0d\x0a    darkslateblue   :\x22#483d8b\x22,\x0d\x0a    darkslategray   :\x22#2f4f4f\x22,\x0d\x0a    darkslategrey   :\x22#2f4f4f\x22,\x0d\x0a    darkturquoise   :\x22#00ced1\x22,\x0d\x0a    darkviolet      :\x22#9400d3\x22,\x0d\x0a    deeppink        :\x22#ff1493\x22,\x0d\x0a    deepskyblue     :\x22#00bfff\x22,\x0d\x0a    dimgray         :\x22#696969\x22,\x0d\x0a    dimgrey         :\x22#696969\x22,\x0d\x0a    dodgerblue      :\x22#1e90ff\x22,\x0d\x0a    firebrick       :\x22#b22222\x22,\x0d\x0a    floralwhite     :\x22#fffaf0\x22,\x0d\x0a    forestgreen     :\x22#228b22\x22,\x0d\x0a    fuchsia         :\x22#ff00ff\x22,\x0d\x0a    gainsboro       :\x22#dcdcdc\x22,\x0d\x0a    ghostwhite      :\x22#f8f8ff\x22,\x0d\x0a    gold            :\x22#ffd700\x22,\x0d\x0a    goldenrod       :\x22#daa520\x22,\x0d\x0a    gray            :\x22#808080\x22,\x0d\x0a    grey            :\x22#808080\x22,\x0d\x0a    green           :\x22#008000\x22,\x0d\x0a    greenyellow     :\x22#adff2f\x22,\x0d\x0a    honeydew        :\x22#f0fff0\x22,\x0d\x0a    hotpink         :\x22#ff69b4\x22,\x0d\x0a    indianred       :\x22#cd5c5c\x22,\x0d\x0a    indigo          :\x22#4b0082\x22,\x0d\x0a    ivory           :\x22#fffff0\x22,\x0d\x0a    khaki           :\x22#f0e68c\x22,\x0d\x0a    lavender        :\x22#e6e6fa\x22,\x0d\x0a    lavenderblush   :\x22#fff0f5\x22,\x0d\x0a    lawngreen       :\x22#7cfc00\x22,\x0d\x0a    lemonchiffon    :\x22#fffacd\x22,\x0d\x0a    lightblue       :\x22#add8e6\x22,\x0d\x0a    lightcoral      :\x22#f08080\x22,\x0d\x0a    lightcyan       :\x22#e0ffff\x22,\x0d\x0a    lightgoldenrodyellow  :\x22#fafad2\x22,\x0d\x0a    lightgray       :\x22#d3d3d3\x22,\x0d\x0a    lightgrey       :\x22#d3d3d3\x22,\x0d\x0a    lightgreen      :\x22#90ee90\x22,\x0d\x0a    lightpink       :\x22#ffb6c1\x22,\x0d\x0a    lightsalmon     :\x22#ffa07a\x22,\x0d\x0a    lightseagreen   :\x22#20b2aa\x22,\x0d\x0a    lightskyblue    :\x22#87cefa\x22,\x0d\x0a    lightslategray  :\x22#778899\x22,\x0d\x0a    lightslategrey  :\x22#778899\x22,\x0d\x0a    lightsteelblue  :\x22#b0c4de\x22,\x0d\x0a    lightyellow     :\x22#ffffe0\x22,\x0d\x0a    lime            :\x22#00ff00\x22,\x0d\x0a    limegreen       :\x22#32cd32\x22,\x0d\x0a    linen           :\x22#faf0e6\x22,\x0d\x0a    magenta         :\x22#ff00ff\x22,\x0d\x0a    maroon          :\x22#800000\x22,\x0d\x0a    mediumaquamarine:\x22#66cdaa\x22,\x0d\x0a    mediumblue      :\x22#0000cd\x22,\x0d\x0a    mediumorchid    :\x22#ba55d3\x22,\x0d\x0a    mediumpurple    :\x22#9370d8\x22,\x0d\x0a    mediumseagreen  :\x22#3cb371\x22,\x0d\x0a    mediumslateblue :\x22#7b68ee\x22,\x0d\x0a    mediumspringgreen   :\x22#00fa9a\x22,\x0d\x0a    mediumturquoise :\x22#48d1cc\x22,\x0d\x0a    mediumvioletred :\x22#c71585\x22,\x0d\x0a    midnightblue    :\x22#191970\x22,\x0d\x0a    mintcream       :\x22#f5fffa\x22,\x0d\x0a    mistyrose       :\x22#ffe4e1\x22,\x0d\x0a    moccasin        :\x22#ffe4b5\x22,\x0d\x0a    navajowhite     :\x22#ffdead\x22,\x0d\x0a    navy            :\x22#000080\x22,\x0d\x0a    oldlace         :\x22#fdf5e6\x22,\x0d\x0a    olive           :\x22#808000\x22,\x0d\x0a    olivedrab       :\x22#6b8e23\x22,\x0d\x0a    orange          :\x22#ffa500\x22,\x0d\x0a    orangered       :\x22#ff4500\x22,\x0d\x0a    orchid          :\x22#da70d6\x22,\x0d\x0a    palegoldenrod   :\x22#eee8aa\x22,\x0d\x0a    palegreen       :\x22#98fb98\x22,\x0d\x0a    paleturquoise   :\x22#afeeee\x22,\x0d\x0a    palevioletred   :\x22#d87093\x22,\x0d\x0a    papayawhip      :\x22#ffefd5\x22,\x0d\x0a    peachpuff       :\x22#ffdab9\x22,\x0d\x0a    peru            :\x22#cd853f\x22,\x0d\x0a    pink            :\x22#ffc0cb\x22,\x0d\x0a    plum            :\x22#dda0dd\x22,\x0d\x0a    powderblue      :\x22#b0e0e6\x22,\x0d\x0a    purple          :\x22#800080\x22,\x0d\x0a    red             :\x22#ff0000\x22,\x0d\x0a    rosybrown       :\x22#bc8f8f\x22,\x0d\x0a    royalblue       :\x22#4169e1\x22,\x0d\x0a    saddlebrown     :\x22#8b4513\x22,\x0d\x0a    salmon          :\x22#fa8072\x22,\x0d\x0a    sandybrown      :\x22#f4a460\x22,\x0d\x0a    seagreen        :\x22#2e8b57\x22,\x0d\x0a    seashell        :\x22#fff5ee\x22,\x0d\x0a    sienna          :\x22#a0522d\x22,\x0d\x0a    silver          :\x22#c0c0c0\x22,\x0d\x0a    skyblue         :\x22#87ceeb\x22,\x0d\x0a    slateblue       :\x22#6a5acd\x22,\x0d\x0a    slategray       :\x22#708090\x22,\x0d\x0a    slategrey       :\x22#708090\x22,\x0d\x0a    snow            :\x22#fffafa\x22,\x0d\x0a    springgreen     :\x22#00ff7f\x22,\x0d\x0a    steelblue       :\x22#4682b4\x22,\x0d\x0a    tan             :\x22#d2b48c\x22,\x0d\x0a    teal            :\x22#008080\x22,\x0d\x0a    thistle         :\x22#d8bfd8\x22,\x0d\x0a    tomato          :\x22#ff6347\x22,\x0d\x0a    turquoise       :\x22#40e0d0\x22,\x0d\x0a    violet          :\x22#ee82ee\x22,\x0d\x0a    wheat           :\x22#f5deb3\x22,\x0d\x0a    white           :\x22#ffffff\x22,\x0d\x0a    whitesmoke      :\x22#f5f5f5\x22,\x0d\x0a    yellow          :\x22#ffff00\x22,\x0d\x0a    yellowgreen     :\x22#9acd32\x22,\x0d\x0a    //\x27currentColor\x27 color keyword https://www.w3.org/TR/css3-color/#currentcolor\x0d\x0a    currentColor        :\x22The value of the \x27color\x27 property.\x22,\x0d\x0a    //CSS2 system colors https://www.w3.org/TR/css3-color/#css2-system\x0d\x0a    activeBorder        :\x22Active window border.\x22,\x0d\x0a    activecaption       :\x22Active window caption.\x22,\x0d\x0a    appworkspace        :\x22Background color of multiple document interface.\x22,\x0d\x0a    background          :\x22Desktop background.\x22,\x0d\x0a    buttonface          :\x22The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.\x22,\x0d\x0a    buttonhighlight     :\x22The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\x22,\x0d\x0a    buttonshadow        :\x22The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\x22,\x0d\x0a    buttontext          :\x22Text on push buttons.\x22,\x0d\x0a    captiontext         :\x22Text in caption, size box, and scrollbar arrow box.\x22,\x0d\x0a    graytext            :\x22Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.\x22,\x0d\x0a    greytext            :\x22Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.\x22,\x0d\x0a    highlight           :\x22Item(s) selected in a control.\x22,\x0d\x0a    highlighttext       :\x22Text of item(s) selected in a control.\x22,\x0d\x0a    inactiveborder      :\x22Inactive window border.\x22,\x0d\x0a    inactivecaption     :\x22Inactive window caption.\x22,\x0d\x0a    inactivecaptiontext :\x22Color of text in an inactive caption.\x22,\x0d\x0a    infobackground      :\x22Background color for tooltip controls.\x22,\x0d\x0a    infotext            :\x22Text color for tooltip controls.\x22,\x0d\x0a    menu                :\x22Menu background.\x22,\x0d\x0a    menutext            :\x22Text in menus.\x22,\x0d\x0a    scrollbar           :\x22Scroll bar gray area.\x22,\x0d\x0a    threeddarkshadow    :\x22The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\x22,\x0d\x0a    threedface          :\x22The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\x22,\x0d\x0a    threedhighlight     :\x22The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\x22,\x0d\x0a    threedlightshadow   :\x22The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\x22,\x0d\x0a    threedshadow        :\x22The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\x22,\x0d\x0a    window              :\x22Window background.\x22,\x0d\x0a    windowframe         :\x22Window frame.\x22,\x0d\x0a    windowtext          :\x22Text in windows.\x22\x0d\x0a};\x0d\x0a\x0d\x0a},{}],2:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = Combinator;\x0d\x0a\x0d\x0avar SyntaxUnit = require(\x22../util/SyntaxUnit\x22);\x0d\x0a\x0d\x0avar Parser = require(\x22./Parser\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * Represents a selector combinator (whitespace, +, \x3e).\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class Combinator\x0d\x0a * @extends parserlib.util.SyntaxUnit\x0d\x0a * @constructor\x0d\x0a * @param {String} text The text representation of the unit.\x0d\x0a * @param {int} line The line of text on which the unit resides.\x0d\x0a * @param {int} col The column of text on which the unit resides.\x0d\x0a */\x0d\x0afunction Combinator(text, line, col) {\x0d\x0a\x0d\x0a    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The type of modifier.\x0d\x0a     * @type String\x0d\x0a     * @property type\x0d\x0a     */\x0d\x0a    this.type = \x22unknown\x22;\x0d\x0a\x0d\x0a    //pretty simple\x0d\x0a    if (/^\x5cs+$/.test(text)) {\x0d\x0a        this.type = \x22descendant\x22;\x0d\x0a    } else if (text === \x22\x3e\x22) {\x0d\x0a        this.type = \x22child\x22;\x0d\x0a    } else if (text === \x22+\x22) {\x0d\x0a        this.type = \x22adjacent-sibling\x22;\x0d\x0a    } else if (text === \x22~\x22) {\x0d\x0a        this.type = \x22sibling\x22;\x0d\x0a    }\x0d\x0a\x0d\x0a}\x0d\x0a\x0d\x0aCombinator.prototype = new SyntaxUnit();\x0d\x0aCombinator.prototype.constructor = Combinator;\x0d\x0a\x0d\x0a\x0d\x0a},{\x22../util/SyntaxUnit\x22:26,\x22./Parser\x22:6}],3:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = Matcher;\x0d\x0a\x0d\x0avar StringReader = require(\x22../util/StringReader\x22);\x0d\x0avar SyntaxError = require(\x22../util/SyntaxError\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * This class implements a combinator library for matcher functions.\x0d\x0a * The combinators are described at:\x0d\x0a * https://developer.mozilla.org/en-US/docs/Web/CSS/Value_definition_syntax#Component_value_combinators\x0d\x0a */\x0d\x0afunction Matcher(matchFunc, toString) {\x0d\x0a    this.match = function(expression) {\x0d\x0a        // Save/restore marks to ensure that failed matches always restore\x0d\x0a        // the original location in the expression.\x0d\x0a        var result;\x0d\x0a        expression.mark();\x0d\x0a        result = matchFunc(expression);\x0d\x0a        if (result) {\x0d\x0a            expression.drop();\x0d\x0a        } else {\x0d\x0a            expression.restore();\x0d\x0a        }\x0d\x0a        return result;\x0d\x0a    };\x0d\x0a    this.toString = typeof toString === \x22function\x22 ? toString : function() {\x0d\x0a        return toString;\x0d\x0a    };\x0d\x0a}\x0d\x0a\x0d\x0a/** Precedence table of combinators. */\x0d\x0aMatcher.prec = {\x0d\x0a    MOD:    5,\x0d\x0a    SEQ:    4,\x0d\x0a    ANDAND: 3,\x0d\x0a    OROR:   2,\x0d\x0a    ALT:    1\x0d\x0a};\x0d\x0a\x0d\x0a/** Simple recursive-descent grammar to build matchers from strings. */\x0d\x0aMatcher.parse = function(str) {\x0d\x0a    var reader, eat, expr, oror, andand, seq, mod, term, result;\x0d\x0a    reader = new StringReader(str);\x0d\x0a    eat = function(matcher) {\x0d\x0a        var result = reader.readMatch(matcher);\x0d\x0a        if (result === null) {\x0d\x0a            throw new SyntaxError(\x0d\x0a                \x22Expected \x22+matcher, reader.getLine(), reader.getCol());\x0d\x0a        }\x0d\x0a        return result;\x0d\x0a    };\x0d\x0a    expr = function() {\x0d\x0a        // expr = oror (\x22 | \x22 oror)*\x0d\x0a        var m = [ oror() ];\x0d\x0a        while (reader.readMatch(\x22 | \x22) !== null) {\x0d\x0a            m.push(oror());\x0d\x0a        }\x0d\x0a        return m.length === 1 ? m[0] : Matcher.alt.apply(Matcher, m);\x0d\x0a    };\x0d\x0a    oror = function() {\x0d\x0a        // oror = andand ( \x22 || \x22 andand)*\x0d\x0a        var m = [ andand() ];\x0d\x0a        while (reader.readMatch(\x22 || \x22) !== null) {\x0d\x0a            m.push(andand());\x0d\x0a        }\x0d\x0a        return m.length === 1 ? m[0] : Matcher.oror.apply(Matcher, m);\x0d\x0a    };\x0d\x0a    andand = function() {\x0d\x0a        // andand = seq ( \x22 && \x22 seq)*\x0d\x0a        var m = [ seq() ];\x0d\x0a        while (reader.readMatch(\x22 && \x22) !== null) {\x0d\x0a            m.push(seq());\x0d\x0a        }\x0d\x0a        return m.length === 1 ? m[0] : Matcher.andand.apply(Matcher, m);\x0d\x0a    };\x0d\x0a    seq = function() {\x0d\x0a        // seq = mod ( \x22 \x22 mod)*\x0d\x0a        var m = [ mod() ];\x0d\x0a        while (reader.readMatch(/^ (?![&|\x5c]])/) !== null) {\x0d\x0a            m.push(mod());\x0d\x0a        }\x0d\x0a        return m.length === 1 ? m[0] : Matcher.seq.apply(Matcher, m);\x0d\x0a    };\x0d\x0a    mod = function() {\x0d\x0a        // mod = term ( \x22?\x22 | \x22*\x22 | \x22+\x22 | \x22#\x22 | \x22{\x3cnum\x3e,\x3cnum\x3e}\x22 )?\x0d\x0a        var m = term();\x0d\x0a        if (reader.readMatch(\x22?\x22) !== null) {\x0d\x0a            return m.question();\x0d\x0a        } else if (reader.readMatch(\x22*\x22) !== null) {\x0d\x0a            return m.star();\x0d\x0a        } else if (reader.readMatch(\x22+\x22) !== null) {\x0d\x0a            return m.plus();\x0d\x0a        } else if (reader.readMatch(\x22#\x22) !== null) {\x0d\x0a            return m.hash();\x0d\x0a        } else if (reader.readMatch(/^\x5c{\x5cs*/) !== null) {\x0d\x0a            var min = eat(/^\x5cd+/);\x0d\x0a            eat(/^\x5cs*,\x5cs*/);\x0d\x0a            var max = eat(/^\x5cd+/);\x0d\x0a            eat(/^\x5cs*\x5c}/);\x0d\x0a            return m.braces(+min, +max);\x0d\x0a        }\x0d\x0a        return m;\x0d\x0a    };\x0d\x0a    term = function() {\x0d\x0a        // term = \x3cnt\x3e | literal | \x22[ \x22 expression \x22 ]\x22\x0d\x0a        if (reader.readMatch(\x22[ \x22) !== null) {\x0d\x0a            var m = expr();\x0d\x0a            eat(\x22 ]\x22);\x0d\x0a            return m;\x0d\x0a        }\x0d\x0a        return Matcher.fromType(eat(/^[^ ?*+#{]+/));\x0d\x0a    };\x0d\x0a    result = expr();\x0d\x0a    if (!reader.eof()) {\x0d\x0a        throw new SyntaxError(\x0d\x0a            \x22Expected end of string\x22, reader.getLine(), reader.getCol());\x0d\x0a    }\x0d\x0a    return result;\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Convert a string to a matcher (parsing simple alternations),\x0d\x0a * or do nothing if the argument is already a matcher.\x0d\x0a */\x0d\x0aMatcher.cast = function(m) {\x0d\x0a    if (m instanceof Matcher) {\x0d\x0a        return m;\x0d\x0a    }\x0d\x0a    return Matcher.parse(m);\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Create a matcher for a single type.\x0d\x0a */\x0d\x0aMatcher.fromType = function(type) {\x0d\x0a    // Late require of ValidationTypes to break a dependency cycle.\x0d\x0a    var ValidationTypes = require(\x22./ValidationTypes\x22);\x0d\x0a    return new Matcher(function(expression) {\x0d\x0a        return expression.hasNext() && ValidationTypes.isType(expression, type);\x0d\x0a    }, type);\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Create a matcher for one or more juxtaposed words, which all must\x0d\x0a * occur, in the given order.\x0d\x0a */\x0d\x0aMatcher.seq = function() {\x0d\x0a    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);\x0d\x0a    if (ms.length === 1) {\x0d\x0a        return ms[0];\x0d\x0a    }\x0d\x0a    return new Matcher(function(expression) {\x0d\x0a        var i, result = true;\x0d\x0a        for (i = 0; result && i \x3c ms.length; i++) {\x0d\x0a            result = ms[i].match(expression);\x0d\x0a        }\x0d\x0a        return result;\x0d\x0a    }, function(prec) {\x0d\x0a        var p = Matcher.prec.SEQ;\x0d\x0a        var s = ms.map(function(m) {\x0d\x0a            return m.toString(p);\x0d\x0a        }).join(\x22 \x22);\x0d\x0a        if (prec \x3e p) {\x0d\x0a            s = \x22[ \x22 + s + \x22 ]\x22;\x0d\x0a        }\x0d\x0a        return s;\x0d\x0a    });\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Create a matcher for one or more alternatives, where exactly one\x0d\x0a * must occur.\x0d\x0a */\x0d\x0aMatcher.alt = function() {\x0d\x0a    var ms = Array.prototype.slice.call(arguments).map(Matcher.cast);\x0d\x0a    if (ms.length === 1) {\x0d\x0a        return ms[0];\x0d\x0a    }\x0d\x0a    return new Matcher(function(expression) {\x0d\x0a        var i, result = false;\x0d\x0a        for (i = 0; !result && i \x3c ms.length; i++) {\x0d\x0a            result = ms[i].match(expression);\x0d\x0a        }\x0d\x0a        return result;\x0d\x0a    }, function(prec) {\x0d\x0a        var p = Matcher.prec.ALT;\x0d\x0a        var s = ms.map(function(m) {\x0d\x0a            return m.toString(p);\x0d\x0a        }).join(\x22 | \x22);\x0d\x0a        if (prec \x3e p) {\x0d\x0a            s = \x22[ \x22 + s + \x22 ]\x22;\x0d\x0a        }\x0d\x0a        return s;\x0d\x0a    });\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Create a matcher for two or more options.  This implements the\x0d\x0a * double bar (||) and double ampersand (&&) operators, as well as\x0d\x0a * variants of && where some of the alternatives are optional.\x0d\x0a * This will backtrack through even successful matches to try to\x0d\x0a * maximize the number of items matched.\x0d\x0a */\x0d\x0aMatcher.many = function(required) {\x0d\x0a    var ms = Array.prototype.slice.call(arguments, 1).reduce(function(acc, v) {\x0d\x0a        if (v.expand) {\x0d\x0a            // Insert all of the options for the given complex rule as\x0d\x0a            // individual options.\x0d\x0a            var ValidationTypes = require(\x22./ValidationTypes\x22);\x0d\x0a            acc.push.apply(acc, ValidationTypes.complex[v.expand].options);\x0d\x0a        } else {\x0d\x0a            acc.push(Matcher.cast(v));\x0d\x0a        }\x0d\x0a        return acc;\x0d\x0a    }, []);\x0d\x0a\x0d\x0a    if (required === true) {\x0d\x0a        required = ms.map(function() {\x0d\x0a            return true;\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a    var result = new Matcher(function(expression) {\x0d\x0a        var seen = [], max = 0, pass = 0;\x0d\x0a        var success = function(matchCount) {\x0d\x0a            if (pass === 0) {\x0d\x0a                max = Math.max(matchCount, max);\x0d\x0a                return matchCount === ms.length;\x0d\x0a            } else {\x0d\x0a                return matchCount === max;\x0d\x0a            }\x0d\x0a        };\x0d\x0a        var tryMatch = function(matchCount) {\x0d\x0a            for (var i = 0; i \x3c ms.length; i++) {\x0d\x0a                if (seen[i]) {\x0d\x0a                    continue;\x0d\x0a                }\x0d\x0a                expression.mark();\x0d\x0a                if (ms[i].match(expression)) {\x0d\x0a                    seen[i] = true;\x0d\x0a                    // Increase matchCount iff this was a required element\x0d\x0a                    // (or if all the elements are optional)\x0d\x0a                    if (tryMatch(matchCount + ((required === false || required[i]) ? 1 : 0))) {\x0d\x0a                        expression.drop();\x0d\x0a                        return true;\x0d\x0a                    }\x0d\x0a                    // Backtrack: try *not* matching using this rule, and\x0d\x0a                    // let\x27s see if it leads to a better overall match.\x0d\x0a                    expression.restore();\x0d\x0a                    seen[i] = false;\x0d\x0a                } else {\x0d\x0a                    expression.drop();\x0d\x0a                }\x0d\x0a            }\x0d\x0a            return success(matchCount);\x0d\x0a        };\x0d\x0a        if (!tryMatch(0)) {\x0d\x0a            // Couldn\x27t get a complete match, retrace our steps to make the\x0d\x0a            // match with the maximum # of required elements.\x0d\x0a            pass++;\x0d\x0a            tryMatch(0);\x0d\x0a        }\x0d\x0a\x0d\x0a        if (required === false) {\x0d\x0a            return max \x3e 0;\x0d\x0a        }\x0d\x0a        // Use finer-grained specification of which matchers are required.\x0d\x0a        for (var i = 0; i \x3c ms.length; i++) {\x0d\x0a            if (required[i] && !seen[i]) {\x0d\x0a                return false;\x0d\x0a            }\x0d\x0a        }\x0d\x0a        return true;\x0d\x0a    }, function(prec) {\x0d\x0a        var p = required === false ? Matcher.prec.OROR : Matcher.prec.ANDAND;\x0d\x0a        var s = ms.map(function(m, i) {\x0d\x0a            if (required !== false && !required[i]) {\x0d\x0a                return m.toString(Matcher.prec.MOD) + \x22?\x22;\x0d\x0a            }\x0d\x0a            return m.toString(p);\x0d\x0a        }).join(required === false ? \x22 || \x22 : \x22 && \x22);\x0d\x0a        if (prec \x3e p) {\x0d\x0a            s = \x22[ \x22 + s + \x22 ]\x22;\x0d\x0a        }\x0d\x0a        return s;\x0d\x0a    });\x0d\x0a    result.options = ms;\x0d\x0a    return result;\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Create a matcher for two or more options, where all options are\x0d\x0a * mandatory but they may appear in any order.\x0d\x0a */\x0d\x0aMatcher.andand = function() {\x0d\x0a    var args = Array.prototype.slice.call(arguments);\x0d\x0a    args.unshift(true);\x0d\x0a    return Matcher.many.apply(Matcher, args);\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Create a matcher for two or more options, where options are\x0d\x0a * optional and may appear in any order, but at least one must be\x0d\x0a * present.\x0d\x0a */\x0d\x0aMatcher.oror = function() {\x0d\x0a    var args = Array.prototype.slice.call(arguments);\x0d\x0a    args.unshift(false);\x0d\x0a    return Matcher.many.apply(Matcher, args);\x0d\x0a};\x0d\x0a\x0d\x0a/** Instance methods on Matchers. */\x0d\x0aMatcher.prototype = {\x0d\x0a    constructor: Matcher,\x0d\x0a    // These are expected to be overridden in every instance.\x0d\x0a    match: function() { throw new Error(\x22unimplemented\x22); },\x0d\x0a    toString: function() { throw new Error(\x22unimplemented\x22); },\x0d\x0a    // This returns a standalone function to do the matching.\x0d\x0a    func: function() { return this.match.bind(this); },\x0d\x0a    // Basic combinators\x0d\x0a    then: function(m) { return Matcher.seq(this, m); },\x0d\x0a    or: function(m) { return Matcher.alt(this, m); },\x0d\x0a    andand: function(m) { return Matcher.many(true, this, m); },\x0d\x0a    oror: function(m) { return Matcher.many(false, this, m); },\x0d\x0a    // Component value multipliers\x0d\x0a    star: function() { return this.braces(0, Infinity, \x22*\x22); },\x0d\x0a    plus: function() { return this.braces(1, Infinity, \x22+\x22); },\x0d\x0a    question: function() { return this.braces(0, 1, \x22?\x22); },\x0d\x0a    hash: function() {\x0d\x0a        return this.braces(1, Infinity, \x22#\x22, Matcher.cast(\x22,\x22));\x0d\x0a    },\x0d\x0a    braces: function(min, max, marker, optSep) {\x0d\x0a        var m1 = this, m2 = optSep ? optSep.then(this) : this;\x0d\x0a        if (!marker) {\x0d\x0a            marker = \x22{\x22 + min + \x22,\x22 + max + \x22}\x22;\x0d\x0a        }\x0d\x0a        return new Matcher(function(expression) {\x0d\x0a            var result = true, i;\x0d\x0a            for (i = 0; i \x3c max; i++) {\x0d\x0a                if (i \x3e 0 && optSep) {\x0d\x0a                    result = m2.match(expression);\x0d\x0a                } else {\x0d\x0a                    result = m1.match(expression);\x0d\x0a                }\x0d\x0a                if (!result) {\x0d\x0a                    break;\x0d\x0a                }\x0d\x0a            }\x0d\x0a            return i \x3e= min;\x0d\x0a        }, function() {\x0d\x0a            return m1.toString(Matcher.prec.MOD) + marker;\x0d\x0a        });\x0d\x0a    }\x0d\x0a};\x0d\x0a\x0d\x0a},{\x22../util/StringReader\x22:24,\x22../util/SyntaxError\x22:25,\x22./ValidationTypes\x22:21}],4:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = MediaFeature;\x0d\x0a\x0d\x0avar SyntaxUnit = require(\x22../util/SyntaxUnit\x22);\x0d\x0a\x0d\x0avar Parser = require(\x22./Parser\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * Represents a media feature, such as max-width:500.\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class MediaFeature\x0d\x0a * @extends parserlib.util.SyntaxUnit\x0d\x0a * @constructor\x0d\x0a * @param {SyntaxUnit} name The name of the feature.\x0d\x0a * @param {SyntaxUnit} value The value of the feature or null if none.\x0d\x0a */\x0d\x0afunction MediaFeature(name, value) {\x0d\x0a\x0d\x0a    SyntaxUnit.call(this, \x22(\x22 + name + (value !== null ? \x22:\x22 + value : \x22\x22) + \x22)\x22, name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The name of the media feature\x0d\x0a     * @type String\x0d\x0a     * @property name\x0d\x0a     */\x0d\x0a    this.name = name;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The value for the feature or null if there is none.\x0d\x0a     * @type SyntaxUnit\x0d\x0a     * @property value\x0d\x0a     */\x0d\x0a    this.value = value;\x0d\x0a}\x0d\x0a\x0d\x0aMediaFeature.prototype = new SyntaxUnit();\x0d\x0aMediaFeature.prototype.constructor = MediaFeature;\x0d\x0a\x0d\x0a\x0d\x0a},{\x22../util/SyntaxUnit\x22:26,\x22./Parser\x22:6}],5:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = MediaQuery;\x0d\x0a\x0d\x0avar SyntaxUnit = require(\x22../util/SyntaxUnit\x22);\x0d\x0a\x0d\x0avar Parser = require(\x22./Parser\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * Represents an individual media query.\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class MediaQuery\x0d\x0a * @extends parserlib.util.SyntaxUnit\x0d\x0a * @constructor\x0d\x0a * @param {String} modifier The modifier \x22not\x22 or \x22only\x22 (or null).\x0d\x0a * @param {String} mediaType The type of media (i.e., \x22print\x22).\x0d\x0a * @param {Array} parts Array of selectors parts making up this selector.\x0d\x0a * @param {int} line The line of text on which the unit resides.\x0d\x0a * @param {int} col The column of text on which the unit resides.\x0d\x0a */\x0d\x0afunction MediaQuery(modifier, mediaType, features, line, col) {\x0d\x0a\x0d\x0a    SyntaxUnit.call(this, (modifier ? modifier + \x22 \x22: \x22\x22) + (mediaType ? mediaType : \x22\x22) + (mediaType && features.length \x3e 0 ? \x22 and \x22 : \x22\x22) + features.join(\x22 and \x22), line, col, Parser.MEDIA_QUERY_TYPE);\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The media modifier (\x22not\x22 or \x22only\x22)\x0d\x0a     * @type String\x0d\x0a     * @property modifier\x0d\x0a     */\x0d\x0a    this.modifier = modifier;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The mediaType (i.e., \x22print\x22)\x0d\x0a     * @type String\x0d\x0a     * @property mediaType\x0d\x0a     */\x0d\x0a    this.mediaType = mediaType;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The parts that make up the selector.\x0d\x0a     * @type Array\x0d\x0a     * @property features\x0d\x0a     */\x0d\x0a    this.features = features;\x0d\x0a\x0d\x0a}\x0d\x0a\x0d\x0aMediaQuery.prototype = new SyntaxUnit();\x0d\x0aMediaQuery.prototype.constructor = MediaQuery;\x0d\x0a\x0d\x0a\x0d\x0a},{\x22../util/SyntaxUnit\x22:26,\x22./Parser\x22:6}],6:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = Parser;\x0d\x0a\x0d\x0avar EventTarget = require(\x22../util/EventTarget\x22);\x0d\x0avar SyntaxError = require(\x22../util/SyntaxError\x22);\x0d\x0avar SyntaxUnit = require(\x22../util/SyntaxUnit\x22);\x0d\x0a\x0d\x0avar Combinator = require(\x22./Combinator\x22);\x0d\x0avar MediaFeature = require(\x22./MediaFeature\x22);\x0d\x0avar MediaQuery = require(\x22./MediaQuery\x22);\x0d\x0avar PropertyName = require(\x22./PropertyName\x22);\x0d\x0avar PropertyValue = require(\x22./PropertyValue\x22);\x0d\x0avar PropertyValuePart = require(\x22./PropertyValuePart\x22);\x0d\x0avar Selector = require(\x22./Selector\x22);\x0d\x0avar SelectorPart = require(\x22./SelectorPart\x22);\x0d\x0avar SelectorSubPart = require(\x22./SelectorSubPart\x22);\x0d\x0avar TokenStream = require(\x22./TokenStream\x22);\x0d\x0avar Tokens = require(\x22./Tokens\x22);\x0d\x0avar Validation = require(\x22./Validation\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * A CSS3 parser.\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class Parser\x0d\x0a * @constructor\x0d\x0a * @param {Object} options (Optional) Various options for the parser:\x0d\x0a *      starHack (true|false) to allow IE6 star hack as valid,\x0d\x0a *      underscoreHack (true|false) to interpret leading underscores\x0d\x0a *      as IE6-7 targeting for known properties, ieFilters (true|false)\x0d\x0a *      to indicate that IE \x3c 8 filters should be accepted and not throw\x0d\x0a *      syntax errors.\x0d\x0a */\x0d\x0afunction Parser(options) {\x0d\x0a\x0d\x0a    //inherit event functionality\x0d\x0a    EventTarget.call(this);\x0d\x0a\x0d\x0a\x0d\x0a    this.options = options || {};\x0d\x0a\x0d\x0a    this._tokenStream = null;\x0d\x0a}\x0d\x0a\x0d\x0a//Static constants\x0d\x0aParser.DEFAULT_TYPE = 0;\x0d\x0aParser.COMBINATOR_TYPE = 1;\x0d\x0aParser.MEDIA_FEATURE_TYPE = 2;\x0d\x0aParser.MEDIA_QUERY_TYPE = 3;\x0d\x0aParser.PROPERTY_NAME_TYPE = 4;\x0d\x0aParser.PROPERTY_VALUE_TYPE = 5;\x0d\x0aParser.PROPERTY_VALUE_PART_TYPE = 6;\x0d\x0aParser.SELECTOR_TYPE = 7;\x0d\x0aParser.SELECTOR_PART_TYPE = 8;\x0d\x0aParser.SELECTOR_SUB_PART_TYPE = 9;\x0d\x0a\x0d\x0aParser.prototype = function() {\x0d\x0a\x0d\x0a    var proto = new EventTarget(),  //new prototype\x0d\x0a        prop,\x0d\x0a        additions =  {\x0d\x0a            __proto__: null,\x0d\x0a\x0d\x0a            //restore constructor\x0d\x0a            constructor: Parser,\x0d\x0a\x0d\x0a            //instance constants - yuck\x0d\x0a            DEFAULT_TYPE : 0,\x0d\x0a            COMBINATOR_TYPE : 1,\x0d\x0a            MEDIA_FEATURE_TYPE : 2,\x0d\x0a            MEDIA_QUERY_TYPE : 3,\x0d\x0a            PROPERTY_NAME_TYPE : 4,\x0d\x0a            PROPERTY_VALUE_TYPE : 5,\x0d\x0a            PROPERTY_VALUE_PART_TYPE : 6,\x0d\x0a            SELECTOR_TYPE : 7,\x0d\x0a            SELECTOR_PART_TYPE : 8,\x0d\x0a            SELECTOR_SUB_PART_TYPE : 9,\x0d\x0a\x0d\x0a            //-----------------------------------------------------------------\x0d\x0a            // Grammar\x0d\x0a            //-----------------------------------------------------------------\x0d\x0a\x0d\x0a            _stylesheet: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * stylesheet\x0d\x0a                 *  : [ CHARSET_SYM S* STRING S* \x27;\x27 ]?\x0d\x0a                 *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*\x0d\x0a                 *    [ namespace [S|CDO|CDC]* ]*\x0d\x0a                 *    [ [ ruleset | media | page | font_face | keyframes_rule | supports_rule ] [S|CDO|CDC]* ]*\x0d\x0a                 *  ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    count,\x0d\x0a                    token,\x0d\x0a                    tt;\x0d\x0a\x0d\x0a                this.fire(\x22startstylesheet\x22);\x0d\x0a\x0d\x0a                //try to read character set\x0d\x0a                this._charset();\x0d\x0a\x0d\x0a                this._skipCruft();\x0d\x0a\x0d\x0a                //try to read imports - may be more than one\x0d\x0a                while (tokenStream.peek() === Tokens.IMPORT_SYM) {\x0d\x0a                    this._import();\x0d\x0a                    this._skipCruft();\x0d\x0a                }\x0d\x0a\x0d\x0a                //try to read namespaces - may be more than one\x0d\x0a                while (tokenStream.peek() === Tokens.NAMESPACE_SYM) {\x0d\x0a                    this._namespace();\x0d\x0a                    this._skipCruft();\x0d\x0a                }\x0d\x0a\x0d\x0a                //get the next token\x0d\x0a                tt = tokenStream.peek();\x0d\x0a\x0d\x0a                //try to read the rest\x0d\x0a                while (tt \x3e Tokens.EOF) {\x0d\x0a\x0d\x0a                    try {\x0d\x0a\x0d\x0a                        switch (tt) {\x0d\x0a                            case Tokens.MEDIA_SYM:\x0d\x0a                                this._media();\x0d\x0a                                this._skipCruft();\x0d\x0a                                break;\x0d\x0a                            case Tokens.PAGE_SYM:\x0d\x0a                                this._page();\x0d\x0a                                this._skipCruft();\x0d\x0a                                break;\x0d\x0a                            case Tokens.FONT_FACE_SYM:\x0d\x0a                                this._font_face();\x0d\x0a                                this._skipCruft();\x0d\x0a                                break;\x0d\x0a                            case Tokens.KEYFRAMES_SYM:\x0d\x0a                                this._keyframes();\x0d\x0a                                this._skipCruft();\x0d\x0a                                break;\x0d\x0a                            case Tokens.VIEWPORT_SYM:\x0d\x0a                                this._viewport();\x0d\x0a                                this._skipCruft();\x0d\x0a                                break;\x0d\x0a                            case Tokens.DOCUMENT_SYM:\x0d\x0a                                this._document();\x0d\x0a                                this._skipCruft();\x0d\x0a                                break;\x0d\x0a                            case Tokens.SUPPORTS_SYM:\x0d\x0a                                this._supports();\x0d\x0a                                this._skipCruft();\x0d\x0a                                break;\x0d\x0a                            case Tokens.UNKNOWN_SYM:  //unknown @ rule\x0d\x0a                                tokenStream.get();\x0d\x0a                                if (!this.options.strict) {\x0d\x0a\x0d\x0a                                    //fire error event\x0d\x0a                                    this.fire({\x0d\x0a                                        type:       \x22error\x22,\x0d\x0a                                        error:      null,\x0d\x0a                                        message:    \x22Unknown @ rule: \x22 + tokenStream.LT(0).value + \x22.\x22,\x0d\x0a                                        line:       tokenStream.LT(0).startLine,\x0d\x0a                                        col:        tokenStream.LT(0).startCol\x0d\x0a                                    });\x0d\x0a\x0d\x0a                                    //skip braces\x0d\x0a                                    count=0;\x0d\x0a                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE) {\x0d\x0a                                        count++;    //keep track of nesting depth\x0d\x0a                                    }\x0d\x0a\x0d\x0a                                    while (count) {\x0d\x0a                                        tokenStream.advance([Tokens.RBRACE]);\x0d\x0a                                        count--;\x0d\x0a                                    }\x0d\x0a\x0d\x0a                                } else {\x0d\x0a                                    //not a syntax error, rethrow it\x0d\x0a                                    throw new SyntaxError(\x22Unknown @ rule.\x22, tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);\x0d\x0a                                }\x0d\x0a                                break;\x0d\x0a                            case Tokens.S:\x0d\x0a                                this._readWhitespace();\x0d\x0a                                break;\x0d\x0a                            default:\x0d\x0a                                if (!this._ruleset()) {\x0d\x0a\x0d\x0a                                    //error handling for known issues\x0d\x0a                                    switch (tt) {\x0d\x0a                                        case Tokens.CHARSET_SYM:\x0d\x0a                                            token = tokenStream.LT(1);\x0d\x0a                                            this._charset(false);\x0d\x0a                                            throw new SyntaxError(\x22@charset not allowed here.\x22, token.startLine, token.startCol);\x0d\x0a                                        case Tokens.IMPORT_SYM:\x0d\x0a                                            token = tokenStream.LT(1);\x0d\x0a                                            this._import(false);\x0d\x0a                                            throw new SyntaxError(\x22@import not allowed here.\x22, token.startLine, token.startCol);\x0d\x0a                                        case Tokens.NAMESPACE_SYM:\x0d\x0a                                            token = tokenStream.LT(1);\x0d\x0a                                            this._namespace(false);\x0d\x0a                                            throw new SyntaxError(\x22@namespace not allowed here.\x22, token.startLine, token.startCol);\x0d\x0a                                        default:\x0d\x0a                                            tokenStream.get();  //get the last token\x0d\x0a                                            this._unexpectedToken(tokenStream.token());\x0d\x0a                                    }\x0d\x0a\x0d\x0a                                }\x0d\x0a                        }\x0d\x0a                    } catch (ex) {\x0d\x0a                        if (ex instanceof SyntaxError && !this.options.strict) {\x0d\x0a                            this.fire({\x0d\x0a                                type:       \x22error\x22,\x0d\x0a                                error:      ex,\x0d\x0a                                message:    ex.message,\x0d\x0a                                line:       ex.line,\x0d\x0a                                col:        ex.col\x0d\x0a                            });\x0d\x0a                        } else {\x0d\x0a                            throw ex;\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a\x0d\x0a                    tt = tokenStream.peek();\x0d\x0a                }\x0d\x0a\x0d\x0a                if (tt !== Tokens.EOF) {\x0d\x0a                    this._unexpectedToken(tokenStream.token());\x0d\x0a                }\x0d\x0a\x0d\x0a                this.fire(\x22endstylesheet\x22);\x0d\x0a            },\x0d\x0a\x0d\x0a            _charset: function(emit) {\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    charset,\x0d\x0a                    token,\x0d\x0a                    line,\x0d\x0a                    col;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.CHARSET_SYM)) {\x0d\x0a                    line = tokenStream.token().startLine;\x0d\x0a                    col = tokenStream.token().startCol;\x0d\x0a\x0d\x0a                    this._readWhitespace();\x0d\x0a                    tokenStream.mustMatch(Tokens.STRING);\x0d\x0a\x0d\x0a                    token = tokenStream.token();\x0d\x0a                    charset = token.value;\x0d\x0a\x0d\x0a                    this._readWhitespace();\x0d\x0a                    tokenStream.mustMatch(Tokens.SEMICOLON);\x0d\x0a\x0d\x0a                    if (emit !== false) {\x0d\x0a                        this.fire({\x0d\x0a                            type:   \x22charset\x22,\x0d\x0a                            charset:charset,\x0d\x0a                            line:   line,\x0d\x0a                            col:    col\x0d\x0a                        });\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            _import: function(emit) {\x0d\x0a                /*\x0d\x0a                 * import\x0d\x0a                 *   : IMPORT_SYM S*\x0d\x0a                 *    [STRING|URI] S* media_query_list? \x27;\x27 S*\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    uri,\x0d\x0a                    importToken,\x0d\x0a                    mediaList   = [];\x0d\x0a\x0d\x0a                //read import symbol\x0d\x0a                tokenStream.mustMatch(Tokens.IMPORT_SYM);\x0d\x0a                importToken = tokenStream.token();\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);\x0d\x0a\x0d\x0a                //grab the URI value\x0d\x0a                uri = tokenStream.token().value.replace(/^(?:url\x5c()?[\x22\x27]?([^\x22\x27]+?)[\x22\x27]?\x5c)?$/, \x22$1\x22);\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                mediaList = this._media_query_list();\x0d\x0a\x0d\x0a                //must end with a semicolon\x0d\x0a                tokenStream.mustMatch(Tokens.SEMICOLON);\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                if (emit !== false) {\x0d\x0a                    this.fire({\x0d\x0a                        type:   \x22import\x22,\x0d\x0a                        uri:    uri,\x0d\x0a                        media:  mediaList,\x0d\x0a                        line:   importToken.startLine,\x0d\x0a                        col:    importToken.startCol\x0d\x0a                    });\x0d\x0a                }\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            _namespace: function(emit) {\x0d\x0a                /*\x0d\x0a                 * namespace\x0d\x0a                 *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* \x27;\x27 S*\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    line,\x0d\x0a                    col,\x0d\x0a                    prefix,\x0d\x0a                    uri;\x0d\x0a\x0d\x0a                //read import symbol\x0d\x0a                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);\x0d\x0a                line = tokenStream.token().startLine;\x0d\x0a                col = tokenStream.token().startCol;\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                //it\x27s a namespace prefix - no _namespace_prefix() method because it\x27s just an IDENT\x0d\x0a                if (tokenStream.match(Tokens.IDENT)) {\x0d\x0a                    prefix = tokenStream.token().value;\x0d\x0a                    this._readWhitespace();\x0d\x0a                }\x0d\x0a\x0d\x0a                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);\x0d\x0a                /*if (!tokenStream.match(Tokens.STRING)){\x0d\x0a                    tokenStream.mustMatch(Tokens.URI);\x0d\x0a                }*/\x0d\x0a\x0d\x0a                //grab the URI value\x0d\x0a                uri = tokenStream.token().value.replace(/(?:url\x5c()?[\x22\x27]([^\x22\x27]+)[\x22\x27]\x5c)?/, \x22$1\x22);\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                //must end with a semicolon\x0d\x0a                tokenStream.mustMatch(Tokens.SEMICOLON);\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                if (emit !== false) {\x0d\x0a                    this.fire({\x0d\x0a                        type:   \x22namespace\x22,\x0d\x0a                        prefix: prefix,\x0d\x0a                        uri:    uri,\x0d\x0a                        line:   line,\x0d\x0a                        col:    col\x0d\x0a                    });\x0d\x0a                }\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            _supports: function(emit) {\x0d\x0a                /*\x0d\x0a                 * supports_rule\x0d\x0a                 *  : SUPPORTS_SYM S* supports_condition S* group_rule_body\x0d\x0a                 *  ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    line,\x0d\x0a                    col;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.SUPPORTS_SYM)) {\x0d\x0a                    line = tokenStream.token().startLine;\x0d\x0a                    col = tokenStream.token().startCol;\x0d\x0a\x0d\x0a                    this._readWhitespace();\x0d\x0a                    this._supports_condition();\x0d\x0a                    this._readWhitespace();\x0d\x0a\x0d\x0a                    tokenStream.mustMatch(Tokens.LBRACE);\x0d\x0a                    this._readWhitespace();\x0d\x0a\x0d\x0a                    if (emit !== false) {\x0d\x0a                        this.fire({\x0d\x0a                            type:   \x22startsupports\x22,\x0d\x0a                            line:   line,\x0d\x0a                            col:    col\x0d\x0a                        });\x0d\x0a                    }\x0d\x0a\x0d\x0a                    while (true) {\x0d\x0a                        if (!this._ruleset()) {\x0d\x0a                            break;\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a\x0d\x0a                    tokenStream.mustMatch(Tokens.RBRACE);\x0d\x0a                    this._readWhitespace();\x0d\x0a\x0d\x0a                    this.fire({\x0d\x0a                        type:   \x22endsupports\x22,\x0d\x0a                        line:   line,\x0d\x0a                        col:    col\x0d\x0a                    });\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            _supports_condition: function() {\x0d\x0a                /*\x0d\x0a                 * supports_condition\x0d\x0a                 *  : supports_negation | supports_conjunction | supports_disjunction |\x0d\x0a                 *    supports_condition_in_parens\x0d\x0a                 *  ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    ident;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.IDENT)) {\x0d\x0a                    ident = tokenStream.token().value.toLowerCase();\x0d\x0a\x0d\x0a                    if (ident === \x22not\x22) {\x0d\x0a                        tokenStream.mustMatch(Tokens.S);\x0d\x0a                        this._supports_condition_in_parens();\x0d\x0a                    } else {\x0d\x0a                        tokenStream.unget();\x0d\x0a                    }\x0d\x0a                } else {\x0d\x0a                    this._supports_condition_in_parens();\x0d\x0a                    this._readWhitespace();\x0d\x0a\x0d\x0a                    while (tokenStream.peek() === Tokens.IDENT) {\x0d\x0a                        ident = tokenStream.LT(1).value.toLowerCase();\x0d\x0a                        if (ident === \x22and\x22 || ident === \x22or\x22) {\x0d\x0a                            tokenStream.mustMatch(Tokens.IDENT);\x0d\x0a                            this._readWhitespace();\x0d\x0a                            this._supports_condition_in_parens();\x0d\x0a                            this._readWhitespace();\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            _supports_condition_in_parens: function() {\x0d\x0a                /*\x0d\x0a                 * supports_condition_in_parens\x0d\x0a                 *  : ( \x27(\x27 S* supports_condition S* \x27)\x27 ) | supports_declaration_condition |\x0d\x0a                 *    general_enclosed\x0d\x0a                 *  ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    ident;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.LPAREN)) {\x0d\x0a                    this._readWhitespace();\x0d\x0a                    if (tokenStream.match(Tokens.IDENT)) {\x0d\x0a                        // look ahead for not keyword, if not given, continue with declaration condition.\x0d\x0a                        ident = tokenStream.token().value.toLowerCase();\x0d\x0a                        if (ident === \x22not\x22) {\x0d\x0a                            this._readWhitespace();\x0d\x0a                            this._supports_condition();\x0d\x0a                            this._readWhitespace();\x0d\x0a                            tokenStream.mustMatch(Tokens.RPAREN);\x0d\x0a                        } else {\x0d\x0a                            tokenStream.unget();\x0d\x0a                            this._supports_declaration_condition(false);\x0d\x0a                        }\x0d\x0a                    } else {\x0d\x0a                        this._supports_condition();\x0d\x0a                        this._readWhitespace();\x0d\x0a                        tokenStream.mustMatch(Tokens.RPAREN);\x0d\x0a                    }\x0d\x0a                } else {\x0d\x0a                    this._supports_declaration_condition();\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            _supports_declaration_condition: function(requireStartParen) {\x0d\x0a                /*\x0d\x0a                 * supports_declaration_condition\x0d\x0a                 *  : \x27(\x27 S* declaration \x27)\x27\x0d\x0a                 *  ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream;\x0d\x0a\x0d\x0a                if (requireStartParen !== false) {\x0d\x0a                    tokenStream.mustMatch(Tokens.LPAREN);\x0d\x0a                }\x0d\x0a                this._readWhitespace();\x0d\x0a                this._declaration();\x0d\x0a                tokenStream.mustMatch(Tokens.RPAREN);\x0d\x0a            },\x0d\x0a\x0d\x0a            _media: function() {\x0d\x0a                /*\x0d\x0a                 * media\x0d\x0a                 *   : MEDIA_SYM S* media_query_list S* \x27{\x27 S* ruleset* \x27}\x27 S*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream     = this._tokenStream,\x0d\x0a                    line,\x0d\x0a                    col,\x0d\x0a                    mediaList;//       = [];\x0d\x0a\x0d\x0a                //look for @media\x0d\x0a                tokenStream.mustMatch(Tokens.MEDIA_SYM);\x0d\x0a                line = tokenStream.token().startLine;\x0d\x0a                col = tokenStream.token().startCol;\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                mediaList = this._media_query_list();\x0d\x0a\x0d\x0a                tokenStream.mustMatch(Tokens.LBRACE);\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22startmedia\x22,\x0d\x0a                    media:  mediaList,\x0d\x0a                    line:   line,\x0d\x0a                    col:    col\x0d\x0a                });\x0d\x0a\x0d\x0a                while (true) {\x0d\x0a                    if (tokenStream.peek() === Tokens.PAGE_SYM) {\x0d\x0a                        this._page();\x0d\x0a                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM) {\x0d\x0a                        this._font_face();\x0d\x0a                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM) {\x0d\x0a                        this._viewport();\x0d\x0a                    } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM) {\x0d\x0a                        this._document();\x0d\x0a                    } else if (tokenStream.peek() === Tokens.SUPPORTS_SYM) {\x0d\x0a                        this._supports();\x0d\x0a                    } else if (tokenStream.peek() === Tokens.MEDIA_SYM) {\x0d\x0a                        this._media();\x0d\x0a                    } else if (!this._ruleset()) {\x0d\x0a                        break;\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a                tokenStream.mustMatch(Tokens.RBRACE);\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22endmedia\x22,\x0d\x0a                    media:  mediaList,\x0d\x0a                    line:   line,\x0d\x0a                    col:    col\x0d\x0a                });\x0d\x0a            },\x0d\x0a\x0d\x0a\x0d\x0a            //CSS3 Media Queries\x0d\x0a            _media_query_list: function() {\x0d\x0a                /*\x0d\x0a                 * media_query_list\x0d\x0a                 *   : S* [media_query [ \x27,\x27 S* media_query ]* ]?\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    mediaList   = [];\x0d\x0a\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN) {\x0d\x0a                    mediaList.push(this._media_query());\x0d\x0a                }\x0d\x0a\x0d\x0a                while (tokenStream.match(Tokens.COMMA)) {\x0d\x0a                    this._readWhitespace();\x0d\x0a                    mediaList.push(this._media_query());\x0d\x0a                }\x0d\x0a\x0d\x0a                return mediaList;\x0d\x0a            },\x0d\x0a\x0d\x0a            /*\x0d\x0a             * Note: \x22expression\x22 in the grammar maps to the _media_expression\x0d\x0a             * method.\x0d\x0a\x0d\x0a             */\x0d\x0a            _media_query: function() {\x0d\x0a                /*\x0d\x0a                 * media_query\x0d\x0a                 *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*\x0d\x0a                 *   | expression [ AND S* expression ]*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    type        = null,\x0d\x0a                    ident       = null,\x0d\x0a                    token       = null,\x0d\x0a                    expressions = [];\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.IDENT)) {\x0d\x0a                    ident = tokenStream.token().value.toLowerCase();\x0d\x0a\x0d\x0a                    //since there\x27s no custom tokens for these, need to manually check\x0d\x0a                    if (ident !== \x22only\x22 && ident !== \x22not\x22) {\x0d\x0a                        tokenStream.unget();\x0d\x0a                        ident = null;\x0d\x0a                    } else {\x0d\x0a                        token = tokenStream.token();\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                if (tokenStream.peek() === Tokens.IDENT) {\x0d\x0a                    type = this._media_type();\x0d\x0a                    if (token === null) {\x0d\x0a                        token = tokenStream.token();\x0d\x0a                    }\x0d\x0a                } else if (tokenStream.peek() === Tokens.LPAREN) {\x0d\x0a                    if (token === null) {\x0d\x0a                        token = tokenStream.LT(1);\x0d\x0a                    }\x0d\x0a                    expressions.push(this._media_expression());\x0d\x0a                }\x0d\x0a\x0d\x0a                if (type === null && expressions.length === 0) {\x0d\x0a                    return null;\x0d\x0a                } else {\x0d\x0a                    this._readWhitespace();\x0d\x0a                    while (tokenStream.match(Tokens.IDENT)) {\x0d\x0a                        if (tokenStream.token().value.toLowerCase() !== \x22and\x22) {\x0d\x0a                            this._unexpectedToken(tokenStream.token());\x0d\x0a                        }\x0d\x0a\x0d\x0a                        this._readWhitespace();\x0d\x0a                        expressions.push(this._media_expression());\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Media Queries\x0d\x0a            _media_type: function() {\x0d\x0a                /*\x0d\x0a                 * media_type\x0d\x0a                 *   : IDENT\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                return this._media_feature();\x0d\x0a            },\x0d\x0a\x0d\x0a            /**\x0d\x0a             * Note: in CSS3 Media Queries, this is called \x22expression\x22.\x0d\x0a             * Renamed here to avoid conflict with CSS3 Selectors\x0d\x0a             * definition of \x22expression\x22. Also note that \x22expr\x22 in the\x0d\x0a             * grammar now maps to \x22expression\x22 from CSS3 selectors.\x0d\x0a             * @method _media_expression\x0d\x0a             * @private\x0d\x0a             */\x0d\x0a            _media_expression: function() {\x0d\x0a                /*\x0d\x0a                 * expression\x0d\x0a                 *  : \x27(\x27 S* media_feature S* [ \x27:\x27 S* expr ]? \x27)\x27 S*\x0d\x0a                 *  ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    feature     = null,\x0d\x0a                    token,\x0d\x0a                    expression  = null;\x0d\x0a\x0d\x0a                tokenStream.mustMatch(Tokens.LPAREN);\x0d\x0a\x0d\x0a                feature = this._media_feature();\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.COLON)) {\x0d\x0a                    this._readWhitespace();\x0d\x0a                    token = tokenStream.LT(1);\x0d\x0a                    expression = this._expression();\x0d\x0a                }\x0d\x0a\x0d\x0a                tokenStream.mustMatch(Tokens.RPAREN);\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                return new MediaFeature(feature, expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null);\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Media Queries\x0d\x0a            _media_feature: function() {\x0d\x0a                /*\x0d\x0a                 * media_feature\x0d\x0a                 *   : IDENT\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream;\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                tokenStream.mustMatch(Tokens.IDENT);\x0d\x0a\x0d\x0a                return SyntaxUnit.fromToken(tokenStream.token());\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Paged Media\x0d\x0a            _page: function() {\x0d\x0a                /*\x0d\x0a                 * page:\x0d\x0a                 *    PAGE_SYM S* IDENT? pseudo_page? S*\x0d\x0a                 *    \x27{\x27 S* [ declaration | margin ]? [ \x27;\x27 S* [ declaration | margin ]? ]* \x27}\x27 S*\x0d\x0a                 *    ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    line,\x0d\x0a                    col,\x0d\x0a                    identifier  = null,\x0d\x0a                    pseudoPage  = null;\x0d\x0a\x0d\x0a                //look for @page\x0d\x0a                tokenStream.mustMatch(Tokens.PAGE_SYM);\x0d\x0a                line = tokenStream.token().startLine;\x0d\x0a                col = tokenStream.token().startCol;\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.IDENT)) {\x0d\x0a                    identifier = tokenStream.token().value;\x0d\x0a\x0d\x0a                    //The value \x27auto\x27 may not be used as a page name and MUST be treated as a syntax error.\x0d\x0a                    if (identifier.toLowerCase() === \x22auto\x22) {\x0d\x0a                        this._unexpectedToken(tokenStream.token());\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a                //see if there\x27s a colon upcoming\x0d\x0a                if (tokenStream.peek() === Tokens.COLON) {\x0d\x0a                    pseudoPage = this._pseudo_page();\x0d\x0a                }\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22startpage\x22,\x0d\x0a                    id:     identifier,\x0d\x0a                    pseudo: pseudoPage,\x0d\x0a                    line:   line,\x0d\x0a                    col:    col\x0d\x0a                });\x0d\x0a\x0d\x0a                this._readDeclarations(true, true);\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22endpage\x22,\x0d\x0a                    id:     identifier,\x0d\x0a                    pseudo: pseudoPage,\x0d\x0a                    line:   line,\x0d\x0a                    col:    col\x0d\x0a                });\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Paged Media\x0d\x0a            _margin: function() {\x0d\x0a                /*\x0d\x0a                 * margin :\x0d\x0a                 *    margin_sym S* \x27{\x27 declaration [ \x27;\x27 S* declaration? ]* \x27}\x27 S*\x0d\x0a                 *    ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    line,\x0d\x0a                    col,\x0d\x0a                    marginSym   = this._margin_sym();\x0d\x0a\x0d\x0a                if (marginSym) {\x0d\x0a                    line = tokenStream.token().startLine;\x0d\x0a                    col = tokenStream.token().startCol;\x0d\x0a\x0d\x0a                    this.fire({\x0d\x0a                        type: \x22startpagemargin\x22,\x0d\x0a                        margin: marginSym,\x0d\x0a                        line:   line,\x0d\x0a                        col:    col\x0d\x0a                    });\x0d\x0a\x0d\x0a                    this._readDeclarations(true);\x0d\x0a\x0d\x0a                    this.fire({\x0d\x0a                        type: \x22endpagemargin\x22,\x0d\x0a                        margin: marginSym,\x0d\x0a                        line:   line,\x0d\x0a                        col:    col\x0d\x0a                    });\x0d\x0a                    return true;\x0d\x0a                } else {\x0d\x0a                    return false;\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Paged Media\x0d\x0a            _margin_sym: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * margin_sym :\x0d\x0a                 *    TOPLEFTCORNER_SYM |\x0d\x0a                 *    TOPLEFT_SYM |\x0d\x0a                 *    TOPCENTER_SYM |\x0d\x0a                 *    TOPRIGHT_SYM |\x0d\x0a                 *    TOPRIGHTCORNER_SYM |\x0d\x0a                 *    BOTTOMLEFTCORNER_SYM |\x0d\x0a                 *    BOTTOMLEFT_SYM |\x0d\x0a                 *    BOTTOMCENTER_SYM |\x0d\x0a                 *    BOTTOMRIGHT_SYM |\x0d\x0a                 *    BOTTOMRIGHTCORNER_SYM |\x0d\x0a                 *    LEFTTOP_SYM |\x0d\x0a                 *    LEFTMIDDLE_SYM |\x0d\x0a                 *    LEFTBOTTOM_SYM |\x0d\x0a                 *    RIGHTTOP_SYM |\x0d\x0a                 *    RIGHTMIDDLE_SYM |\x0d\x0a                 *    RIGHTBOTTOM_SYM\x0d\x0a                 *    ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream;\x0d\x0a\x0d\x0a                if (tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,\x0d\x0a                        Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,\x0d\x0a                        Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,\x0d\x0a                        Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,\x0d\x0a                        Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,\x0d\x0a                        Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,\x0d\x0a                        Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM])) {\x0d\x0a                    return SyntaxUnit.fromToken(tokenStream.token());\x0d\x0a                } else {\x0d\x0a                    return null;\x0d\x0a                }\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            _pseudo_page: function() {\x0d\x0a                /*\x0d\x0a                 * pseudo_page\x0d\x0a                 *   : \x27:\x27 IDENT\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream;\x0d\x0a\x0d\x0a                tokenStream.mustMatch(Tokens.COLON);\x0d\x0a                tokenStream.mustMatch(Tokens.IDENT);\x0d\x0a\x0d\x0a                //TODO: CSS3 Paged Media says only \x22left\x22, \x22center\x22, and \x22right\x22 are allowed\x0d\x0a\x0d\x0a                return tokenStream.token().value;\x0d\x0a            },\x0d\x0a\x0d\x0a            _font_face: function() {\x0d\x0a                /*\x0d\x0a                 * font_face\x0d\x0a                 *   : FONT_FACE_SYM S*\x0d\x0a                 *     \x27{\x27 S* declaration [ \x27;\x27 S* declaration ]* \x27}\x27 S*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    line,\x0d\x0a                    col;\x0d\x0a\x0d\x0a                //look for @page\x0d\x0a                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);\x0d\x0a                line = tokenStream.token().startLine;\x0d\x0a                col = tokenStream.token().startCol;\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22startfontface\x22,\x0d\x0a                    line:   line,\x0d\x0a                    col:    col\x0d\x0a                });\x0d\x0a\x0d\x0a                this._readDeclarations(true);\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22endfontface\x22,\x0d\x0a                    line:   line,\x0d\x0a                    col:    col\x0d\x0a                });\x0d\x0a            },\x0d\x0a\x0d\x0a            _viewport: function() {\x0d\x0a                /*\x0d\x0a                 * viewport\x0d\x0a                 *   : VIEWPORT_SYM S*\x0d\x0a                 *     \x27{\x27 S* declaration? [ \x27;\x27 S* declaration? ]* \x27}\x27 S*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    line,\x0d\x0a                    col;\x0d\x0a\x0d\x0a                tokenStream.mustMatch(Tokens.VIEWPORT_SYM);\x0d\x0a                line = tokenStream.token().startLine;\x0d\x0a                col = tokenStream.token().startCol;\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22startviewport\x22,\x0d\x0a                    line:   line,\x0d\x0a                    col:    col\x0d\x0a                });\x0d\x0a\x0d\x0a                this._readDeclarations(true);\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22endviewport\x22,\x0d\x0a                    line:   line,\x0d\x0a                    col:    col\x0d\x0a                });\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            _document: function() {\x0d\x0a                /*\x0d\x0a                 * document\x0d\x0a                 *   : DOCUMENT_SYM S*\x0d\x0a                 *     _document_function [ \x27,\x27 S* _document_function ]* S*\x0d\x0a                 *     \x27{\x27 S* ruleset* \x27}\x27\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    token,\x0d\x0a                    functions = [],\x0d\x0a                    prefix = \x22\x22;\x0d\x0a\x0d\x0a                tokenStream.mustMatch(Tokens.DOCUMENT_SYM);\x0d\x0a                token = tokenStream.token();\x0d\x0a                if (/^@\x5c-([^\x5c-]+)\x5c-/.test(token.value)) {\x0d\x0a                    prefix = RegExp.$1;\x0d\x0a                }\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a                functions.push(this._document_function());\x0d\x0a\x0d\x0a                while (tokenStream.match(Tokens.COMMA)) {\x0d\x0a                    this._readWhitespace();\x0d\x0a                    functions.push(this._document_function());\x0d\x0a                }\x0d\x0a\x0d\x0a                tokenStream.mustMatch(Tokens.LBRACE);\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:      \x22startdocument\x22,\x0d\x0a                    functions: functions,\x0d\x0a                    prefix:    prefix,\x0d\x0a                    line:      token.startLine,\x0d\x0a                    col:       token.startCol\x0d\x0a                });\x0d\x0a\x0d\x0a                var ok = true;\x0d\x0a                while (ok) {\x0d\x0a                    switch (tokenStream.peek()) {\x0d\x0a                        case Tokens.PAGE_SYM:\x0d\x0a                            this._page();\x0d\x0a                            break;\x0d\x0a                        case Tokens.FONT_FACE_SYM:\x0d\x0a                            this._font_face();\x0d\x0a                            break;\x0d\x0a                        case Tokens.VIEWPORT_SYM:\x0d\x0a                            this._viewport();\x0d\x0a                            break;\x0d\x0a                        case Tokens.MEDIA_SYM:\x0d\x0a                            this._media();\x0d\x0a                            break;\x0d\x0a                        case Tokens.KEYFRAMES_SYM:\x0d\x0a                            this._keyframes();\x0d\x0a                            break;\x0d\x0a                        case Tokens.DOCUMENT_SYM:\x0d\x0a                            this._document();\x0d\x0a                            break;\x0d\x0a                        default:\x0d\x0a                            ok = Boolean(this._ruleset());\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a                tokenStream.mustMatch(Tokens.RBRACE);\x0d\x0a                token = tokenStream.token();\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:      \x22enddocument\x22,\x0d\x0a                    functions: functions,\x0d\x0a                    prefix:    prefix,\x0d\x0a                    line:      token.startLine,\x0d\x0a                    col:       token.startCol\x0d\x0a                });\x0d\x0a            },\x0d\x0a\x0d\x0a            _document_function: function() {\x0d\x0a                /*\x0d\x0a                 * document_function\x0d\x0a                 *   : function | URI S*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    value;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.URI)) {\x0d\x0a                    value = tokenStream.token().value;\x0d\x0a                    this._readWhitespace();\x0d\x0a                } else {\x0d\x0a                    value = this._function();\x0d\x0a                }\x0d\x0a\x0d\x0a                return value;\x0d\x0a            },\x0d\x0a\x0d\x0a            _operator: function(inFunction) {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * operator (outside function)\x0d\x0a                 *  : \x27/\x27 S* | \x27,\x27 S* | /( empty )/\x0d\x0a                 * operator (inside function)\x0d\x0a                 *  : \x27/\x27 S* | \x27+\x27 S* | \x27*\x27 S* | \x27-\x27 S* /( empty )/\x0d\x0a                 *  ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    token       = null;\x0d\x0a\x0d\x0a                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||\x0d\x0a                    (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))) {\x0d\x0a                    token =  tokenStream.token();\x0d\x0a                    this._readWhitespace();\x0d\x0a                }\x0d\x0a                return token ? PropertyValuePart.fromToken(token) : null;\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            _combinator: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * combinator\x0d\x0a                 *  : PLUS S* | GREATER S* | TILDE S* | S+\x0d\x0a                 *  ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    value       = null,\x0d\x0a                    token;\x0d\x0a\x0d\x0a                if (tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])) {\x0d\x0a                    token = tokenStream.token();\x0d\x0a                    value = new Combinator(token.value, token.startLine, token.startCol);\x0d\x0a                    this._readWhitespace();\x0d\x0a                }\x0d\x0a\x0d\x0a                return value;\x0d\x0a            },\x0d\x0a\x0d\x0a            _unary_operator: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * unary_operator\x0d\x0a                 *  : \x27-\x27 | \x27+\x27\x0d\x0a                 *  ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream;\x0d\x0a\x0d\x0a                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])) {\x0d\x0a                    return tokenStream.token().value;\x0d\x0a                } else {\x0d\x0a                    return null;\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            _property: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * property\x0d\x0a                 *   : IDENT S*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    value       = null,\x0d\x0a                    hack        = null,\x0d\x0a                    tokenValue,\x0d\x0a                    token,\x0d\x0a                    line,\x0d\x0a                    col;\x0d\x0a\x0d\x0a                //check for star hack - throws error if not allowed\x0d\x0a                if (tokenStream.peek() === Tokens.STAR && this.options.starHack) {\x0d\x0a                    tokenStream.get();\x0d\x0a                    token = tokenStream.token();\x0d\x0a                    hack = token.value;\x0d\x0a                    line = token.startLine;\x0d\x0a                    col = token.startCol;\x0d\x0a                }\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.IDENT)) {\x0d\x0a                    token = tokenStream.token();\x0d\x0a                    tokenValue = token.value;\x0d\x0a\x0d\x0a                    //check for underscore hack - no error if not allowed because it\x27s valid CSS syntax\x0d\x0a                    if (tokenValue.charAt(0) === \x22_\x22 && this.options.underscoreHack) {\x0d\x0a                        hack = \x22_\x22;\x0d\x0a                        tokenValue = tokenValue.substring(1);\x0d\x0a                    }\x0d\x0a\x0d\x0a                    value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));\x0d\x0a                    this._readWhitespace();\x0d\x0a                }\x0d\x0a\x0d\x0a                return value;\x0d\x0a            },\x0d\x0a\x0d\x0a            //Augmented with CSS3 Selectors\x0d\x0a            _ruleset: function() {\x0d\x0a                /*\x0d\x0a                 * ruleset\x0d\x0a                 *   : selectors_group\x0d\x0a                 *     \x27{\x27 S* declaration? [ \x27;\x27 S* declaration? ]* \x27}\x27 S*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    tt,\x0d\x0a                    selectors;\x0d\x0a\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Error Recovery: If even a single selector fails to parse,\x0d\x0a                 * then the entire ruleset should be thrown away.\x0d\x0a                 */\x0d\x0a                try {\x0d\x0a                    selectors = this._selectors_group();\x0d\x0a                } catch (ex) {\x0d\x0a                    if (ex instanceof SyntaxError && !this.options.strict) {\x0d\x0a\x0d\x0a                        //fire error event\x0d\x0a                        this.fire({\x0d\x0a                            type:       \x22error\x22,\x0d\x0a                            error:      ex,\x0d\x0a                            message:    ex.message,\x0d\x0a                            line:       ex.line,\x0d\x0a                            col:        ex.col\x0d\x0a                        });\x0d\x0a\x0d\x0a                        //skip over everything until closing brace\x0d\x0a                        tt = tokenStream.advance([Tokens.RBRACE]);\x0d\x0a                        if (tt === Tokens.RBRACE) {\x0d\x0a                            //if there\x27s a right brace, the rule is finished so don\x27t do anything\x0d\x0a                        } else {\x0d\x0a                            //otherwise, rethrow the error because it wasn\x27t handled properly\x0d\x0a                            throw ex;\x0d\x0a                        }\x0d\x0a\x0d\x0a                    } else {\x0d\x0a                        //not a syntax error, rethrow it\x0d\x0a                        throw ex;\x0d\x0a                    }\x0d\x0a\x0d\x0a                    //trigger parser to continue\x0d\x0a                    return true;\x0d\x0a                }\x0d\x0a\x0d\x0a                //if it got here, all selectors parsed\x0d\x0a                if (selectors) {\x0d\x0a\x0d\x0a                    this.fire({\x0d\x0a                        type:       \x22startrule\x22,\x0d\x0a                        selectors:  selectors,\x0d\x0a                        line:       selectors[0].line,\x0d\x0a                        col:        selectors[0].col\x0d\x0a                    });\x0d\x0a\x0d\x0a                    this._readDeclarations(true);\x0d\x0a\x0d\x0a                    this.fire({\x0d\x0a                        type:       \x22endrule\x22,\x0d\x0a                        selectors:  selectors,\x0d\x0a                        line:       selectors[0].line,\x0d\x0a                        col:        selectors[0].col\x0d\x0a                    });\x0d\x0a\x0d\x0a                }\x0d\x0a\x0d\x0a                return selectors;\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _selectors_group: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * selectors_group\x0d\x0a                 *   : selector [ COMMA S* selector ]*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    selectors   = [],\x0d\x0a                    selector;\x0d\x0a\x0d\x0a                selector = this._selector();\x0d\x0a                if (selector !== null) {\x0d\x0a\x0d\x0a                    selectors.push(selector);\x0d\x0a                    while (tokenStream.match(Tokens.COMMA)) {\x0d\x0a                        this._readWhitespace();\x0d\x0a                        selector = this._selector();\x0d\x0a                        if (selector !== null) {\x0d\x0a                            selectors.push(selector);\x0d\x0a                        } else {\x0d\x0a                            this._unexpectedToken(tokenStream.LT(1));\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a                return selectors.length ? selectors : null;\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _selector: function() {\x0d\x0a                /*\x0d\x0a                 * selector\x0d\x0a                 *   : simple_selector_sequence [ combinator simple_selector_sequence ]*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    selector    = [],\x0d\x0a                    nextSelector = null,\x0d\x0a                    combinator  = null,\x0d\x0a                    ws          = null;\x0d\x0a\x0d\x0a                //if there\x27s no simple selector, then there\x27s no selector\x0d\x0a                nextSelector = this._simple_selector_sequence();\x0d\x0a                if (nextSelector === null) {\x0d\x0a                    return null;\x0d\x0a                }\x0d\x0a\x0d\x0a                selector.push(nextSelector);\x0d\x0a\x0d\x0a                do {\x0d\x0a\x0d\x0a                    //look for a combinator\x0d\x0a                    combinator = this._combinator();\x0d\x0a\x0d\x0a                    if (combinator !== null) {\x0d\x0a                        selector.push(combinator);\x0d\x0a                        nextSelector = this._simple_selector_sequence();\x0d\x0a\x0d\x0a                        //there must be a next selector\x0d\x0a                        if (nextSelector === null) {\x0d\x0a                            this._unexpectedToken(tokenStream.LT(1));\x0d\x0a                        } else {\x0d\x0a\x0d\x0a                            //nextSelector is an instance of SelectorPart\x0d\x0a                            selector.push(nextSelector);\x0d\x0a                        }\x0d\x0a                    } else {\x0d\x0a\x0d\x0a                        //if there\x27s not whitespace, we\x27re done\x0d\x0a                        if (this._readWhitespace()) {\x0d\x0a\x0d\x0a                            //add whitespace separator\x0d\x0a                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);\x0d\x0a\x0d\x0a                            //combinator is not required\x0d\x0a                            combinator = this._combinator();\x0d\x0a\x0d\x0a                            //selector is required if there\x27s a combinator\x0d\x0a                            nextSelector = this._simple_selector_sequence();\x0d\x0a                            if (nextSelector === null) {\x0d\x0a                                if (combinator !== null) {\x0d\x0a                                    this._unexpectedToken(tokenStream.LT(1));\x0d\x0a                                }\x0d\x0a                            } else {\x0d\x0a\x0d\x0a                                if (combinator !== null) {\x0d\x0a                                    selector.push(combinator);\x0d\x0a                                } else {\x0d\x0a                                    selector.push(ws);\x0d\x0a                                }\x0d\x0a\x0d\x0a                                selector.push(nextSelector);\x0d\x0a                            }\x0d\x0a                        } else {\x0d\x0a                            break;\x0d\x0a                        }\x0d\x0a\x0d\x0a                    }\x0d\x0a                } while (true);\x0d\x0a\x0d\x0a                return new Selector(selector, selector[0].line, selector[0].col);\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _simple_selector_sequence: function() {\x0d\x0a                /*\x0d\x0a                 * simple_selector_sequence\x0d\x0a                 *   : [ type_selector | universal ]\x0d\x0a                 *     [ HASH | class | attrib | pseudo | negation ]*\x0d\x0a                 *   | [ HASH | class | attrib | pseudo | negation ]+\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a\x0d\x0a                    //parts of a simple selector\x0d\x0a                    elementName = null,\x0d\x0a                    modifiers   = [],\x0d\x0a\x0d\x0a                    //complete selector text\x0d\x0a                    selectorText= \x22\x22,\x0d\x0a\x0d\x0a                    //the different parts after the element name to search for\x0d\x0a                    components  = [\x0d\x0a                        //HASH\x0d\x0a                        function() {\x0d\x0a                            return tokenStream.match(Tokens.HASH) ?\x0d\x0a                                    new SelectorSubPart(tokenStream.token().value, \x22id\x22, tokenStream.token().startLine, tokenStream.token().startCol) :\x0d\x0a                                    null;\x0d\x0a                        },\x0d\x0a                        this._class,\x0d\x0a                        this._attrib,\x0d\x0a                        this._pseudo,\x0d\x0a                        this._negation\x0d\x0a                    ],\x0d\x0a                    i           = 0,\x0d\x0a                    len         = components.length,\x0d\x0a                    component   = null,\x0d\x0a                    line,\x0d\x0a                    col;\x0d\x0a\x0d\x0a\x0d\x0a                //get starting line and column for the selector\x0d\x0a                line = tokenStream.LT(1).startLine;\x0d\x0a                col = tokenStream.LT(1).startCol;\x0d\x0a\x0d\x0a                elementName = this._type_selector();\x0d\x0a                if (!elementName) {\x0d\x0a                    elementName = this._universal();\x0d\x0a                }\x0d\x0a\x0d\x0a                if (elementName !== null) {\x0d\x0a                    selectorText += elementName;\x0d\x0a                }\x0d\x0a\x0d\x0a                while (true) {\x0d\x0a\x0d\x0a                    //whitespace means we\x27re done\x0d\x0a                    if (tokenStream.peek() === Tokens.S) {\x0d\x0a                        break;\x0d\x0a                    }\x0d\x0a\x0d\x0a                    //check for each component\x0d\x0a                    while (i \x3c len && component === null) {\x0d\x0a                        component = components[i++].call(this);\x0d\x0a                    }\x0d\x0a\x0d\x0a                    if (component === null) {\x0d\x0a\x0d\x0a                        //we don\x27t have a selector\x0d\x0a                        if (selectorText === \x22\x22) {\x0d\x0a                            return null;\x0d\x0a                        } else {\x0d\x0a                            break;\x0d\x0a                        }\x0d\x0a                    } else {\x0d\x0a                        i = 0;\x0d\x0a                        modifiers.push(component);\x0d\x0a                        selectorText += component.toString();\x0d\x0a                        component = null;\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a\x0d\x0a                return selectorText !== \x22\x22 ?\x0d\x0a                        new SelectorPart(elementName, modifiers, selectorText, line, col) :\x0d\x0a                        null;\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _type_selector: function() {\x0d\x0a                /*\x0d\x0a                 * type_selector\x0d\x0a                 *   : [ namespace_prefix ]? element_name\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    ns          = this._namespace_prefix(),\x0d\x0a                    elementName = this._element_name();\x0d\x0a\x0d\x0a                if (!elementName) {\x0d\x0a                    /*\x0d\x0a                     * Need to back out the namespace that was read due to both\x0d\x0a                     * type_selector and universal reading namespace_prefix\x0d\x0a                     * first. Kind of hacky, but only way I can figure out\x0d\x0a                     * right now how to not change the grammar.\x0d\x0a                     */\x0d\x0a                    if (ns) {\x0d\x0a                        tokenStream.unget();\x0d\x0a                        if (ns.length \x3e 1) {\x0d\x0a                            tokenStream.unget();\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a\x0d\x0a                    return null;\x0d\x0a                } else {\x0d\x0a                    if (ns) {\x0d\x0a                        elementName.text = ns + elementName.text;\x0d\x0a                        elementName.col -= ns.length;\x0d\x0a                    }\x0d\x0a                    return elementName;\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _class: function() {\x0d\x0a                /*\x0d\x0a                 * class\x0d\x0a                 *   : \x27.\x27 IDENT\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    token;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.DOT)) {\x0d\x0a                    tokenStream.mustMatch(Tokens.IDENT);\x0d\x0a                    token = tokenStream.token();\x0d\x0a                    return new SelectorSubPart(\x22.\x22 + token.value, \x22class\x22, token.startLine, token.startCol - 1);\x0d\x0a                } else {\x0d\x0a                    return null;\x0d\x0a                }\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _element_name: function() {\x0d\x0a                /*\x0d\x0a                 * element_name\x0d\x0a                 *   : IDENT\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    token;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.IDENT)) {\x0d\x0a                    token = tokenStream.token();\x0d\x0a                    return new SelectorSubPart(token.value, \x22elementName\x22, token.startLine, token.startCol);\x0d\x0a\x0d\x0a                } else {\x0d\x0a                    return null;\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _namespace_prefix: function() {\x0d\x0a                /*\x0d\x0a                 * namespace_prefix\x0d\x0a                 *   : [ IDENT | \x27*\x27 ]? \x27|\x27\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    value       = \x22\x22;\x0d\x0a\x0d\x0a                //verify that this is a namespace prefix\x0d\x0a                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE) {\x0d\x0a\x0d\x0a                    if (tokenStream.match([Tokens.IDENT, Tokens.STAR])) {\x0d\x0a                        value += tokenStream.token().value;\x0d\x0a                    }\x0d\x0a\x0d\x0a                    tokenStream.mustMatch(Tokens.PIPE);\x0d\x0a                    value += \x22|\x22;\x0d\x0a\x0d\x0a                }\x0d\x0a\x0d\x0a                return value.length ? value : null;\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _universal: function() {\x0d\x0a                /*\x0d\x0a                 * universal\x0d\x0a                 *   : [ namespace_prefix ]? \x27*\x27\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    value       = \x22\x22,\x0d\x0a                    ns;\x0d\x0a\x0d\x0a                ns = this._namespace_prefix();\x0d\x0a                if (ns) {\x0d\x0a                    value += ns;\x0d\x0a                }\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.STAR)) {\x0d\x0a                    value += \x22*\x22;\x0d\x0a                }\x0d\x0a\x0d\x0a                return value.length ? value : null;\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _attrib: function() {\x0d\x0a                /*\x0d\x0a                 * attrib\x0d\x0a                 *   : \x27[\x27 S* [ namespace_prefix ]? IDENT S*\x0d\x0a                 *         [ [ PREFIXMATCH |\x0d\x0a                 *             SUFFIXMATCH |\x0d\x0a                 *             SUBSTRINGMATCH |\x0d\x0a                 *             \x27=\x27 |\x0d\x0a                 *             INCLUDES |\x0d\x0a                 *             DASHMATCH ] S* [ IDENT | STRING ] S*\x0d\x0a                 *         ]? \x27]\x27\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    value       = null,\x0d\x0a                    ns,\x0d\x0a                    token;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.LBRACKET)) {\x0d\x0a                    token = tokenStream.token();\x0d\x0a                    value = token.value;\x0d\x0a                    value += this._readWhitespace();\x0d\x0a\x0d\x0a                    ns = this._namespace_prefix();\x0d\x0a\x0d\x0a                    if (ns) {\x0d\x0a                        value += ns;\x0d\x0a                    }\x0d\x0a\x0d\x0a                    tokenStream.mustMatch(Tokens.IDENT);\x0d\x0a                    value += tokenStream.token().value;\x0d\x0a                    value += this._readWhitespace();\x0d\x0a\x0d\x0a                    if (tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,\x0d\x0a                            Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])) {\x0d\x0a\x0d\x0a                        value += tokenStream.token().value;\x0d\x0a                        value += this._readWhitespace();\x0d\x0a\x0d\x0a                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);\x0d\x0a                        value += tokenStream.token().value;\x0d\x0a                        value += this._readWhitespace();\x0d\x0a                    }\x0d\x0a\x0d\x0a                    tokenStream.mustMatch(Tokens.RBRACKET);\x0d\x0a\x0d\x0a                    return new SelectorSubPart(value + \x22]\x22, \x22attribute\x22, token.startLine, token.startCol);\x0d\x0a                } else {\x0d\x0a                    return null;\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _pseudo: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * pseudo\x0d\x0a                 *   : \x27:\x27 \x27:\x27? [ IDENT | functional_pseudo ]\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    pseudo      = null,\x0d\x0a                    colons      = \x22:\x22,\x0d\x0a                    line,\x0d\x0a                    col;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.COLON)) {\x0d\x0a\x0d\x0a                    if (tokenStream.match(Tokens.COLON)) {\x0d\x0a                        colons += \x22:\x22;\x0d\x0a                    }\x0d\x0a\x0d\x0a                    if (tokenStream.match(Tokens.IDENT)) {\x0d\x0a                        pseudo = tokenStream.token().value;\x0d\x0a                        line = tokenStream.token().startLine;\x0d\x0a                        col = tokenStream.token().startCol - colons.length;\x0d\x0a                    } else if (tokenStream.peek() === Tokens.FUNCTION) {\x0d\x0a                        line = tokenStream.LT(1).startLine;\x0d\x0a                        col = tokenStream.LT(1).startCol - colons.length;\x0d\x0a                        pseudo = this._functional_pseudo();\x0d\x0a                    }\x0d\x0a\x0d\x0a                    if (pseudo) {\x0d\x0a                        pseudo = new SelectorSubPart(colons + pseudo, \x22pseudo\x22, line, col);\x0d\x0a                    } else {\x0d\x0a                        var startLine = tokenStream.LT(1).startLine,\x0d\x0a                            startCol  = tokenStream.LT(0).startCol;\x0d\x0a                        throw new SyntaxError(\x22Expected a `FUNCTION` or `IDENT` after colon at line \x22 + startLine + \x22, col \x22 + startCol + \x22.\x22, startLine, startCol);\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a                return pseudo;\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _functional_pseudo: function() {\x0d\x0a                /*\x0d\x0a                 * functional_pseudo\x0d\x0a                 *   : FUNCTION S* expression \x27)\x27\x0d\x0a                 *   ;\x0d\x0a                */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    value = null;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.FUNCTION)) {\x0d\x0a                    value = tokenStream.token().value;\x0d\x0a                    value += this._readWhitespace();\x0d\x0a                    value += this._expression();\x0d\x0a                    tokenStream.mustMatch(Tokens.RPAREN);\x0d\x0a                    value += \x22)\x22;\x0d\x0a                }\x0d\x0a\x0d\x0a                return value;\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _expression: function() {\x0d\x0a                /*\x0d\x0a                 * expression\x0d\x0a                 *   : [ [ PLUS | \x27-\x27 | DIMENSION | NUMBER | STRING | IDENT ] S* ]+\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    value       = \x22\x22;\x0d\x0a\x0d\x0a                while (tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,\x0d\x0a                        Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,\x0d\x0a                        Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,\x0d\x0a                        Tokens.RESOLUTION, Tokens.SLASH])) {\x0d\x0a\x0d\x0a                    value += tokenStream.token().value;\x0d\x0a                    value += this._readWhitespace();\x0d\x0a                }\x0d\x0a\x0d\x0a                return value.length ? value : null;\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _negation: function() {\x0d\x0a                /*\x0d\x0a                 * negation\x0d\x0a                 *   : NOT S* negation_arg S* \x27)\x27\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    line,\x0d\x0a                    col,\x0d\x0a                    value       = \x22\x22,\x0d\x0a                    arg,\x0d\x0a                    subpart     = null;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.NOT)) {\x0d\x0a                    value = tokenStream.token().value;\x0d\x0a                    line = tokenStream.token().startLine;\x0d\x0a                    col = tokenStream.token().startCol;\x0d\x0a                    value += this._readWhitespace();\x0d\x0a                    arg = this._negation_arg();\x0d\x0a                    value += arg;\x0d\x0a                    value += this._readWhitespace();\x0d\x0a                    tokenStream.match(Tokens.RPAREN);\x0d\x0a                    value += tokenStream.token().value;\x0d\x0a\x0d\x0a                    subpart = new SelectorSubPart(value, \x22not\x22, line, col);\x0d\x0a                    subpart.args.push(arg);\x0d\x0a                }\x0d\x0a\x0d\x0a                return subpart;\x0d\x0a            },\x0d\x0a\x0d\x0a            //CSS3 Selectors\x0d\x0a            _negation_arg: function() {\x0d\x0a                /*\x0d\x0a                 * negation_arg\x0d\x0a                 *   : type_selector | universal | HASH | class | attrib | pseudo\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    args        = [\x0d\x0a                        this._type_selector,\x0d\x0a                        this._universal,\x0d\x0a                        function() {\x0d\x0a                            return tokenStream.match(Tokens.HASH) ?\x0d\x0a                                    new SelectorSubPart(tokenStream.token().value, \x22id\x22, tokenStream.token().startLine, tokenStream.token().startCol) :\x0d\x0a                                    null;\x0d\x0a                        },\x0d\x0a                        this._class,\x0d\x0a                        this._attrib,\x0d\x0a                        this._pseudo\x0d\x0a                    ],\x0d\x0a                    arg         = null,\x0d\x0a                    i           = 0,\x0d\x0a                    len         = args.length,\x0d\x0a                    line,\x0d\x0a                    col,\x0d\x0a                    part;\x0d\x0a\x0d\x0a                line = tokenStream.LT(1).startLine;\x0d\x0a                col = tokenStream.LT(1).startCol;\x0d\x0a\x0d\x0a                while (i \x3c len && arg === null) {\x0d\x0a\x0d\x0a                    arg = args[i].call(this);\x0d\x0a                    i++;\x0d\x0a                }\x0d\x0a\x0d\x0a                //must be a negation arg\x0d\x0a                if (arg === null) {\x0d\x0a                    this._unexpectedToken(tokenStream.LT(1));\x0d\x0a                }\x0d\x0a\x0d\x0a                //it\x27s an element name\x0d\x0a                if (arg.type === \x22elementName\x22) {\x0d\x0a                    part = new SelectorPart(arg, [], arg.toString(), line, col);\x0d\x0a                } else {\x0d\x0a                    part = new SelectorPart(null, [arg], arg.toString(), line, col);\x0d\x0a                }\x0d\x0a\x0d\x0a                return part;\x0d\x0a            },\x0d\x0a\x0d\x0a            _declaration: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * declaration\x0d\x0a                 *   : property \x27:\x27 S* expr prio?\x0d\x0a                 *   | /( empty )/\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    property    = null,\x0d\x0a                    expr        = null,\x0d\x0a                    prio        = null,\x0d\x0a                    invalid     = null,\x0d\x0a                    propertyName= \x22\x22;\x0d\x0a\x0d\x0a                property = this._property();\x0d\x0a                if (property !== null) {\x0d\x0a\x0d\x0a                    tokenStream.mustMatch(Tokens.COLON);\x0d\x0a                    this._readWhitespace();\x0d\x0a\x0d\x0a                    expr = this._expr();\x0d\x0a\x0d\x0a                    //if there\x27s no parts for the value, it\x27s an error\x0d\x0a                    if (!expr || expr.length === 0) {\x0d\x0a                        this._unexpectedToken(tokenStream.LT(1));\x0d\x0a                    }\x0d\x0a\x0d\x0a                    prio = this._prio();\x0d\x0a\x0d\x0a                    /*\x0d\x0a                     * If hacks should be allowed, then only check the root\x0d\x0a                     * property. If hacks should not be allowed, treat\x0d\x0a                     * _property or *property as invalid properties.\x0d\x0a                     */\x0d\x0a                    propertyName = property.toString();\x0d\x0a                    if (this.options.starHack && property.hack === \x22*\x22 ||\x0d\x0a                            this.options.underscoreHack && property.hack === \x22_\x22) {\x0d\x0a\x0d\x0a                        propertyName = property.text;\x0d\x0a                    }\x0d\x0a\x0d\x0a                    try {\x0d\x0a                        this._validateProperty(propertyName, expr);\x0d\x0a                    } catch (ex) {\x0d\x0a                        invalid = ex;\x0d\x0a                    }\x0d\x0a\x0d\x0a                    this.fire({\x0d\x0a                        type:       \x22property\x22,\x0d\x0a                        property:   property,\x0d\x0a                        value:      expr,\x0d\x0a                        important:  prio,\x0d\x0a                        line:       property.line,\x0d\x0a                        col:        property.col,\x0d\x0a                        invalid:    invalid\x0d\x0a                    });\x0d\x0a\x0d\x0a                    return true;\x0d\x0a                } else {\x0d\x0a                    return false;\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            _prio: function() {\x0d\x0a                /*\x0d\x0a                 * prio\x0d\x0a                 *   : IMPORTANT_SYM S*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a                return result;\x0d\x0a            },\x0d\x0a\x0d\x0a            _expr: function(inFunction) {\x0d\x0a                /*\x0d\x0a                 * expr\x0d\x0a                 *   : term [ operator term ]*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var values      = [],\x0d\x0a                    //valueParts    = [],\x0d\x0a                    value       = null,\x0d\x0a                    operator    = null;\x0d\x0a\x0d\x0a                value = this._term(inFunction);\x0d\x0a                if (value !== null) {\x0d\x0a\x0d\x0a                    values.push(value);\x0d\x0a\x0d\x0a                    do {\x0d\x0a                        operator = this._operator(inFunction);\x0d\x0a\x0d\x0a                        //if there\x27s an operator, keep building up the value parts\x0d\x0a                        if (operator) {\x0d\x0a                            values.push(operator);\x0d\x0a                        } /*else {\x0d\x0a                            //if there\x27s not an operator, you have a full value\x0d\x0a                            values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));\x0d\x0a                            valueParts = [];\x0d\x0a                        }*/\x0d\x0a\x0d\x0a                        value = this._term(inFunction);\x0d\x0a\x0d\x0a                        if (value === null) {\x0d\x0a                            break;\x0d\x0a                        } else {\x0d\x0a                            values.push(value);\x0d\x0a                        }\x0d\x0a                    } while (true);\x0d\x0a                }\x0d\x0a\x0d\x0a                //cleanup\x0d\x0a                /*if (valueParts.length) {\x0d\x0a                    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));\x0d\x0a                }*/\x0d\x0a\x0d\x0a                return values.length \x3e 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;\x0d\x0a            },\x0d\x0a\x0d\x0a            _term: function(inFunction) {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * term\x0d\x0a                 *   : unary_operator?\x0d\x0a                 *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |\x0d\x0a                 *       TIME S* | FREQ S* | function | ie_function ]\x0d\x0a                 *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    unary       = null,\x0d\x0a                    value       = null,\x0d\x0a                    endChar     = null,\x0d\x0a                    part        = null,\x0d\x0a                    token,\x0d\x0a                    line,\x0d\x0a                    col;\x0d\x0a\x0d\x0a                //returns the operator or null\x0d\x0a                unary = this._unary_operator();\x0d\x0a                if (unary !== null) {\x0d\x0a                    line = tokenStream.token().startLine;\x0d\x0a                    col = tokenStream.token().startCol;\x0d\x0a                }\x0d\x0a\x0d\x0a                //exception for IE filters\x0d\x0a                if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters) {\x0d\x0a\x0d\x0a                    value = this._ie_function();\x0d\x0a                    if (unary === null) {\x0d\x0a                        line = tokenStream.token().startLine;\x0d\x0a                        col = tokenStream.token().startCol;\x0d\x0a                    }\x0d\x0a\x0d\x0a                //see if it\x27s a simple block\x0d\x0a                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])) {\x0d\x0a\x0d\x0a                    token = tokenStream.token();\x0d\x0a                    endChar = token.endChar;\x0d\x0a                    value = token.value + this._expr(inFunction).text;\x0d\x0a                    if (unary === null) {\x0d\x0a                        line = tokenStream.token().startLine;\x0d\x0a                        col = tokenStream.token().startCol;\x0d\x0a                    }\x0d\x0a                    tokenStream.mustMatch(Tokens.type(endChar));\x0d\x0a                    value += endChar;\x0d\x0a                    this._readWhitespace();\x0d\x0a\x0d\x0a                //see if there\x27s a simple match\x0d\x0a                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,\x0d\x0a                        Tokens.ANGLE, Tokens.TIME,\x0d\x0a                        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])) {\x0d\x0a\x0d\x0a                    value = tokenStream.token().value;\x0d\x0a                    if (unary === null) {\x0d\x0a                        line = tokenStream.token().startLine;\x0d\x0a                        col = tokenStream.token().startCol;\x0d\x0a                        // Correct potentially-inaccurate IDENT parsing in\x0d\x0a                        // PropertyValuePart constructor.\x0d\x0a                        part = PropertyValuePart.fromToken(tokenStream.token());\x0d\x0a                    }\x0d\x0a                    this._readWhitespace();\x0d\x0a                } else {\x0d\x0a\x0d\x0a                    //see if it\x27s a color\x0d\x0a                    token = this._hexcolor();\x0d\x0a                    if (token === null) {\x0d\x0a\x0d\x0a                        //if there\x27s no unary, get the start of the next token for line/col info\x0d\x0a                        if (unary === null) {\x0d\x0a                            line = tokenStream.LT(1).startLine;\x0d\x0a                            col = tokenStream.LT(1).startCol;\x0d\x0a                        }\x0d\x0a\x0d\x0a                        //has to be a function\x0d\x0a                        if (value === null) {\x0d\x0a\x0d\x0a                            /*\x0d\x0a                             * This checks for alpha(opacity=0) style of IE\x0d\x0a                             * functions. IE_FUNCTION only presents progid: style.\x0d\x0a                             */\x0d\x0a                            if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters) {\x0d\x0a                                value = this._ie_function();\x0d\x0a                            } else {\x0d\x0a                                value = this._function();\x0d\x0a                            }\x0d\x0a                        }\x0d\x0a\x0d\x0a                        /*if (value === null) {\x0d\x0a                            return null;\x0d\x0a                            //throw new Error(\x22Expected identifier at line \x22 + tokenStream.token().startLine + \x22, character \x22 +  tokenStream.token().startCol + \x22.\x22);\x0d\x0a                        }*/\x0d\x0a\x0d\x0a                    } else {\x0d\x0a                        value = token.value;\x0d\x0a                        if (unary === null) {\x0d\x0a                            line = token.startLine;\x0d\x0a                            col = token.startCol;\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a\x0d\x0a                }\x0d\x0a\x0d\x0a                return part !== null ? part : value !== null ?\x0d\x0a                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :\x0d\x0a                        null;\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            _function: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * function\x0d\x0a                 *   : FUNCTION S* expr \x27)\x27 S*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    functionText = null,\x0d\x0a                    expr        = null,\x0d\x0a                    lt;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.FUNCTION)) {\x0d\x0a                    functionText = tokenStream.token().value;\x0d\x0a                    this._readWhitespace();\x0d\x0a                    expr = this._expr(true);\x0d\x0a                    functionText += expr;\x0d\x0a\x0d\x0a                    //START: Horrible hack in case it\x27s an IE filter\x0d\x0a                    if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS) {\x0d\x0a                        do {\x0d\x0a\x0d\x0a                            if (this._readWhitespace()) {\x0d\x0a                                functionText += tokenStream.token().value;\x0d\x0a                            }\x0d\x0a\x0d\x0a                            //might be second time in the loop\x0d\x0a                            if (tokenStream.LA(0) === Tokens.COMMA) {\x0d\x0a                                functionText += tokenStream.token().value;\x0d\x0a                            }\x0d\x0a\x0d\x0a                            tokenStream.match(Tokens.IDENT);\x0d\x0a                            functionText += tokenStream.token().value;\x0d\x0a\x0d\x0a                            tokenStream.match(Tokens.EQUALS);\x0d\x0a                            functionText += tokenStream.token().value;\x0d\x0a\x0d\x0a                            //functionText += this._term();\x0d\x0a                            lt = tokenStream.peek();\x0d\x0a                            while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {\x0d\x0a                                tokenStream.get();\x0d\x0a                                functionText += tokenStream.token().value;\x0d\x0a                                lt = tokenStream.peek();\x0d\x0a                            }\x0d\x0a                        } while (tokenStream.match([Tokens.COMMA, Tokens.S]));\x0d\x0a                    }\x0d\x0a\x0d\x0a                    //END: Horrible Hack\x0d\x0a\x0d\x0a                    tokenStream.match(Tokens.RPAREN);\x0d\x0a                    functionText += \x22)\x22;\x0d\x0a                    this._readWhitespace();\x0d\x0a                }\x0d\x0a\x0d\x0a                return functionText;\x0d\x0a            },\x0d\x0a\x0d\x0a            _ie_function: function() {\x0d\x0a\x0d\x0a                /* (My own extension)\x0d\x0a                 * ie_function\x0d\x0a                 *   : IE_FUNCTION S* IDENT \x27=\x27 term [S* \x27,\x27? IDENT \x27=\x27 term]+ \x27)\x27 S*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    functionText = null,\x0d\x0a                    lt;\x0d\x0a\x0d\x0a                //IE function can begin like a regular function, too\x0d\x0a                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])) {\x0d\x0a                    functionText = tokenStream.token().value;\x0d\x0a\x0d\x0a                    do {\x0d\x0a\x0d\x0a                        if (this._readWhitespace()) {\x0d\x0a                            functionText += tokenStream.token().value;\x0d\x0a                        }\x0d\x0a\x0d\x0a                        //might be second time in the loop\x0d\x0a                        if (tokenStream.LA(0) === Tokens.COMMA) {\x0d\x0a                            functionText += tokenStream.token().value;\x0d\x0a                        }\x0d\x0a\x0d\x0a                        tokenStream.match(Tokens.IDENT);\x0d\x0a                        functionText += tokenStream.token().value;\x0d\x0a\x0d\x0a                        tokenStream.match(Tokens.EQUALS);\x0d\x0a                        functionText += tokenStream.token().value;\x0d\x0a\x0d\x0a                        //functionText += this._term();\x0d\x0a                        lt = tokenStream.peek();\x0d\x0a                        while (lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN) {\x0d\x0a                            tokenStream.get();\x0d\x0a                            functionText += tokenStream.token().value;\x0d\x0a                            lt = tokenStream.peek();\x0d\x0a                        }\x0d\x0a                    } while (tokenStream.match([Tokens.COMMA, Tokens.S]));\x0d\x0a\x0d\x0a                    tokenStream.match(Tokens.RPAREN);\x0d\x0a                    functionText += \x22)\x22;\x0d\x0a                    this._readWhitespace();\x0d\x0a                }\x0d\x0a\x0d\x0a                return functionText;\x0d\x0a            },\x0d\x0a\x0d\x0a            _hexcolor: function() {\x0d\x0a                /*\x0d\x0a                 * There is a constraint on the color that it must\x0d\x0a                 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])\x0d\x0a                 * after the \x22#\x22; e.g., \x22#000\x22 is OK, but \x22#abcd\x22 is not.\x0d\x0a                 *\x0d\x0a                 * hexcolor\x0d\x0a                 *   : HASH S*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    token = null,\x0d\x0a                    color;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.HASH)) {\x0d\x0a\x0d\x0a                    //need to do some validation here\x0d\x0a\x0d\x0a                    token = tokenStream.token();\x0d\x0a                    color = token.value;\x0d\x0a                    if (!/#[a-f0-9]{3,6}/i.test(color)) {\x0d\x0a                        throw new SyntaxError(\x22Expected a hex color but found \x27\x22 + color + \x22\x27 at line \x22 + token.startLine + \x22, col \x22 + token.startCol + \x22.\x22, token.startLine, token.startCol);\x0d\x0a                    }\x0d\x0a                    this._readWhitespace();\x0d\x0a                }\x0d\x0a\x0d\x0a                return token;\x0d\x0a            },\x0d\x0a\x0d\x0a            //-----------------------------------------------------------------\x0d\x0a            // Animations methods\x0d\x0a            //-----------------------------------------------------------------\x0d\x0a\x0d\x0a            _keyframes: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * keyframes:\x0d\x0a                 *   : KEYFRAMES_SYM S* keyframe_name S* \x27{\x27 S* keyframe_rule* \x27}\x27 {\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    token,\x0d\x0a                    tt,\x0d\x0a                    name,\x0d\x0a                    prefix = \x22\x22;\x0d\x0a\x0d\x0a                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);\x0d\x0a                token = tokenStream.token();\x0d\x0a                if (/^@\x5c-([^\x5c-]+)\x5c-/.test(token.value)) {\x0d\x0a                    prefix = RegExp.$1;\x0d\x0a                }\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a                name = this._keyframe_name();\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a                tokenStream.mustMatch(Tokens.LBRACE);\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22startkeyframes\x22,\x0d\x0a                    name:   name,\x0d\x0a                    prefix: prefix,\x0d\x0a                    line:   token.startLine,\x0d\x0a                    col:    token.startCol\x0d\x0a                });\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a                tt = tokenStream.peek();\x0d\x0a\x0d\x0a                //check for key\x0d\x0a                while (tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {\x0d\x0a                    this._keyframe_rule();\x0d\x0a                    this._readWhitespace();\x0d\x0a                    tt = tokenStream.peek();\x0d\x0a                }\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22endkeyframes\x22,\x0d\x0a                    name:   name,\x0d\x0a                    prefix: prefix,\x0d\x0a                    line:   token.startLine,\x0d\x0a                    col:    token.startCol\x0d\x0a                });\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a                tokenStream.mustMatch(Tokens.RBRACE);\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            _keyframe_name: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * keyframe_name:\x0d\x0a                 *   : IDENT\x0d\x0a                 *   | STRING\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream;\x0d\x0a\x0d\x0a                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);\x0d\x0a                return SyntaxUnit.fromToken(tokenStream.token());\x0d\x0a            },\x0d\x0a\x0d\x0a            _keyframe_rule: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * keyframe_rule:\x0d\x0a                 *   : key_list S*\x0d\x0a                 *     \x27{\x27 S* declaration [ \x27;\x27 S* declaration ]* \x27}\x27 S*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var keyList = this._key_list();\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22startkeyframerule\x22,\x0d\x0a                    keys:   keyList,\x0d\x0a                    line:   keyList[0].line,\x0d\x0a                    col:    keyList[0].col\x0d\x0a                });\x0d\x0a\x0d\x0a                this._readDeclarations(true);\x0d\x0a\x0d\x0a                this.fire({\x0d\x0a                    type:   \x22endkeyframerule\x22,\x0d\x0a                    keys:   keyList,\x0d\x0a                    line:   keyList[0].line,\x0d\x0a                    col:    keyList[0].col\x0d\x0a                });\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            _key_list: function() {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * key_list:\x0d\x0a                 *   : key [ S* \x27,\x27 S* key]*\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    keyList = [];\x0d\x0a\x0d\x0a                //must be least one key\x0d\x0a                keyList.push(this._key());\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                while (tokenStream.match(Tokens.COMMA)) {\x0d\x0a                    this._readWhitespace();\x0d\x0a                    keyList.push(this._key());\x0d\x0a                    this._readWhitespace();\x0d\x0a                }\x0d\x0a\x0d\x0a                return keyList;\x0d\x0a            },\x0d\x0a\x0d\x0a            _key: function() {\x0d\x0a                /*\x0d\x0a                 * There is a restriction that IDENT can be only \x22from\x22 or \x22to\x22.\x0d\x0a                 *\x0d\x0a                 * key\x0d\x0a                 *   : PERCENTAGE\x0d\x0a                 *   | IDENT\x0d\x0a                 *   ;\x0d\x0a                 */\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    token;\x0d\x0a\x0d\x0a                if (tokenStream.match(Tokens.PERCENTAGE)) {\x0d\x0a                    return SyntaxUnit.fromToken(tokenStream.token());\x0d\x0a                } else if (tokenStream.match(Tokens.IDENT)) {\x0d\x0a                    token = tokenStream.token();\x0d\x0a\x0d\x0a                    if (/from|to/i.test(token.value)) {\x0d\x0a                        return SyntaxUnit.fromToken(token);\x0d\x0a                    }\x0d\x0a\x0d\x0a                    tokenStream.unget();\x0d\x0a                }\x0d\x0a\x0d\x0a                //if it gets here, there wasn\x27t a valid token, so time to explode\x0d\x0a                this._unexpectedToken(tokenStream.LT(1));\x0d\x0a            },\x0d\x0a\x0d\x0a            //-----------------------------------------------------------------\x0d\x0a            // Helper methods\x0d\x0a            //-----------------------------------------------------------------\x0d\x0a\x0d\x0a            /**\x0d\x0a             * Not part of CSS grammar, but useful for skipping over\x0d\x0a             * combination of white space and HTML-style comments.\x0d\x0a             * @return {void}\x0d\x0a             * @method _skipCruft\x0d\x0a             * @private\x0d\x0a             */\x0d\x0a            _skipCruft: function() {\x0d\x0a                while (this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])) {\x0d\x0a                    //noop\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            /**\x0d\x0a             * Not part of CSS grammar, but this pattern occurs frequently\x0d\x0a             * in the official CSS grammar. Split out here to eliminate\x0d\x0a             * duplicate code.\x0d\x0a             * @param {Boolean} checkStart Indicates if the rule should check\x0d\x0a             *      for the left brace at the beginning.\x0d\x0a             * @param {Boolean} readMargins Indicates if the rule should check\x0d\x0a             *      for margin patterns.\x0d\x0a             * @return {void}\x0d\x0a             * @method _readDeclarations\x0d\x0a             * @private\x0d\x0a             */\x0d\x0a            _readDeclarations: function(checkStart, readMargins) {\x0d\x0a                /*\x0d\x0a                 * Reads the pattern\x0d\x0a                 * S* \x27{\x27 S* declaration [ \x27;\x27 S* declaration ]* \x27}\x27 S*\x0d\x0a                 * or\x0d\x0a                 * S* \x27{\x27 S* [ declaration | margin ]? [ \x27;\x27 S* [ declaration | margin ]? ]* \x27}\x27 S*\x0d\x0a                 * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.\x0d\x0a                 * A semicolon is only necessary following a declaration if there\x27s another declaration\x0d\x0a                 * or margin afterwards.\x0d\x0a                 */\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    tt;\x0d\x0a\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                if (checkStart) {\x0d\x0a                    tokenStream.mustMatch(Tokens.LBRACE);\x0d\x0a                }\x0d\x0a\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                try {\x0d\x0a\x0d\x0a                    while (true) {\x0d\x0a\x0d\x0a                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())) {\x0d\x0a                            //noop\x0d\x0a                        } else if (this._declaration()) {\x0d\x0a                            if (!tokenStream.match(Tokens.SEMICOLON)) {\x0d\x0a                                break;\x0d\x0a                            }\x0d\x0a                        } else {\x0d\x0a                            break;\x0d\x0a                        }\x0d\x0a\x0d\x0a                        //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){\x0d\x0a                        //    break;\x0d\x0a                        //}\x0d\x0a                        this._readWhitespace();\x0d\x0a                    }\x0d\x0a\x0d\x0a                    tokenStream.mustMatch(Tokens.RBRACE);\x0d\x0a                    this._readWhitespace();\x0d\x0a\x0d\x0a                } catch (ex) {\x0d\x0a                    if (ex instanceof SyntaxError && !this.options.strict) {\x0d\x0a\x0d\x0a                        //fire error event\x0d\x0a                        this.fire({\x0d\x0a                            type:       \x22error\x22,\x0d\x0a                            error:      ex,\x0d\x0a                            message:    ex.message,\x0d\x0a                            line:       ex.line,\x0d\x0a                            col:        ex.col\x0d\x0a                        });\x0d\x0a\x0d\x0a                        //see if there\x27s another declaration\x0d\x0a                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);\x0d\x0a                        if (tt === Tokens.SEMICOLON) {\x0d\x0a                            //if there\x27s a semicolon, then there might be another declaration\x0d\x0a                            this._readDeclarations(false, readMargins);\x0d\x0a                        } else if (tt !== Tokens.RBRACE) {\x0d\x0a                            //if there\x27s a right brace, the rule is finished so don\x27t do anything\x0d\x0a                            //otherwise, rethrow the error because it wasn\x27t handled properly\x0d\x0a                            throw ex;\x0d\x0a                        }\x0d\x0a\x0d\x0a                    } else {\x0d\x0a                        //not a syntax error, rethrow it\x0d\x0a                        throw ex;\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a            },\x0d\x0a\x0d\x0a            /**\x0d\x0a             * In some cases, you can end up with two white space tokens in a\x0d\x0a             * row. Instead of making a change in every function that looks for\x0d\x0a             * white space, this function is used to match as much white space\x0d\x0a             * as necessary.\x0d\x0a             * @method _readWhitespace\x0d\x0a             * @return {String} The white space if found, empty string if not.\x0d\x0a             * @private\x0d\x0a             */\x0d\x0a            _readWhitespace: function() {\x0d\x0a\x0d\x0a                var tokenStream = this._tokenStream,\x0d\x0a                    ws = \x22\x22;\x0d\x0a\x0d\x0a                while (tokenStream.match(Tokens.S)) {\x0d\x0a                    ws += tokenStream.token().value;\x0d\x0a                }\x0d\x0a\x0d\x0a                return ws;\x0d\x0a            },\x0d\x0a\x0d\x0a\x0d\x0a            /**\x0d\x0a             * Throws an error when an unexpected token is found.\x0d\x0a             * @param {Object} token The token that was found.\x0d\x0a             * @method _unexpectedToken\x0d\x0a             * @return {void}\x0d\x0a             * @private\x0d\x0a             */\x0d\x0a            _unexpectedToken: function(token) {\x0d\x0a                throw new SyntaxError(\x22Unexpected token \x27\x22 + token.value + \x22\x27 at line \x22 + token.startLine + \x22, col \x22 + token.startCol + \x22.\x22, token.startLine, token.startCol);\x0d\x0a            },\x0d\x0a\x0d\x0a            /**\x0d\x0a             * Helper method used for parsing subparts of a style sheet.\x0d\x0a             * @return {void}\x0d\x0a             * @method _verifyEnd\x0d\x0a             * @private\x0d\x0a             */\x0d\x0a            _verifyEnd: function() {\x0d\x0a                if (this._tokenStream.LA(1) !== Tokens.EOF) {\x0d\x0a                    this._unexpectedToken(this._tokenStream.LT(1));\x0d\x0a                }\x0d\x0a            },\x0d\x0a\x0d\x0a            //-----------------------------------------------------------------\x0d\x0a            // Validation methods\x0d\x0a            //-----------------------------------------------------------------\x0d\x0a            _validateProperty: function(property, value) {\x0d\x0a                Validation.validate(property, value);\x0d\x0a            },\x0d\x0a\x0d\x0a            //-----------------------------------------------------------------\x0d\x0a            // Parsing methods\x0d\x0a            //-----------------------------------------------------------------\x0d\x0a\x0d\x0a            parse: function(input) {\x0d\x0a                this._tokenStream = new TokenStream(input, Tokens);\x0d\x0a                this._stylesheet();\x0d\x0a            },\x0d\x0a\x0d\x0a            parseStyleSheet: function(input) {\x0d\x0a                //just passthrough\x0d\x0a                return this.parse(input);\x0d\x0a            },\x0d\x0a\x0d\x0a            parseMediaQuery: function(input) {\x0d\x0a                this._tokenStream = new TokenStream(input, Tokens);\x0d\x0a                var result = this._media_query();\x0d\x0a\x0d\x0a                //if there\x27s anything more, then it\x27s an invalid selector\x0d\x0a                this._verifyEnd();\x0d\x0a\x0d\x0a                //otherwise return result\x0d\x0a                return result;\x0d\x0a            },\x0d\x0a\x0d\x0a            /**\x0d\x0a             * Parses a property value (everything after the semicolon).\x0d\x0a             * @return {parserlib.css.PropertyValue} The property value.\x0d\x0a             * @throws parserlib.util.SyntaxError If an unexpected token is found.\x0d\x0a             * @method parserPropertyValue\x0d\x0a             */\x0d\x0a            parsePropertyValue: function(input) {\x0d\x0a\x0d\x0a                this._tokenStream = new TokenStream(input, Tokens);\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                var result = this._expr();\x0d\x0a\x0d\x0a                //okay to have a trailing white space\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                //if there\x27s anything more, then it\x27s an invalid selector\x0d\x0a                this._verifyEnd();\x0d\x0a\x0d\x0a                //otherwise return result\x0d\x0a                return result;\x0d\x0a            },\x0d\x0a\x0d\x0a            /**\x0d\x0a             * Parses a complete CSS rule, including selectors and\x0d\x0a             * properties.\x0d\x0a             * @param {String} input The text to parser.\x0d\x0a             * @return {Boolean} True if the parse completed successfully, false if not.\x0d\x0a             * @method parseRule\x0d\x0a             */\x0d\x0a            parseRule: function(input) {\x0d\x0a                this._tokenStream = new TokenStream(input, Tokens);\x0d\x0a\x0d\x0a                //skip any leading white space\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                var result = this._ruleset();\x0d\x0a\x0d\x0a                //skip any trailing white space\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                //if there\x27s anything more, then it\x27s an invalid selector\x0d\x0a                this._verifyEnd();\x0d\x0a\x0d\x0a                //otherwise return result\x0d\x0a                return result;\x0d\x0a            },\x0d\x0a\x0d\x0a            /**\x0d\x0a             * Parses a single CSS selector (no comma)\x0d\x0a             * @param {String} input The text to parse as a CSS selector.\x0d\x0a             * @return {Selector} An object representing the selector.\x0d\x0a             * @throws parserlib.util.SyntaxError If an unexpected token is found.\x0d\x0a             * @method parseSelector\x0d\x0a             */\x0d\x0a            parseSelector: function(input) {\x0d\x0a\x0d\x0a                this._tokenStream = new TokenStream(input, Tokens);\x0d\x0a\x0d\x0a                //skip any leading white space\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                var result = this._selector();\x0d\x0a\x0d\x0a                //skip any trailing white space\x0d\x0a                this._readWhitespace();\x0d\x0a\x0d\x0a                //if there\x27s anything more, then it\x27s an invalid selector\x0d\x0a                this._verifyEnd();\x0d\x0a\x0d\x0a                //otherwise return result\x0d\x0a                return result;\x0d\x0a            },\x0d\x0a\x0d\x0a            /**\x0d\x0a             * Parses an HTML style attribute: a set of CSS declarations\x0d\x0a             * separated by semicolons.\x0d\x0a             * @param {String} input The text to parse as a style attribute\x0d\x0a             * @return {void}\x0d\x0a             * @method parseStyleAttribute\x0d\x0a             */\x0d\x0a            parseStyleAttribute: function(input) {\x0d\x0a                input += \x22}\x22; // for error recovery in _readDeclarations()\x0d\x0a                this._tokenStream = new TokenStream(input, Tokens);\x0d\x0a                this._readDeclarations();\x0d\x0a            }\x0d\x0a        };\x0d\x0a\x0d\x0a    //copy over onto prototype\x0d\x0a    for (prop in additions) {\x0d\x0a        if (Object.prototype.hasOwnProperty.call(additions, prop)) {\x0d\x0a            proto[prop] = additions[prop];\x0d\x0a        }\x0d\x0a    }\x0d\x0a\x0d\x0a    return proto;\x0d\x0a}();\x0d\x0a\x0d\x0a\x0d\x0a/*\x0d\x0anth\x0d\x0a  : S* [ [\x27-\x27|\x27+\x27]? INTEGER? {N} [ S* [\x27-\x27|\x27+\x27] S* INTEGER ]? |\x0d\x0a         [\x27-\x27|\x27+\x27]? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*\x0d\x0a  ;\x0d\x0a*/\x0d\x0a\x0d\x0a},{\x22../util/EventTarget\x22:23,\x22../util/SyntaxError\x22:25,\x22../util/SyntaxUnit\x22:26,\x22./Combinator\x22:2,\x22./MediaFeature\x22:4,\x22./MediaQuery\x22:5,\x22./PropertyName\x22:8,\x22./PropertyValue\x22:9,\x22./PropertyValuePart\x22:11,\x22./Selector\x22:13,\x22./SelectorPart\x22:14,\x22./SelectorSubPart\x22:15,\x22./TokenStream\x22:17,\x22./Tokens\x22:18,\x22./Validation\x22:19}],7:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0a/* exported Properties */\x0d\x0a\x0d\x0avar Properties = module.exports = {\x0d\x0a    __proto__: null,\x0d\x0a\x0d\x0a    //A\x0d\x0a    \x22align-items\x22                   : \x22flex-start | flex-end | center | baseline | stretch\x22,\x0d\x0a    \x22align-content\x22                 : \x22flex-start | flex-end | center | space-between | space-around | stretch\x22,\x0d\x0a    \x22align-self\x22                    : \x22auto | flex-start | flex-end | center | baseline | stretch\x22,\x0d\x0a    \x22all\x22                           : \x22initial | inherit | unset\x22,\x0d\x0a    \x22-webkit-align-items\x22           : \x22flex-start | flex-end | center | baseline | stretch\x22,\x0d\x0a    \x22-webkit-align-content\x22         : \x22flex-start | flex-end | center | space-between | space-around | stretch\x22,\x0d\x0a    \x22-webkit-align-self\x22            : \x22auto | flex-start | flex-end | center | baseline | stretch\x22,\x0d\x0a    \x22alignment-adjust\x22              : \x22auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | \x3cpercentage\x3e | \x3clength\x3e\x22,\x0d\x0a    \x22alignment-baseline\x22            : \x22auto | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\x22,\x0d\x0a    \x22animation\x22                     : 1,\x0d\x0a    \x22animation-delay\x22               : \x22\x3ctime\x3e#\x22,\x0d\x0a    \x22animation-direction\x22           : \x22\x3csingle-animation-direction\x3e#\x22,\x0d\x0a    \x22animation-duration\x22            : \x22\x3ctime\x3e#\x22,\x0d\x0a    \x22animation-fill-mode\x22           : \x22[ none | forwards | backwards | both ]#\x22,\x0d\x0a    \x22animation-iteration-count\x22     : \x22[ \x3cnumber\x3e | infinite ]#\x22,\x0d\x0a    \x22animation-name\x22                : \x22[ none | \x3csingle-animation-name\x3e ]#\x22,\x0d\x0a    \x22animation-play-state\x22          : \x22[ running | paused ]#\x22,\x0d\x0a    \x22animation-timing-function\x22     : 1,\x0d\x0a\x0d\x0a    //vendor prefixed\x0d\x0a    \x22-moz-animation-delay\x22               : \x22\x3ctime\x3e#\x22,\x0d\x0a    \x22-moz-animation-direction\x22           : \x22[ normal | alternate ]#\x22,\x0d\x0a    \x22-moz-animation-duration\x22            : \x22\x3ctime\x3e#\x22,\x0d\x0a    \x22-moz-animation-iteration-count\x22     : \x22[ \x3cnumber\x3e | infinite ]#\x22,\x0d\x0a    \x22-moz-animation-name\x22                : \x22[ none | \x3csingle-animation-name\x3e ]#\x22,\x0d\x0a    \x22-moz-animation-play-state\x22          : \x22[ running | paused ]#\x22,\x0d\x0a\x0d\x0a    \x22-ms-animation-delay\x22               : \x22\x3ctime\x3e#\x22,\x0d\x0a    \x22-ms-animation-direction\x22           : \x22[ normal | alternate ]#\x22,\x0d\x0a    \x22-ms-animation-duration\x22            : \x22\x3ctime\x3e#\x22,\x0d\x0a    \x22-ms-animation-iteration-count\x22     : \x22[ \x3cnumber\x3e | infinite ]#\x22,\x0d\x0a    \x22-ms-animation-name\x22                : \x22[ none | \x3csingle-animation-name\x3e ]#\x22,\x0d\x0a    \x22-ms-animation-play-state\x22          : \x22[ running | paused ]#\x22,\x0d\x0a\x0d\x0a    \x22-webkit-animation-delay\x22               : \x22\x3ctime\x3e#\x22,\x0d\x0a    \x22-webkit-animation-direction\x22           : \x22[ normal | alternate ]#\x22,\x0d\x0a    \x22-webkit-animation-duration\x22            : \x22\x3ctime\x3e#\x22,\x0d\x0a    \x22-webkit-animation-fill-mode\x22           : \x22[ none | forwards | backwards | both ]#\x22,\x0d\x0a    \x22-webkit-animation-iteration-count\x22     : \x22[ \x3cnumber\x3e | infinite ]#\x22,\x0d\x0a    \x22-webkit-animation-name\x22                : \x22[ none | \x3csingle-animation-name\x3e ]#\x22,\x0d\x0a    \x22-webkit-animation-play-state\x22          : \x22[ running | paused ]#\x22,\x0d\x0a\x0d\x0a    \x22-o-animation-delay\x22               : \x22\x3ctime\x3e#\x22,\x0d\x0a    \x22-o-animation-direction\x22           : \x22[ normal | alternate ]#\x22,\x0d\x0a    \x22-o-animation-duration\x22            : \x22\x3ctime\x3e#\x22,\x0d\x0a    \x22-o-animation-iteration-count\x22     : \x22[ \x3cnumber\x3e | infinite ]#\x22,\x0d\x0a    \x22-o-animation-name\x22                : \x22[ none | \x3csingle-animation-name\x3e ]#\x22,\x0d\x0a    \x22-o-animation-play-state\x22          : \x22[ running | paused ]#\x22,\x0d\x0a\x0d\x0a    \x22appearance\x22                    : \x22none | auto\x22,\x0d\x0a    \x22-moz-appearance\x22               : \x22none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized\x22,\x0d\x0a    \x22-ms-appearance\x22                : \x22none | icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal\x22,\x0d\x0a    \x22-webkit-appearance\x22            : \x22none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox\x09| listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button\x09| media-seek-forward-button\x09| media-slider | media-sliderthumb | menulist\x09| menulist-button\x09| menulist-text\x09| menulist-textfield | push-button\x09| radio\x09| searchfield\x09| searchfield-cancel-button\x09| searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical\x09| square-button\x09| textarea\x09| textfield\x09| scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical\x22,\x0d\x0a    \x22-o-appearance\x22                 : \x22none | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal\x22,\x0d\x0a\x0d\x0a    \x22azimuth\x22                       : \x22\x3cazimuth\x3e\x22,\x0d\x0a\x0d\x0a    //B\x0d\x0a    \x22backface-visibility\x22           : \x22visible | hidden\x22,\x0d\x0a    \x22background\x22                    : 1,\x0d\x0a    \x22background-attachment\x22         : \x22\x3cattachment\x3e#\x22,\x0d\x0a    \x22background-clip\x22               : \x22\x3cbox\x3e#\x22,\x0d\x0a    \x22background-color\x22              : \x22\x3ccolor\x3e\x22,\x0d\x0a    \x22background-image\x22              : \x22\x3cbg-image\x3e#\x22,\x0d\x0a    \x22background-origin\x22             : \x22\x3cbox\x3e#\x22,\x0d\x0a    \x22background-position\x22           : \x22\x3cbg-position\x3e\x22,\x0d\x0a    \x22background-repeat\x22             : \x22\x3crepeat-style\x3e#\x22,\x0d\x0a    \x22background-size\x22               : \x22\x3cbg-size\x3e#\x22,\x0d\x0a    \x22baseline-shift\x22                : \x22baseline | sub | super | \x3cpercentage\x3e | \x3clength\x3e\x22,\x0d\x0a    \x22behavior\x22                      : 1,\x0d\x0a    \x22binding\x22                       : 1,\x0d\x0a    \x22bleed\x22                         : \x22\x3clength\x3e\x22,\x0d\x0a    \x22bookmark-label\x22                : \x22\x3ccontent\x3e | \x3cattr\x3e | \x3cstring\x3e\x22,\x0d\x0a    \x22bookmark-level\x22                : \x22none | \x3cinteger\x3e\x22,\x0d\x0a    \x22bookmark-state\x22                : \x22open | closed\x22,\x0d\x0a    \x22bookmark-target\x22               : \x22none | \x3curi\x3e | \x3cattr\x3e\x22,\x0d\x0a    \x22border\x22                        : \x22\x3cborder-width\x3e || \x3cborder-style\x3e || \x3ccolor\x3e\x22,\x0d\x0a    \x22border-bottom\x22                 : \x22\x3cborder-width\x3e || \x3cborder-style\x3e || \x3ccolor\x3e\x22,\x0d\x0a    \x22border-bottom-color\x22           : \x22\x3ccolor\x3e\x22,\x0d\x0a    \x22border-bottom-left-radius\x22     :  \x22\x3cx-one-radius\x3e\x22,\x0d\x0a    \x22border-bottom-right-radius\x22    :  \x22\x3cx-one-radius\x3e\x22,\x0d\x0a    \x22border-bottom-style\x22           : \x22\x3cborder-style\x3e\x22,\x0d\x0a    \x22border-bottom-width\x22           : \x22\x3cborder-width\x3e\x22,\x0d\x0a    \x22border-collapse\x22               : \x22collapse | separate\x22,\x0d\x0a    \x22border-color\x22                  : \x22\x3ccolor\x3e{1,4}\x22,\x0d\x0a    \x22border-image\x22                  : 1,\x0d\x0a    \x22border-image-outset\x22           : \x22[ \x3clength\x3e | \x3cnumber\x3e ]{1,4}\x22,\x0d\x0a    \x22border-image-repeat\x22           : \x22[ stretch | repeat | round ]{1,2}\x22,\x0d\x0a    \x22border-image-slice\x22            : \x22\x3cborder-image-slice\x3e\x22,\x0d\x0a    \x22border-image-source\x22           : \x22\x3cimage\x3e | none\x22,\x0d\x0a    \x22border-image-width\x22            : \x22[ \x3clength\x3e | \x3cpercentage\x3e | \x3cnumber\x3e | auto ]{1,4}\x22,\x0d\x0a    \x22border-left\x22                   : \x22\x3cborder-width\x3e || \x3cborder-style\x3e || \x3ccolor\x3e\x22,\x0d\x0a    \x22border-left-color\x22             : \x22\x3ccolor\x3e\x22,\x0d\x0a    \x22border-left-style\x22             : \x22\x3cborder-style\x3e\x22,\x0d\x0a    \x22border-left-width\x22             : \x22\x3cborder-width\x3e\x22,\x0d\x0a    \x22border-radius\x22                 : \x22\x3cborder-radius\x3e\x22,\x0d\x0a    \x22border-right\x22                  : \x22\x3cborder-width\x3e || \x3cborder-style\x3e || \x3ccolor\x3e\x22,\x0d\x0a    \x22border-right-color\x22            : \x22\x3ccolor\x3e\x22,\x0d\x0a    \x22border-right-style\x22            : \x22\x3cborder-style\x3e\x22,\x0d\x0a    \x22border-right-width\x22            : \x22\x3cborder-width\x3e\x22,\x0d\x0a    \x22border-spacing\x22                : \x22\x3clength\x3e{1,2}\x22,\x0d\x0a    \x22border-style\x22                  : \x22\x3cborder-style\x3e{1,4}\x22,\x0d\x0a    \x22border-top\x22                    : \x22\x3cborder-width\x3e || \x3cborder-style\x3e || \x3ccolor\x3e\x22,\x0d\x0a    \x22border-top-color\x22              : \x22\x3ccolor\x3e\x22,\x0d\x0a    \x22border-top-left-radius\x22        : \x22\x3cx-one-radius\x3e\x22,\x0d\x0a    \x22border-top-right-radius\x22       : \x22\x3cx-one-radius\x3e\x22,\x0d\x0a    \x22border-top-style\x22              : \x22\x3cborder-style\x3e\x22,\x0d\x0a    \x22border-top-width\x22              : \x22\x3cborder-width\x3e\x22,\x0d\x0a    \x22border-width\x22                  : \x22\x3cborder-width\x3e{1,4}\x22,\x0d\x0a    \x22bottom\x22                        : \x22\x3cmargin-width\x3e\x22,\x0d\x0a    \x22-moz-box-align\x22                : \x22start | end | center | baseline | stretch\x22,\x0d\x0a    \x22-moz-box-decoration-break\x22     : \x22slice | clone\x22,\x0d\x0a    \x22-moz-box-direction\x22            : \x22normal | reverse\x22,\x0d\x0a    \x22-moz-box-flex\x22                 : \x22\x3cnumber\x3e\x22,\x0d\x0a    \x22-moz-box-flex-group\x22           : \x22\x3cinteger\x3e\x22,\x0d\x0a    \x22-moz-box-lines\x22                : \x22single | multiple\x22,\x0d\x0a    \x22-moz-box-ordinal-group\x22        : \x22\x3cinteger\x3e\x22,\x0d\x0a    \x22-moz-box-orient\x22               : \x22horizontal | vertical | inline-axis | block-axis\x22,\x0d\x0a    \x22-moz-box-pack\x22                 : \x22start | end | center | justify\x22,\x0d\x0a    \x22-o-box-decoration-break\x22       : \x22slice | clone\x22,\x0d\x0a    \x22-webkit-box-align\x22             : \x22start | end | center | baseline | stretch\x22,\x0d\x0a    \x22-webkit-box-decoration-break\x22  : \x22slice | clone\x22,\x0d\x0a    \x22-webkit-box-direction\x22         : \x22normal | reverse\x22,\x0d\x0a    \x22-webkit-box-flex\x22              : \x22\x3cnumber\x3e\x22,\x0d\x0a    \x22-webkit-box-flex-group\x22        : \x22\x3cinteger\x3e\x22,\x0d\x0a    \x22-webkit-box-lines\x22             : \x22single | multiple\x22,\x0d\x0a    \x22-webkit-box-ordinal-group\x22     : \x22\x3cinteger\x3e\x22,\x0d\x0a    \x22-webkit-box-orient\x22            : \x22horizontal | vertical | inline-axis | block-axis\x22,\x0d\x0a    \x22-webkit-box-pack\x22              : \x22start | end | center | justify\x22,\x0d\x0a    \x22box-decoration-break\x22          : \x22slice | clone\x22,\x0d\x0a    \x22box-shadow\x22                    : \x22\x3cbox-shadow\x3e\x22,\x0d\x0a    \x22box-sizing\x22                    : \x22content-box | border-box\x22,\x0d\x0a    \x22break-after\x22                   : \x22auto | always | avoid | left | right | page | column | avoid-page | avoid-column\x22,\x0d\x0a    \x22break-before\x22                  : \x22auto | always | avoid | left | right | page | column | avoid-page | avoid-column\x22,\x0d\x0a    \x22break-inside\x22                  : \x22auto | avoid | avoid-page | avoid-column\x22,\x0d\x0a\x0d\x0a    //C\x0d\x0a    \x22caption-side\x22                  : \x22top | bottom\x22,\x0d\x0a    \x22clear\x22                         : \x22none | right | left | both\x22,\x0d\x0a    \x22clip\x22                          : \x22\x3cshape\x3e | auto\x22,\x0d\x0a    \x22-webkit-clip-path\x22             : \x22\x3cclip-source\x3e | \x3cclip-path\x3e | none\x22,\x0d\x0a    \x22clip-path\x22                     : \x22\x3cclip-source\x3e | \x3cclip-path\x3e | none\x22,\x0d\x0a    \x22clip-rule\x22                     : \x22nonzero | evenodd\x22,\x0d\x0a    \x22color\x22                         : \x22\x3ccolor\x3e\x22,\x0d\x0a    \x22color-interpolation\x22           : \x22auto | sRGB | linearRGB\x22,\x0d\x0a    \x22color-interpolation-filters\x22   : \x22auto | sRGB | linearRGB\x22,\x0d\x0a    \x22color-profile\x22                 : 1,\x0d\x0a    \x22color-rendering\x22               : \x22auto | optimizeSpeed | optimizeQuality\x22,\x0d\x0a    \x22column-count\x22                  : \x22\x3cinteger\x3e | auto\x22,                      //https://www.w3.org/TR/css3-multicol/\x0d\x0a    \x22column-fill\x22                   : \x22auto | balance\x22,\x0d\x0a    \x22column-gap\x22                    : \x22\x3clength\x3e | normal\x22,\x0d\x0a    \x22column-rule\x22                   : \x22\x3cborder-width\x3e || \x3cborder-style\x3e || \x3ccolor\x3e\x22,\x0d\x0a    \x22column-rule-color\x22             : \x22\x3ccolor\x3e\x22,\x0d\x0a    \x22column-rule-style\x22             : \x22\x3cborder-style\x3e\x22,\x0d\x0a    \x22column-rule-width\x22             : \x22\x3cborder-width\x3e\x22,\x0d\x0a    \x22column-span\x22                   : \x22none | all\x22,\x0d\x0a    \x22column-width\x22                  : \x22\x3clength\x3e | auto\x22,\x0d\x0a    \x22columns\x22                       : 1,\x0d\x0a    \x22content\x22                       : 1,\x0d\x0a    \x22counter-increment\x22             : 1,\x0d\x0a    \x22counter-reset\x22                 : 1,\x0d\x0a    \x22crop\x22                          : \x22\x3cshape\x3e | auto\x22,\x0d\x0a    \x22cue\x22                           : \x22cue-after | cue-before\x22,\x0d\x0a    \x22cue-after\x22                     : 1,\x0d\x0a    \x22cue-before\x22                    : 1,\x0d\x0a    \x22cursor\x22                        : 1,\x0d\x0a\x0d\x0a    //D\x0d\x0a    \x22direction\x22                     : \x22ltr | rtl\x22,\x0d\x0a    \x22display\x22                       : \x22inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex\x22,\x0d\x0a    \x22dominant-baseline\x22             : \x22auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge\x22,\x0d\x0a    \x22drop-initial-after-adjust\x22     : \x22central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | \x3cpercentage\x3e | \x3clength\x3e\x22,\x0d\x0a    \x22drop-initial-after-align\x22      : \x22baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\x22,\x0d\x0a    \x22drop-initial-before-adjust\x22    : \x22before-edge | text-before-edge | central | middle | hanging | mathematical | \x3cpercentage\x3e | \x3clength\x3e\x22,\x0d\x0a    \x22drop-initial-before-align\x22     : \x22caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\x22,\x0d\x0a    \x22drop-initial-size\x22             : \x22auto | line | \x3clength\x3e | \x3cpercentage\x3e\x22,\x0d\x0a    \x22drop-initial-value\x22            : \x22\x3cinteger\x3e\x22,\x0d\x0a\x0d\x0a    //E\x0d\x0a    \x22elevation\x22                     : \x22\x3cangle\x3e | below | level | above | higher | lower\x22,\x0d\x0a    \x22empty-cells\x22                   : \x22show | hide\x22,\x0d\x0a    \x22enable-background\x22             : 1,\x0d\x0a\x0d\x0a    //F\x0d\x0a    \x22fill\x22                          : \x22\x3cpaint\x3e\x22,\x0d\x0a    \x22fill-opacity\x22                  : \x22\x3copacity-value\x3e\x22,\x0d\x0a    \x22fill-rule\x22                     : \x22nonzero | evenodd\x22,\x0d\x0a    \x22filter\x22                        : \x22\x3cfilter-function-list\x3e | none\x22,\x0d\x0a    \x22fit\x22                           : \x22fill | hidden | meet | slice\x22,\x0d\x0a    \x22fit-position\x22                  : 1,\x0d\x0a    \x22flex\x22                          : \x22\x3cflex\x3e\x22,\x0d\x0a    \x22flex-basis\x22                    : \x22\x3cwidth\x3e\x22,\x0d\x0a    \x22flex-direction\x22                : \x22row | row-reverse | column | column-reverse\x22,\x0d\x0a    \x22flex-flow\x22                     : \x22\x3cflex-direction\x3e || \x3cflex-wrap\x3e\x22,\x0d\x0a    \x22flex-grow\x22                     : \x22\x3cnumber\x3e\x22,\x0d\x0a    \x22flex-shrink\x22                   : \x22\x3cnumber\x3e\x22,\x0d\x0a    \x22flex-wrap\x22                     : \x22nowrap | wrap | wrap-reverse\x22,\x0d\x0a    \x22-webkit-flex\x22                  : \x22\x3cflex\x3e\x22,\x0d\x0a    \x22-webkit-flex-basis\x22            : \x22\x3cwidth\x3e\x22,\x0d\x0a    \x22-webkit-flex-direction\x22        : \x22row | row-reverse | column | column-reverse\x22,\x0d\x0a    \x22-webkit-flex-flow\x22             : \x22\x3cflex-direction\x3e || \x3cflex-wrap\x3e\x22,\x0d\x0a    \x22-webkit-flex-grow\x22             : \x22\x3cnumber\x3e\x22,\x0d\x0a    \x22-webkit-flex-shrink\x22           : \x22\x3cnumber\x3e\x22,\x0d\x0a    \x22-webkit-flex-wrap\x22             : \x22nowrap | wrap | wrap-reverse\x22,\x0d\x0a    \x22-ms-flex\x22                      : \x22\x3cflex\x3e\x22,\x0d\x0a    \x22-ms-flex-align\x22                : \x22start | end | center | stretch | baseline\x22,\x0d\x0a    \x22-ms-flex-direction\x22            : \x22row | row-reverse | column | column-reverse\x22,\x0d\x0a    \x22-ms-flex-order\x22                : \x22\x3cnumber\x3e\x22,\x0d\x0a    \x22-ms-flex-pack\x22                 : \x22start | end | center | justify\x22,\x0d\x0a    \x22-ms-flex-wrap\x22                 : \x22nowrap | wrap | wrap-reverse\x22,\x0d\x0a    \x22float\x22                         : \x22left | right | none\x22,\x0d\x0a    \x22float-offset\x22                  : 1,\x0d\x0a    \x22flood-color\x22                   : 1,\x0d\x0a    \x22flood-opacity\x22                 : \x22\x3copacity-value\x3e\x22,\x0d\x0a    \x22font\x22                          : \x22\x3cfont-shorthand\x3e | caption | icon | menu | message-box | small-caption | status-bar\x22,\x0d\x0a    \x22font-family\x22                   : \x22\x3cfont-family\x3e\x22,\x0d\x0a    \x22font-feature-settings\x22         : \x22\x3cfeature-tag-value\x3e | normal\x22,\x0d\x0a    \x22font-kerning\x22                  : \x22auto | normal | none\x22,\x0d\x0a    \x22font-size\x22                     : \x22\x3cfont-size\x3e\x22,\x0d\x0a    \x22font-size-adjust\x22              : \x22\x3cnumber\x3e | none\x22,\x0d\x0a    \x22font-stretch\x22                  : \x22\x3cfont-stretch\x3e\x22,\x0d\x0a    \x22font-style\x22                    : \x22\x3cfont-style\x3e\x22,\x0d\x0a    \x22font-variant\x22                  : \x22\x3cfont-variant\x3e | normal | none\x22,\x0d\x0a    \x22font-variant-alternates\x22       : \x22\x3cfont-variant-alternates\x3e | normal\x22,\x0d\x0a    \x22font-variant-caps\x22             : \x22\x3cfont-variant-caps\x3e | normal\x22,\x0d\x0a    \x22font-variant-east-asian\x22       : \x22\x3cfont-variant-east-asian\x3e | normal\x22,\x0d\x0a    \x22font-variant-ligatures\x22        : \x22\x3cfont-variant-ligatures\x3e | normal | none\x22,\x0d\x0a    \x22font-variant-numeric\x22          : \x22\x3cfont-variant-numeric\x3e | normal\x22,\x0d\x0a    \x22font-variant-position\x22         : \x22normal | sub | super\x22,\x0d\x0a    \x22font-weight\x22                   : \x22\x3cfont-weight\x3e\x22,\x0d\x0a\x0d\x0a    //G\x0d\x0a    \x22glyph-orientation-horizontal\x22  : \x22\x3cglyph-angle\x3e\x22,\x0d\x0a    \x22glyph-orientation-vertical\x22    : \x22auto | \x3cglyph-angle\x3e\x22,\x0d\x0a    \x22grid\x22                          : 1,\x0d\x0a    \x22grid-area\x22                     : 1,\x0d\x0a    \x22grid-auto-columns\x22             : 1,\x0d\x0a    \x22grid-auto-flow\x22                : 1,\x0d\x0a    \x22grid-auto-position\x22            : 1,\x0d\x0a    \x22grid-auto-rows\x22                : 1,\x0d\x0a    \x22grid-cell-stacking\x22            : \x22columns | rows | layer\x22,\x0d\x0a    \x22grid-column\x22                   : 1,\x0d\x0a    \x22grid-columns\x22                  : 1,\x0d\x0a    \x22grid-column-align\x22             : \x22start | end | center | stretch\x22,\x0d\x0a    \x22grid-column-sizing\x22            : 1,\x0d\x0a    \x22grid-column-start\x22             : 1,\x0d\x0a    \x22grid-column-end\x22               : 1,\x0d\x0a    \x22grid-column-span\x22              : \x22\x3cinteger\x3e\x22,\x0d\x0a    \x22grid-flow\x22                     : \x22none | rows | columns\x22,\x0d\x0a    \x22grid-layer\x22                    : \x22\x3cinteger\x3e\x22,\x0d\x0a    \x22grid-row\x22                      : 1,\x0d\x0a    \x22grid-rows\x22                     : 1,\x0d\x0a    \x22grid-row-align\x22                : \x22start | end | center | stretch\x22,\x0d\x0a    \x22grid-row-start\x22                : 1,\x0d\x0a    \x22grid-row-end\x22                  : 1,\x0d\x0a    \x22grid-row-span\x22                 : \x22\x3cinteger\x3e\x22,\x0d\x0a    \x22grid-row-sizing\x22               : 1,\x0d\x0a    \x22grid-template\x22                 : 1,\x0d\x0a    \x22grid-template-areas\x22           : 1,\x0d\x0a    \x22grid-template-columns\x22         : 1,\x0d\x0a    \x22grid-template-rows\x22            : 1,\x0d\x0a\x0d\x0a    //H\x0d\x0a    \x22hanging-punctuation\x22           : 1,\x0d\x0a    \x22height\x22                        : \x22\x3cmargin-width\x3e | \x3ccontent-sizing\x3e\x22,\x0d\x0a    \x22hyphenate-after\x22               : \x22\x3cinteger\x3e | auto\x22,\x0d\x0a    \x22hyphenate-before\x22              : \x22\x3cinteger\x3e | auto\x22,\x0d\x0a    \x22hyphenate-character\x22           : \x22\x3cstring\x3e | auto\x22,\x0d\x0a    \x22hyphenate-lines\x22               : \x22no-limit | \x3cinteger\x3e\x22,\x0d\x0a    \x22hyphenate-resource\x22            : 1,\x0d\x0a    \x22hyphens\x22                       : \x22none | manual | auto\x22,\x0d\x0a\x0d\x0a    //I\x0d\x0a    \x22icon\x22                          : 1,\x0d\x0a    \x22image-orientation\x22             : \x22angle | auto\x22,\x0d\x0a    \x22image-rendering\x22               : \x22auto | optimizeSpeed | optimizeQuality\x22,\x0d\x0a    \x22image-resolution\x22              : 1,\x0d\x0a    \x22ime-mode\x22                      : \x22auto | normal | active | inactive | disabled\x22,\x0d\x0a    \x22inline-box-align\x22              : \x22last | \x3cinteger\x3e\x22,\x0d\x0a\x0d\x0a    //J\x0d\x0a    \x22justify-content\x22               : \x22flex-start | flex-end | center | space-between | space-around\x22,\x0d\x0a    \x22-webkit-justify-content\x22       : \x22flex-start | flex-end | center | space-between | space-around\x22,\x0d\x0a\x0d\x0a    //K\x0d\x0a    \x22kerning\x22                       : \x22auto | \x3clength\x3e\x22,\x0d\x0a\x0d\x0a    //L\x0d\x0a    \x22left\x22                          : \x22\x3cmargin-width\x3e\x22,\x0d\x0a    \x22letter-spacing\x22                : \x22\x3clength\x3e | normal\x22,\x0d\x0a    \x22line-height\x22                   : \x22\x3cline-height\x3e\x22,\x0d\x0a    \x22line-break\x22                    : \x22auto | loose | normal | strict\x22,\x0d\x0a    \x22line-stacking\x22                 : 1,\x0d\x0a    \x22line-stacking-ruby\x22            : \x22exclude-ruby | include-ruby\x22,\x0d\x0a    \x22line-stacking-shift\x22           : \x22consider-shifts | disregard-shifts\x22,\x0d\x0a    \x22line-stacking-strategy\x22        : \x22inline-line-height | block-line-height | max-height | grid-height\x22,\x0d\x0a    \x22list-style\x22                    : 1,\x0d\x0a    \x22list-style-image\x22              : \x22\x3curi\x3e | none\x22,\x0d\x0a    \x22list-style-position\x22           : \x22inside | outside\x22,\x0d\x0a    \x22list-style-type\x22               : \x22disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none\x22,\x0d\x0a\x0d\x0a    //M\x0d\x0a    \x22margin\x22                        : \x22\x3cmargin-width\x3e{1,4}\x22,\x0d\x0a    \x22margin-bottom\x22                 : \x22\x3cmargin-width\x3e\x22,\x0d\x0a    \x22margin-left\x22                   : \x22\x3cmargin-width\x3e\x22,\x0d\x0a    \x22margin-right\x22                  : \x22\x3cmargin-width\x3e\x22,\x0d\x0a    \x22margin-top\x22                    : \x22\x3cmargin-width\x3e\x22,\x0d\x0a    \x22mark\x22                          : 1,\x0d\x0a    \x22mark-after\x22                    : 1,\x0d\x0a    \x22mark-before\x22                   : 1,\x0d\x0a    \x22marker\x22                        : 1,\x0d\x0a    \x22marker-end\x22                    : 1,\x0d\x0a    \x22marker-mid\x22                    : 1,\x0d\x0a    \x22marker-start\x22                  : 1,\x0d\x0a    \x22marks\x22                         : 1,\x0d\x0a    \x22marquee-direction\x22             : 1,\x0d\x0a    \x22marquee-play-count\x22            : 1,\x0d\x0a    \x22marquee-speed\x22                 : 1,\x0d\x0a    \x22marquee-style\x22                 : 1,\x0d\x0a    \x22mask\x22                          : 1,\x0d\x0a    \x22max-height\x22                    : \x22\x3clength\x3e | \x3cpercentage\x3e | \x3ccontent-sizing\x3e | none\x22,\x0d\x0a    \x22max-width\x22                     : \x22\x3clength\x3e | \x3cpercentage\x3e | \x3ccontent-sizing\x3e | none\x22,\x0d\x0a    \x22min-height\x22                    : \x22\x3clength\x3e | \x3cpercentage\x3e | \x3ccontent-sizing\x3e | contain-floats | -moz-contain-floats | -webkit-contain-floats\x22,\x0d\x0a    \x22min-width\x22                     : \x22\x3clength\x3e | \x3cpercentage\x3e | \x3ccontent-sizing\x3e | contain-floats | -moz-contain-floats | -webkit-contain-floats\x22,\x0d\x0a    \x22move-to\x22                       : 1,\x0d\x0a\x0d\x0a    //N\x0d\x0a    \x22nav-down\x22                      : 1,\x0d\x0a    \x22nav-index\x22                     : 1,\x0d\x0a    \x22nav-left\x22                      : 1,\x0d\x0a    \x22nav-right\x22                     : 1,\x0d\x0a    \x22nav-up\x22                        : 1,\x0d\x0a\x0d\x0a    //O\x0d\x0a    \x22object-fit\x22                    : \x22fill | contain | cover | none | scale-down\x22,\x0d\x0a    \x22object-position\x22               : \x22\x3cposition\x3e\x22,\x0d\x0a    \x22opacity\x22                       : \x22\x3copacity-value\x3e\x22,\x0d\x0a    \x22order\x22                         : \x22\x3cinteger\x3e\x22,\x0d\x0a    \x22-webkit-order\x22                 : \x22\x3cinteger\x3e\x22,\x0d\x0a    \x22orphans\x22                       : \x22\x3cinteger\x3e\x22,\x0d\x0a    \x22outline\x22                       : 1,\x0d\x0a    \x22outline-color\x22                 : \x22\x3ccolor\x3e | invert\x22,\x0d\x0a    \x22outline-offset\x22                : 1,\x0d\x0a    \x22outline-style\x22                 : \x22\x3cborder-style\x3e\x22,\x0d\x0a    \x22outline-width\x22                 : \x22\x3cborder-width\x3e\x22,\x0d\x0a    \x22overflow\x22                      : \x22visible | hidden | scroll | auto\x22,\x0d\x0a    \x22overflow-style\x22                : 1,\x0d\x0a    \x22overflow-wrap\x22                 : \x22normal | break-word\x22,\x0d\x0a    \x22overflow-x\x22                    : 1,\x0d\x0a    \x22overflow-y\x22                    : 1,\x0d\x0a\x0d\x0a    //P\x0d\x0a    \x22padding\x22                       : \x22\x3cpadding-width\x3e{1,4}\x22,\x0d\x0a    \x22padding-bottom\x22                : \x22\x3cpadding-width\x3e\x22,\x0d\x0a    \x22padding-left\x22                  : \x22\x3cpadding-width\x3e\x22,\x0d\x0a    \x22padding-right\x22                 : \x22\x3cpadding-width\x3e\x22,\x0d\x0a    \x22padding-top\x22                   : \x22\x3cpadding-width\x3e\x22,\x0d\x0a    \x22page\x22                          : 1,\x0d\x0a    \x22page-break-after\x22              : \x22auto | always | avoid | left | right\x22,\x0d\x0a    \x22page-break-before\x22             : \x22auto | always | avoid | left | right\x22,\x0d\x0a    \x22page-break-inside\x22             : \x22auto | avoid\x22,\x0d\x0a    \x22page-policy\x22                   : 1,\x0d\x0a    \x22pause\x22                         : 1,\x0d\x0a    \x22pause-after\x22                   : 1,\x0d\x0a    \x22pause-before\x22                  : 1,\x0d\x0a    \x22perspective\x22                   : 1,\x0d\x0a    \x22perspective-origin\x22            : 1,\x0d\x0a    \x22phonemes\x22                      : 1,\x0d\x0a    \x22pitch\x22                         : 1,\x0d\x0a    \x22pitch-range\x22                   : 1,\x0d\x0a    \x22play-during\x22                   : 1,\x0d\x0a    \x22pointer-events\x22                : \x22auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all\x22,\x0d\x0a    \x22position\x22                      : \x22static | relative | absolute | fixed\x22,\x0d\x0a    \x22presentation-level\x22            : 1,\x0d\x0a    \x22punctuation-trim\x22              : 1,\x0d\x0a\x0d\x0a    //Q\x0d\x0a    \x22quotes\x22                        : 1,\x0d\x0a\x0d\x0a    //R\x0d\x0a    \x22rendering-intent\x22              : 1,\x0d\x0a    \x22resize\x22                        : 1,\x0d\x0a    \x22rest\x22                          : 1,\x0d\x0a    \x22rest-after\x22                    : 1,\x0d\x0a    \x22rest-before\x22                   : 1,\x0d\x0a    \x22richness\x22                      : 1,\x0d\x0a    \x22right\x22                         : \x22\x3cmargin-width\x3e\x22,\x0d\x0a    \x22rotation\x22                      : 1,\x0d\x0a    \x22rotation-point\x22                : 1,\x0d\x0a    \x22ruby-align\x22                    : 1,\x0d\x0a    \x22ruby-overhang\x22                 : 1,\x0d\x0a    \x22ruby-position\x22                 : 1,\x0d\x0a    \x22ruby-span\x22                     : 1,\x0d\x0a\x0d\x0a    //S\x0d\x0a    \x22shape-rendering\x22               : \x22auto | optimizeSpeed | crispEdges | geometricPrecision\x22,\x0d\x0a    \x22size\x22                          : 1,\x0d\x0a    \x22speak\x22                         : \x22normal | none | spell-out\x22,\x0d\x0a    \x22speak-header\x22                  : \x22once | always\x22,\x0d\x0a    \x22speak-numeral\x22                 : \x22digits | continuous\x22,\x0d\x0a    \x22speak-punctuation\x22             : \x22code | none\x22,\x0d\x0a    \x22speech-rate\x22                   : 1,\x0d\x0a    \x22src\x22                           : 1,\x0d\x0a    \x22stop-color\x22                    : 1,\x0d\x0a    \x22stop-opacity\x22                  : \x22\x3copacity-value\x3e\x22,\x0d\x0a    \x22stress\x22                        : 1,\x0d\x0a    \x22string-set\x22                    : 1,\x0d\x0a    \x22stroke\x22                        : \x22\x3cpaint\x3e\x22,\x0d\x0a    \x22stroke-dasharray\x22              : \x22none | \x3cdasharray\x3e\x22,\x0d\x0a    \x22stroke-dashoffset\x22             : \x22\x3cpercentage\x3e | \x3clength\x3e\x22,\x0d\x0a    \x22stroke-linecap\x22                : \x22butt | round | square\x22,\x0d\x0a    \x22stroke-linejoin\x22               : \x22miter | round | bevel\x22,\x0d\x0a    \x22stroke-miterlimit\x22             : \x22\x3cmiterlimit\x3e\x22,\x0d\x0a    \x22stroke-opacity\x22                : \x22\x3copacity-value\x3e\x22,\x0d\x0a    \x22stroke-width\x22                  : \x22\x3cpercentage\x3e | \x3clength\x3e\x22,\x0d\x0a\x0d\x0a    \x22table-layout\x22                  : \x22auto | fixed\x22,\x0d\x0a    \x22tab-size\x22                      : \x22\x3cinteger\x3e | \x3clength\x3e\x22,\x0d\x0a    \x22target\x22                        : 1,\x0d\x0a    \x22target-name\x22                   : 1,\x0d\x0a    \x22target-new\x22                    : 1,\x0d\x0a    \x22target-position\x22               : 1,\x0d\x0a    \x22text-align\x22                    : \x22left | right | center | justify | match-parent | start | end\x22,\x0d\x0a    \x22text-align-last\x22               : 1,\x0d\x0a    \x22text-anchor\x22                   : \x22start | middle | end\x22,\x0d\x0a    \x22text-decoration\x22               : \x22\x3ctext-decoration-line\x3e || \x3ctext-decoration-style\x3e || \x3ctext-decoration-color\x3e\x22,\x0d\x0a    \x22text-decoration-color\x22         : \x22\x3ctext-decoration-color\x3e\x22,\x0d\x0a    \x22text-decoration-line\x22          : \x22\x3ctext-decoration-line\x3e\x22,\x0d\x0a    \x22text-decoration-style\x22         : \x22\x3ctext-decoration-style\x3e\x22,\x0d\x0a    \x22text-emphasis\x22                 : 1,\x0d\x0a    \x22text-height\x22                   : 1,\x0d\x0a    \x22text-indent\x22                   : \x22\x3clength\x3e | \x3cpercentage\x3e\x22,\x0d\x0a    \x22text-justify\x22                  : \x22auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida\x22,\x0d\x0a    \x22text-outline\x22                  : 1,\x0d\x0a    \x22text-overflow\x22                 : 1,\x0d\x0a    \x22text-rendering\x22                : \x22auto | optimizeSpeed | optimizeLegibility | geometricPrecision\x22,\x0d\x0a    \x22text-shadow\x22                   : 1,\x0d\x0a    \x22text-transform\x22                : \x22capitalize | uppercase | lowercase | none\x22,\x0d\x0a    \x22text-wrap\x22                     : \x22normal | none | avoid\x22,\x0d\x0a    \x22top\x22                           : \x22\x3cmargin-width\x3e\x22,\x0d\x0a    \x22-ms-touch-action\x22              : \x22auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation\x22,\x0d\x0a    \x22touch-action\x22                  : \x22auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation\x22,\x0d\x0a    \x22transform\x22                     : 1,\x0d\x0a    \x22transform-origin\x22              : 1,\x0d\x0a    \x22transform-style\x22               : 1,\x0d\x0a    \x22transition\x22                    : 1,\x0d\x0a    \x22transition-delay\x22              : 1,\x0d\x0a    \x22transition-duration\x22           : 1,\x0d\x0a    \x22transition-property\x22           : 1,\x0d\x0a    \x22transition-timing-function\x22    : 1,\x0d\x0a\x0d\x0a    //U\x0d\x0a    \x22unicode-bidi\x22                  : \x22normal | embed | isolate | bidi-override | isolate-override | plaintext\x22,\x0d\x0a    \x22user-modify\x22                   : \x22read-only | read-write | write-only\x22,\x0d\x0a    \x22user-select\x22                   : \x22none | text | toggle | element | elements | all\x22,\x0d\x0a\x0d\x0a    //V\x0d\x0a    \x22vertical-align\x22                : \x22auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | \x3cpercentage\x3e | \x3clength\x3e\x22,\x0d\x0a    \x22visibility\x22                    : \x22visible | hidden | collapse\x22,\x0d\x0a    \x22voice-balance\x22                 : 1,\x0d\x0a    \x22voice-duration\x22                : 1,\x0d\x0a    \x22voice-family\x22                  : 1,\x0d\x0a    \x22voice-pitch\x22                   : 1,\x0d\x0a    \x22voice-pitch-range\x22             : 1,\x0d\x0a    \x22voice-rate\x22                    : 1,\x0d\x0a    \x22voice-stress\x22                  : 1,\x0d\x0a    \x22voice-volume\x22                  : 1,\x0d\x0a    \x22volume\x22                        : 1,\x0d\x0a\x0d\x0a    //W\x0d\x0a    \x22white-space\x22                   : \x22normal | pre | nowrap | pre-wrap | pre-line | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap\x22,   // https://perishablepress.com/wrapping-content/\x0d\x0a    \x22white-space-collapse\x22          : 1,\x0d\x0a    \x22widows\x22                        : \x22\x3cinteger\x3e\x22,\x0d\x0a    \x22width\x22                         : \x22\x3clength\x3e | \x3cpercentage\x3e | \x3ccontent-sizing\x3e | auto\x22,\x0d\x0a    \x22will-change\x22                   : \x22\x3cwill-change\x3e\x22,\x0d\x0a    \x22word-break\x22                    : \x22normal | keep-all | break-all\x22,\x0d\x0a    \x22word-spacing\x22                  : \x22\x3clength\x3e | normal\x22,\x0d\x0a    \x22word-wrap\x22                     : \x22normal | break-word\x22,\x0d\x0a    \x22writing-mode\x22                  : \x22horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb\x22,\x0d\x0a\x0d\x0a    //Z\x0d\x0a    \x22z-index\x22                       : \x22\x3cinteger\x3e | auto\x22,\x0d\x0a    \x22zoom\x22                          : \x22\x3cnumber\x3e | \x3cpercentage\x3e | normal\x22\x0d\x0a};\x0d\x0a\x0d\x0a},{}],8:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = PropertyName;\x0d\x0a\x0d\x0avar SyntaxUnit = require(\x22../util/SyntaxUnit\x22);\x0d\x0a\x0d\x0avar Parser = require(\x22./Parser\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * Represents a selector combinator (whitespace, +, \x3e).\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class PropertyName\x0d\x0a * @extends parserlib.util.SyntaxUnit\x0d\x0a * @constructor\x0d\x0a * @param {String} text The text representation of the unit.\x0d\x0a * @param {String} hack The type of IE hack applied (\x22*\x22, \x22_\x22, or null).\x0d\x0a * @param {int} line The line of text on which the unit resides.\x0d\x0a * @param {int} col The column of text on which the unit resides.\x0d\x0a */\x0d\x0afunction PropertyName(text, hack, line, col) {\x0d\x0a\x0d\x0a    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The type of IE hack applied (\x22*\x22, \x22_\x22, or null).\x0d\x0a     * @type String\x0d\x0a     * @property hack\x0d\x0a     */\x0d\x0a    this.hack = hack;\x0d\x0a\x0d\x0a}\x0d\x0a\x0d\x0aPropertyName.prototype = new SyntaxUnit();\x0d\x0aPropertyName.prototype.constructor = PropertyName;\x0d\x0aPropertyName.prototype.toString = function() {\x0d\x0a    return (this.hack ? this.hack : \x22\x22) + this.text;\x0d\x0a};\x0d\x0a\x0d\x0a},{\x22../util/SyntaxUnit\x22:26,\x22./Parser\x22:6}],9:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = PropertyValue;\x0d\x0a\x0d\x0avar SyntaxUnit = require(\x22../util/SyntaxUnit\x22);\x0d\x0a\x0d\x0avar Parser = require(\x22./Parser\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * Represents a single part of a CSS property value, meaning that it represents\x0d\x0a * just everything single part between \x22:\x22 and \x22;\x22. If there are multiple values\x0d\x0a * separated by commas, this type represents just one of the values.\x0d\x0a * @param {String[]} parts An array of value parts making up this value.\x0d\x0a * @param {int} line The line of text on which the unit resides.\x0d\x0a * @param {int} col The column of text on which the unit resides.\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class PropertyValue\x0d\x0a * @extends parserlib.util.SyntaxUnit\x0d\x0a * @constructor\x0d\x0a */\x0d\x0afunction PropertyValue(parts, line, col) {\x0d\x0a\x0d\x0a    SyntaxUnit.call(this, parts.join(\x22 \x22), line, col, Parser.PROPERTY_VALUE_TYPE);\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The parts that make up the selector.\x0d\x0a     * @type Array\x0d\x0a     * @property parts\x0d\x0a     */\x0d\x0a    this.parts = parts;\x0d\x0a\x0d\x0a}\x0d\x0a\x0d\x0aPropertyValue.prototype = new SyntaxUnit();\x0d\x0aPropertyValue.prototype.constructor = PropertyValue;\x0d\x0a\x0d\x0a\x0d\x0a},{\x22../util/SyntaxUnit\x22:26,\x22./Parser\x22:6}],10:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = PropertyValueIterator;\x0d\x0a\x0d\x0a/**\x0d\x0a * A utility class that allows for easy iteration over the various parts of a\x0d\x0a * property value.\x0d\x0a * @param {parserlib.css.PropertyValue} value The property value to iterate over.\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class PropertyValueIterator\x0d\x0a * @constructor\x0d\x0a */\x0d\x0afunction PropertyValueIterator(value) {\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Iterator value\x0d\x0a     * @type int\x0d\x0a     * @property _i\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._i = 0;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The parts that make up the value.\x0d\x0a     * @type Array\x0d\x0a     * @property _parts\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._parts = value.parts;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Keeps track of bookmarks along the way.\x0d\x0a     * @type Array\x0d\x0a     * @property _marks\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._marks = [];\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Holds the original property value.\x0d\x0a     * @type parserlib.css.PropertyValue\x0d\x0a     * @property value\x0d\x0a     */\x0d\x0a    this.value = value;\x0d\x0a\x0d\x0a}\x0d\x0a\x0d\x0a/**\x0d\x0a * Returns the total number of parts in the value.\x0d\x0a * @return {int} The total number of parts in the value.\x0d\x0a * @method count\x0d\x0a */\x0d\x0aPropertyValueIterator.prototype.count = function() {\x0d\x0a    return this._parts.length;\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Indicates if the iterator is positioned at the first item.\x0d\x0a * @return {Boolean} True if positioned at first item, false if not.\x0d\x0a * @method isFirst\x0d\x0a */\x0d\x0aPropertyValueIterator.prototype.isFirst = function() {\x0d\x0a    return this._i === 0;\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Indicates if there are more parts of the property value.\x0d\x0a * @return {Boolean} True if there are more parts, false if not.\x0d\x0a * @method hasNext\x0d\x0a */\x0d\x0aPropertyValueIterator.prototype.hasNext = function() {\x0d\x0a    return this._i \x3c this._parts.length;\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Marks the current spot in the iteration so it can be restored to\x0d\x0a * later on.\x0d\x0a * @return {void}\x0d\x0a * @method mark\x0d\x0a */\x0d\x0aPropertyValueIterator.prototype.mark = function() {\x0d\x0a    this._marks.push(this._i);\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Returns the next part of the property value or null if there is no next\x0d\x0a * part. Does not move the internal counter forward.\x0d\x0a * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next\x0d\x0a * part.\x0d\x0a * @method peek\x0d\x0a */\x0d\x0aPropertyValueIterator.prototype.peek = function(count) {\x0d\x0a    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Returns the next part of the property value or null if there is no next\x0d\x0a * part.\x0d\x0a * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next\x0d\x0a * part.\x0d\x0a * @method next\x0d\x0a */\x0d\x0aPropertyValueIterator.prototype.next = function() {\x0d\x0a    return this.hasNext() ? this._parts[this._i++] : null;\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Returns the previous part of the property value or null if there is no\x0d\x0a * previous part.\x0d\x0a * @return {parserlib.css.PropertyValuePart} The previous part of the\x0d\x0a * property value or null if there is no previous part.\x0d\x0a * @method previous\x0d\x0a */\x0d\x0aPropertyValueIterator.prototype.previous = function() {\x0d\x0a    return this._i \x3e 0 ? this._parts[--this._i] : null;\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Restores the last saved bookmark.\x0d\x0a * @return {void}\x0d\x0a * @method restore\x0d\x0a */\x0d\x0aPropertyValueIterator.prototype.restore = function() {\x0d\x0a    if (this._marks.length) {\x0d\x0a        this._i = this._marks.pop();\x0d\x0a    }\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Drops the last saved bookmark.\x0d\x0a * @return {void}\x0d\x0a * @method drop\x0d\x0a */\x0d\x0aPropertyValueIterator.prototype.drop = function() {\x0d\x0a    this._marks.pop();\x0d\x0a};\x0d\x0a\x0d\x0a},{}],11:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = PropertyValuePart;\x0d\x0a\x0d\x0avar SyntaxUnit = require(\x22../util/SyntaxUnit\x22);\x0d\x0a\x0d\x0avar Colors = require(\x22./Colors\x22);\x0d\x0avar Parser = require(\x22./Parser\x22);\x0d\x0avar Tokens = require(\x22./Tokens\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * Represents a single part of a CSS property value, meaning that it represents\x0d\x0a * just one part of the data between \x22:\x22 and \x22;\x22.\x0d\x0a * @param {String} text The text representation of the unit.\x0d\x0a * @param {int} line The line of text on which the unit resides.\x0d\x0a * @param {int} col The column of text on which the unit resides.\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class PropertyValuePart\x0d\x0a * @extends parserlib.util.SyntaxUnit\x0d\x0a * @constructor\x0d\x0a */\x0d\x0afunction PropertyValuePart(text, line, col, optionalHint) {\x0d\x0a    var hint = optionalHint || {};\x0d\x0a\x0d\x0a    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Indicates the type of value unit.\x0d\x0a     * @type String\x0d\x0a     * @property type\x0d\x0a     */\x0d\x0a    this.type = \x22unknown\x22;\x0d\x0a\x0d\x0a    //figure out what type of data it is\x0d\x0a\x0d\x0a    var temp;\x0d\x0a\x0d\x0a    //it is a measurement?\x0d\x0a    if (/^([+\x5c-]?[\x5cd\x5c.]+)([a-z]+)$/i.test(text)) {  //dimension\x0d\x0a        this.type = \x22dimension\x22;\x0d\x0a        this.value = +RegExp.$1;\x0d\x0a        this.units = RegExp.$2;\x0d\x0a\x0d\x0a        //try to narrow down\x0d\x0a        switch (this.units.toLowerCase()) {\x0d\x0a\x0d\x0a            case \x22em\x22:\x0d\x0a            case \x22rem\x22:\x0d\x0a            case \x22ex\x22:\x0d\x0a            case \x22px\x22:\x0d\x0a            case \x22cm\x22:\x0d\x0a            case \x22mm\x22:\x0d\x0a            case \x22in\x22:\x0d\x0a            case \x22pt\x22:\x0d\x0a            case \x22pc\x22:\x0d\x0a            case \x22ch\x22:\x0d\x0a            case \x22vh\x22:\x0d\x0a            case \x22vw\x22:\x0d\x0a            case \x22vmax\x22:\x0d\x0a            case \x22vmin\x22:\x0d\x0a                this.type = \x22length\x22;\x0d\x0a                break;\x0d\x0a\x0d\x0a            case \x22fr\x22:\x0d\x0a                this.type = \x22grid\x22;\x0d\x0a                break;\x0d\x0a\x0d\x0a            case \x22deg\x22:\x0d\x0a            case \x22rad\x22:\x0d\x0a            case \x22grad\x22:\x0d\x0a            case \x22turn\x22:\x0d\x0a                this.type = \x22angle\x22;\x0d\x0a                break;\x0d\x0a\x0d\x0a            case \x22ms\x22:\x0d\x0a            case \x22s\x22:\x0d\x0a                this.type = \x22time\x22;\x0d\x0a                break;\x0d\x0a\x0d\x0a            case \x22hz\x22:\x0d\x0a            case \x22khz\x22:\x0d\x0a                this.type = \x22frequency\x22;\x0d\x0a                break;\x0d\x0a\x0d\x0a            case \x22dpi\x22:\x0d\x0a            case \x22dpcm\x22:\x0d\x0a                this.type = \x22resolution\x22;\x0d\x0a                break;\x0d\x0a\x0d\x0a            //default\x0d\x0a\x0d\x0a        }\x0d\x0a\x0d\x0a    } else if (/^([+\x5c-]?[\x5cd\x5c.]+)%$/i.test(text)) {  //percentage\x0d\x0a        this.type = \x22percentage\x22;\x0d\x0a        this.value = +RegExp.$1;\x0d\x0a    } else if (/^([+\x5c-]?\x5cd+)$/i.test(text)) {  //integer\x0d\x0a        this.type = \x22integer\x22;\x0d\x0a        this.value = +RegExp.$1;\x0d\x0a    } else if (/^([+\x5c-]?[\x5cd\x5c.]+)$/i.test(text)) {  //number\x0d\x0a        this.type = \x22number\x22;\x0d\x0a        this.value = +RegExp.$1;\x0d\x0a\x0d\x0a    } else if (/^#([a-f0-9]{3,6})/i.test(text)) {  //hexcolor\x0d\x0a        this.type = \x22color\x22;\x0d\x0a        temp = RegExp.$1;\x0d\x0a        if (temp.length === 3) {\x0d\x0a            this.red    = parseInt(temp.charAt(0)+temp.charAt(0), 16);\x0d\x0a            this.green  = parseInt(temp.charAt(1)+temp.charAt(1), 16);\x0d\x0a            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2), 16);\x0d\x0a        } else {\x0d\x0a            this.red    = parseInt(temp.substring(0, 2), 16);\x0d\x0a            this.green  = parseInt(temp.substring(2, 4), 16);\x0d\x0a            this.blue   = parseInt(temp.substring(4, 6), 16);\x0d\x0a        }\x0d\x0a    } else if (/^rgb\x5c(\x5cs*(\x5cd+)\x5cs*,\x5cs*(\x5cd+)\x5cs*,\x5cs*(\x5cd+)\x5cs*\x5c)/i.test(text)) { //rgb() color with absolute numbers\x0d\x0a        this.type   = \x22color\x22;\x0d\x0a        this.red    = +RegExp.$1;\x0d\x0a        this.green  = +RegExp.$2;\x0d\x0a        this.blue   = +RegExp.$3;\x0d\x0a    } else if (/^rgb\x5c(\x5cs*(\x5cd+)%\x5cs*,\x5cs*(\x5cd+)%\x5cs*,\x5cs*(\x5cd+)%\x5cs*\x5c)/i.test(text)) { //rgb() color with percentages\x0d\x0a        this.type   = \x22color\x22;\x0d\x0a        this.red    = +RegExp.$1 * 255 / 100;\x0d\x0a        this.green  = +RegExp.$2 * 255 / 100;\x0d\x0a        this.blue   = +RegExp.$3 * 255 / 100;\x0d\x0a    } else if (/^rgba\x5c(\x5cs*(\x5cd+)\x5cs*,\x5cs*(\x5cd+)\x5cs*,\x5cs*(\x5cd+)\x5cs*,\x5cs*([\x5cd\x5c.]+)\x5cs*\x5c)/i.test(text)) { //rgba() color with absolute numbers\x0d\x0a        this.type   = \x22color\x22;\x0d\x0a        this.red    = +RegExp.$1;\x0d\x0a        this.green  = +RegExp.$2;\x0d\x0a        this.blue   = +RegExp.$3;\x0d\x0a        this.alpha  = +RegExp.$4;\x0d\x0a    } else if (/^rgba\x5c(\x5cs*(\x5cd+)%\x5cs*,\x5cs*(\x5cd+)%\x5cs*,\x5cs*(\x5cd+)%\x5cs*,\x5cs*([\x5cd\x5c.]+)\x5cs*\x5c)/i.test(text)) { //rgba() color with percentages\x0d\x0a        this.type   = \x22color\x22;\x0d\x0a        this.red    = +RegExp.$1 * 255 / 100;\x0d\x0a        this.green  = +RegExp.$2 * 255 / 100;\x0d\x0a        this.blue   = +RegExp.$3 * 255 / 100;\x0d\x0a        this.alpha  = +RegExp.$4;\x0d\x0a    } else if (/^hsl\x5c(\x5cs*(\x5cd+)\x5cs*,\x5cs*(\x5cd+)%\x5cs*,\x5cs*(\x5cd+)%\x5cs*\x5c)/i.test(text)) { //hsl()\x0d\x0a        this.type   = \x22color\x22;\x0d\x0a        this.hue    = +RegExp.$1;\x0d\x0a        this.saturation = +RegExp.$2 / 100;\x0d\x0a        this.lightness  = +RegExp.$3 / 100;\x0d\x0a    } else if (/^hsla\x5c(\x5cs*(\x5cd+)\x5cs*,\x5cs*(\x5cd+)%\x5cs*,\x5cs*(\x5cd+)%\x5cs*,\x5cs*([\x5cd\x5c.]+)\x5cs*\x5c)/i.test(text)) { //hsla() color with percentages\x0d\x0a        this.type   = \x22color\x22;\x0d\x0a        this.hue    = +RegExp.$1;\x0d\x0a        this.saturation = +RegExp.$2 / 100;\x0d\x0a        this.lightness  = +RegExp.$3 / 100;\x0d\x0a        this.alpha  = +RegExp.$4;\x0d\x0a    } else if (/^url\x5c((\x22([^\x5c\x5c\x22]|\x5c\x5c.)*\x22)\x5c)/i.test(text)) { //URI\x0d\x0a        // generated by TokenStream.readURI, so always double-quoted.\x0d\x0a        this.type   = \x22uri\x22;\x0d\x0a        this.uri    = PropertyValuePart.parseString(RegExp.$1);\x0d\x0a    } else if (/^([^\x5c(]+)\x5c(/i.test(text)) {\x0d\x0a        this.type   = \x22function\x22;\x0d\x0a        this.name   = RegExp.$1;\x0d\x0a        this.value  = text;\x0d\x0a    } else if (/^\x22([^\x5cn\x5cr\x5cf\x5c\x5c\x22]|\x5c\x5c\x5cr\x5cn|\x5c\x5c[^\x5cr0-9a-f]|\x5c\x5c[0-9a-f]{1,6}(\x5cr\x5cn|[ \x5cn\x5cr\x5ct\x5cf])?)*\x22/i.test(text)) {    //double-quoted string\x0d\x0a        this.type   = \x22string\x22;\x0d\x0a        this.value  = PropertyValuePart.parseString(text);\x0d\x0a    } else if (/^\x27([^\x5cn\x5cr\x5cf\x5c\x5c\x27]|\x5c\x5c\x5cr\x5cn|\x5c\x5c[^\x5cr0-9a-f]|\x5c\x5c[0-9a-f]{1,6}(\x5cr\x5cn|[ \x5cn\x5cr\x5ct\x5cf])?)*\x27/i.test(text)) {    //single-quoted string\x0d\x0a        this.type   = \x22string\x22;\x0d\x0a        this.value  = PropertyValuePart.parseString(text);\x0d\x0a    } else if (Colors[text.toLowerCase()]) {  //named color\x0d\x0a        this.type   = \x22color\x22;\x0d\x0a        temp        = Colors[text.toLowerCase()].substring(1);\x0d\x0a        this.red    = parseInt(temp.substring(0, 2), 16);\x0d\x0a        this.green  = parseInt(temp.substring(2, 4), 16);\x0d\x0a        this.blue   = parseInt(temp.substring(4, 6), 16);\x0d\x0a    } else if (/^[,\x5c/]$/.test(text)) {\x0d\x0a        this.type   = \x22operator\x22;\x0d\x0a        this.value  = text;\x0d\x0a    } else if (/^-?[a-z_\x5cu00A0-\x5cuFFFF][a-z0-9\x5c-_\x5cu00A0-\x5cuFFFF]*$/i.test(text)) {\x0d\x0a        this.type   = \x22identifier\x22;\x0d\x0a        this.value  = text;\x0d\x0a    }\x0d\x0a\x0d\x0a    // There can be ambiguity with escape sequences in identifiers, as\x0d\x0a    // well as with \x22color\x22 parts which are also \x22identifiers\x22, so record\x0d\x0a    // an explicit hint when the token generating this PropertyValuePart\x0d\x0a    // was an identifier.\x0d\x0a    this.wasIdent = Boolean(hint.ident);\x0d\x0a\x0d\x0a}\x0d\x0a\x0d\x0aPropertyValuePart.prototype = new SyntaxUnit();\x0d\x0aPropertyValuePart.prototype.constructor = PropertyValuePart;\x0d\x0a\x0d\x0a/**\x0d\x0a * Helper method to parse a CSS string.\x0d\x0a */\x0d\x0aPropertyValuePart.parseString = function(str) {\x0d\x0a    str = str.slice(1, -1); // Strip surrounding single/double quotes\x0d\x0a    var replacer = function(match, esc) {\x0d\x0a        if (/^(\x5cn|\x5cr\x5cn|\x5cr|\x5cf)$/.test(esc)) {\x0d\x0a            return \x22\x22;\x0d\x0a        }\x0d\x0a        var m = /^[0-9a-f]{1,6}/i.exec(esc);\x0d\x0a        if (m) {\x0d\x0a            var codePoint = parseInt(m[0], 16);\x0d\x0a            if (String.fromCodePoint) {\x0d\x0a                return String.fromCodePoint(codePoint);\x0d\x0a            } else {\x0d\x0a                // XXX No support for surrogates on old JavaScript engines.\x0d\x0a                return String.fromCharCode(codePoint);\x0d\x0a            }\x0d\x0a        }\x0d\x0a        return esc;\x0d\x0a    };\x0d\x0a    return str.replace(/\x5c\x5c(\x5cr\x5cn|[^\x5cr0-9a-f]|[0-9a-f]{1,6}(\x5cr\x5cn|[ \x5cn\x5cr\x5ct\x5cf])?)/ig,\x0d\x0a                       replacer);\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Helper method to serialize a CSS string.\x0d\x0a */\x0d\x0aPropertyValuePart.serializeString = function(value) {\x0d\x0a    var replacer = function(match, c) {\x0d\x0a        if (c === \x22\x5c\x22\x22) {\x0d\x0a            return \x22\x5c\x5c\x22 + c;\x0d\x0a        }\x0d\x0a        var cp = String.codePointAt ? String.codePointAt(0) :\x0d\x0a            // We only escape non-surrogate chars, so using charCodeAt\x0d\x0a            // is harmless here.\x0d\x0a            String.charCodeAt(0);\x0d\x0a        return \x22\x5c\x5c\x22 + cp.toString(16) + \x22 \x22;\x0d\x0a    };\x0d\x0a    return \x22\x5c\x22\x22 + value.replace(/[\x22\x5cr\x5cn\x5cf]/g, replacer) + \x22\x5c\x22\x22;\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Create a new syntax unit based solely on the given token.\x0d\x0a * Convenience method for creating a new syntax unit when\x0d\x0a * it represents a single token instead of multiple.\x0d\x0a * @param {Object} token The token object to represent.\x0d\x0a * @return {parserlib.css.PropertyValuePart} The object representing the token.\x0d\x0a * @static\x0d\x0a * @method fromToken\x0d\x0a */\x0d\x0aPropertyValuePart.fromToken = function(token) {\x0d\x0a    var part = new PropertyValuePart(token.value, token.startLine, token.startCol, {\x0d\x0a        // Tokens can have escaped characters that would fool the type\x0d\x0a        // identification in the PropertyValuePart constructor, so pass\x0d\x0a        // in a hint if this was an identifier.\x0d\x0a        ident: token.type === Tokens.IDENT\x0d\x0a    });\x0d\x0a    return part;\x0d\x0a};\x0d\x0a\x0d\x0a},{\x22../util/SyntaxUnit\x22:26,\x22./Colors\x22:1,\x22./Parser\x22:6,\x22./Tokens\x22:18}],12:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0avar Pseudos = module.exports = {\x0d\x0a    __proto__:       null,\x0d\x0a    \x22:first-letter\x22: 1,\x0d\x0a    \x22:first-line\x22:   1,\x0d\x0a    \x22:before\x22:       1,\x0d\x0a    \x22:after\x22:        1\x0d\x0a};\x0d\x0a\x0d\x0aPseudos.ELEMENT = 1;\x0d\x0aPseudos.CLASS = 2;\x0d\x0a\x0d\x0aPseudos.isElement = function(pseudo) {\x0d\x0a    return pseudo.indexOf(\x22::\x22) === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;\x0d\x0a};\x0d\x0a\x0d\x0a},{}],13:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = Selector;\x0d\x0a\x0d\x0avar SyntaxUnit = require(\x22../util/SyntaxUnit\x22);\x0d\x0a\x0d\x0avar Parser = require(\x22./Parser\x22);\x0d\x0avar Specificity = require(\x22./Specificity\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * Represents an entire single selector, including all parts but not\x0d\x0a * including multiple selectors (those separated by commas).\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class Selector\x0d\x0a * @extends parserlib.util.SyntaxUnit\x0d\x0a * @constructor\x0d\x0a * @param {Array} parts Array of selectors parts making up this selector.\x0d\x0a * @param {int} line The line of text on which the unit resides.\x0d\x0a * @param {int} col The column of text on which the unit resides.\x0d\x0a */\x0d\x0afunction Selector(parts, line, col) {\x0d\x0a\x0d\x0a    SyntaxUnit.call(this, parts.join(\x22 \x22), line, col, Parser.SELECTOR_TYPE);\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The parts that make up the selector.\x0d\x0a     * @type Array\x0d\x0a     * @property parts\x0d\x0a     */\x0d\x0a    this.parts = parts;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The specificity of the selector.\x0d\x0a     * @type parserlib.css.Specificity\x0d\x0a     * @property specificity\x0d\x0a     */\x0d\x0a    this.specificity = Specificity.calculate(this);\x0d\x0a\x0d\x0a}\x0d\x0a\x0d\x0aSelector.prototype = new SyntaxUnit();\x0d\x0aSelector.prototype.constructor = Selector;\x0d\x0a\x0d\x0a\x0d\x0a},{\x22../util/SyntaxUnit\x22:26,\x22./Parser\x22:6,\x22./Specificity\x22:16}],14:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = SelectorPart;\x0d\x0a\x0d\x0avar SyntaxUnit = require(\x22../util/SyntaxUnit\x22);\x0d\x0a\x0d\x0avar Parser = require(\x22./Parser\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * Represents a single part of a selector string, meaning a single set of\x0d\x0a * element name and modifiers. This does not include combinators such as\x0d\x0a * spaces, +, \x3e, etc.\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class SelectorPart\x0d\x0a * @extends parserlib.util.SyntaxUnit\x0d\x0a * @constructor\x0d\x0a * @param {String} elementName The element name in the selector or null\x0d\x0a *      if there is no element name.\x0d\x0a * @param {Array} modifiers Array of individual modifiers for the element.\x0d\x0a *      May be empty if there are none.\x0d\x0a * @param {String} text The text representation of the unit.\x0d\x0a * @param {int} line The line of text on which the unit resides.\x0d\x0a * @param {int} col The column of text on which the unit resides.\x0d\x0a */\x0d\x0afunction SelectorPart(elementName, modifiers, text, line, col) {\x0d\x0a\x0d\x0a    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The tag name of the element to which this part\x0d\x0a     * of the selector affects.\x0d\x0a     * @type String\x0d\x0a     * @property elementName\x0d\x0a     */\x0d\x0a    this.elementName = elementName;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The parts that come after the element name, such as class names, IDs,\x0d\x0a     * pseudo classes/elements, etc.\x0d\x0a     * @type Array\x0d\x0a     * @property modifiers\x0d\x0a     */\x0d\x0a    this.modifiers = modifiers;\x0d\x0a\x0d\x0a}\x0d\x0a\x0d\x0aSelectorPart.prototype = new SyntaxUnit();\x0d\x0aSelectorPart.prototype.constructor = SelectorPart;\x0d\x0a\x0d\x0a\x0d\x0a},{\x22../util/SyntaxUnit\x22:26,\x22./Parser\x22:6}],15:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = SelectorSubPart;\x0d\x0a\x0d\x0avar SyntaxUnit = require(\x22../util/SyntaxUnit\x22);\x0d\x0a\x0d\x0avar Parser = require(\x22./Parser\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * Represents a selector modifier string, meaning a class name, element name,\x0d\x0a * element ID, pseudo rule, etc.\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class SelectorSubPart\x0d\x0a * @extends parserlib.util.SyntaxUnit\x0d\x0a * @constructor\x0d\x0a * @param {String} text The text representation of the unit.\x0d\x0a * @param {String} type The type of selector modifier.\x0d\x0a * @param {int} line The line of text on which the unit resides.\x0d\x0a * @param {int} col The column of text on which the unit resides.\x0d\x0a */\x0d\x0afunction SelectorSubPart(text, type, line, col) {\x0d\x0a\x0d\x0a    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The type of modifier.\x0d\x0a     * @type String\x0d\x0a     * @property type\x0d\x0a     */\x0d\x0a    this.type = type;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Some subparts have arguments, this represents them.\x0d\x0a     * @type Array\x0d\x0a     * @property args\x0d\x0a     */\x0d\x0a    this.args = [];\x0d\x0a\x0d\x0a}\x0d\x0a\x0d\x0aSelectorSubPart.prototype = new SyntaxUnit();\x0d\x0aSelectorSubPart.prototype.constructor = SelectorSubPart;\x0d\x0a\x0d\x0a\x0d\x0a},{\x22../util/SyntaxUnit\x22:26,\x22./Parser\x22:6}],16:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = Specificity;\x0d\x0a\x0d\x0avar Pseudos = require(\x22./Pseudos\x22);\x0d\x0avar SelectorPart = require(\x22./SelectorPart\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * Represents a selector\x27s specificity.\x0d\x0a * @namespace parserlib.css\x0d\x0a * @class Specificity\x0d\x0a * @constructor\x0d\x0a * @param {int} a Should be 1 for inline styles, zero for stylesheet styles\x0d\x0a * @param {int} b Number of ID selectors\x0d\x0a * @param {int} c Number of classes and pseudo classes\x0d\x0a * @param {int} d Number of element names and pseudo elements\x0d\x0a */\x0d\x0afunction Specificity(a, b, c, d) {\x0d\x0a    this.a = a;\x0d\x0a    this.b = b;\x0d\x0a    this.c = c;\x0d\x0a    this.d = d;\x0d\x0a}\x0d\x0a\x0d\x0aSpecificity.prototype = {\x0d\x0a    constructor: Specificity,\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Compare this specificity to another.\x0d\x0a     * @param {Specificity} other The other specificity to compare to.\x0d\x0a     * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.\x0d\x0a     * @method compare\x0d\x0a     */\x0d\x0a    compare: function(other) {\x0d\x0a        var comps = [\x22a\x22, \x22b\x22, \x22c\x22, \x22d\x22],\x0d\x0a            i, len;\x0d\x0a\x0d\x0a        for (i=0, len=comps.length; i \x3c len; i++) {\x0d\x0a            if (this[comps[i]] \x3c other[comps[i]]) {\x0d\x0a                return -1;\x0d\x0a            } else if (this[comps[i]] \x3e other[comps[i]]) {\x0d\x0a                return 1;\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        return 0;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Creates a numeric value for the specificity.\x0d\x0a     * @return {int} The numeric value for the specificity.\x0d\x0a     * @method valueOf\x0d\x0a     */\x0d\x0a    valueOf: function() {\x0d\x0a        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns a string representation for specificity.\x0d\x0a     * @return {String} The string representation of specificity.\x0d\x0a     * @method toString\x0d\x0a     */\x0d\x0a    toString: function() {\x0d\x0a        return this.a + \x22,\x22 + this.b + \x22,\x22 + this.c + \x22,\x22 + this.d;\x0d\x0a    }\x0d\x0a\x0d\x0a};\x0d\x0a\x0d\x0a/**\x0d\x0a * Calculates the specificity of the given selector.\x0d\x0a * @param {parserlib.css.Selector} The selector to calculate specificity for.\x0d\x0a * @return {parserlib.css.Specificity} The specificity of the selector.\x0d\x0a * @static\x0d\x0a * @method calculate\x0d\x0a */\x0d\x0aSpecificity.calculate = function(selector) {\x0d\x0a\x0d\x0a    var i, len,\x0d\x0a        part,\x0d\x0a        b=0, c=0, d=0;\x0d\x0a\x0d\x0a    function updateValues(part) {\x0d\x0a\x0d\x0a        var i, j, len, num,\x0d\x0a            elementName = part.elementName ? part.elementName.text : \x22\x22,\x0d\x0a            modifier;\x0d\x0a\x0d\x0a        if (elementName && elementName.charAt(elementName.length-1) !== \x22*\x22) {\x0d\x0a            d++;\x0d\x0a        }\x0d\x0a\x0d\x0a        for (i=0, len=part.modifiers.length; i \x3c len; i++) {\x0d\x0a            modifier = part.modifiers[i];\x0d\x0a            switch (modifier.type) {\x0d\x0a                case \x22class\x22:\x0d\x0a                case \x22attribute\x22:\x0d\x0a                    c++;\x0d\x0a                    break;\x0d\x0a\x0d\x0a                case \x22id\x22:\x0d\x0a                    b++;\x0d\x0a                    break;\x0d\x0a\x0d\x0a                case \x22pseudo\x22:\x0d\x0a                    if (Pseudos.isElement(modifier.text)) {\x0d\x0a                        d++;\x0d\x0a                    } else {\x0d\x0a                        c++;\x0d\x0a                    }\x0d\x0a                    break;\x0d\x0a\x0d\x0a                case \x22not\x22:\x0d\x0a                    for (j=0, num=modifier.args.length; j \x3c num; j++) {\x0d\x0a                        updateValues(modifier.args[j]);\x0d\x0a                    }\x0d\x0a            }\x0d\x0a        }\x0d\x0a    }\x0d\x0a\x0d\x0a    for (i=0, len=selector.parts.length; i \x3c len; i++) {\x0d\x0a        part = selector.parts[i];\x0d\x0a\x0d\x0a        if (part instanceof SelectorPart) {\x0d\x0a            updateValues(part);\x0d\x0a        }\x0d\x0a    }\x0d\x0a\x0d\x0a    return new Specificity(0, b, c, d);\x0d\x0a};\x0d\x0a\x0d\x0a},{\x22./Pseudos\x22:12,\x22./SelectorPart\x22:14}],17:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = TokenStream;\x0d\x0a\x0d\x0avar TokenStreamBase = require(\x22../util/TokenStreamBase\x22);\x0d\x0a\x0d\x0avar PropertyValuePart = require(\x22./PropertyValuePart\x22);\x0d\x0avar Tokens = require(\x22./Tokens\x22);\x0d\x0a\x0d\x0avar h = /^[0-9a-fA-F]$/,\x0d\x0a    nonascii = /^[\x5cu00A0-\x5cuFFFF]$/,\x0d\x0a    nl = /\x5cn|\x5cr\x5cn|\x5cr|\x5cf/,\x0d\x0a    whitespace = /\x5cu0009|\x5cu000a|\x5cu000c|\x5cu000d|\x5cu0020/;\x0d\x0a\x0d\x0a//-----------------------------------------------------------------------------\x0d\x0a// Helper functions\x0d\x0a//-----------------------------------------------------------------------------\x0d\x0a\x0d\x0a\x0d\x0afunction isHexDigit(c) {\x0d\x0a    return c !== null && h.test(c);\x0d\x0a}\x0d\x0a\x0d\x0afunction isDigit(c) {\x0d\x0a    return c !== null && /\x5cd/.test(c);\x0d\x0a}\x0d\x0a\x0d\x0afunction isWhitespace(c) {\x0d\x0a    return c !== null && whitespace.test(c);\x0d\x0a}\x0d\x0a\x0d\x0afunction isNewLine(c) {\x0d\x0a    return c !== null && nl.test(c);\x0d\x0a}\x0d\x0a\x0d\x0afunction isNameStart(c) {\x0d\x0a    return c !== null && /[a-z_\x5cu00A0-\x5cuFFFF\x5c\x5c]/i.test(c);\x0d\x0a}\x0d\x0a\x0d\x0afunction isNameChar(c) {\x0d\x0a    return c !== null && (isNameStart(c) || /[0-9\x5c-\x5c\x5c]/.test(c));\x0d\x0a}\x0d\x0a\x0d\x0afunction isIdentStart(c) {\x0d\x0a    return c !== null && (isNameStart(c) || /\x5c-\x5c\x5c/.test(c));\x0d\x0a}\x0d\x0a\x0d\x0afunction mix(receiver, supplier) {\x0d\x0a    for (var prop in supplier) {\x0d\x0a        if (Object.prototype.hasOwnProperty.call(supplier, prop)) {\x0d\x0a            receiver[prop] = supplier[prop];\x0d\x0a        }\x0d\x0a    }\x0d\x0a    return receiver;\x0d\x0a}\x0d\x0a\x0d\x0a//-----------------------------------------------------------------------------\x0d\x0a// CSS Token Stream\x0d\x0a//-----------------------------------------------------------------------------\x0d\x0a\x0d\x0a\x0d\x0a/**\x0d\x0a * A token stream that produces CSS tokens.\x0d\x0a * @param {String|Reader} input The source of text to tokenize.\x0d\x0a * @constructor\x0d\x0a * @class TokenStream\x0d\x0a * @namespace parserlib.css\x0d\x0a */\x0d\x0afunction TokenStream(input) {\x0d\x0a    TokenStreamBase.call(this, input, Tokens);\x0d\x0a}\x0d\x0a\x0d\x0aTokenStream.prototype = mix(new TokenStreamBase(), {\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Overrides the TokenStreamBase method of the same name\x0d\x0a     * to produce CSS tokens.\x0d\x0a     * @return {Object} A token object representing the next token.\x0d\x0a     * @method _getToken\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    _getToken: function() {\x0d\x0a\x0d\x0a        var c,\x0d\x0a            reader = this._reader,\x0d\x0a            token   = null,\x0d\x0a            startLine   = reader.getLine(),\x0d\x0a            startCol    = reader.getCol();\x0d\x0a\x0d\x0a        c = reader.read();\x0d\x0a\x0d\x0a\x0d\x0a        while (c) {\x0d\x0a            switch (c) {\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Potential tokens:\x0d\x0a                 * - COMMENT\x0d\x0a                 * - SLASH\x0d\x0a                 * - CHAR\x0d\x0a                 */\x0d\x0a                case \x22/\x22:\x0d\x0a\x0d\x0a                    if (reader.peek() === \x22*\x22) {\x0d\x0a                        token = this.commentToken(c, startLine, startCol);\x0d\x0a                    } else {\x0d\x0a                        token = this.charToken(c, startLine, startCol);\x0d\x0a                    }\x0d\x0a                    break;\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Potential tokens:\x0d\x0a                 * - DASHMATCH\x0d\x0a                 * - INCLUDES\x0d\x0a                 * - PREFIXMATCH\x0d\x0a                 * - SUFFIXMATCH\x0d\x0a                 * - SUBSTRINGMATCH\x0d\x0a                 * - CHAR\x0d\x0a                 */\x0d\x0a                case \x22|\x22:\x0d\x0a                case \x22~\x22:\x0d\x0a                case \x22^\x22:\x0d\x0a                case \x22$\x22:\x0d\x0a                case \x22*\x22:\x0d\x0a                    if (reader.peek() === \x22=\x22) {\x0d\x0a                        token = this.comparisonToken(c, startLine, startCol);\x0d\x0a                    } else {\x0d\x0a                        token = this.charToken(c, startLine, startCol);\x0d\x0a                    }\x0d\x0a                    break;\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Potential tokens:\x0d\x0a                 * - STRING\x0d\x0a                 * - INVALID\x0d\x0a                 */\x0d\x0a                case \x22\x5c\x22\x22:\x0d\x0a                case \x22\x27\x22:\x0d\x0a                    token = this.stringToken(c, startLine, startCol);\x0d\x0a                    break;\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Potential tokens:\x0d\x0a                 * - HASH\x0d\x0a                 * - CHAR\x0d\x0a                 */\x0d\x0a                case \x22#\x22:\x0d\x0a                    if (isNameChar(reader.peek())) {\x0d\x0a                        token = this.hashToken(c, startLine, startCol);\x0d\x0a                    } else {\x0d\x0a                        token = this.charToken(c, startLine, startCol);\x0d\x0a                    }\x0d\x0a                    break;\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Potential tokens:\x0d\x0a                 * - DOT\x0d\x0a                 * - NUMBER\x0d\x0a                 * - DIMENSION\x0d\x0a                 * - PERCENTAGE\x0d\x0a                 */\x0d\x0a                case \x22.\x22:\x0d\x0a                    if (isDigit(reader.peek())) {\x0d\x0a                        token = this.numberToken(c, startLine, startCol);\x0d\x0a                    } else {\x0d\x0a                        token = this.charToken(c, startLine, startCol);\x0d\x0a                    }\x0d\x0a                    break;\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Potential tokens:\x0d\x0a                 * - CDC\x0d\x0a                 * - MINUS\x0d\x0a                 * - NUMBER\x0d\x0a                 * - DIMENSION\x0d\x0a                 * - PERCENTAGE\x0d\x0a                 */\x0d\x0a                case \x22-\x22:\x0d\x0a                    if (reader.peek() === \x22-\x22) {  //could be closing HTML-style comment\x0d\x0a                        token = this.htmlCommentEndToken(c, startLine, startCol);\x0d\x0a                    } else if (isNameStart(reader.peek())) {\x0d\x0a                        token = this.identOrFunctionToken(c, startLine, startCol);\x0d\x0a                    } else {\x0d\x0a                        token = this.charToken(c, startLine, startCol);\x0d\x0a                    }\x0d\x0a                    break;\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Potential tokens:\x0d\x0a                 * - IMPORTANT_SYM\x0d\x0a                 * - CHAR\x0d\x0a                 */\x0d\x0a                case \x22!\x22:\x0d\x0a                    token = this.importantToken(c, startLine, startCol);\x0d\x0a                    break;\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Any at-keyword or CHAR\x0d\x0a                 */\x0d\x0a                case \x22@\x22:\x0d\x0a                    token = this.atRuleToken(c, startLine, startCol);\x0d\x0a                    break;\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Potential tokens:\x0d\x0a                 * - NOT\x0d\x0a                 * - CHAR\x0d\x0a                 */\x0d\x0a                case \x22:\x22:\x0d\x0a                    token = this.notToken(c, startLine, startCol);\x0d\x0a                    break;\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Potential tokens:\x0d\x0a                 * - CDO\x0d\x0a                 * - CHAR\x0d\x0a                 */\x0d\x0a                case \x22\x3c\x22:\x0d\x0a                    token = this.htmlCommentStartToken(c, startLine, startCol);\x0d\x0a                    break;\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Potential tokens:\x0d\x0a                 * - IDENT\x0d\x0a                 * - CHAR\x0d\x0a                 */\x0d\x0a                case \x22\x5c\x5c\x22:\x0d\x0a                    if (/[^\x5cr\x5cn\x5cf]/.test(reader.peek())) {\x0d\x0a                        token = this.identOrFunctionToken(this.readEscape(c, true), startLine, startCol);\x0d\x0a                    } else {\x0d\x0a                        token = this.charToken(c, startLine, startCol);\x0d\x0a                    }\x0d\x0a                    break;\x0d\x0a\x0d\x0a                /*\x0d\x0a                 * Potential tokens:\x0d\x0a                 * - UNICODE_RANGE\x0d\x0a                 * - URL\x0d\x0a                 * - CHAR\x0d\x0a                 */\x0d\x0a                case \x22U\x22:\x0d\x0a                case \x22u\x22:\x0d\x0a                    if (reader.peek() === \x22+\x22) {\x0d\x0a                        token = this.unicodeRangeToken(c, startLine, startCol);\x0d\x0a                        break;\x0d\x0a                    }\x0d\x0a                    /* falls through */\x0d\x0a                default:\x0d\x0a\x0d\x0a                    /*\x0d\x0a                     * Potential tokens:\x0d\x0a                     * - NUMBER\x0d\x0a                     * - DIMENSION\x0d\x0a                     * - LENGTH\x0d\x0a                     * - FREQ\x0d\x0a                     * - TIME\x0d\x0a                     * - EMS\x0d\x0a                     * - EXS\x0d\x0a                     * - ANGLE\x0d\x0a                     */\x0d\x0a                    if (isDigit(c)) {\x0d\x0a                        token = this.numberToken(c, startLine, startCol);\x0d\x0a                    } else\x0d\x0a\x0d\x0a                    /*\x0d\x0a                     * Potential tokens:\x0d\x0a                     * - S\x0d\x0a                     */\x0d\x0a                    if (isWhitespace(c)) {\x0d\x0a                        token = this.whitespaceToken(c, startLine, startCol);\x0d\x0a                    } else\x0d\x0a\x0d\x0a                    /*\x0d\x0a                     * Potential tokens:\x0d\x0a                     * - IDENT\x0d\x0a                     */\x0d\x0a                    if (isIdentStart(c)) {\x0d\x0a                        token = this.identOrFunctionToken(c, startLine, startCol);\x0d\x0a                    } else {\x0d\x0a                       /*\x0d\x0a                        * Potential tokens:\x0d\x0a                        * - CHAR\x0d\x0a                        * - PLUS\x0d\x0a                        */\x0d\x0a                        token = this.charToken(c, startLine, startCol);\x0d\x0a                    }\x0d\x0a\x0d\x0a            }\x0d\x0a\x0d\x0a            //make sure this token is wanted\x0d\x0a            //TODO: check channel\x0d\x0a            break;\x0d\x0a        }\x0d\x0a\x0d\x0a        if (!token && c === null) {\x0d\x0a            token = this.createToken(Tokens.EOF, null, startLine, startCol);\x0d\x0a        }\x0d\x0a\x0d\x0a        return token;\x0d\x0a    },\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Methods to create tokens\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a token based on available data and the current\x0d\x0a     * reader position information. This method is called by other\x0d\x0a     * private methods to create tokens and is never called directly.\x0d\x0a     * @param {int} tt The token type.\x0d\x0a     * @param {String} value The text value of the token.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @param {Object} options (Optional) Specifies a channel property\x0d\x0a     *      to indicate that a different channel should be scanned\x0d\x0a     *      and/or a hide property indicating that the token should\x0d\x0a     *      be hidden.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method createToken\x0d\x0a     */\x0d\x0a    createToken: function(tt, value, startLine, startCol, options) {\x0d\x0a        var reader = this._reader;\x0d\x0a        options = options || {};\x0d\x0a\x0d\x0a        return {\x0d\x0a            value:      value,\x0d\x0a            type:       tt,\x0d\x0a            channel:    options.channel,\x0d\x0a            endChar:    options.endChar,\x0d\x0a            hide:       options.hide || false,\x0d\x0a            startLine:  startLine,\x0d\x0a            startCol:   startCol,\x0d\x0a            endLine:    reader.getLine(),\x0d\x0a            endCol:     reader.getCol()\x0d\x0a        };\x0d\x0a    },\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Methods to create specific tokens\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a token for any at-rule. If the at-rule is unknown, then\x0d\x0a     * the token is for a single \x22@\x22 character.\x0d\x0a     * @param {String} first The first character for the token.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method atRuleToken\x0d\x0a     */\x0d\x0a    atRuleToken: function(first, startLine, startCol) {\x0d\x0a        var rule    = first,\x0d\x0a            reader  = this._reader,\x0d\x0a            tt      = Tokens.CHAR,\x0d\x0a            ident;\x0d\x0a\x0d\x0a        /*\x0d\x0a         * First, mark where we are. There are only four @ rules,\x0d\x0a         * so anything else is really just an invalid token.\x0d\x0a         * Basically, if this doesn\x27t match one of the known @\x0d\x0a         * rules, just return \x27@\x27 as an unknown token and allow\x0d\x0a         * parsing to continue after that point.\x0d\x0a         */\x0d\x0a        reader.mark();\x0d\x0a\x0d\x0a        //try to find the at-keyword\x0d\x0a        ident = this.readName();\x0d\x0a        rule = first + ident;\x0d\x0a        tt = Tokens.type(rule.toLowerCase());\x0d\x0a\x0d\x0a        //if it\x27s not valid, use the first character only and reset the reader\x0d\x0a        if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN) {\x0d\x0a            if (rule.length \x3e 1) {\x0d\x0a                tt = Tokens.UNKNOWN_SYM;\x0d\x0a            } else {\x0d\x0a                tt = Tokens.CHAR;\x0d\x0a                rule = first;\x0d\x0a                reader.reset();\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        return this.createToken(tt, rule, startLine, startCol);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a character token based on the given character\x0d\x0a     * and location in the stream. If there\x27s a special (non-standard)\x0d\x0a     * token name, this is used; otherwise CHAR is used.\x0d\x0a     * @param {String} c The character for the token.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method charToken\x0d\x0a     */\x0d\x0a    charToken: function(c, startLine, startCol) {\x0d\x0a        var tt = Tokens.type(c);\x0d\x0a        var opts = {};\x0d\x0a\x0d\x0a        if (tt === -1) {\x0d\x0a            tt = Tokens.CHAR;\x0d\x0a        } else {\x0d\x0a            opts.endChar = Tokens[tt].endChar;\x0d\x0a        }\x0d\x0a\x0d\x0a        return this.createToken(tt, c, startLine, startCol, opts);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a character token based on the given character\x0d\x0a     * and location in the stream. If there\x27s a special (non-standard)\x0d\x0a     * token name, this is used; otherwise CHAR is used.\x0d\x0a     * @param {String} first The first character for the token.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method commentToken\x0d\x0a     */\x0d\x0a    commentToken: function(first, startLine, startCol) {\x0d\x0a        var comment = this.readComment(first);\x0d\x0a\x0d\x0a        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a comparison token based on the given character\x0d\x0a     * and location in the stream. The next character must be\x0d\x0a     * read and is already known to be an equals sign.\x0d\x0a     * @param {String} c The character for the token.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method comparisonToken\x0d\x0a     */\x0d\x0a    comparisonToken: function(c, startLine, startCol) {\x0d\x0a        var reader  = this._reader,\x0d\x0a            comparison  = c + reader.read(),\x0d\x0a            tt      = Tokens.type(comparison) || Tokens.CHAR;\x0d\x0a\x0d\x0a        return this.createToken(tt, comparison, startLine, startCol);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a hash token based on the specified information. The\x0d\x0a     * first character provided is the pound sign (#) and then this\x0d\x0a     * method reads a name afterward.\x0d\x0a     * @param {String} first The first character (#) in the hash name.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method hashToken\x0d\x0a     */\x0d\x0a    hashToken: function(first, startLine, startCol) {\x0d\x0a        var name    = this.readName(first);\x0d\x0a\x0d\x0a        return this.createToken(Tokens.HASH, name, startLine, startCol);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a CDO or CHAR token based on the specified information. The\x0d\x0a     * first character is provided and the rest is read by the function to determine\x0d\x0a     * the correct token to create.\x0d\x0a     * @param {String} first The first character in the token.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method htmlCommentStartToken\x0d\x0a     */\x0d\x0a    htmlCommentStartToken: function(first, startLine, startCol) {\x0d\x0a        var reader      = this._reader,\x0d\x0a            text        = first;\x0d\x0a\x0d\x0a        reader.mark();\x0d\x0a        text += reader.readCount(3);\x0d\x0a\x0d\x0a        if (text === \x22\x3c!--\x22) {\x0d\x0a            return this.createToken(Tokens.CDO, text, startLine, startCol);\x0d\x0a        } else {\x0d\x0a            reader.reset();\x0d\x0a            return this.charToken(first, startLine, startCol);\x0d\x0a        }\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a CDC or CHAR token based on the specified information. The\x0d\x0a     * first character is provided and the rest is read by the function to determine\x0d\x0a     * the correct token to create.\x0d\x0a     * @param {String} first The first character in the token.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method htmlCommentEndToken\x0d\x0a     */\x0d\x0a    htmlCommentEndToken: function(first, startLine, startCol) {\x0d\x0a        var reader      = this._reader,\x0d\x0a            text        = first;\x0d\x0a\x0d\x0a        reader.mark();\x0d\x0a        text += reader.readCount(2);\x0d\x0a\x0d\x0a        if (text === \x22--\x3e\x22) {\x0d\x0a            return this.createToken(Tokens.CDC, text, startLine, startCol);\x0d\x0a        } else {\x0d\x0a            reader.reset();\x0d\x0a            return this.charToken(first, startLine, startCol);\x0d\x0a        }\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces an IDENT or FUNCTION token based on the specified information. The\x0d\x0a     * first character is provided and the rest is read by the function to determine\x0d\x0a     * the correct token to create.\x0d\x0a     * @param {String} first The first character in the identifier.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method identOrFunctionToken\x0d\x0a     */\x0d\x0a    identOrFunctionToken: function(first, startLine, startCol) {\x0d\x0a        var reader  = this._reader,\x0d\x0a            ident   = this.readName(first),\x0d\x0a            tt      = Tokens.IDENT,\x0d\x0a            uriFns  = [\x22url(\x22, \x22url-prefix(\x22, \x22domain(\x22],\x0d\x0a            uri;\x0d\x0a\x0d\x0a        //if there\x27s a left paren immediately after, it\x27s a URI or function\x0d\x0a        if (reader.peek() === \x22(\x22) {\x0d\x0a            ident += reader.read();\x0d\x0a            if (uriFns.indexOf(ident.toLowerCase()) \x3e -1) {\x0d\x0a                reader.mark();\x0d\x0a                uri = this.readURI(ident);\x0d\x0a                if (uri === null) {\x0d\x0a                    //didn\x27t find a valid URL or there\x27s no closing paren\x0d\x0a                    reader.reset();\x0d\x0a                    tt = Tokens.FUNCTION;\x0d\x0a                } else {\x0d\x0a                    tt = Tokens.URI;\x0d\x0a                    ident = uri;\x0d\x0a                }\x0d\x0a            } else {\x0d\x0a                tt = Tokens.FUNCTION;\x0d\x0a            }\x0d\x0a        } else if (reader.peek() === \x22:\x22) {  //might be an IE function\x0d\x0a\x0d\x0a            //IE-specific functions always being with progid:\x0d\x0a            if (ident.toLowerCase() === \x22progid\x22) {\x0d\x0a                ident += reader.readTo(\x22(\x22);\x0d\x0a                tt = Tokens.IE_FUNCTION;\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        return this.createToken(tt, ident, startLine, startCol);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The\x0d\x0a     * first character is provided and the rest is read by the function to determine\x0d\x0a     * the correct token to create.\x0d\x0a     * @param {String} first The first character in the token.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method importantToken\x0d\x0a     */\x0d\x0a    importantToken: function(first, startLine, startCol) {\x0d\x0a        var reader      = this._reader,\x0d\x0a            important   = first,\x0d\x0a            tt          = Tokens.CHAR,\x0d\x0a            temp,\x0d\x0a            c;\x0d\x0a\x0d\x0a        reader.mark();\x0d\x0a        c = reader.read();\x0d\x0a\x0d\x0a        while (c) {\x0d\x0a\x0d\x0a            //there can be a comment in here\x0d\x0a            if (c === \x22/\x22) {\x0d\x0a\x0d\x0a                //if the next character isn\x27t a star, then this isn\x27t a valid !important token\x0d\x0a                if (reader.peek() !== \x22*\x22) {\x0d\x0a                    break;\x0d\x0a                } else {\x0d\x0a                    temp = this.readComment(c);\x0d\x0a                    if (temp === \x22\x22) {    //broken!\x0d\x0a                        break;\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            } else if (isWhitespace(c)) {\x0d\x0a                important += c + this.readWhitespace();\x0d\x0a            } else if (/i/i.test(c)) {\x0d\x0a                temp = reader.readCount(8);\x0d\x0a                if (/mportant/i.test(temp)) {\x0d\x0a                    important += c + temp;\x0d\x0a                    tt = Tokens.IMPORTANT_SYM;\x0d\x0a\x0d\x0a                }\x0d\x0a                break;  //we\x27re done\x0d\x0a            } else {\x0d\x0a                break;\x0d\x0a            }\x0d\x0a\x0d\x0a            c = reader.read();\x0d\x0a        }\x0d\x0a\x0d\x0a        if (tt === Tokens.CHAR) {\x0d\x0a            reader.reset();\x0d\x0a            return this.charToken(first, startLine, startCol);\x0d\x0a        } else {\x0d\x0a            return this.createToken(tt, important, startLine, startCol);\x0d\x0a        }\x0d\x0a\x0d\x0a\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a NOT or CHAR token based on the specified information. The\x0d\x0a     * first character is provided and the rest is read by the function to determine\x0d\x0a     * the correct token to create.\x0d\x0a     * @param {String} first The first character in the token.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method notToken\x0d\x0a     */\x0d\x0a    notToken: function(first, startLine, startCol) {\x0d\x0a        var reader      = this._reader,\x0d\x0a            text        = first;\x0d\x0a\x0d\x0a        reader.mark();\x0d\x0a        text += reader.readCount(4);\x0d\x0a\x0d\x0a        if (text.toLowerCase() === \x22:not(\x22) {\x0d\x0a            return this.createToken(Tokens.NOT, text, startLine, startCol);\x0d\x0a        } else {\x0d\x0a            reader.reset();\x0d\x0a            return this.charToken(first, startLine, startCol);\x0d\x0a        }\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a number token based on the given character\x0d\x0a     * and location in the stream. This may return a token of\x0d\x0a     * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,\x0d\x0a     * or PERCENTAGE.\x0d\x0a     * @param {String} first The first character for the token.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method numberToken\x0d\x0a     */\x0d\x0a    numberToken: function(first, startLine, startCol) {\x0d\x0a        var reader  = this._reader,\x0d\x0a            value   = this.readNumber(first),\x0d\x0a            ident,\x0d\x0a            tt      = Tokens.NUMBER,\x0d\x0a            c       = reader.peek();\x0d\x0a\x0d\x0a        if (isIdentStart(c)) {\x0d\x0a            ident = this.readName(reader.read());\x0d\x0a            value += ident;\x0d\x0a\x0d\x0a            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)) {\x0d\x0a                tt = Tokens.LENGTH;\x0d\x0a            } else if (/^deg|^rad$|^grad$|^turn$/i.test(ident)) {\x0d\x0a                tt = Tokens.ANGLE;\x0d\x0a            } else if (/^ms$|^s$/i.test(ident)) {\x0d\x0a                tt = Tokens.TIME;\x0d\x0a            } else if (/^hz$|^khz$/i.test(ident)) {\x0d\x0a                tt = Tokens.FREQ;\x0d\x0a            } else if (/^dpi$|^dpcm$/i.test(ident)) {\x0d\x0a                tt = Tokens.RESOLUTION;\x0d\x0a            } else {\x0d\x0a                tt = Tokens.DIMENSION;\x0d\x0a            }\x0d\x0a\x0d\x0a        } else if (c === \x22%\x22) {\x0d\x0a            value += reader.read();\x0d\x0a            tt = Tokens.PERCENTAGE;\x0d\x0a        }\x0d\x0a\x0d\x0a        return this.createToken(tt, value, startLine, startCol);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a string token based on the given character\x0d\x0a     * and location in the stream. Since strings may be indicated\x0d\x0a     * by single or double quotes, a failure to match starting\x0d\x0a     * and ending quotes results in an INVALID token being generated.\x0d\x0a     * The first character in the string is passed in and then\x0d\x0a     * the rest are read up to and including the final quotation mark.\x0d\x0a     * @param {String} first The first character in the string.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method stringToken\x0d\x0a     */\x0d\x0a    stringToken: function(first, startLine, startCol) {\x0d\x0a        var delim   = first,\x0d\x0a            string  = first,\x0d\x0a            reader  = this._reader,\x0d\x0a            tt      = Tokens.STRING,\x0d\x0a            c       = reader.read(),\x0d\x0a            i;\x0d\x0a\x0d\x0a        while (c) {\x0d\x0a            string += c;\x0d\x0a\x0d\x0a            if (c === \x22\x5c\x5c\x22) {\x0d\x0a                c = reader.read();\x0d\x0a                if (c === null) {\x0d\x0a                    break; // premature EOF after backslash\x0d\x0a                } else if (/[^\x5cr\x5cn\x5cf0-9a-f]/i.test(c)) {\x0d\x0a                    // single-character escape\x0d\x0a                    string += c;\x0d\x0a                } else {\x0d\x0a                    // read up to six hex digits\x0d\x0a                    for (i=0; isHexDigit(c) && i\x3c6; i++) {\x0d\x0a                        string += c;\x0d\x0a                        c = reader.read();\x0d\x0a                    }\x0d\x0a                    // swallow trailing newline or space\x0d\x0a                    if (c === \x22\x5cr\x22 && reader.peek() === \x22\x5cn\x22) {\x0d\x0a                        string += c;\x0d\x0a                        c = reader.read();\x0d\x0a                    }\x0d\x0a                    if (isWhitespace(c)) {\x0d\x0a                        string += c;\x0d\x0a                    } else {\x0d\x0a                        // This character is null or not part of the escape;\x0d\x0a                        // jump back to the top to process it.\x0d\x0a                        continue;\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            } else if (c === delim) {\x0d\x0a                break; // delimiter found.\x0d\x0a            } else if (isNewLine(reader.peek())) {\x0d\x0a                // newline without an escapement: it\x27s an invalid string\x0d\x0a                tt = Tokens.INVALID;\x0d\x0a                break;\x0d\x0a            }\x0d\x0a            c = reader.read();\x0d\x0a        }\x0d\x0a\x0d\x0a        //if c is null, that means we\x27re out of input and the string was never closed\x0d\x0a        if (c === null) {\x0d\x0a            tt = Tokens.INVALID;\x0d\x0a        }\x0d\x0a\x0d\x0a        return this.createToken(tt, string, startLine, startCol);\x0d\x0a    },\x0d\x0a\x0d\x0a    unicodeRangeToken: function(first, startLine, startCol) {\x0d\x0a        var reader  = this._reader,\x0d\x0a            value   = first,\x0d\x0a            temp,\x0d\x0a            tt      = Tokens.CHAR;\x0d\x0a\x0d\x0a        //then it should be a unicode range\x0d\x0a        if (reader.peek() === \x22+\x22) {\x0d\x0a            reader.mark();\x0d\x0a            value += reader.read();\x0d\x0a            value += this.readUnicodeRangePart(true);\x0d\x0a\x0d\x0a            //ensure there\x27s an actual unicode range here\x0d\x0a            if (value.length === 2) {\x0d\x0a                reader.reset();\x0d\x0a            } else {\x0d\x0a\x0d\x0a                tt = Tokens.UNICODE_RANGE;\x0d\x0a\x0d\x0a                //if there\x27s a ? in the first part, there can\x27t be a second part\x0d\x0a                if (value.indexOf(\x22?\x22) === -1) {\x0d\x0a\x0d\x0a                    if (reader.peek() === \x22-\x22) {\x0d\x0a                        reader.mark();\x0d\x0a                        temp = reader.read();\x0d\x0a                        temp += this.readUnicodeRangePart(false);\x0d\x0a\x0d\x0a                        //if there\x27s not another value, back up and just take the first\x0d\x0a                        if (temp.length === 1) {\x0d\x0a                            reader.reset();\x0d\x0a                        } else {\x0d\x0a                            value += temp;\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a\x0d\x0a                }\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        return this.createToken(tt, value, startLine, startCol);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Produces a S token based on the specified information. Since whitespace\x0d\x0a     * may have multiple characters, this consumes all whitespace characters\x0d\x0a     * into a single token.\x0d\x0a     * @param {String} first The first character in the token.\x0d\x0a     * @param {int} startLine The beginning line for the character.\x0d\x0a     * @param {int} startCol The beginning column for the character.\x0d\x0a     * @return {Object} A token object.\x0d\x0a     * @method whitespaceToken\x0d\x0a     */\x0d\x0a    whitespaceToken: function(first, startLine, startCol) {\x0d\x0a        var value   = first + this.readWhitespace();\x0d\x0a        return this.createToken(Tokens.S, value, startLine, startCol);\x0d\x0a    },\x0d\x0a\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Methods to read values from the string stream\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    readUnicodeRangePart: function(allowQuestionMark) {\x0d\x0a        var reader  = this._reader,\x0d\x0a            part = \x22\x22,\x0d\x0a            c       = reader.peek();\x0d\x0a\x0d\x0a        //first read hex digits\x0d\x0a        while (isHexDigit(c) && part.length \x3c 6) {\x0d\x0a            reader.read();\x0d\x0a            part += c;\x0d\x0a            c = reader.peek();\x0d\x0a        }\x0d\x0a\x0d\x0a        //then read question marks if allowed\x0d\x0a        if (allowQuestionMark) {\x0d\x0a            while (c === \x22?\x22 && part.length \x3c 6) {\x0d\x0a                reader.read();\x0d\x0a                part += c;\x0d\x0a                c = reader.peek();\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        //there can\x27t be any other characters after this point\x0d\x0a\x0d\x0a        return part;\x0d\x0a    },\x0d\x0a\x0d\x0a    readWhitespace: function() {\x0d\x0a        var reader  = this._reader,\x0d\x0a            whitespace = \x22\x22,\x0d\x0a            c       = reader.peek();\x0d\x0a\x0d\x0a        while (isWhitespace(c)) {\x0d\x0a            reader.read();\x0d\x0a            whitespace += c;\x0d\x0a            c = reader.peek();\x0d\x0a        }\x0d\x0a\x0d\x0a        return whitespace;\x0d\x0a    },\x0d\x0a    readNumber: function(first) {\x0d\x0a        var reader  = this._reader,\x0d\x0a            number  = first,\x0d\x0a            hasDot  = (first === \x22.\x22),\x0d\x0a            c       = reader.peek();\x0d\x0a\x0d\x0a\x0d\x0a        while (c) {\x0d\x0a            if (isDigit(c)) {\x0d\x0a                number += reader.read();\x0d\x0a            } else if (c === \x22.\x22) {\x0d\x0a                if (hasDot) {\x0d\x0a                    break;\x0d\x0a                } else {\x0d\x0a                    hasDot = true;\x0d\x0a                    number += reader.read();\x0d\x0a                }\x0d\x0a            } else {\x0d\x0a                break;\x0d\x0a            }\x0d\x0a\x0d\x0a            c = reader.peek();\x0d\x0a        }\x0d\x0a\x0d\x0a        return number;\x0d\x0a    },\x0d\x0a\x0d\x0a    // returns null w/o resetting reader if string is invalid.\x0d\x0a    readString: function() {\x0d\x0a        var token = this.stringToken(this._reader.read(), 0, 0);\x0d\x0a        return token.type === Tokens.INVALID ? null : token.value;\x0d\x0a    },\x0d\x0a\x0d\x0a    // returns null w/o resetting reader if URI is invalid.\x0d\x0a    readURI: function(first) {\x0d\x0a        var reader  = this._reader,\x0d\x0a            uri     = first,\x0d\x0a            inner   = \x22\x22,\x0d\x0a            c       = reader.peek();\x0d\x0a\x0d\x0a        //skip whitespace before\x0d\x0a        while (c && isWhitespace(c)) {\x0d\x0a            reader.read();\x0d\x0a            c = reader.peek();\x0d\x0a        }\x0d\x0a\x0d\x0a        //it\x27s a string\x0d\x0a        if (c === \x22\x27\x22 || c === \x22\x5c\x22\x22) {\x0d\x0a            inner = this.readString();\x0d\x0a            if (inner !== null) {\x0d\x0a                inner = PropertyValuePart.parseString(inner);\x0d\x0a            }\x0d\x0a        } else {\x0d\x0a            inner = this.readUnquotedURL();\x0d\x0a        }\x0d\x0a\x0d\x0a        c = reader.peek();\x0d\x0a\x0d\x0a        //skip whitespace after\x0d\x0a        while (c && isWhitespace(c)) {\x0d\x0a            reader.read();\x0d\x0a            c = reader.peek();\x0d\x0a        }\x0d\x0a\x0d\x0a        //if there was no inner value or the next character isn\x27t closing paren, it\x27s not a URI\x0d\x0a        if (inner === null || c !== \x22)\x22) {\x0d\x0a            uri = null;\x0d\x0a        } else {\x0d\x0a            // Ensure argument to URL is always double-quoted\x0d\x0a            // (This simplifies later processing in PropertyValuePart.)\x0d\x0a            uri += PropertyValuePart.serializeString(inner) + reader.read();\x0d\x0a        }\x0d\x0a\x0d\x0a        return uri;\x0d\x0a    },\x0d\x0a    // This method never fails, although it may return an empty string.\x0d\x0a    readUnquotedURL: function(first) {\x0d\x0a        var reader  = this._reader,\x0d\x0a            url     = first || \x22\x22,\x0d\x0a            c;\x0d\x0a\x0d\x0a        for (c = reader.peek(); c; c = reader.peek()) {\x0d\x0a            // Note that the grammar at\x0d\x0a            // https://www.w3.org/TR/CSS2/grammar.html#scanner\x0d\x0a            // incorrectly includes the backslash character in the\x0d\x0a            // `url` production, although it is correctly omitted in\x0d\x0a            // the `baduri1` production.\x0d\x0a            if (nonascii.test(c) || /^[\x5c-!#$%&*-\x5c[\x5c]-~]$/.test(c)) {\x0d\x0a                url += c;\x0d\x0a                reader.read();\x0d\x0a            } else if (c === \x22\x5c\x5c\x22) {\x0d\x0a                if (/^[^\x5cr\x5cn\x5cf]$/.test(reader.peek(2))) {\x0d\x0a                    url += this.readEscape(reader.read(), true);\x0d\x0a                } else {\x0d\x0a                    break; // bad escape sequence.\x0d\x0a                }\x0d\x0a            } else {\x0d\x0a                break; // bad character\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        return url;\x0d\x0a    },\x0d\x0a\x0d\x0a    readName: function(first) {\x0d\x0a        var reader  = this._reader,\x0d\x0a            ident   = first || \x22\x22,\x0d\x0a            c;\x0d\x0a\x0d\x0a        for (c = reader.peek(); c; c = reader.peek()) {\x0d\x0a            if (c === \x22\x5c\x5c\x22) {\x0d\x0a                if (/^[^\x5cr\x5cn\x5cf]$/.test(reader.peek(2))) {\x0d\x0a                    ident += this.readEscape(reader.read(), true);\x0d\x0a                } else {\x0d\x0a                    // Bad escape sequence.\x0d\x0a                    break;\x0d\x0a                }\x0d\x0a            } else if (isNameChar(c)) {\x0d\x0a                ident += reader.read();\x0d\x0a            } else {\x0d\x0a                break;\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        return ident;\x0d\x0a    },\x0d\x0a\x0d\x0a    readEscape: function(first, unescape) {\x0d\x0a        var reader  = this._reader,\x0d\x0a            cssEscape = first || \x22\x22,\x0d\x0a            i       = 0,\x0d\x0a            c       = reader.peek();\x0d\x0a\x0d\x0a        if (isHexDigit(c)) {\x0d\x0a            do {\x0d\x0a                cssEscape += reader.read();\x0d\x0a                c = reader.peek();\x0d\x0a            } while (c && isHexDigit(c) && ++i \x3c 6);\x0d\x0a        }\x0d\x0a\x0d\x0a        if (cssEscape.length === 1) {\x0d\x0a            if (/^[^\x5cr\x5cn\x5cf0-9a-f]$/.test(c)) {\x0d\x0a                reader.read();\x0d\x0a                if (unescape) {\x0d\x0a                    return c;\x0d\x0a                }\x0d\x0a            } else {\x0d\x0a                // We should never get here (readName won\x27t call readEscape\x0d\x0a                // if the escape sequence is bad).\x0d\x0a                throw new Error(\x22Bad escape sequence.\x22);\x0d\x0a            }\x0d\x0a        } else if (c === \x22\x5cr\x22) {\x0d\x0a            reader.read();\x0d\x0a            if (reader.peek() === \x22\x5cn\x22) {\x0d\x0a                c += reader.read();\x0d\x0a            }\x0d\x0a        } else if (/^[ \x5ct\x5cn\x5cf]$/.test(c)) {\x0d\x0a            reader.read();\x0d\x0a        } else {\x0d\x0a            c = \x22\x22;\x0d\x0a        }\x0d\x0a\x0d\x0a        if (unescape) {\x0d\x0a            var cp = parseInt(cssEscape.slice(first.length), 16);\x0d\x0a            return String.fromCodePoint ? String.fromCodePoint(cp) :\x0d\x0a                String.fromCharCode(cp);\x0d\x0a        }\x0d\x0a        return cssEscape + c;\x0d\x0a    },\x0d\x0a\x0d\x0a    readComment: function(first) {\x0d\x0a        var reader  = this._reader,\x0d\x0a            comment = first || \x22\x22,\x0d\x0a            c       = reader.read();\x0d\x0a\x0d\x0a        if (c === \x22*\x22) {\x0d\x0a            while (c) {\x0d\x0a                comment += c;\x0d\x0a\x0d\x0a                //look for end of comment\x0d\x0a                if (comment.length \x3e 2 && c === \x22*\x22 && reader.peek() === \x22/\x22) {\x0d\x0a                    comment += reader.read();\x0d\x0a                    break;\x0d\x0a                }\x0d\x0a\x0d\x0a                c = reader.read();\x0d\x0a            }\x0d\x0a\x0d\x0a            return comment;\x0d\x0a        } else {\x0d\x0a            return \x22\x22;\x0d\x0a        }\x0d\x0a\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0a},{\x22../util/TokenStreamBase\x22:27,\x22./PropertyValuePart\x22:11,\x22./Tokens\x22:18}],18:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0avar Tokens = module.exports = [\x0d\x0a\x0d\x0a    /*\x0d\x0a     * The following token names are defined in CSS3 Grammar: https://www.w3.org/TR/css3-syntax/#lexical\x0d\x0a     */\x0d\x0a\x0d\x0a    // HTML-style comments\x0d\x0a    { name: \x22CDO\x22 },\x0d\x0a    { name: \x22CDC\x22 },\x0d\x0a\x0d\x0a    // ignorables\x0d\x0a    { name: \x22S\x22, whitespace: true/*, channel: \x22ws\x22*/ },\x0d\x0a    { name: \x22COMMENT\x22, comment: true, hide: true, channel: \x22comment\x22 },\x0d\x0a\x0d\x0a    // attribute equality\x0d\x0a    { name: \x22INCLUDES\x22, text: \x22~=\x22 },\x0d\x0a    { name: \x22DASHMATCH\x22, text: \x22|=\x22 },\x0d\x0a    { name: \x22PREFIXMATCH\x22, text: \x22^=\x22 },\x0d\x0a    { name: \x22SUFFIXMATCH\x22, text: \x22$=\x22 },\x0d\x0a    { name: \x22SUBSTRINGMATCH\x22, text: \x22*=\x22 },\x0d\x0a\x0d\x0a    // identifier types\x0d\x0a    { name: \x22STRING\x22 },\x0d\x0a    { name: \x22IDENT\x22 },\x0d\x0a    { name: \x22HASH\x22 },\x0d\x0a\x0d\x0a    // at-keywords\x0d\x0a    { name: \x22IMPORT_SYM\x22, text: \x22@import\x22 },\x0d\x0a    { name: \x22PAGE_SYM\x22, text: \x22@page\x22 },\x0d\x0a    { name: \x22MEDIA_SYM\x22, text: \x22@media\x22 },\x0d\x0a    { name: \x22FONT_FACE_SYM\x22, text: \x22@font-face\x22 },\x0d\x0a    { name: \x22CHARSET_SYM\x22, text: \x22@charset\x22 },\x0d\x0a    { name: \x22NAMESPACE_SYM\x22, text: \x22@namespace\x22 },\x0d\x0a    { name: \x22SUPPORTS_SYM\x22, text: \x22@supports\x22 },\x0d\x0a    { name: \x22VIEWPORT_SYM\x22, text: [\x22@viewport\x22, \x22@-ms-viewport\x22, \x22@-o-viewport\x22] },\x0d\x0a    { name: \x22DOCUMENT_SYM\x22, text: [\x22@document\x22, \x22@-moz-document\x22] },\x0d\x0a    { name: \x22UNKNOWN_SYM\x22 },\x0d\x0a    //{ name: \x22ATKEYWORD\x22},\x0d\x0a\x0d\x0a    // CSS3 animations\x0d\x0a    { name: \x22KEYFRAMES_SYM\x22, text: [ \x22@keyframes\x22, \x22@-webkit-keyframes\x22, \x22@-moz-keyframes\x22, \x22@-o-keyframes\x22 ] },\x0d\x0a\x0d\x0a    // important symbol\x0d\x0a    { name: \x22IMPORTANT_SYM\x22 },\x0d\x0a\x0d\x0a    // measurements\x0d\x0a    { name: \x22LENGTH\x22 },\x0d\x0a    { name: \x22ANGLE\x22 },\x0d\x0a    { name: \x22TIME\x22 },\x0d\x0a    { name: \x22FREQ\x22 },\x0d\x0a    { name: \x22DIMENSION\x22 },\x0d\x0a    { name: \x22PERCENTAGE\x22 },\x0d\x0a    { name: \x22NUMBER\x22 },\x0d\x0a\x0d\x0a    // functions\x0d\x0a    { name: \x22URI\x22 },\x0d\x0a    { name: \x22FUNCTION\x22 },\x0d\x0a\x0d\x0a    // Unicode ranges\x0d\x0a    { name: \x22UNICODE_RANGE\x22 },\x0d\x0a\x0d\x0a    /*\x0d\x0a     * The following token names are defined in CSS3 Selectors: https://www.w3.org/TR/css3-selectors/#selector-syntax\x0d\x0a     */\x0d\x0a\x0d\x0a    // invalid string\x0d\x0a    { name: \x22INVALID\x22 },\x0d\x0a\x0d\x0a    // combinators\x0d\x0a    { name: \x22PLUS\x22, text: \x22+\x22 },\x0d\x0a    { name: \x22GREATER\x22, text: \x22\x3e\x22 },\x0d\x0a    { name: \x22COMMA\x22, text: \x22,\x22 },\x0d\x0a    { name: \x22TILDE\x22, text: \x22~\x22 },\x0d\x0a\x0d\x0a    // modifier\x0d\x0a    { name: \x22NOT\x22 },\x0d\x0a\x0d\x0a    /*\x0d\x0a     * Defined in CSS3 Paged Media\x0d\x0a     */\x0d\x0a    { name: \x22TOPLEFTCORNER_SYM\x22, text: \x22@top-left-corner\x22 },\x0d\x0a    { name: \x22TOPLEFT_SYM\x22, text: \x22@top-left\x22 },\x0d\x0a    { name: \x22TOPCENTER_SYM\x22, text: \x22@top-center\x22 },\x0d\x0a    { name: \x22TOPRIGHT_SYM\x22, text: \x22@top-right\x22 },\x0d\x0a    { name: \x22TOPRIGHTCORNER_SYM\x22, text: \x22@top-right-corner\x22 },\x0d\x0a    { name: \x22BOTTOMLEFTCORNER_SYM\x22, text: \x22@bottom-left-corner\x22 },\x0d\x0a    { name: \x22BOTTOMLEFT_SYM\x22, text: \x22@bottom-left\x22 },\x0d\x0a    { name: \x22BOTTOMCENTER_SYM\x22, text: \x22@bottom-center\x22 },\x0d\x0a    { name: \x22BOTTOMRIGHT_SYM\x22, text: \x22@bottom-right\x22 },\x0d\x0a    { name: \x22BOTTOMRIGHTCORNER_SYM\x22, text: \x22@bottom-right-corner\x22 },\x0d\x0a    { name: \x22LEFTTOP_SYM\x22, text: \x22@left-top\x22 },\x0d\x0a    { name: \x22LEFTMIDDLE_SYM\x22, text: \x22@left-middle\x22 },\x0d\x0a    { name: \x22LEFTBOTTOM_SYM\x22, text: \x22@left-bottom\x22 },\x0d\x0a    { name: \x22RIGHTTOP_SYM\x22, text: \x22@right-top\x22 },\x0d\x0a    { name: \x22RIGHTMIDDLE_SYM\x22, text: \x22@right-middle\x22 },\x0d\x0a    { name: \x22RIGHTBOTTOM_SYM\x22, text: \x22@right-bottom\x22 },\x0d\x0a\x0d\x0a    /*\x0d\x0a     * The following token names are defined in CSS3 Media Queries: https://www.w3.org/TR/css3-mediaqueries/#syntax\x0d\x0a     */\x0d\x0a    /*{ name: \x22MEDIA_ONLY\x22, state: \x22media\x22},\x0d\x0a    { name: \x22MEDIA_NOT\x22, state: \x22media\x22},\x0d\x0a    { name: \x22MEDIA_AND\x22, state: \x22media\x22},*/\x0d\x0a    { name: \x22RESOLUTION\x22, state: \x22media\x22 },\x0d\x0a\x0d\x0a    /*\x0d\x0a     * The following token names are not defined in any CSS specification but are used by the lexer.\x0d\x0a     */\x0d\x0a\x0d\x0a    // not a real token, but useful for stupid IE filters\x0d\x0a    { name: \x22IE_FUNCTION\x22 },\x0d\x0a\x0d\x0a    // part of CSS3 grammar but not the Flex code\x0d\x0a    { name: \x22CHAR\x22 },\x0d\x0a\x0d\x0a    // TODO: Needed?\x0d\x0a    // Not defined as tokens, but might as well be\x0d\x0a    {\x0d\x0a        name: \x22PIPE\x22,\x0d\x0a        text: \x22|\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22SLASH\x22,\x0d\x0a        text: \x22/\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22MINUS\x22,\x0d\x0a        text: \x22-\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22STAR\x22,\x0d\x0a        text: \x22*\x22\x0d\x0a    },\x0d\x0a\x0d\x0a    {\x0d\x0a        name: \x22LBRACE\x22,\x0d\x0a        endChar: \x22}\x22,\x0d\x0a        text: \x22{\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22RBRACE\x22,\x0d\x0a        text: \x22}\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22LBRACKET\x22,\x0d\x0a        endChar: \x22]\x22,\x0d\x0a        text: \x22[\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22RBRACKET\x22,\x0d\x0a        text: \x22]\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22EQUALS\x22,\x0d\x0a        text: \x22=\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22COLON\x22,\x0d\x0a        text: \x22:\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22SEMICOLON\x22,\x0d\x0a        text: \x22;\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22LPAREN\x22,\x0d\x0a        endChar: \x22)\x22,\x0d\x0a        text: \x22(\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22RPAREN\x22,\x0d\x0a        text: \x22)\x22\x0d\x0a    },\x0d\x0a    {\x0d\x0a        name: \x22DOT\x22,\x0d\x0a        text: \x22.\x22\x0d\x0a    }\x0d\x0a];\x0d\x0a\x0d\x0a(function() {\x0d\x0a    var nameMap = [],\x0d\x0a        typeMap = Object.create(null);\x0d\x0a\x0d\x0a    Tokens.UNKNOWN = -1;\x0d\x0a    Tokens.unshift({ name:\x22EOF\x22 });\x0d\x0a    for (var i=0, len = Tokens.length; i \x3c len; i++) {\x0d\x0a        nameMap.push(Tokens[i].name);\x0d\x0a        Tokens[Tokens[i].name] = i;\x0d\x0a        if (Tokens[i].text) {\x0d\x0a            if (Tokens[i].text instanceof Array) {\x0d\x0a                for (var j=0; j \x3c Tokens[i].text.length; j++) {\x0d\x0a                    typeMap[Tokens[i].text[j]] = i;\x0d\x0a                }\x0d\x0a            } else {\x0d\x0a                typeMap[Tokens[i].text] = i;\x0d\x0a            }\x0d\x0a        }\x0d\x0a    }\x0d\x0a\x0d\x0a    Tokens.name = function(tt) {\x0d\x0a        return nameMap[tt];\x0d\x0a    };\x0d\x0a\x0d\x0a    Tokens.type = function(c) {\x0d\x0a        return typeMap[c] || -1;\x0d\x0a    };\x0d\x0a})();\x0d\x0a\x0d\x0a},{}],19:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0a/* exported Validation */\x0d\x0a\x0d\x0avar Matcher = require(\x22./Matcher\x22);\x0d\x0avar Properties = require(\x22./Properties\x22);\x0d\x0avar ValidationTypes = require(\x22./ValidationTypes\x22);\x0d\x0avar ValidationError = require(\x22./ValidationError\x22);\x0d\x0avar PropertyValueIterator = require(\x22./PropertyValueIterator\x22);\x0d\x0a\x0d\x0avar Validation = module.exports = {\x0d\x0a\x0d\x0a    validate: function(property, value) {\x0d\x0a\x0d\x0a        //normalize name\x0d\x0a        var name        = property.toString().toLowerCase(),\x0d\x0a            expression  = new PropertyValueIterator(value),\x0d\x0a            spec        = Properties[name],\x0d\x0a            part;\x0d\x0a\x0d\x0a        if (!spec) {\x0d\x0a            if (name.indexOf(\x22-\x22) !== 0) {    //vendor prefixed are ok\x0d\x0a                throw new ValidationError(\x22Unknown property \x27\x22 + property + \x22\x27.\x22, property.line, property.col);\x0d\x0a            }\x0d\x0a        } else if (typeof spec !== \x22number\x22) {\x0d\x0a\x0d\x0a            // All properties accept some CSS-wide values.\x0d\x0a            // https://drafts.csswg.org/css-values-3/#common-keywords\x0d\x0a            if (ValidationTypes.isAny(expression, \x22inherit | initial | unset\x22)) {\x0d\x0a                if (expression.hasNext()) {\x0d\x0a                    part = expression.next();\x0d\x0a                    throw new ValidationError(\x22Expected end of value but found \x27\x22 + part + \x22\x27.\x22, part.line, part.col);\x0d\x0a                }\x0d\x0a                return;\x0d\x0a            }\x0d\x0a\x0d\x0a            // Property-specific validation.\x0d\x0a            this.singleProperty(spec, expression);\x0d\x0a\x0d\x0a        }\x0d\x0a\x0d\x0a    },\x0d\x0a\x0d\x0a    singleProperty: function(types, expression) {\x0d\x0a\x0d\x0a        var result      = false,\x0d\x0a            value       = expression.value,\x0d\x0a            part;\x0d\x0a\x0d\x0a        result = Matcher.parse(types).match(expression);\x0d\x0a\x0d\x0a        if (!result) {\x0d\x0a            if (expression.hasNext() && !expression.isFirst()) {\x0d\x0a                part = expression.peek();\x0d\x0a                throw new ValidationError(\x22Expected end of value but found \x27\x22 + part + \x22\x27.\x22, part.line, part.col);\x0d\x0a            } else {\x0d\x0a                throw new ValidationError(\x22Expected (\x22 + ValidationTypes.describe(types) + \x22) but found \x27\x22 + value + \x22\x27.\x22, value.line, value.col);\x0d\x0a            }\x0d\x0a        } else if (expression.hasNext()) {\x0d\x0a            part = expression.next();\x0d\x0a            throw new ValidationError(\x22Expected end of value but found \x27\x22 + part + \x22\x27.\x22, part.line, part.col);\x0d\x0a        }\x0d\x0a\x0d\x0a    }\x0d\x0a\x0d\x0a};\x0d\x0a\x0d\x0a},{\x22./Matcher\x22:3,\x22./Properties\x22:7,\x22./PropertyValueIterator\x22:10,\x22./ValidationError\x22:20,\x22./ValidationTypes\x22:21}],20:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = ValidationError;\x0d\x0a\x0d\x0a/**\x0d\x0a * Type to use when a validation error occurs.\x0d\x0a * @class ValidationError\x0d\x0a * @namespace parserlib.util\x0d\x0a * @constructor\x0d\x0a * @param {String} message The error message.\x0d\x0a * @param {int} line The line at which the error occurred.\x0d\x0a * @param {int} col The column at which the error occurred.\x0d\x0a */\x0d\x0afunction ValidationError(message, line, col) {\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The column at which the error occurred.\x0d\x0a     * @type int\x0d\x0a     * @property col\x0d\x0a     */\x0d\x0a    this.col = col;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The line at which the error occurred.\x0d\x0a     * @type int\x0d\x0a     * @property line\x0d\x0a     */\x0d\x0a    this.line = line;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The text representation of the unit.\x0d\x0a     * @type String\x0d\x0a     * @property text\x0d\x0a     */\x0d\x0a    this.message = message;\x0d\x0a\x0d\x0a}\x0d\x0a\x0d\x0a//inherit from Error\x0d\x0aValidationError.prototype = new Error();\x0d\x0a\x0d\x0a},{}],21:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0avar ValidationTypes = module.exports;\x0d\x0a\x0d\x0avar Matcher = require(\x22./Matcher\x22);\x0d\x0a\x0d\x0afunction copy(to, from) {\x0d\x0a    Object.keys(from).forEach(function(prop) {\x0d\x0a        to[prop] = from[prop];\x0d\x0a    });\x0d\x0a}\x0d\x0acopy(ValidationTypes, {\x0d\x0a\x0d\x0a    isLiteral: function (part, literals) {\x0d\x0a        var text = part.text.toString().toLowerCase(),\x0d\x0a            args = literals.split(\x22 | \x22),\x0d\x0a            i, len, found = false;\x0d\x0a\x0d\x0a        for (i=0, len=args.length; i \x3c len && !found; i++) {\x0d\x0a            if (args[i].charAt(0) === \x22\x3c\x22) {\x0d\x0a                found = this.simple[args[i]](part);\x0d\x0a            } else if (args[i].slice(-2) === \x22()\x22) {\x0d\x0a                found = (part.type === \x22function\x22 &&\x0d\x0a                         part.name === args[i].slice(0, -2));\x0d\x0a            } else if (text === args[i].toLowerCase()) {\x0d\x0a                found = true;\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        return found;\x0d\x0a    },\x0d\x0a\x0d\x0a    isSimple: function(type) {\x0d\x0a        return Boolean(this.simple[type]);\x0d\x0a    },\x0d\x0a\x0d\x0a    isComplex: function(type) {\x0d\x0a        return Boolean(this.complex[type]);\x0d\x0a    },\x0d\x0a\x0d\x0a    describe: function(type) {\x0d\x0a        if (this.complex[type] instanceof Matcher) {\x0d\x0a            return this.complex[type].toString(0);\x0d\x0a        }\x0d\x0a        return type;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Determines if the next part(s) of the given expression\x0d\x0a     * are any of the given types.\x0d\x0a     */\x0d\x0a    isAny: function (expression, types) {\x0d\x0a        var args = types.split(\x22 | \x22),\x0d\x0a            i, len, found = false;\x0d\x0a\x0d\x0a        for (i=0, len=args.length; i \x3c len && !found && expression.hasNext(); i++) {\x0d\x0a            found = this.isType(expression, args[i]);\x0d\x0a        }\x0d\x0a\x0d\x0a        return found;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Determines if the next part(s) of the given expression\x0d\x0a     * are one of a group.\x0d\x0a     */\x0d\x0a    isAnyOfGroup: function(expression, types) {\x0d\x0a        var args = types.split(\x22 || \x22),\x0d\x0a            i, len, found = false;\x0d\x0a\x0d\x0a        for (i=0, len=args.length; i \x3c len && !found; i++) {\x0d\x0a            found = this.isType(expression, args[i]);\x0d\x0a        }\x0d\x0a\x0d\x0a        return found ? args[i-1] : false;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Determines if the next part(s) of the given expression\x0d\x0a     * are of a given type.\x0d\x0a     */\x0d\x0a    isType: function (expression, type) {\x0d\x0a        var part = expression.peek(),\x0d\x0a            result = false;\x0d\x0a\x0d\x0a        if (type.charAt(0) !== \x22\x3c\x22) {\x0d\x0a            result = this.isLiteral(part, type);\x0d\x0a            if (result) {\x0d\x0a                expression.next();\x0d\x0a            }\x0d\x0a        } else if (this.simple[type]) {\x0d\x0a            result = this.simple[type](part);\x0d\x0a            if (result) {\x0d\x0a                expression.next();\x0d\x0a            }\x0d\x0a        } else if (this.complex[type] instanceof Matcher) {\x0d\x0a            result = this.complex[type].match(expression);\x0d\x0a        } else {\x0d\x0a            result = this.complex[type](expression);\x0d\x0a        }\x0d\x0a\x0d\x0a        return result;\x0d\x0a    },\x0d\x0a\x0d\x0a\x0d\x0a    simple: {\x0d\x0a        __proto__: null,\x0d\x0a\x0d\x0a        \x22\x3cabsolute-size\x3e\x22:\x0d\x0a            \x22xx-small | x-small | small | medium | large | x-large | xx-large\x22,\x0d\x0a\x0d\x0a        \x22\x3canimateable-feature\x3e\x22:\x0d\x0a            \x22scroll-position | contents | \x3canimateable-feature-name\x3e\x22,\x0d\x0a\x0d\x0a        \x22\x3canimateable-feature-name\x3e\x22: function(part) {\x0d\x0a            return this[\x22\x3cident\x3e\x22](part) &&\x0d\x0a                !/^(unset|initial|inherit|will-change|auto|scroll-position|contents)$/i.test(part);\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cangle\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22angle\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cattachment\x3e\x22: \x22scroll | fixed | local\x22,\x0d\x0a\x0d\x0a        \x22\x3cattr\x3e\x22: \x22attr()\x22,\x0d\x0a\x0d\x0a        // inset() = inset( \x3cshape-arg\x3e{1,4} [round \x3cborder-radius\x3e]? )\x0d\x0a        // circle() = circle( [\x3cshape-radius\x3e]? [at \x3cposition\x3e]? )\x0d\x0a        // ellipse() = ellipse( [\x3cshape-radius\x3e{2}]? [at \x3cposition\x3e]? )\x0d\x0a        // polygon() = polygon( [\x3cfill-rule\x3e,]? [\x3cshape-arg\x3e \x3cshape-arg\x3e]# )\x0d\x0a        \x22\x3cbasic-shape\x3e\x22: \x22inset() | circle() | ellipse() | polygon()\x22,\x0d\x0a\x0d\x0a        \x22\x3cbg-image\x3e\x22: \x22\x3cimage\x3e | \x3cgradient\x3e | none\x22,\x0d\x0a\x0d\x0a        \x22\x3cborder-style\x3e\x22:\x0d\x0a            \x22none | hidden | dotted | dashed | solid | double | groove | \x22 +\x0d\x0a            \x22ridge | inset | outset\x22,\x0d\x0a\x0d\x0a        \x22\x3cborder-width\x3e\x22: \x22\x3clength\x3e | thin | medium | thick\x22,\x0d\x0a\x0d\x0a        \x22\x3cbox\x3e\x22: \x22padding-box | border-box | content-box\x22,\x0d\x0a\x0d\x0a        \x22\x3cclip-source\x3e\x22: \x22\x3curi\x3e\x22,\x0d\x0a\x0d\x0a        \x22\x3ccolor\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22color\x22 || String(part) === \x22transparent\x22 || String(part) === \x22currentColor\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        // The SVG \x3ccolor\x3e spec doesn\x27t include \x22currentColor\x22 or \x22transparent\x22 as a color.\x0d\x0a        \x22\x3ccolor-svg\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22color\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3ccontent\x3e\x22: \x22content()\x22,\x0d\x0a\x0d\x0a        // https://www.w3.org/TR/css3-sizing/#width-height-keywords\x0d\x0a        \x22\x3ccontent-sizing\x3e\x22:\x0d\x0a            \x22fill-available | -moz-available | -webkit-fill-available | \x22 +\x0d\x0a            \x22max-content | -moz-max-content | -webkit-max-content | \x22 +\x0d\x0a            \x22min-content | -moz-min-content | -webkit-min-content | \x22 +\x0d\x0a            \x22fit-content | -moz-fit-content | -webkit-fit-content\x22,\x0d\x0a\x0d\x0a        \x22\x3cfeature-tag-value\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22function\x22 && /^[A-Z0-9]{4}$/i.test(part);\x0d\x0a        },\x0d\x0a\x0d\x0a        // custom() isn\x27t actually in the spec\x0d\x0a        \x22\x3cfilter-function\x3e\x22:\x0d\x0a            \x22blur() | brightness() | contrast() | custom() | \x22 +\x0d\x0a            \x22drop-shadow() | grayscale() | hue-rotate() | invert() | \x22 +\x0d\x0a            \x22opacity() | saturate() | sepia()\x22,\x0d\x0a\x0d\x0a        \x22\x3cflex-basis\x3e\x22: \x22\x3cwidth\x3e\x22,\x0d\x0a\x0d\x0a        \x22\x3cflex-direction\x3e\x22: \x22row | row-reverse | column | column-reverse\x22,\x0d\x0a\x0d\x0a        \x22\x3cflex-grow\x3e\x22: \x22\x3cnumber\x3e\x22,\x0d\x0a\x0d\x0a        \x22\x3cflex-shrink\x3e\x22: \x22\x3cnumber\x3e\x22,\x0d\x0a\x0d\x0a        \x22\x3cflex-wrap\x3e\x22: \x22nowrap | wrap | wrap-reverse\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-size\x3e\x22:\x0d\x0a            \x22\x3cabsolute-size\x3e | \x3crelative-size\x3e | \x3clength\x3e | \x3cpercentage\x3e\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-stretch\x3e\x22:\x0d\x0a            \x22normal | ultra-condensed | extra-condensed | condensed | \x22 +\x0d\x0a            \x22semi-condensed | semi-expanded | expanded | extra-expanded | \x22 +\x0d\x0a            \x22ultra-expanded\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-style\x3e\x22: \x22normal | italic | oblique\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-variant-caps\x3e\x22:\x0d\x0a            \x22small-caps | all-small-caps | petite-caps | all-petite-caps | \x22 +\x0d\x0a            \x22unicase | titling-caps\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-variant-css21\x3e\x22: \x22normal | small-caps\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-weight\x3e\x22:\x0d\x0a            \x22normal | bold | bolder | lighter | \x22 +\x0d\x0a            \x22100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900\x22,\x0d\x0a\x0d\x0a        \x22\x3cgeneric-family\x3e\x22:\x0d\x0a            \x22serif | sans-serif | cursive | fantasy | monospace\x22,\x0d\x0a\x0d\x0a        \x22\x3cgeometry-box\x3e\x22: \x22\x3cshape-box\x3e | fill-box | stroke-box | view-box\x22,\x0d\x0a\x0d\x0a        \x22\x3cglyph-angle\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22angle\x22 && part.units === \x22deg\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cgradient\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22function\x22 && /^(?:\x5c-(?:ms|moz|o|webkit)\x5c-)?(?:repeating\x5c-)?(?:radial\x5c-|linear\x5c-)?gradient/i.test(part);\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cicccolor\x3e\x22:\x0d\x0a            \x22cielab() | cielch() | cielchab() | \x22 +\x0d\x0a            \x22icc-color() | icc-named-color()\x22,\x0d\x0a\x0d\x0a        //any identifier\x0d\x0a        \x22\x3cident\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22identifier\x22 || part.wasIdent;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cident-not-generic-family\x3e\x22: function(part) {\x0d\x0a            return this[\x22\x3cident\x3e\x22](part) && !this[\x22\x3cgeneric-family\x3e\x22](part);\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cimage\x3e\x22: \x22\x3curi\x3e\x22,\x0d\x0a\x0d\x0a        \x22\x3cinteger\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22integer\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3clength\x3e\x22: function(part) {\x0d\x0a            if (part.type === \x22function\x22 && /^(?:\x5c-(?:ms|moz|o|webkit)\x5c-)?calc/i.test(part)) {\x0d\x0a                return true;\x0d\x0a            } else {\x0d\x0a                return part.type === \x22length\x22 || part.type === \x22number\x22 || part.type === \x22integer\x22 || String(part) === \x220\x22;\x0d\x0a            }\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cline\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22integer\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cline-height\x3e\x22: \x22\x3cnumber\x3e | \x3clength\x3e | \x3cpercentage\x3e | normal\x22,\x0d\x0a\x0d\x0a        \x22\x3cmargin-width\x3e\x22: \x22\x3clength\x3e | \x3cpercentage\x3e | auto\x22,\x0d\x0a\x0d\x0a        \x22\x3cmiterlimit\x3e\x22: function(part) {\x0d\x0a            return this[\x22\x3cnumber\x3e\x22](part) && part.value \x3e= 1;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cnonnegative-length-or-percentage\x3e\x22: function(part) {\x0d\x0a            return (this[\x22\x3clength\x3e\x22](part) || this[\x22\x3cpercentage\x3e\x22](part)) &&\x0d\x0a                (String(part) === \x220\x22 || part.type === \x22function\x22 || (part.value) \x3e= 0);\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cnonnegative-number-or-percentage\x3e\x22: function(part) {\x0d\x0a            return (this[\x22\x3cnumber\x3e\x22](part) || this[\x22\x3cpercentage\x3e\x22](part)) &&\x0d\x0a                (String(part) === \x220\x22 || part.type === \x22function\x22 || (part.value) \x3e= 0);\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cnumber\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22number\x22 || this[\x22\x3cinteger\x3e\x22](part);\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3copacity-value\x3e\x22: function(part) {\x0d\x0a            return this[\x22\x3cnumber\x3e\x22](part) && part.value \x3e= 0 && part.value \x3c= 1;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cpadding-width\x3e\x22: \x22\x3cnonnegative-length-or-percentage\x3e\x22,\x0d\x0a\x0d\x0a        \x22\x3cpercentage\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22percentage\x22 || String(part) === \x220\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3crelative-size\x3e\x22: \x22smaller | larger\x22,\x0d\x0a\x0d\x0a        \x22\x3cshape\x3e\x22: \x22rect() | inset-rect()\x22,\x0d\x0a\x0d\x0a        \x22\x3cshape-box\x3e\x22: \x22\x3cbox\x3e | margin-box\x22,\x0d\x0a\x0d\x0a        \x22\x3csingle-animation-direction\x3e\x22:\x0d\x0a            \x22normal | reverse | alternate | alternate-reverse\x22,\x0d\x0a\x0d\x0a        \x22\x3csingle-animation-name\x3e\x22: function(part) {\x0d\x0a            return this[\x22\x3cident\x3e\x22](part) &&\x0d\x0a                /^-?[a-z_][-a-z0-9_]+$/i.test(part) &&\x0d\x0a                !/^(none|unset|initial|inherit)$/i.test(part);\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cstring\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22string\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3ctime\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22time\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3curi\x3e\x22: function(part) {\x0d\x0a            return part.type === \x22uri\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        \x22\x3cwidth\x3e\x22: \x22\x3cmargin-width\x3e\x22\x0d\x0a    },\x0d\x0a\x0d\x0a    complex: {\x0d\x0a        __proto__: null,\x0d\x0a\x0d\x0a        \x22\x3cazimuth\x3e\x22:\x0d\x0a            \x22\x3cangle\x3e\x22 +\x0d\x0a            \x22 | \x22 +\x0d\x0a            \x22[ [ left-side | far-left | left | center-left | center | \x22 +\x0d\x0a            \x22center-right | right | far-right | right-side ] || behind ]\x22 +\x0d\x0a            \x22 | \x22+\x0d\x0a            \x22leftwards | rightwards\x22,\x0d\x0a\x0d\x0a        \x22\x3cbg-position\x3e\x22: \x22\x3cposition\x3e#\x22,\x0d\x0a\x0d\x0a        \x22\x3cbg-size\x3e\x22:\x0d\x0a            \x22[ \x3clength\x3e | \x3cpercentage\x3e | auto ]{1,2} | cover | contain\x22,\x0d\x0a\x0d\x0a        \x22\x3cborder-image-slice\x3e\x22:\x0d\x0a        // [\x3cnumber\x3e | \x3cpercentage\x3e]{1,4} && fill?\x0d\x0a        // *but* fill can appear between any of the numbers\x0d\x0a        Matcher.many([true /* first element is required */],\x0d\x0a                     Matcher.cast(\x22\x3cnonnegative-number-or-percentage\x3e\x22),\x0d\x0a                     Matcher.cast(\x22\x3cnonnegative-number-or-percentage\x3e\x22),\x0d\x0a                     Matcher.cast(\x22\x3cnonnegative-number-or-percentage\x3e\x22),\x0d\x0a                     Matcher.cast(\x22\x3cnonnegative-number-or-percentage\x3e\x22),\x0d\x0a                     \x22fill\x22),\x0d\x0a\x0d\x0a        \x22\x3cborder-radius\x3e\x22:\x0d\x0a            \x22\x3cnonnegative-length-or-percentage\x3e{1,4} \x22 +\x0d\x0a            \x22[ / \x3cnonnegative-length-or-percentage\x3e{1,4} ]?\x22,\x0d\x0a\x0d\x0a        \x22\x3cbox-shadow\x3e\x22: \x22none | \x3cshadow\x3e#\x22,\x0d\x0a\x0d\x0a        \x22\x3cclip-path\x3e\x22: \x22\x3cbasic-shape\x3e || \x3cgeometry-box\x3e\x22,\x0d\x0a\x0d\x0a        \x22\x3cdasharray\x3e\x22:\x0d\x0a        // \x22list of comma and/or white space separated \x3clength\x3es and\x0d\x0a        // \x3cpercentage\x3es\x22.  There is a non-negative constraint.\x0d\x0a        Matcher.cast(\x22\x3cnonnegative-length-or-percentage\x3e\x22)\x0d\x0a            .braces(1, Infinity, \x22#\x22, Matcher.cast(\x22,\x22).question()),\x0d\x0a\x0d\x0a        \x22\x3cfamily-name\x3e\x22:\x0d\x0a            // \x3cstring\x3e | \x3cIDENT\x3e+\x0d\x0a            \x22\x3cstring\x3e | \x3cident-not-generic-family\x3e \x3cident\x3e*\x22,\x0d\x0a\x0d\x0a        \x22\x3cfilter-function-list\x3e\x22: \x22[ \x3cfilter-function\x3e | \x3curi\x3e ]+\x22,\x0d\x0a\x0d\x0a        // https://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/#flex-property\x0d\x0a        \x22\x3cflex\x3e\x22:\x0d\x0a            \x22none | [ \x3cflex-grow\x3e \x3cflex-shrink\x3e? || \x3cflex-basis\x3e ]\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-family\x3e\x22: \x22[ \x3cgeneric-family\x3e | \x3cfamily-name\x3e ]#\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-shorthand\x3e\x22:\x0d\x0a            \x22[ \x3cfont-style\x3e || \x3cfont-variant-css21\x3e || \x22 +\x0d\x0a            \x22\x3cfont-weight\x3e || \x3cfont-stretch\x3e ]? \x3cfont-size\x3e \x22 +\x0d\x0a            \x22[ / \x3cline-height\x3e ]? \x3cfont-family\x3e\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-variant-alternates\x3e\x22:\x0d\x0a            // stylistic(\x3cfeature-value-name\x3e)\x0d\x0a            \x22stylistic() || \x22 +\x0d\x0a            \x22historical-forms || \x22 +\x0d\x0a            // styleset(\x3cfeature-value-name\x3e #)\x0d\x0a            \x22styleset() || \x22 +\x0d\x0a            // character-variant(\x3cfeature-value-name\x3e #)\x0d\x0a            \x22character-variant() || \x22 +\x0d\x0a            // swash(\x3cfeature-value-name\x3e)\x0d\x0a            \x22swash() || \x22 +\x0d\x0a            // ornaments(\x3cfeature-value-name\x3e)\x0d\x0a            \x22ornaments() || \x22 +\x0d\x0a            // annotation(\x3cfeature-value-name\x3e)\x0d\x0a            \x22annotation()\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-variant-ligatures\x3e\x22:\x0d\x0a            // \x3ccommon-lig-values\x3e\x0d\x0a            \x22[ common-ligatures | no-common-ligatures ] || \x22 +\x0d\x0a            // \x3cdiscretionary-lig-values\x3e\x0d\x0a            \x22[ discretionary-ligatures | no-discretionary-ligatures ] || \x22 +\x0d\x0a            // \x3chistorical-lig-values\x3e\x0d\x0a            \x22[ historical-ligatures | no-historical-ligatures ] || \x22 +\x0d\x0a            // \x3ccontextual-alt-values\x3e\x0d\x0a            \x22[ contextual | no-contextual ]\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-variant-numeric\x3e\x22:\x0d\x0a            // \x3cnumeric-figure-values\x3e\x0d\x0a            \x22[ lining-nums | oldstyle-nums ] || \x22 +\x0d\x0a            // \x3cnumeric-spacing-values\x3e\x0d\x0a            \x22[ proportional-nums | tabular-nums ] || \x22 +\x0d\x0a            // \x3cnumeric-fraction-values\x3e\x0d\x0a            \x22[ diagonal-fractions | stacked-fractions ] || \x22 +\x0d\x0a            \x22ordinal || slashed-zero\x22,\x0d\x0a\x0d\x0a        \x22\x3cfont-variant-east-asian\x3e\x22:\x0d\x0a            // \x3ceast-asian-variant-values\x3e\x0d\x0a            \x22[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ] || \x22 +\x0d\x0a            // \x3ceast-asian-width-values\x3e\x0d\x0a            \x22[ full-width | proportional-width ] || \x22 +\x0d\x0a            \x22ruby\x22,\x0d\x0a\x0d\x0a        // Note that \x3ccolor\x3e here is \x22as defined in the SVG spec\x22, which\x0d\x0a        // is more restrictive that the \x3ccolor\x3e defined in the CSS spec.\x0d\x0a        // none | currentColor | \x3ccolor\x3e [\x3cicccolor\x3e]? |\x0d\x0a        // \x3cfunciri\x3e [ none | currentColor | \x3ccolor\x3e [\x3cicccolor\x3e]? ]?\x0d\x0a        \x22\x3cpaint\x3e\x22: \x22\x3cpaint-basic\x3e | \x3curi\x3e \x3cpaint-basic\x3e?\x22,\x0d\x0a\x0d\x0a        // Helper definition for \x3cpaint\x3e above.\x0d\x0a        \x22\x3cpaint-basic\x3e\x22: \x22none | currentColor | \x3ccolor-svg\x3e \x3cicccolor\x3e?\x22,\x0d\x0a\x0d\x0a        \x22\x3cposition\x3e\x22:\x0d\x0a            // Because our `alt` combinator is ordered, we need to test these\x0d\x0a            // in order from longest possible match to shortest.\x0d\x0a            \x22[ center | [ left | right ] [ \x3cpercentage\x3e | \x3clength\x3e ]? ] && \x22 +\x0d\x0a            \x22[ center | [ top | bottom ] [ \x3cpercentage\x3e | \x3clength\x3e ]? ]\x22 +\x0d\x0a            \x22 | \x22 +\x0d\x0a            \x22[ left | center | right | \x3cpercentage\x3e | \x3clength\x3e ] \x22 +\x0d\x0a            \x22[ top | center | bottom | \x3cpercentage\x3e | \x3clength\x3e ]\x22 +\x0d\x0a            \x22 | \x22 +\x0d\x0a            \x22[ left | center | right | top | bottom | \x3cpercentage\x3e | \x3clength\x3e ]\x22,\x0d\x0a\x0d\x0a        \x22\x3crepeat-style\x3e\x22:\x0d\x0a            \x22repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}\x22,\x0d\x0a\x0d\x0a        \x22\x3cshadow\x3e\x22:\x0d\x0a        //inset? && [ \x3clength\x3e{2,4} && \x3ccolor\x3e? ]\x0d\x0a        Matcher.many([true /* length is required */],\x0d\x0a                     Matcher.cast(\x22\x3clength\x3e\x22).braces(2, 4), \x22inset\x22, \x22\x3ccolor\x3e\x22),\x0d\x0a\x0d\x0a        \x22\x3ctext-decoration-color\x3e\x22:\x0d\x0a           \x22\x3ccolor\x3e\x22,\x0d\x0a\x0d\x0a        \x22\x3ctext-decoration-line\x3e\x22:\x0d\x0a            \x22none | [ underline || overline || line-through || blink ]\x22,\x0d\x0a\x0d\x0a        \x22\x3ctext-decoration-style\x3e\x22:\x0d\x0a            \x22solid | double | dotted | dashed | wavy\x22,\x0d\x0a\x0d\x0a        \x22\x3cwill-change\x3e\x22:\x0d\x0a            \x22auto | \x3canimateable-feature\x3e#\x22,\x0d\x0a\x0d\x0a        \x22\x3cx-one-radius\x3e\x22:\x0d\x0a            //[ \x3clength\x3e | \x3cpercentage\x3e ] [ \x3clength\x3e | \x3cpercentage\x3e ]?\x0d\x0a            \x22[ \x3clength\x3e | \x3cpercentage\x3e ]{1,2}\x22\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0aObject.keys(ValidationTypes.simple).forEach(function(nt) {\x0d\x0a    var rule = ValidationTypes.simple[nt];\x0d\x0a    if (typeof rule === \x22string\x22) {\x0d\x0a        ValidationTypes.simple[nt] = function(part) {\x0d\x0a            return ValidationTypes.isLiteral(part, rule);\x0d\x0a        };\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0aObject.keys(ValidationTypes.complex).forEach(function(nt) {\x0d\x0a    var rule = ValidationTypes.complex[nt];\x0d\x0a    if (typeof rule === \x22string\x22) {\x0d\x0a        ValidationTypes.complex[nt] = Matcher.parse(rule);\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0a// Because this is defined relative to other complex validation types,\x0d\x0a// we need to define it *after* the rest of the types are initialized.\x0d\x0aValidationTypes.complex[\x22\x3cfont-variant\x3e\x22] =\x0d\x0a    Matcher.oror({ expand: \x22\x3cfont-variant-ligatures\x3e\x22 },\x0d\x0a                 { expand: \x22\x3cfont-variant-alternates\x3e\x22 },\x0d\x0a                 \x22\x3cfont-variant-caps\x3e\x22,\x0d\x0a                 { expand: \x22\x3cfont-variant-numeric\x3e\x22 },\x0d\x0a                 { expand: \x22\x3cfont-variant-east-asian\x3e\x22 });\x0d\x0a\x0d\x0a},{\x22./Matcher\x22:3}],22:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = {\x0d\x0a    Colors            : require(\x22./Colors\x22),\x0d\x0a    Combinator        : require(\x22./Combinator\x22),\x0d\x0a    Parser            : require(\x22./Parser\x22),\x0d\x0a    PropertyName      : require(\x22./PropertyName\x22),\x0d\x0a    PropertyValue     : require(\x22./PropertyValue\x22),\x0d\x0a    PropertyValuePart : require(\x22./PropertyValuePart\x22),\x0d\x0a    Matcher           : require(\x22./Matcher\x22),\x0d\x0a    MediaFeature      : require(\x22./MediaFeature\x22),\x0d\x0a    MediaQuery        : require(\x22./MediaQuery\x22),\x0d\x0a    Selector          : require(\x22./Selector\x22),\x0d\x0a    SelectorPart      : require(\x22./SelectorPart\x22),\x0d\x0a    SelectorSubPart   : require(\x22./SelectorSubPart\x22),\x0d\x0a    Specificity       : require(\x22./Specificity\x22),\x0d\x0a    TokenStream       : require(\x22./TokenStream\x22),\x0d\x0a    Tokens            : require(\x22./Tokens\x22),\x0d\x0a    ValidationError   : require(\x22./ValidationError\x22)\x0d\x0a};\x0d\x0a\x0d\x0a},{\x22./Colors\x22:1,\x22./Combinator\x22:2,\x22./Matcher\x22:3,\x22./MediaFeature\x22:4,\x22./MediaQuery\x22:5,\x22./Parser\x22:6,\x22./PropertyName\x22:8,\x22./PropertyValue\x22:9,\x22./PropertyValuePart\x22:11,\x22./Selector\x22:13,\x22./SelectorPart\x22:14,\x22./SelectorSubPart\x22:15,\x22./Specificity\x22:16,\x22./TokenStream\x22:17,\x22./Tokens\x22:18,\x22./ValidationError\x22:20}],23:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = EventTarget;\x0d\x0a\x0d\x0a/**\x0d\x0a * A generic base to inherit from for any object\x0d\x0a * that needs event handling.\x0d\x0a * @class EventTarget\x0d\x0a * @constructor\x0d\x0a */\x0d\x0afunction EventTarget() {\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The array of listeners for various events.\x0d\x0a     * @type Object\x0d\x0a     * @property _listeners\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._listeners = Object.create(null);\x0d\x0a}\x0d\x0a\x0d\x0aEventTarget.prototype = {\x0d\x0a\x0d\x0a    //restore constructor\x0d\x0a    constructor: EventTarget,\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Adds a listener for a given event type.\x0d\x0a     * @param {String} type The type of event to add a listener for.\x0d\x0a     * @param {Function} listener The function to call when the event occurs.\x0d\x0a     * @return {void}\x0d\x0a     * @method addListener\x0d\x0a     */\x0d\x0a    addListener: function(type, listener) {\x0d\x0a        if (!this._listeners[type]) {\x0d\x0a            this._listeners[type] = [];\x0d\x0a        }\x0d\x0a\x0d\x0a        this._listeners[type].push(listener);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Fires an event based on the passed-in object.\x0d\x0a     * @param {Object|String} event An object with at least a \x27type\x27 attribute\x0d\x0a     *      or a string indicating the event name.\x0d\x0a     * @return {void}\x0d\x0a     * @method fire\x0d\x0a     */\x0d\x0a    fire: function(event) {\x0d\x0a        if (typeof event === \x22string\x22) {\x0d\x0a            event = { type: event };\x0d\x0a        }\x0d\x0a        if (typeof event.target !== \x22undefined\x22) {\x0d\x0a            event.target = this;\x0d\x0a        }\x0d\x0a\x0d\x0a        if (typeof event.type === \x22undefined\x22) {\x0d\x0a            throw new Error(\x22Event object missing \x27type\x27 property.\x22);\x0d\x0a        }\x0d\x0a\x0d\x0a        if (this._listeners[event.type]) {\x0d\x0a\x0d\x0a            //create a copy of the array and use that so listeners can\x27t chane\x0d\x0a            var listeners = this._listeners[event.type].concat();\x0d\x0a            for (var i=0, len=listeners.length; i \x3c len; i++) {\x0d\x0a                listeners[i].call(this, event);\x0d\x0a            }\x0d\x0a        }\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Removes a listener for a given event type.\x0d\x0a     * @param {String} type The type of event to remove a listener from.\x0d\x0a     * @param {Function} listener The function to remove from the event.\x0d\x0a     * @return {void}\x0d\x0a     * @method removeListener\x0d\x0a     */\x0d\x0a    removeListener: function(type, listener) {\x0d\x0a        if (this._listeners[type]) {\x0d\x0a            var listeners = this._listeners[type];\x0d\x0a            for (var i=0, len=listeners.length; i \x3c len; i++) {\x0d\x0a                if (listeners[i] === listener) {\x0d\x0a                    listeners.splice(i, 1);\x0d\x0a                    break;\x0d\x0a                }\x0d\x0a            }\x0d\x0a\x0d\x0a\x0d\x0a        }\x0d\x0a    }\x0d\x0a};\x0d\x0a\x0d\x0a},{}],24:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = StringReader;\x0d\x0a\x0d\x0a/**\x0d\x0a * Convenient way to read through strings.\x0d\x0a * @namespace parserlib.util\x0d\x0a * @class StringReader\x0d\x0a * @constructor\x0d\x0a * @param {String} text The text to read.\x0d\x0a */\x0d\x0afunction StringReader(text) {\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The input text with line endings normalized.\x0d\x0a     * @property _input\x0d\x0a     * @type String\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._input = text.replace(/(\x5cr\x5cn?|\x5cn)/g, \x22\x5cn\x22);\x0d\x0a\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The row for the character to be read next.\x0d\x0a     * @property _line\x0d\x0a     * @type int\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._line = 1;\x0d\x0a\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The column for the character to be read next.\x0d\x0a     * @property _col\x0d\x0a     * @type int\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._col = 1;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The index of the character in the input to be read next.\x0d\x0a     * @property _cursor\x0d\x0a     * @type int\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._cursor = 0;\x0d\x0a}\x0d\x0a\x0d\x0aStringReader.prototype = {\x0d\x0a\x0d\x0a    // restore constructor\x0d\x0a    constructor: StringReader,\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Position info\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns the column of the character to be read next.\x0d\x0a     * @return {int} The column of the character to be read next.\x0d\x0a     * @method getCol\x0d\x0a     */\x0d\x0a    getCol: function() {\x0d\x0a        return this._col;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns the row of the character to be read next.\x0d\x0a     * @return {int} The row of the character to be read next.\x0d\x0a     * @method getLine\x0d\x0a     */\x0d\x0a    getLine: function() {\x0d\x0a        return this._line;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Determines if you\x27re at the end of the input.\x0d\x0a     * @return {Boolean} True if there\x27s no more input, false otherwise.\x0d\x0a     * @method eof\x0d\x0a     */\x0d\x0a    eof: function() {\x0d\x0a        return this._cursor === this._input.length;\x0d\x0a    },\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Basic reading\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Reads the next character without advancing the cursor.\x0d\x0a     * @param {int} count How many characters to look ahead (default is 1).\x0d\x0a     * @return {String} The next character or null if there is no next character.\x0d\x0a     * @method peek\x0d\x0a     */\x0d\x0a    peek: function(count) {\x0d\x0a        var c = null;\x0d\x0a        count = typeof count === \x22undefined\x22 ? 1 : count;\x0d\x0a\x0d\x0a        // if we\x27re not at the end of the input...\x0d\x0a        if (this._cursor \x3c this._input.length) {\x0d\x0a\x0d\x0a            // get character and increment cursor and column\x0d\x0a            c = this._input.charAt(this._cursor + count - 1);\x0d\x0a        }\x0d\x0a\x0d\x0a        return c;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Reads the next character from the input and adjusts the row and column\x0d\x0a     * accordingly.\x0d\x0a     * @return {String} The next character or null if there is no next character.\x0d\x0a     * @method read\x0d\x0a     */\x0d\x0a    read: function() {\x0d\x0a        var c = null;\x0d\x0a\x0d\x0a        // if we\x27re not at the end of the input...\x0d\x0a        if (this._cursor \x3c this._input.length) {\x0d\x0a\x0d\x0a            // if the last character was a newline, increment row count\x0d\x0a            // and reset column count\x0d\x0a            if (this._input.charAt(this._cursor) === \x22\x5cn\x22) {\x0d\x0a                this._line++;\x0d\x0a                this._col=1;\x0d\x0a            } else {\x0d\x0a                this._col++;\x0d\x0a            }\x0d\x0a\x0d\x0a            // get character and increment cursor and column\x0d\x0a            c = this._input.charAt(this._cursor++);\x0d\x0a        }\x0d\x0a\x0d\x0a        return c;\x0d\x0a    },\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Misc\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Saves the current location so it can be returned to later.\x0d\x0a     * @method mark\x0d\x0a     * @return {void}\x0d\x0a     */\x0d\x0a    mark: function() {\x0d\x0a        this._bookmark = {\x0d\x0a            cursor: this._cursor,\x0d\x0a            line:   this._line,\x0d\x0a            col:    this._col\x0d\x0a        };\x0d\x0a    },\x0d\x0a\x0d\x0a    reset: function() {\x0d\x0a        if (this._bookmark) {\x0d\x0a            this._cursor = this._bookmark.cursor;\x0d\x0a            this._line = this._bookmark.line;\x0d\x0a            this._col = this._bookmark.col;\x0d\x0a            delete this._bookmark;\x0d\x0a        }\x0d\x0a    },\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Advanced reading\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Reads up to and including the given string. Throws an error if that\x0d\x0a     * string is not found.\x0d\x0a     * @param {String} pattern The string to read.\x0d\x0a     * @return {String} The string when it is found.\x0d\x0a     * @throws Error when the string pattern is not found.\x0d\x0a     * @method readTo\x0d\x0a     */\x0d\x0a    readTo: function(pattern) {\x0d\x0a\x0d\x0a        var buffer = \x22\x22,\x0d\x0a            c;\x0d\x0a\x0d\x0a        /*\x0d\x0a         * First, buffer must be the same length as the pattern.\x0d\x0a         * Then, buffer must end with the pattern or else reach the\x0d\x0a         * end of the input.\x0d\x0a         */\x0d\x0a        while (buffer.length \x3c pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length) {\x0d\x0a            c = this.read();\x0d\x0a            if (c) {\x0d\x0a                buffer += c;\x0d\x0a            } else {\x0d\x0a                throw new Error(\x22Expected \x5c\x22\x22 + pattern + \x22\x5c\x22 at line \x22 + this._line  + \x22, col \x22 + this._col + \x22.\x22);\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        return buffer;\x0d\x0a\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Reads characters while each character causes the given\x0d\x0a     * filter function to return true. The function is passed\x0d\x0a     * in each character and either returns true to continue\x0d\x0a     * reading or false to stop.\x0d\x0a     * @param {Function} filter The function to read on each character.\x0d\x0a     * @return {String} The string made up of all characters that passed the\x0d\x0a     *      filter check.\x0d\x0a     * @method readWhile\x0d\x0a     */\x0d\x0a    readWhile: function(filter) {\x0d\x0a\x0d\x0a        var buffer = \x22\x22,\x0d\x0a            c = this.peek();\x0d\x0a\x0d\x0a        while (c !== null && filter(c)) {\x0d\x0a            buffer += this.read();\x0d\x0a            c = this.peek();\x0d\x0a        }\x0d\x0a\x0d\x0a        return buffer;\x0d\x0a\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Reads characters that match either text or a regular expression and\x0d\x0a     * returns those characters. If a match is found, the row and column\x0d\x0a     * are adjusted; if no match is found, the reader\x27s state is unchanged.\x0d\x0a     * reading or false to stop.\x0d\x0a     * @param {String|RegExp} matcher If a string, then the literal string\x0d\x0a     *      value is searched for. If a regular expression, then any string\x0d\x0a     *      matching the pattern is search for.\x0d\x0a     * @return {String} The string made up of all characters that matched or\x0d\x0a     *      null if there was no match.\x0d\x0a     * @method readMatch\x0d\x0a     */\x0d\x0a    readMatch: function(matcher) {\x0d\x0a\x0d\x0a        var source = this._input.substring(this._cursor),\x0d\x0a            value = null;\x0d\x0a\x0d\x0a        // if it\x27s a string, just do a straight match\x0d\x0a        if (typeof matcher === \x22string\x22) {\x0d\x0a            if (source.slice(0, matcher.length) === matcher) {\x0d\x0a                value = this.readCount(matcher.length);\x0d\x0a            }\x0d\x0a        } else if (matcher instanceof RegExp) {\x0d\x0a            if (matcher.test(source)) {\x0d\x0a                value = this.readCount(RegExp.lastMatch.length);\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        return value;\x0d\x0a    },\x0d\x0a\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Reads a given number of characters. If the end of the input is reached,\x0d\x0a     * it reads only the remaining characters and does not throw an error.\x0d\x0a     * @param {int} count The number of characters to read.\x0d\x0a     * @return {String} The string made up the read characters.\x0d\x0a     * @method readCount\x0d\x0a     */\x0d\x0a    readCount: function(count) {\x0d\x0a        var buffer = \x22\x22;\x0d\x0a\x0d\x0a        while (count--) {\x0d\x0a            buffer += this.read();\x0d\x0a        }\x0d\x0a\x0d\x0a        return buffer;\x0d\x0a    }\x0d\x0a\x0d\x0a};\x0d\x0a\x0d\x0a},{}],25:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = SyntaxError;\x0d\x0a\x0d\x0a/**\x0d\x0a * Type to use when a syntax error occurs.\x0d\x0a * @class SyntaxError\x0d\x0a * @namespace parserlib.util\x0d\x0a * @constructor\x0d\x0a * @param {String} message The error message.\x0d\x0a * @param {int} line The line at which the error occurred.\x0d\x0a * @param {int} col The column at which the error occurred.\x0d\x0a */\x0d\x0afunction SyntaxError(message, line, col) {\x0d\x0a    Error.call(this);\x0d\x0a    this.name = this.constructor.name;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The column at which the error occurred.\x0d\x0a     * @type int\x0d\x0a     * @property col\x0d\x0a     */\x0d\x0a    this.col = col;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The line at which the error occurred.\x0d\x0a     * @type int\x0d\x0a     * @property line\x0d\x0a     */\x0d\x0a    this.line = line;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The text representation of the unit.\x0d\x0a     * @type String\x0d\x0a     * @property text\x0d\x0a     */\x0d\x0a    this.message = message;\x0d\x0a\x0d\x0a}\x0d\x0a\x0d\x0a//inherit from Error\x0d\x0aSyntaxError.prototype = Object.create(Error.prototype); // jshint ignore:line\x0d\x0aSyntaxError.prototype.constructor = SyntaxError; // jshint ignore:line\x0d\x0a\x0d\x0a},{}],26:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = SyntaxUnit;\x0d\x0a\x0d\x0a/**\x0d\x0a * Base type to represent a single syntactic unit.\x0d\x0a * @class SyntaxUnit\x0d\x0a * @namespace parserlib.util\x0d\x0a * @constructor\x0d\x0a * @param {String} text The text of the unit.\x0d\x0a * @param {int} line The line of text on which the unit resides.\x0d\x0a * @param {int} col The column of text on which the unit resides.\x0d\x0a */\x0d\x0afunction SyntaxUnit(text, line, col, type) {\x0d\x0a\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The column of text on which the unit resides.\x0d\x0a     * @type int\x0d\x0a     * @property col\x0d\x0a     */\x0d\x0a    this.col = col;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The line of text on which the unit resides.\x0d\x0a     * @type int\x0d\x0a     * @property line\x0d\x0a     */\x0d\x0a    this.line = line;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The text representation of the unit.\x0d\x0a     * @type String\x0d\x0a     * @property text\x0d\x0a     */\x0d\x0a    this.text = text;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The type of syntax unit.\x0d\x0a     * @type int\x0d\x0a     * @property type\x0d\x0a     */\x0d\x0a    this.type = type;\x0d\x0a}\x0d\x0a\x0d\x0a/**\x0d\x0a * Create a new syntax unit based solely on the given token.\x0d\x0a * Convenience method for creating a new syntax unit when\x0d\x0a * it represents a single token instead of multiple.\x0d\x0a * @param {Object} token The token object to represent.\x0d\x0a * @return {parserlib.util.SyntaxUnit} The object representing the token.\x0d\x0a * @static\x0d\x0a * @method fromToken\x0d\x0a */\x0d\x0aSyntaxUnit.fromToken = function(token) {\x0d\x0a    return new SyntaxUnit(token.value, token.startLine, token.startCol);\x0d\x0a};\x0d\x0a\x0d\x0aSyntaxUnit.prototype = {\x0d\x0a\x0d\x0a    //restore constructor\x0d\x0a    constructor: SyntaxUnit,\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns the text representation of the unit.\x0d\x0a     * @return {String} The text representation of the unit.\x0d\x0a     * @method valueOf\x0d\x0a     */\x0d\x0a    valueOf: function() {\x0d\x0a        return this.toString();\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns the text representation of the unit.\x0d\x0a     * @return {String} The text representation of the unit.\x0d\x0a     * @method toString\x0d\x0a     */\x0d\x0a    toString: function() {\x0d\x0a        return this.text;\x0d\x0a    }\x0d\x0a\x0d\x0a};\x0d\x0a\x0d\x0a},{}],27:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = TokenStreamBase;\x0d\x0a\x0d\x0avar StringReader = require(\x22./StringReader\x22);\x0d\x0avar SyntaxError = require(\x22./SyntaxError\x22);\x0d\x0a\x0d\x0a/**\x0d\x0a * Generic TokenStream providing base functionality.\x0d\x0a * @class TokenStreamBase\x0d\x0a * @namespace parserlib.util\x0d\x0a * @constructor\x0d\x0a * @param {String|StringReader} input The text to tokenize or a reader from\x0d\x0a *      which to read the input.\x0d\x0a */\x0d\x0afunction TokenStreamBase(input, tokenData) {\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The string reader for easy access to the text.\x0d\x0a     * @type StringReader\x0d\x0a     * @property _reader\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._reader = new StringReader(input ? input.toString() : \x22\x22);\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Token object for the last consumed token.\x0d\x0a     * @type Token\x0d\x0a     * @property _token\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._token = null;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * The array of token information.\x0d\x0a     * @type Array\x0d\x0a     * @property _tokenData\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._tokenData = tokenData;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Lookahead token buffer.\x0d\x0a     * @type Array\x0d\x0a     * @property _lt\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._lt = [];\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Lookahead token buffer index.\x0d\x0a     * @type int\x0d\x0a     * @property _ltIndex\x0d\x0a     * @private\x0d\x0a     */\x0d\x0a    this._ltIndex = 0;\x0d\x0a\x0d\x0a    this._ltIndexCache = [];\x0d\x0a}\x0d\x0a\x0d\x0a/**\x0d\x0a * Accepts an array of token information and outputs\x0d\x0a * an array of token data containing key-value mappings\x0d\x0a * and matching functions that the TokenStream needs.\x0d\x0a * @param {Array} tokens An array of token descriptors.\x0d\x0a * @return {Array} An array of processed token data.\x0d\x0a * @method createTokenData\x0d\x0a * @static\x0d\x0a */\x0d\x0aTokenStreamBase.createTokenData = function(tokens) {\x0d\x0a\x0d\x0a    var nameMap     = [],\x0d\x0a        typeMap     = Object.create(null),\x0d\x0a        tokenData     = tokens.concat([]),\x0d\x0a        i            = 0,\x0d\x0a        len            = tokenData.length+1;\x0d\x0a\x0d\x0a    tokenData.UNKNOWN = -1;\x0d\x0a    tokenData.unshift({ name:\x22EOF\x22 });\x0d\x0a\x0d\x0a    for (; i \x3c len; i++) {\x0d\x0a        nameMap.push(tokenData[i].name);\x0d\x0a        tokenData[tokenData[i].name] = i;\x0d\x0a        if (tokenData[i].text) {\x0d\x0a            typeMap[tokenData[i].text] = i;\x0d\x0a        }\x0d\x0a    }\x0d\x0a\x0d\x0a    tokenData.name = function(tt) {\x0d\x0a        return nameMap[tt];\x0d\x0a    };\x0d\x0a\x0d\x0a    tokenData.type = function(c) {\x0d\x0a        return typeMap[c];\x0d\x0a    };\x0d\x0a\x0d\x0a    return tokenData;\x0d\x0a};\x0d\x0a\x0d\x0aTokenStreamBase.prototype = {\x0d\x0a\x0d\x0a    //restore constructor\x0d\x0a    constructor: TokenStreamBase,\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Matching methods\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Determines if the next token matches the given token type.\x0d\x0a     * If so, that token is consumed; if not, the token is placed\x0d\x0a     * back onto the token stream. You can pass in any number of\x0d\x0a     * token types and this will return true if any of the token\x0d\x0a     * types is found.\x0d\x0a     * @param {int|int[]} tokenTypes Either a single token type or an array of\x0d\x0a     *      token types that the next token might be. If an array is passed,\x0d\x0a     *      it\x27s assumed that the token can be any of these.\x0d\x0a     * @param {variant} channel (Optional) The channel to read from. If not\x0d\x0a     *      provided, reads from the default (unnamed) channel.\x0d\x0a     * @return {Boolean} True if the token type matches, false if not.\x0d\x0a     * @method match\x0d\x0a     */\x0d\x0a    match: function(tokenTypes, channel) {\x0d\x0a\x0d\x0a        //always convert to an array, makes things easier\x0d\x0a        if (!(tokenTypes instanceof Array)) {\x0d\x0a            tokenTypes = [tokenTypes];\x0d\x0a        }\x0d\x0a\x0d\x0a        var tt  = this.get(channel),\x0d\x0a            i   = 0,\x0d\x0a            len = tokenTypes.length;\x0d\x0a\x0d\x0a        while (i \x3c len) {\x0d\x0a            if (tt === tokenTypes[i++]) {\x0d\x0a                return true;\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        //no match found, put the token back\x0d\x0a        this.unget();\x0d\x0a        return false;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Determines if the next token matches the given token type.\x0d\x0a     * If so, that token is consumed; if not, an error is thrown.\x0d\x0a     * @param {int|int[]} tokenTypes Either a single token type or an array of\x0d\x0a     *      token types that the next token should be. If an array is passed,\x0d\x0a     *      it\x27s assumed that the token must be one of these.\x0d\x0a     * @return {void}\x0d\x0a     * @method mustMatch\x0d\x0a     */\x0d\x0a    mustMatch: function(tokenTypes) {\x0d\x0a\x0d\x0a        var token;\x0d\x0a\x0d\x0a        //always convert to an array, makes things easier\x0d\x0a        if (!(tokenTypes instanceof Array)) {\x0d\x0a            tokenTypes = [tokenTypes];\x0d\x0a        }\x0d\x0a\x0d\x0a        if (!this.match.apply(this, arguments)) {\x0d\x0a            token = this.LT(1);\x0d\x0a            throw new SyntaxError(\x22Expected \x22 + this._tokenData[tokenTypes[0]].name +\x0d\x0a                \x22 at line \x22 + token.startLine + \x22, col \x22 + token.startCol + \x22.\x22, token.startLine, token.startCol);\x0d\x0a        }\x0d\x0a    },\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Consuming methods\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Keeps reading from the token stream until either one of the specified\x0d\x0a     * token types is found or until the end of the input is reached.\x0d\x0a     * @param {int|int[]} tokenTypes Either a single token type or an array of\x0d\x0a     *      token types that the next token should be. If an array is passed,\x0d\x0a     *      it\x27s assumed that the token must be one of these.\x0d\x0a     * @param {variant} channel (Optional) The channel to read from. If not\x0d\x0a     *      provided, reads from the default (unnamed) channel.\x0d\x0a     * @return {void}\x0d\x0a     * @method advance\x0d\x0a     */\x0d\x0a    advance: function(tokenTypes, channel) {\x0d\x0a\x0d\x0a        while (this.LA(0) !== 0 && !this.match(tokenTypes, channel)) {\x0d\x0a            this.get();\x0d\x0a        }\x0d\x0a\x0d\x0a        return this.LA(0);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Consumes the next token from the token stream.\x0d\x0a     * @return {int} The token type of the token that was just consumed.\x0d\x0a     * @method get\x0d\x0a     */\x0d\x0a    get: function(channel) {\x0d\x0a\x0d\x0a        var tokenInfo   = this._tokenData,\x0d\x0a            i           =0,\x0d\x0a            token,\x0d\x0a            info;\x0d\x0a\x0d\x0a        //check the lookahead buffer first\x0d\x0a        if (this._lt.length && this._ltIndex \x3e= 0 && this._ltIndex \x3c this._lt.length) {\x0d\x0a\x0d\x0a            i++;\x0d\x0a            this._token = this._lt[this._ltIndex++];\x0d\x0a            info = tokenInfo[this._token.type];\x0d\x0a\x0d\x0a            //obey channels logic\x0d\x0a            while ((info.channel !== undefined && channel !== info.channel) &&\x0d\x0a                    this._ltIndex \x3c this._lt.length) {\x0d\x0a                this._token = this._lt[this._ltIndex++];\x0d\x0a                info = tokenInfo[this._token.type];\x0d\x0a                i++;\x0d\x0a            }\x0d\x0a\x0d\x0a            //here be dragons\x0d\x0a            if ((info.channel === undefined || channel === info.channel) &&\x0d\x0a                    this._ltIndex \x3c= this._lt.length) {\x0d\x0a                this._ltIndexCache.push(i);\x0d\x0a                return this._token.type;\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        //call token retriever method\x0d\x0a        token = this._getToken();\x0d\x0a\x0d\x0a        //if it should be hidden, don\x27t save a token\x0d\x0a        if (token.type \x3e -1 && !tokenInfo[token.type].hide) {\x0d\x0a\x0d\x0a            //apply token channel\x0d\x0a            token.channel = tokenInfo[token.type].channel;\x0d\x0a\x0d\x0a            //save for later\x0d\x0a            this._token = token;\x0d\x0a            this._lt.push(token);\x0d\x0a\x0d\x0a            //save space that will be moved (must be done before array is truncated)\x0d\x0a            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);\x0d\x0a\x0d\x0a            //keep the buffer under 5 items\x0d\x0a            if (this._lt.length \x3e 5) {\x0d\x0a                this._lt.shift();\x0d\x0a            }\x0d\x0a\x0d\x0a            //also keep the shift buffer under 5 items\x0d\x0a            if (this._ltIndexCache.length \x3e 5) {\x0d\x0a                this._ltIndexCache.shift();\x0d\x0a            }\x0d\x0a\x0d\x0a            //update lookahead index\x0d\x0a            this._ltIndex = this._lt.length;\x0d\x0a        }\x0d\x0a\x0d\x0a        /*\x0d\x0a         * Skip to the next token if:\x0d\x0a         * 1. The token type is marked as hidden.\x0d\x0a         * 2. The token type has a channel specified and it isn\x27t the current channel.\x0d\x0a         */\x0d\x0a        info = tokenInfo[token.type];\x0d\x0a        if (info &&\x0d\x0a                (info.hide ||\x0d\x0a                (info.channel !== undefined && channel !== info.channel))) {\x0d\x0a            return this.get(channel);\x0d\x0a        } else {\x0d\x0a            //return just the type\x0d\x0a            return token.type;\x0d\x0a        }\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Looks ahead a certain number of tokens and returns the token type at\x0d\x0a     * that position. This will throw an error if you lookahead past the\x0d\x0a     * end of input, past the size of the lookahead buffer, or back past\x0d\x0a     * the first token in the lookahead buffer.\x0d\x0a     * @param {int} The index of the token type to retrieve. 0 for the\x0d\x0a     *      current token, 1 for the next, -1 for the previous, etc.\x0d\x0a     * @return {int} The token type of the token in the given position.\x0d\x0a     * @method LA\x0d\x0a     */\x0d\x0a    LA: function(index) {\x0d\x0a        var total = index,\x0d\x0a            tt;\x0d\x0a        if (index \x3e 0) {\x0d\x0a            //TODO: Store 5 somewhere\x0d\x0a            if (index \x3e 5) {\x0d\x0a                throw new Error(\x22Too much lookahead.\x22);\x0d\x0a            }\x0d\x0a\x0d\x0a            //get all those tokens\x0d\x0a            while (total) {\x0d\x0a                tt = this.get();\x0d\x0a                total--;\x0d\x0a            }\x0d\x0a\x0d\x0a            //unget all those tokens\x0d\x0a            while (total \x3c index) {\x0d\x0a                this.unget();\x0d\x0a                total++;\x0d\x0a            }\x0d\x0a        } else if (index \x3c 0) {\x0d\x0a\x0d\x0a            if (this._lt[this._ltIndex+index]) {\x0d\x0a                tt = this._lt[this._ltIndex+index].type;\x0d\x0a            } else {\x0d\x0a                throw new Error(\x22Too much lookbehind.\x22);\x0d\x0a            }\x0d\x0a\x0d\x0a        } else {\x0d\x0a            tt = this._token.type;\x0d\x0a        }\x0d\x0a\x0d\x0a        return tt;\x0d\x0a\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Looks ahead a certain number of tokens and returns the token at\x0d\x0a     * that position. This will throw an error if you lookahead past the\x0d\x0a     * end of input, past the size of the lookahead buffer, or back past\x0d\x0a     * the first token in the lookahead buffer.\x0d\x0a     * @param {int} The index of the token type to retrieve. 0 for the\x0d\x0a     *      current token, 1 for the next, -1 for the previous, etc.\x0d\x0a     * @return {Object} The token of the token in the given position.\x0d\x0a     * @method LA\x0d\x0a     */\x0d\x0a    LT: function(index) {\x0d\x0a\x0d\x0a        //lookahead first to prime the token buffer\x0d\x0a        this.LA(index);\x0d\x0a\x0d\x0a        //now find the token, subtract one because _ltIndex is already at the next index\x0d\x0a        return this._lt[this._ltIndex+index-1];\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns the token type for the next token in the stream without\x0d\x0a     * consuming it.\x0d\x0a     * @return {int} The token type of the next token in the stream.\x0d\x0a     * @method peek\x0d\x0a     */\x0d\x0a    peek: function() {\x0d\x0a        return this.LA(1);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns the actual token object for the last consumed token.\x0d\x0a     * @return {Token} The token object for the last consumed token.\x0d\x0a     * @method token\x0d\x0a     */\x0d\x0a    token: function() {\x0d\x0a        return this._token;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns the name of the token for the given token type.\x0d\x0a     * @param {int} tokenType The type of token to get the name of.\x0d\x0a     * @return {String} The name of the token or \x22UNKNOWN_TOKEN\x22 for any\x0d\x0a     *      invalid token type.\x0d\x0a     * @method tokenName\x0d\x0a     */\x0d\x0a    tokenName: function(tokenType) {\x0d\x0a        if (tokenType \x3c 0 || tokenType \x3e this._tokenData.length) {\x0d\x0a            return \x22UNKNOWN_TOKEN\x22;\x0d\x0a        } else {\x0d\x0a            return this._tokenData[tokenType].name;\x0d\x0a        }\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns the token type value for the given token name.\x0d\x0a     * @param {String} tokenName The name of the token whose value should be returned.\x0d\x0a     * @return {int} The token type value for the given token name or -1\x0d\x0a     *      for an unknown token.\x0d\x0a     * @method tokenName\x0d\x0a     */\x0d\x0a    tokenType: function(tokenName) {\x0d\x0a        return this._tokenData[tokenName] || -1;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns the last consumed token to the token stream.\x0d\x0a     * @method unget\x0d\x0a     */\x0d\x0a    unget: function() {\x0d\x0a        //if (this._ltIndex \x3e -1) {\x0d\x0a        if (this._ltIndexCache.length) {\x0d\x0a            this._ltIndex -= this._ltIndexCache.pop();//--;\x0d\x0a            this._token = this._lt[this._ltIndex - 1];\x0d\x0a        } else {\x0d\x0a            throw new Error(\x22Too much lookahead.\x22);\x0d\x0a        }\x0d\x0a    }\x0d\x0a\x0d\x0a};\x0d\x0a\x0d\x0a\x0d\x0a},{\x22./StringReader\x22:24,\x22./SyntaxError\x22:25}],28:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = {\x0d\x0a    StringReader    : require(\x22./StringReader\x22),\x0d\x0a    SyntaxError     : require(\x22./SyntaxError\x22),\x0d\x0a    SyntaxUnit      : require(\x22./SyntaxUnit\x22),\x0d\x0a    EventTarget     : require(\x22./EventTarget\x22),\x0d\x0a    TokenStreamBase : require(\x22./TokenStreamBase\x22)\x0d\x0a};\x0d\x0a\x0d\x0a},{\x22./EventTarget\x22:23,\x22./StringReader\x22:24,\x22./SyntaxError\x22:25,\x22./SyntaxUnit\x22:26,\x22./TokenStreamBase\x22:27}],\x22parserlib\x22:[function(require,module,exports){\x0d\x0a\x22use strict\x22;\x0d\x0a\x0d\x0amodule.exports = {\x0d\x0a    css  : require(\x22./css\x22),\x0d\x0a    util : require(\x22./util\x22)\x0d\x0a};\x0d\x0a\x0d\x0a},{\x22./css\x22:22,\x22./util\x22:28}]},{},[]);\x0d\x0a\x0d\x0areturn require(\x27parserlib\x27);\x0d\x0a})();\x0d\x0avar clone = (function() {\x0d\x0a\x27use strict\x27;\x0d\x0a\x0d\x0avar nativeMap;\x0d\x0atry {\x0d\x0a  nativeMap = Map;\x0d\x0a} catch(_) {\x0d\x0a  // maybe a reference error because no `Map`. Give it a dummy value that no\x0d\x0a  // value will ever be an instanceof.\x0d\x0a  nativeMap = function() {};\x0d\x0a}\x0d\x0a\x0d\x0avar nativeSet;\x0d\x0atry {\x0d\x0a  nativeSet = Set;\x0d\x0a} catch(_) {\x0d\x0a  nativeSet = function() {};\x0d\x0a}\x0d\x0a\x0d\x0avar nativePromise;\x0d\x0atry {\x0d\x0a  nativePromise = Promise;\x0d\x0a} catch(_) {\x0d\x0a  nativePromise = function() {};\x0d\x0a}\x0d\x0a\x0d\x0a/**\x0d\x0a * Clones (copies) an Object using deep copying.\x0d\x0a *\x0d\x0a * This function supports circular references by default, but if you are certain\x0d\x0a * there are no circular references in your object, you can save some CPU time\x0d\x0a * by calling clone(obj, false).\x0d\x0a *\x0d\x0a * Caution: if `circular` is false and `parent` contains circular references,\x0d\x0a * your program may enter an infinite loop and crash.\x0d\x0a *\x0d\x0a * @param `parent` - the object to be cloned\x0d\x0a * @param `circular` - set to true if the object to be cloned may contain\x0d\x0a *    circular references. (optional - true by default)\x0d\x0a * @param `depth` - set to a number if the object is only to be cloned to\x0d\x0a *    a particular depth. (optional - defaults to Infinity)\x0d\x0a * @param `prototype` - sets the prototype to be used when cloning an object.\x0d\x0a *    (optional - defaults to parent prototype).\x0d\x0a * @param `includeNonEnumerable` - set to true if the non-enumerable properties\x0d\x0a *    should be cloned as well. Non-enumerable properties on the prototype\x0d\x0a *    chain will be ignored. (optional - false by default)\x0d\x0a*/\x0d\x0afunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\x0d\x0a  if (typeof circular === \x27object\x27) {\x0d\x0a    depth = circular.depth;\x0d\x0a    prototype = circular.prototype;\x0d\x0a    includeNonEnumerable = circular.includeNonEnumerable;\x0d\x0a    circular = circular.circular;\x0d\x0a  }\x0d\x0a  // maintain two arrays for circular references, where corresponding parents\x0d\x0a  // and children have the same index\x0d\x0a  var allParents = [];\x0d\x0a  var allChildren = [];\x0d\x0a\x0d\x0a  var useBuffer = typeof Buffer != \x27undefined\x27;\x0d\x0a\x0d\x0a  if (typeof circular == \x27undefined\x27)\x0d\x0a    circular = true;\x0d\x0a\x0d\x0a  if (typeof depth == \x27undefined\x27)\x0d\x0a    depth = Infinity;\x0d\x0a\x0d\x0a  // recurse this function so we don\x27t reset allParents and allChildren\x0d\x0a  function _clone(parent, depth) {\x0d\x0a    // cloning null always returns null\x0d\x0a    if (parent === null)\x0d\x0a      return null;\x0d\x0a\x0d\x0a    if (depth === 0)\x0d\x0a      return parent;\x0d\x0a\x0d\x0a    var child;\x0d\x0a    var proto;\x0d\x0a    if (typeof parent != \x27object\x27) {\x0d\x0a      return parent;\x0d\x0a    }\x0d\x0a\x0d\x0a    if (parent instanceof nativeMap) {\x0d\x0a      child = new nativeMap();\x0d\x0a    } else if (parent instanceof nativeSet) {\x0d\x0a      child = new nativeSet();\x0d\x0a    } else if (parent instanceof nativePromise) {\x0d\x0a      child = new nativePromise(function (resolve, reject) {\x0d\x0a        parent.then(function(value) {\x0d\x0a          resolve(_clone(value, depth - 1));\x0d\x0a        }, function(err) {\x0d\x0a          reject(_clone(err, depth - 1));\x0d\x0a        });\x0d\x0a      });\x0d\x0a    } else if (clone.__isArray(parent)) {\x0d\x0a      child = [];\x0d\x0a    } else if (clone.__isRegExp(parent)) {\x0d\x0a      child = new RegExp(parent.source, __getRegExpFlags(parent));\x0d\x0a      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\x0d\x0a    } else if (clone.__isDate(parent)) {\x0d\x0a      child = new Date(parent.getTime());\x0d\x0a    } else if (useBuffer && Buffer.isBuffer(parent)) {\x0d\x0a      child = new Buffer(parent.length);\x0d\x0a      parent.copy(child);\x0d\x0a      return child;\x0d\x0a    } else if (parent instanceof Error) {\x0d\x0a      child = Object.create(parent);\x0d\x0a    } else {\x0d\x0a      if (typeof prototype == \x27undefined\x27) {\x0d\x0a        proto = Object.getPrototypeOf(parent);\x0d\x0a        child = Object.create(proto);\x0d\x0a      }\x0d\x0a      else {\x0d\x0a        child = Object.create(prototype);\x0d\x0a        proto = prototype;\x0d\x0a      }\x0d\x0a    }\x0d\x0a\x0d\x0a    if (circular) {\x0d\x0a      var index = allParents.indexOf(parent);\x0d\x0a\x0d\x0a      if (index != -1) {\x0d\x0a        return allChildren[index];\x0d\x0a      }\x0d\x0a      allParents.push(parent);\x0d\x0a      allChildren.push(child);\x0d\x0a    }\x0d\x0a\x0d\x0a    if (parent instanceof nativeMap) {\x0d\x0a      var keyIterator = parent.keys();\x0d\x0a      while(true) {\x0d\x0a        var next = keyIterator.next();\x0d\x0a        if (next.done) {\x0d\x0a          break;\x0d\x0a        }\x0d\x0a        var keyChild = _clone(next.value, depth - 1);\x0d\x0a        var valueChild = _clone(parent.get(next.value), depth - 1);\x0d\x0a        child.set(keyChild, valueChild);\x0d\x0a      }\x0d\x0a    }\x0d\x0a    if (parent instanceof nativeSet) {\x0d\x0a      var iterator = parent.keys();\x0d\x0a      while(true) {\x0d\x0a        var next = iterator.next();\x0d\x0a        if (next.done) {\x0d\x0a          break;\x0d\x0a        }\x0d\x0a        var entryChild = _clone(next.value, depth - 1);\x0d\x0a        child.add(entryChild);\x0d\x0a      }\x0d\x0a    }\x0d\x0a\x0d\x0a    for (var i in parent) {\x0d\x0a      var attrs;\x0d\x0a      if (proto) {\x0d\x0a        attrs = Object.getOwnPropertyDescriptor(proto, i);\x0d\x0a      }\x0d\x0a\x0d\x0a      if (attrs && attrs.set == null) {\x0d\x0a        continue;\x0d\x0a      }\x0d\x0a      child[i] = _clone(parent[i], depth - 1);\x0d\x0a    }\x0d\x0a\x0d\x0a    if (Object.getOwnPropertySymbols) {\x0d\x0a      var symbols = Object.getOwnPropertySymbols(parent);\x0d\x0a      for (var i = 0; i \x3c symbols.length; i++) {\x0d\x0a        // Don\x27t need to worry about cloning a symbol because it is a primitive,\x0d\x0a        // like a number or string.\x0d\x0a        var symbol = symbols[i];\x0d\x0a        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\x0d\x0a        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\x0d\x0a          continue;\x0d\x0a        }\x0d\x0a        child[symbol] = _clone(parent[symbol], depth - 1);\x0d\x0a        if (!descriptor.enumerable) {\x0d\x0a          Object.defineProperty(child, symbol, {\x0d\x0a            enumerable: false\x0d\x0a          });\x0d\x0a        }\x0d\x0a      }\x0d\x0a    }\x0d\x0a\x0d\x0a    if (includeNonEnumerable) {\x0d\x0a      var allPropertyNames = Object.getOwnPropertyNames(parent);\x0d\x0a      for (var i = 0; i \x3c allPropertyNames.length; i++) {\x0d\x0a        var propertyName = allPropertyNames[i];\x0d\x0a        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\x0d\x0a        if (descriptor && descriptor.enumerable) {\x0d\x0a          continue;\x0d\x0a        }\x0d\x0a        child[propertyName] = _clone(parent[propertyName], depth - 1);\x0d\x0a        Object.defineProperty(child, propertyName, {\x0d\x0a          enumerable: false\x0d\x0a        });\x0d\x0a      }\x0d\x0a    }\x0d\x0a\x0d\x0a    return child;\x0d\x0a  }\x0d\x0a\x0d\x0a  return _clone(parent, depth);\x0d\x0a}\x0d\x0a\x0d\x0a/**\x0d\x0a * Simple flat clone using prototype, accepts only objects, usefull for property\x0d\x0a * override on FLAT configuration object (no nested props).\x0d\x0a *\x0d\x0a * USE WITH CAUTION! This may not behave as you wish if you do not know how this\x0d\x0a * works.\x0d\x0a */\x0d\x0aclone.clonePrototype = function clonePrototype(parent) {\x0d\x0a  if (parent === null)\x0d\x0a    return null;\x0d\x0a\x0d\x0a  var c = function () {};\x0d\x0a  c.prototype = parent;\x0d\x0a  return new c();\x0d\x0a};\x0d\x0a\x0d\x0a// private utility functions\x0d\x0a\x0d\x0afunction __objToStr(o) {\x0d\x0a  return Object.prototype.toString.call(o);\x0d\x0a}\x0d\x0aclone.__objToStr = __objToStr;\x0d\x0a\x0d\x0afunction __isDate(o) {\x0d\x0a  return typeof o === \x27object\x27 && __objToStr(o) === \x27[object Date]\x27;\x0d\x0a}\x0d\x0aclone.__isDate = __isDate;\x0d\x0a\x0d\x0afunction __isArray(o) {\x0d\x0a  return typeof o === \x27object\x27 && __objToStr(o) === \x27[object Array]\x27;\x0d\x0a}\x0d\x0aclone.__isArray = __isArray;\x0d\x0a\x0d\x0afunction __isRegExp(o) {\x0d\x0a  return typeof o === \x27object\x27 && __objToStr(o) === \x27[object RegExp]\x27;\x0d\x0a}\x0d\x0aclone.__isRegExp = __isRegExp;\x0d\x0a\x0d\x0afunction __getRegExpFlags(re) {\x0d\x0a  var flags = \x27\x27;\x0d\x0a  if (re.global) flags += \x27g\x27;\x0d\x0a  if (re.ignoreCase) flags += \x27i\x27;\x0d\x0a  if (re.multiline) flags += \x27m\x27;\x0d\x0a  return flags;\x0d\x0a}\x0d\x0aclone.__getRegExpFlags = __getRegExpFlags;\x0d\x0a\x0d\x0areturn clone;\x0d\x0a})();\x0d\x0a\x0d\x0aif (typeof module === \x27object\x27 && module.exports) {\x0d\x0a  module.exports = clone;\x0d\x0a}\x0d\x0a\x0d\x0a/**\x0d\x0a * Main CSSLint object.\x0d\x0a * @class CSSLint\x0d\x0a * @static\x0d\x0a * @extends parserlib.util.EventTarget\x0d\x0a */\x0d\x0a\x0d\x0a/* global parserlib, clone, Reporter */\x0d\x0a/* exported CSSLint */\x0d\x0a\x0d\x0avar CSSLint = (function() {\x0d\x0a    \x22use strict\x22;\x0d\x0a\x0d\x0a    var rules           = [],\x0d\x0a        formatters      = [],\x0d\x0a        embeddedRuleset = /\x5c/\x5c*\x5cs*csslint([^\x5c*]*)\x5c*\x5c//,\x0d\x0a        api             = new parserlib.util.EventTarget();\x0d\x0a\x0d\x0a    api.version = \x221.0.4\x22;\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Rule Management\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Adds a new rule to the engine.\x0d\x0a     * @param {Object} rule The rule to add.\x0d\x0a     * @method addRule\x0d\x0a     */\x0d\x0a    api.addRule = function(rule) {\x0d\x0a        rules.push(rule);\x0d\x0a        rules[rule.id] = rule;\x0d\x0a    };\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Clears all rule from the engine.\x0d\x0a     * @method clearRules\x0d\x0a     */\x0d\x0a    api.clearRules = function() {\x0d\x0a        rules = [];\x0d\x0a    };\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns the rule objects.\x0d\x0a     * @return An array of rule objects.\x0d\x0a     * @method getRules\x0d\x0a     */\x0d\x0a    api.getRules = function() {\x0d\x0a        return [].concat(rules).sort(function(a, b) {\x0d\x0a            return a.id \x3e b.id ? 1 : 0;\x0d\x0a        });\x0d\x0a    };\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns a ruleset configuration object with all current rules.\x0d\x0a     * @return A ruleset object.\x0d\x0a     * @method getRuleset\x0d\x0a     */\x0d\x0a    api.getRuleset = function() {\x0d\x0a        var ruleset = {},\x0d\x0a            i = 0,\x0d\x0a            len = rules.length;\x0d\x0a\x0d\x0a        while (i \x3c len) {\x0d\x0a            ruleset[rules[i++].id] = 1;    // by default, everything is a warning\x0d\x0a        }\x0d\x0a\x0d\x0a        return ruleset;\x0d\x0a    };\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Returns a ruleset object based on embedded rules.\x0d\x0a     * @param {String} text A string of css containing embedded rules.\x0d\x0a     * @param {Object} ruleset A ruleset object to modify.\x0d\x0a     * @return {Object} A ruleset object.\x0d\x0a     * @method getEmbeddedRuleset\x0d\x0a     */\x0d\x0a    function applyEmbeddedRuleset(text, ruleset) {\x0d\x0a        var valueMap,\x0d\x0a            embedded = text && text.match(embeddedRuleset),\x0d\x0a            rules = embedded && embedded[1];\x0d\x0a\x0d\x0a        if (rules) {\x0d\x0a            valueMap = {\x0d\x0a                \x22true\x22: 2,  // true is error\x0d\x0a                \x22\x22: 1,      // blank is warning\x0d\x0a                \x22false\x22: 0, // false is ignore\x0d\x0a\x0d\x0a                \x222\x22: 2,     // explicit error\x0d\x0a                \x221\x22: 1,     // explicit warning\x0d\x0a                \x220\x22: 0      // explicit ignore\x0d\x0a            };\x0d\x0a\x0d\x0a            rules.toLowerCase().split(\x22,\x22).forEach(function(rule) {\x0d\x0a                var pair = rule.split(\x22:\x22),\x0d\x0a                    property = pair[0] || \x22\x22,\x0d\x0a                    value = pair[1] || \x22\x22;\x0d\x0a\x0d\x0a                ruleset[property.trim()] = valueMap[value.trim()];\x0d\x0a            });\x0d\x0a        }\x0d\x0a\x0d\x0a        return ruleset;\x0d\x0a    }\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Formatters\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Adds a new formatter to the engine.\x0d\x0a     * @param {Object} formatter The formatter to add.\x0d\x0a     * @method addFormatter\x0d\x0a     */\x0d\x0a    api.addFormatter = function(formatter) {\x0d\x0a        // formatters.push(formatter);\x0d\x0a        formatters[formatter.id] = formatter;\x0d\x0a    };\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Retrieves a formatter for use.\x0d\x0a     * @param {String} formatId The name of the format to retrieve.\x0d\x0a     * @return {Object} The formatter or undefined.\x0d\x0a     * @method getFormatter\x0d\x0a     */\x0d\x0a    api.getFormatter = function(formatId) {\x0d\x0a        return formatters[formatId];\x0d\x0a    };\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Formats the results in a particular format for a single file.\x0d\x0a     * @param {Object} result The results returned from CSSLint.verify().\x0d\x0a     * @param {String} filename The filename for which the results apply.\x0d\x0a     * @param {String} formatId The name of the formatter to use.\x0d\x0a     * @param {Object} options (Optional) for special output handling.\x0d\x0a     * @return {String} A formatted string for the results.\x0d\x0a     * @method format\x0d\x0a     */\x0d\x0a    api.format = function(results, filename, formatId, options) {\x0d\x0a        var formatter = this.getFormatter(formatId),\x0d\x0a            result = null;\x0d\x0a\x0d\x0a        if (formatter) {\x0d\x0a            result = formatter.startFormat();\x0d\x0a            result += formatter.formatResults(results, filename, options || {});\x0d\x0a            result += formatter.endFormat();\x0d\x0a        }\x0d\x0a\x0d\x0a        return result;\x0d\x0a    };\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Indicates if the given format is supported.\x0d\x0a     * @param {String} formatId The ID of the format to check.\x0d\x0a     * @return {Boolean} True if the format exists, false if not.\x0d\x0a     * @method hasFormat\x0d\x0a     */\x0d\x0a    api.hasFormat = function(formatId) {\x0d\x0a        return formatters.hasOwnProperty(formatId);\x0d\x0a    };\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Verification\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Starts the verification process for the given CSS text.\x0d\x0a     * @param {String} text The CSS text to verify.\x0d\x0a     * @param {Object} ruleset (Optional) List of rules to apply. If null, then\x0d\x0a     *      all rules are used. If a rule has a value of 1 then it\x27s a warning,\x0d\x0a     *      a value of 2 means it\x27s an error.\x0d\x0a     * @return {Object} Results of the verification.\x0d\x0a     * @method verify\x0d\x0a     */\x0d\x0a    api.verify = function(text, ruleset) {\x0d\x0a\x0d\x0a        var i = 0,\x0d\x0a            reporter,\x0d\x0a            lines,\x0d\x0a            allow = {},\x0d\x0a            ignore = [],\x0d\x0a            report,\x0d\x0a            parser = new parserlib.css.Parser({\x0d\x0a                starHack: true,\x0d\x0a                ieFilters: true,\x0d\x0a                underscoreHack: true,\x0d\x0a                strict: false\x0d\x0a            });\x0d\x0a\x0d\x0a        // normalize line endings\x0d\x0a        lines = text.replace(/\x5cn\x5cr?/g, \x22$split$\x22).split(\x22$split$\x22);\x0d\x0a\x0d\x0a        // find \x27allow\x27 comments\x0d\x0a        CSSLint.Util.forEach(lines, function (line, lineno) {\x0d\x0a            var allowLine = line && line.match(/\x5c/\x5c*[ \x5ct]*csslint[ \x5ct]+allow:[ \x5ct]*([^\x5c*]*)\x5c*\x5c//i),\x0d\x0a                allowRules = allowLine && allowLine[1],\x0d\x0a                allowRuleset = {};\x0d\x0a\x0d\x0a            if (allowRules) {\x0d\x0a                allowRules.toLowerCase().split(\x22,\x22).forEach(function(allowRule) {\x0d\x0a                    allowRuleset[allowRule.trim()] = true;\x0d\x0a                });\x0d\x0a                if (Object.keys(allowRuleset).length \x3e 0) {\x0d\x0a                    allow[lineno + 1] = allowRuleset;\x0d\x0a                }\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        var ignoreStart = null,\x0d\x0a            ignoreEnd = null;\x0d\x0a        CSSLint.Util.forEach(lines, function (line, lineno) {\x0d\x0a            // Keep oldest, \x22unclosest\x22 ignore:start\x0d\x0a            if (ignoreStart === null && line.match(/\x5c/\x5c*[ \x5ct]*csslint[ \x5ct]+ignore:start[ \x5ct]*\x5c*\x5c//i)) {\x0d\x0a                ignoreStart = lineno;\x0d\x0a            }\x0d\x0a\x0d\x0a            if (line.match(/\x5c/\x5c*[ \x5ct]*csslint[ \x5ct]+ignore:end[ \x5ct]*\x5c*\x5c//i)) {\x0d\x0a                ignoreEnd = lineno;\x0d\x0a            }\x0d\x0a\x0d\x0a            if (ignoreStart !== null && ignoreEnd !== null) {\x0d\x0a                ignore.push([ignoreStart, ignoreEnd]);\x0d\x0a                ignoreStart = ignoreEnd = null;\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        // Close remaining ignore block, if any\x0d\x0a        if (ignoreStart !== null) {\x0d\x0a            ignore.push([ignoreStart, lines.length]);\x0d\x0a        }\x0d\x0a\x0d\x0a        if (!ruleset) {\x0d\x0a            ruleset = this.getRuleset();\x0d\x0a        }\x0d\x0a\x0d\x0a        if (embeddedRuleset.test(text)) {\x0d\x0a            // defensively copy so that caller\x27s version does not get modified\x0d\x0a            ruleset = clone(ruleset);\x0d\x0a            ruleset = applyEmbeddedRuleset(text, ruleset);\x0d\x0a        }\x0d\x0a\x0d\x0a        reporter = new Reporter(lines, ruleset, allow, ignore);\x0d\x0a\x0d\x0a        ruleset.errors = 2;       // always report parsing errors as errors\x0d\x0a        for (i in ruleset) {\x0d\x0a            if (ruleset.hasOwnProperty(i) && ruleset[i]) {\x0d\x0a                if (rules[i]) {\x0d\x0a                    rules[i].init(parser, reporter);\x0d\x0a                }\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a\x0d\x0a        // capture most horrible error type\x0d\x0a        try {\x0d\x0a            parser.parse(text);\x0d\x0a        } catch (ex) {\x0d\x0a            reporter.error(\x22Fatal error, cannot continue: \x22 + ex.message, ex.line, ex.col, {});\x0d\x0a        }\x0d\x0a\x0d\x0a        report = {\x0d\x0a            messages    : reporter.messages,\x0d\x0a            stats       : reporter.stats,\x0d\x0a            ruleset     : reporter.ruleset,\x0d\x0a            allow       : reporter.allow,\x0d\x0a            ignore      : reporter.ignore\x0d\x0a        };\x0d\x0a\x0d\x0a        // sort by line numbers, rollups at the bottom\x0d\x0a        report.messages.sort(function (a, b) {\x0d\x0a            if (a.rollup && !b.rollup) {\x0d\x0a                return 1;\x0d\x0a            } else if (!a.rollup && b.rollup) {\x0d\x0a                return -1;\x0d\x0a            } else {\x0d\x0a                return a.line - b.line;\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        return report;\x0d\x0a    };\x0d\x0a\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a    // Publish the API\x0d\x0a    //-------------------------------------------------------------------------\x0d\x0a\x0d\x0a    return api;\x0d\x0a\x0d\x0a})();\x0d\x0a\x0d\x0a/**\x0d\x0a * An instance of Report is used to report results of the\x0d\x0a * verification back to the main API.\x0d\x0a * @class Reporter\x0d\x0a * @constructor\x0d\x0a * @param {String[]} lines The text lines of the source.\x0d\x0a * @param {Object} ruleset The set of rules to work with, including if\x0d\x0a *      they are errors or warnings.\x0d\x0a * @param {Object} explicitly allowed lines\x0d\x0a * @param {[][]} ingore list of line ranges to be ignored\x0d\x0a */\x0d\x0afunction Reporter(lines, ruleset, allow, ignore) {\x0d\x0a    \x22use strict\x22;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * List of messages being reported.\x0d\x0a     * @property messages\x0d\x0a     * @type String[]\x0d\x0a     */\x0d\x0a    this.messages = [];\x0d\x0a\x0d\x0a    /**\x0d\x0a     * List of statistics being reported.\x0d\x0a     * @property stats\x0d\x0a     * @type String[]\x0d\x0a     */\x0d\x0a    this.stats = [];\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Lines of code being reported on. Used to provide contextual information\x0d\x0a     * for messages.\x0d\x0a     * @property lines\x0d\x0a     * @type String[]\x0d\x0a     */\x0d\x0a    this.lines = lines;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Information about the rules. Used to determine whether an issue is an\x0d\x0a     * error or warning.\x0d\x0a     * @property ruleset\x0d\x0a     * @type Object\x0d\x0a     */\x0d\x0a    this.ruleset = ruleset;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Lines with specific rule messages to leave out of the report.\x0d\x0a     * @property allow\x0d\x0a     * @type Object\x0d\x0a     */\x0d\x0a    this.allow = allow;\x0d\x0a    if (!this.allow) {\x0d\x0a        this.allow = {};\x0d\x0a    }\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Linesets not to include in the report.\x0d\x0a     * @property ignore\x0d\x0a     * @type [][]\x0d\x0a     */\x0d\x0a    this.ignore = ignore;\x0d\x0a    if (!this.ignore) {\x0d\x0a        this.ignore = [];\x0d\x0a    }\x0d\x0a}\x0d\x0a\x0d\x0aReporter.prototype = {\x0d\x0a\x0d\x0a    // restore constructor\x0d\x0a    constructor: Reporter,\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Report an error.\x0d\x0a     * @param {String} message The message to store.\x0d\x0a     * @param {int} line The line number.\x0d\x0a     * @param {int} col The column number.\x0d\x0a     * @param {Object} rule The rule this message relates to.\x0d\x0a     * @method error\x0d\x0a     */\x0d\x0a    error: function(message, line, col, rule) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        this.messages.push({\x0d\x0a            type    : \x22error\x22,\x0d\x0a            line    : line,\x0d\x0a            col     : col,\x0d\x0a            message : message,\x0d\x0a            evidence: this.lines[line-1],\x0d\x0a            rule    : rule || {}\x0d\x0a        });\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Report an warning.\x0d\x0a     * @param {String} message The message to store.\x0d\x0a     * @param {int} line The line number.\x0d\x0a     * @param {int} col The column number.\x0d\x0a     * @param {Object} rule The rule this message relates to.\x0d\x0a     * @method warn\x0d\x0a     * @deprecated Use report instead.\x0d\x0a     */\x0d\x0a    warn: function(message, line, col, rule) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        this.report(message, line, col, rule);\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Report an issue.\x0d\x0a     * @param {String} message The message to store.\x0d\x0a     * @param {int} line The line number.\x0d\x0a     * @param {int} col The column number.\x0d\x0a     * @param {Object} rule The rule this message relates to.\x0d\x0a     * @method report\x0d\x0a     */\x0d\x0a    report: function(message, line, col, rule) {\x0d\x0a        \x22use strict\x22;\x0d\x0a\x0d\x0a        // Check if rule violation should be allowed\x0d\x0a        if (this.allow.hasOwnProperty(line) && this.allow[line].hasOwnProperty(rule.id)) {\x0d\x0a            return;\x0d\x0a        }\x0d\x0a\x0d\x0a        var ignore = false;\x0d\x0a        CSSLint.Util.forEach(this.ignore, function (range) {\x0d\x0a            if (range[0] \x3c= line && line \x3c= range[1]) {\x0d\x0a                ignore = true;\x0d\x0a            }\x0d\x0a        });\x0d\x0a        if (ignore) {\x0d\x0a            return;\x0d\x0a        }\x0d\x0a\x0d\x0a        this.messages.push({\x0d\x0a            type    : this.ruleset[rule.id] === 2 ? \x22error\x22 : \x22warning\x22,\x0d\x0a            line    : line,\x0d\x0a            col     : col,\x0d\x0a            message : message,\x0d\x0a            evidence: this.lines[line-1],\x0d\x0a            rule    : rule\x0d\x0a        });\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Report some informational text.\x0d\x0a     * @param {String} message The message to store.\x0d\x0a     * @param {int} line The line number.\x0d\x0a     * @param {int} col The column number.\x0d\x0a     * @param {Object} rule The rule this message relates to.\x0d\x0a     * @method info\x0d\x0a     */\x0d\x0a    info: function(message, line, col, rule) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        this.messages.push({\x0d\x0a            type    : \x22info\x22,\x0d\x0a            line    : line,\x0d\x0a            col     : col,\x0d\x0a            message : message,\x0d\x0a            evidence: this.lines[line-1],\x0d\x0a            rule    : rule\x0d\x0a        });\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Report some rollup error information.\x0d\x0a     * @param {String} message The message to store.\x0d\x0a     * @param {Object} rule The rule this message relates to.\x0d\x0a     * @method rollupError\x0d\x0a     */\x0d\x0a    rollupError: function(message, rule) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        this.messages.push({\x0d\x0a            type    : \x22error\x22,\x0d\x0a            rollup  : true,\x0d\x0a            message : message,\x0d\x0a            rule    : rule\x0d\x0a        });\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Report some rollup warning information.\x0d\x0a     * @param {String} message The message to store.\x0d\x0a     * @param {Object} rule The rule this message relates to.\x0d\x0a     * @method rollupWarn\x0d\x0a     */\x0d\x0a    rollupWarn: function(message, rule) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        this.messages.push({\x0d\x0a            type    : \x22warning\x22,\x0d\x0a            rollup  : true,\x0d\x0a            message : message,\x0d\x0a            rule    : rule\x0d\x0a        });\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Report a statistic.\x0d\x0a     * @param {String} name The name of the stat to store.\x0d\x0a     * @param {Variant} value The value of the stat.\x0d\x0a     * @method stat\x0d\x0a     */\x0d\x0a    stat: function(name, value) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        this.stats[name] = value;\x0d\x0a    }\x0d\x0a};\x0d\x0a\x0d\x0a// expose for testing purposes\x0d\x0aCSSLint._Reporter = Reporter;\x0d\x0a\x0d\x0a/*\x0d\x0a * Utility functions that make life easier.\x0d\x0a */\x0d\x0aCSSLint.Util = {\x0d\x0a    /*\x0d\x0a     * Adds all properties from supplier onto receiver,\x0d\x0a     * overwriting if the same name already exists on\x0d\x0a     * receiver.\x0d\x0a     * @param {Object} The object to receive the properties.\x0d\x0a     * @param {Object} The object to provide the properties.\x0d\x0a     * @return {Object} The receiver\x0d\x0a     */\x0d\x0a    mix: function(receiver, supplier) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var prop;\x0d\x0a\x0d\x0a        for (prop in supplier) {\x0d\x0a            if (supplier.hasOwnProperty(prop)) {\x0d\x0a                receiver[prop] = supplier[prop];\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        return prop;\x0d\x0a    },\x0d\x0a\x0d\x0a    /*\x0d\x0a     * Polyfill for array indexOf() method.\x0d\x0a     * @param {Array} values The array to search.\x0d\x0a     * @param {Variant} value The value to search for.\x0d\x0a     * @return {int} The index of the value if found, -1 if not.\x0d\x0a     */\x0d\x0a    indexOf: function(values, value) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        if (values.indexOf) {\x0d\x0a            return values.indexOf(value);\x0d\x0a        } else {\x0d\x0a            for (var i=0, len=values.length; i \x3c len; i++) {\x0d\x0a                if (values[i] === value) {\x0d\x0a                    return i;\x0d\x0a                }\x0d\x0a            }\x0d\x0a            return -1;\x0d\x0a        }\x0d\x0a    },\x0d\x0a\x0d\x0a    /*\x0d\x0a     * Polyfill for array forEach() method.\x0d\x0a     * @param {Array} values The array to operate on.\x0d\x0a     * @param {Function} func The function to call on each item.\x0d\x0a     * @return {void}\x0d\x0a     */\x0d\x0a    forEach: function(values, func) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        if (values.forEach) {\x0d\x0a            return values.forEach(func);\x0d\x0a        } else {\x0d\x0a            for (var i=0, len=values.length; i \x3c len; i++) {\x0d\x0a                func(values[i], i, values);\x0d\x0a            }\x0d\x0a        }\x0d\x0a    }\x0d\x0a};\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Don\x27t use adjoining classes (.foo.bar).\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22adjoining-classes\x22,\x0d\x0a    name: \x22Disallow adjoining classes\x22,\x0d\x0a    desc: \x22Don\x27t use adjoining classes.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-adjoining-classes\x22,\x0d\x0a    browsers: \x22IE6\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a        parser.addListener(\x22startrule\x22, function(event) {\x0d\x0a            var selectors = event.selectors,\x0d\x0a                selector,\x0d\x0a                part,\x0d\x0a                modifier,\x0d\x0a                classCount,\x0d\x0a                i, j, k;\x0d\x0a\x0d\x0a            for (i=0; i \x3c selectors.length; i++) {\x0d\x0a                selector = selectors[i];\x0d\x0a                for (j=0; j \x3c selector.parts.length; j++) {\x0d\x0a                    part = selector.parts[j];\x0d\x0a                    if (part.type === parser.SELECTOR_PART_TYPE) {\x0d\x0a                        classCount = 0;\x0d\x0a                        for (k=0; k \x3c part.modifiers.length; k++) {\x0d\x0a                            modifier = part.modifiers[k];\x0d\x0a                            if (modifier.type === \x22class\x22) {\x0d\x0a                                classCount++;\x0d\x0a                            }\x0d\x0a                            if (classCount \x3e 1){\x0d\x0a                                reporter.report(\x22Adjoining classes: \x22+selectors[i].text, part.line, part.col, rule);\x0d\x0a                            }\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Don\x27t use width or height when using padding or border.\x0d\x0a */\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22box-model\x22,\x0d\x0a    name: \x22Beware of broken box size\x22,\x0d\x0a    desc: \x22Don\x27t use width or height when using padding or border.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Beware-of-box-model-size\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            widthProperties = {\x0d\x0a                border: 1,\x0d\x0a                \x22border-left\x22: 1,\x0d\x0a                \x22border-right\x22: 1,\x0d\x0a                padding: 1,\x0d\x0a                \x22padding-left\x22: 1,\x0d\x0a                \x22padding-right\x22: 1\x0d\x0a            },\x0d\x0a            heightProperties = {\x0d\x0a                border: 1,\x0d\x0a                \x22border-bottom\x22: 1,\x0d\x0a                \x22border-top\x22: 1,\x0d\x0a                padding: 1,\x0d\x0a                \x22padding-bottom\x22: 1,\x0d\x0a                \x22padding-top\x22: 1\x0d\x0a            },\x0d\x0a            properties,\x0d\x0a            boxSizing = false;\x0d\x0a\x0d\x0a        function startRule() {\x0d\x0a            properties = {};\x0d\x0a            boxSizing = false;\x0d\x0a        }\x0d\x0a\x0d\x0a        function endRule() {\x0d\x0a            var prop, value;\x0d\x0a\x0d\x0a            if (!boxSizing) {\x0d\x0a                if (properties.height) {\x0d\x0a                    for (prop in heightProperties) {\x0d\x0a                        if (heightProperties.hasOwnProperty(prop) && properties[prop]) {\x0d\x0a                            value = properties[prop].value;\x0d\x0a                            // special case for padding\x0d\x0a                            if (!(prop === \x22padding\x22 && value.parts.length === 2 && value.parts[0].value === 0)) {\x0d\x0a                                reporter.report(\x22Using height with \x22 + prop + \x22 can sometimes make elements larger than you expect.\x22, properties[prop].line, properties[prop].col, rule);\x0d\x0a                            }\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a                if (properties.width) {\x0d\x0a                    for (prop in widthProperties) {\x0d\x0a                        if (widthProperties.hasOwnProperty(prop) && properties[prop]) {\x0d\x0a                            value = properties[prop].value;\x0d\x0a\x0d\x0a                            if (!(prop === \x22padding\x22 && value.parts.length === 2 && value.parts[1].value === 0)) {\x0d\x0a                                reporter.report(\x22Using width with \x22 + prop + \x22 can sometimes make elements larger than you expect.\x22, properties[prop].line, properties[prop].col, rule);\x0d\x0a                            }\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, startRule);\x0d\x0a        parser.addListener(\x22startfontface\x22, startRule);\x0d\x0a        parser.addListener(\x22startpage\x22, startRule);\x0d\x0a        parser.addListener(\x22startpagemargin\x22, startRule);\x0d\x0a        parser.addListener(\x22startkeyframerule\x22, startRule);\x0d\x0a        parser.addListener(\x22startviewport\x22, startRule);\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var name = event.property.text.toLowerCase();\x0d\x0a\x0d\x0a            if (heightProperties[name] || widthProperties[name]) {\x0d\x0a                if (!/^0\x5cS*$/.test(event.value) && !(name === \x22border\x22 && event.value.toString() === \x22none\x22)) {\x0d\x0a                    properties[name] = {\x0d\x0a                        line: event.property.line,\x0d\x0a                        col: event.property.col,\x0d\x0a                        value: event.value\x0d\x0a                    };\x0d\x0a                }\x0d\x0a            } else {\x0d\x0a                if (/^(width|height)/i.test(name) && /^(length|percentage)/.test(event.value.parts[0].type)) {\x0d\x0a                    properties[name] = 1;\x0d\x0a                } else if (name === \x22box-sizing\x22) {\x0d\x0a                    boxSizing = true;\x0d\x0a                }\x0d\x0a            }\x0d\x0a\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endrule\x22, endRule);\x0d\x0a        parser.addListener(\x22endfontface\x22, endRule);\x0d\x0a        parser.addListener(\x22endpage\x22, endRule);\x0d\x0a        parser.addListener(\x22endpagemargin\x22, endRule);\x0d\x0a        parser.addListener(\x22endkeyframerule\x22, endRule);\x0d\x0a        parser.addListener(\x22endviewport\x22, endRule);\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: box-sizing doesn\x27t work in IE6 and IE7.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22box-sizing\x22,\x0d\x0a    name: \x22Disallow use of box-sizing\x22,\x0d\x0a    desc: \x22The box-sizing properties isn\x27t supported in IE6 and IE7.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-box-sizing\x22,\x0d\x0a    browsers: \x22IE6, IE7\x22,\x0d\x0a    tags: [\x22Compatibility\x22],\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var name = event.property.text.toLowerCase();\x0d\x0a\x0d\x0a            if (name === \x22box-sizing\x22) {\x0d\x0a                reporter.report(\x22The box-sizing property isn\x27t supported in IE6 and IE7.\x22, event.line, event.col, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Use the bulletproof @font-face syntax to avoid 404\x27s in old IE\x0d\x0a * (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax)\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22bulletproof-font-face\x22,\x0d\x0a    name: \x22Use the bulletproof @font-face syntax\x22,\x0d\x0a    desc: \x22Use the bulletproof @font-face syntax to avoid 404\x27s in old IE (http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax).\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Bulletproof-font-face\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            fontFaceRule = false,\x0d\x0a            firstSrc = true,\x0d\x0a            ruleFailed = false,\x0d\x0a            line, col;\x0d\x0a\x0d\x0a        // Mark the start of a @font-face declaration so we only test properties inside it\x0d\x0a        parser.addListener(\x22startfontface\x22, function() {\x0d\x0a            fontFaceRule = true;\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            // If we aren\x27t inside an @font-face declaration then just return\x0d\x0a            if (!fontFaceRule) {\x0d\x0a                return;\x0d\x0a            }\x0d\x0a\x0d\x0a            var propertyName = event.property.toString().toLowerCase(),\x0d\x0a                value = event.value.toString();\x0d\x0a\x0d\x0a            // Set the line and col numbers for use in the endfontface listener\x0d\x0a            line = event.line;\x0d\x0a            col = event.col;\x0d\x0a\x0d\x0a            // This is the property that we care about, we can ignore the rest\x0d\x0a            if (propertyName === \x22src\x22) {\x0d\x0a                var regex = /^\x5cs?url\x5c([\x27\x22].+\x5c.eot\x5c?.*[\x27\x22]\x5c)\x5cs*format\x5c([\x27\x22]embedded-opentype[\x27\x22]\x5c).*$/i;\x0d\x0a\x0d\x0a                // We need to handle the advanced syntax with two src properties\x0d\x0a                if (!value.match(regex) && firstSrc) {\x0d\x0a                    ruleFailed = true;\x0d\x0a                    firstSrc = false;\x0d\x0a                } else if (value.match(regex) && !firstSrc) {\x0d\x0a                    ruleFailed = false;\x0d\x0a                }\x0d\x0a            }\x0d\x0a\x0d\x0a\x0d\x0a        });\x0d\x0a\x0d\x0a        // Back to normal rules that we don\x27t need to test\x0d\x0a        parser.addListener(\x22endfontface\x22, function() {\x0d\x0a            fontFaceRule = false;\x0d\x0a\x0d\x0a            if (ruleFailed) {\x0d\x0a                reporter.report(\x22@font-face declaration doesn\x27t follow the fontspring bulletproof syntax.\x22, line, col, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Include all compatible vendor prefixes to reach a wider\x0d\x0a * range of users.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22compatible-vendor-prefixes\x22,\x0d\x0a    name: \x22Require compatible vendor prefixes\x22,\x0d\x0a    desc: \x22Include all compatible vendor prefixes to reach a wider range of users.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Require-compatible-vendor-prefixes\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function (parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            compatiblePrefixes,\x0d\x0a            properties,\x0d\x0a            prop,\x0d\x0a            variations,\x0d\x0a            prefixed,\x0d\x0a            i,\x0d\x0a            len,\x0d\x0a            inKeyFrame = false,\x0d\x0a            arrayPush = Array.prototype.push,\x0d\x0a            applyTo = [];\x0d\x0a\x0d\x0a        // See http://peter.sh/experiments/vendor-prefixed-css-property-overview/ for details\x0d\x0a        compatiblePrefixes = {\x0d\x0a            \x22animation\x22                  : \x22webkit\x22,\x0d\x0a            \x22animation-delay\x22            : \x22webkit\x22,\x0d\x0a            \x22animation-direction\x22        : \x22webkit\x22,\x0d\x0a            \x22animation-duration\x22         : \x22webkit\x22,\x0d\x0a            \x22animation-fill-mode\x22        : \x22webkit\x22,\x0d\x0a            \x22animation-iteration-count\x22  : \x22webkit\x22,\x0d\x0a            \x22animation-name\x22             : \x22webkit\x22,\x0d\x0a            \x22animation-play-state\x22       : \x22webkit\x22,\x0d\x0a            \x22animation-timing-function\x22  : \x22webkit\x22,\x0d\x0a            \x22appearance\x22                 : \x22webkit moz\x22,\x0d\x0a            \x22border-end\x22                 : \x22webkit moz\x22,\x0d\x0a            \x22border-end-color\x22           : \x22webkit moz\x22,\x0d\x0a            \x22border-end-style\x22           : \x22webkit moz\x22,\x0d\x0a            \x22border-end-width\x22           : \x22webkit moz\x22,\x0d\x0a            \x22border-image\x22               : \x22webkit moz o\x22,\x0d\x0a            \x22border-radius\x22              : \x22webkit\x22,\x0d\x0a            \x22border-start\x22               : \x22webkit moz\x22,\x0d\x0a            \x22border-start-color\x22         : \x22webkit moz\x22,\x0d\x0a            \x22border-start-style\x22         : \x22webkit moz\x22,\x0d\x0a            \x22border-start-width\x22         : \x22webkit moz\x22,\x0d\x0a            \x22box-align\x22                  : \x22webkit moz ms\x22,\x0d\x0a            \x22box-direction\x22              : \x22webkit moz ms\x22,\x0d\x0a            \x22box-flex\x22                   : \x22webkit moz ms\x22,\x0d\x0a            \x22box-lines\x22                  : \x22webkit ms\x22,\x0d\x0a            \x22box-ordinal-group\x22          : \x22webkit moz ms\x22,\x0d\x0a            \x22box-orient\x22                 : \x22webkit moz ms\x22,\x0d\x0a            \x22box-pack\x22                   : \x22webkit moz ms\x22,\x0d\x0a            \x22box-sizing\x22                 : \x22\x22,\x0d\x0a            \x22box-shadow\x22                 : \x22\x22,\x0d\x0a            \x22column-count\x22               : \x22webkit moz ms\x22,\x0d\x0a            \x22column-gap\x22                 : \x22webkit moz ms\x22,\x0d\x0a            \x22column-rule\x22                : \x22webkit moz ms\x22,\x0d\x0a            \x22column-rule-color\x22          : \x22webkit moz ms\x22,\x0d\x0a            \x22column-rule-style\x22          : \x22webkit moz ms\x22,\x0d\x0a            \x22column-rule-width\x22          : \x22webkit moz ms\x22,\x0d\x0a            \x22column-width\x22               : \x22webkit moz ms\x22,\x0d\x0a            \x22hyphens\x22                    : \x22epub moz\x22,\x0d\x0a            \x22line-break\x22                 : \x22webkit ms\x22,\x0d\x0a            \x22margin-end\x22                 : \x22webkit moz\x22,\x0d\x0a            \x22margin-start\x22               : \x22webkit moz\x22,\x0d\x0a            \x22marquee-speed\x22              : \x22webkit wap\x22,\x0d\x0a            \x22marquee-style\x22              : \x22webkit wap\x22,\x0d\x0a            \x22padding-end\x22                : \x22webkit moz\x22,\x0d\x0a            \x22padding-start\x22              : \x22webkit moz\x22,\x0d\x0a            \x22tab-size\x22                   : \x22moz o\x22,\x0d\x0a            \x22text-size-adjust\x22           : \x22webkit ms\x22,\x0d\x0a            \x22transform\x22                  : \x22webkit ms\x22,\x0d\x0a            \x22transform-origin\x22           : \x22webkit ms\x22,\x0d\x0a            \x22transition\x22                 : \x22\x22,\x0d\x0a            \x22transition-delay\x22           : \x22\x22,\x0d\x0a            \x22transition-duration\x22        : \x22\x22,\x0d\x0a            \x22transition-property\x22        : \x22\x22,\x0d\x0a            \x22transition-timing-function\x22 : \x22\x22,\x0d\x0a            \x22user-modify\x22                : \x22webkit moz\x22,\x0d\x0a            \x22user-select\x22                : \x22webkit moz ms\x22,\x0d\x0a            \x22word-break\x22                 : \x22epub ms\x22,\x0d\x0a            \x22writing-mode\x22               : \x22epub ms\x22\x0d\x0a        };\x0d\x0a\x0d\x0a\x0d\x0a        for (prop in compatiblePrefixes) {\x0d\x0a            if (compatiblePrefixes.hasOwnProperty(prop)) {\x0d\x0a                variations = [];\x0d\x0a                prefixed = compatiblePrefixes[prop].split(\x22 \x22);\x0d\x0a                for (i = 0, len = prefixed.length; i \x3c len; i++) {\x0d\x0a                    variations.push(\x22-\x22 + prefixed[i] + \x22-\x22 + prop);\x0d\x0a                }\x0d\x0a                compatiblePrefixes[prop] = variations;\x0d\x0a                arrayPush.apply(applyTo, variations);\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, function () {\x0d\x0a            properties = [];\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22startkeyframes\x22, function (event) {\x0d\x0a            inKeyFrame = event.prefix || true;\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endkeyframes\x22, function () {\x0d\x0a            inKeyFrame = false;\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function (event) {\x0d\x0a            var name = event.property;\x0d\x0a            if (CSSLint.Util.indexOf(applyTo, name.text) \x3e -1) {\x0d\x0a\x0d\x0a                // e.g., -moz-transform is okay to be alone in @-moz-keyframes\x0d\x0a                if (!inKeyFrame || typeof inKeyFrame !== \x22string\x22 ||\x0d\x0a                        name.text.indexOf(\x22-\x22 + inKeyFrame + \x22-\x22) !== 0) {\x0d\x0a                    properties.push(name);\x0d\x0a                }\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endrule\x22, function () {\x0d\x0a            if (!properties.length) {\x0d\x0a                return;\x0d\x0a            }\x0d\x0a\x0d\x0a            var propertyGroups = {},\x0d\x0a                i,\x0d\x0a                len,\x0d\x0a                name,\x0d\x0a                prop,\x0d\x0a                variations,\x0d\x0a                value,\x0d\x0a                full,\x0d\x0a                actual,\x0d\x0a                item,\x0d\x0a                propertiesSpecified;\x0d\x0a\x0d\x0a            for (i = 0, len = properties.length; i \x3c len; i++) {\x0d\x0a                name = properties[i];\x0d\x0a\x0d\x0a                for (prop in compatiblePrefixes) {\x0d\x0a                    if (compatiblePrefixes.hasOwnProperty(prop)) {\x0d\x0a                        variations = compatiblePrefixes[prop];\x0d\x0a                        if (CSSLint.Util.indexOf(variations, name.text) \x3e -1) {\x0d\x0a                            if (!propertyGroups[prop]) {\x0d\x0a                                propertyGroups[prop] = {\x0d\x0a                                    full: variations.slice(0),\x0d\x0a                                    actual: [],\x0d\x0a                                    actualNodes: []\x0d\x0a                                };\x0d\x0a                            }\x0d\x0a                            if (CSSLint.Util.indexOf(propertyGroups[prop].actual, name.text) === -1) {\x0d\x0a                                propertyGroups[prop].actual.push(name.text);\x0d\x0a                                propertyGroups[prop].actualNodes.push(name);\x0d\x0a                            }\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a\x0d\x0a            for (prop in propertyGroups) {\x0d\x0a                if (propertyGroups.hasOwnProperty(prop)) {\x0d\x0a                    value = propertyGroups[prop];\x0d\x0a                    full = value.full;\x0d\x0a                    actual = value.actual;\x0d\x0a\x0d\x0a                    if (full.length \x3e actual.length) {\x0d\x0a                        for (i = 0, len = full.length; i \x3c len; i++) {\x0d\x0a                            item = full[i];\x0d\x0a                            if (CSSLint.Util.indexOf(actual, item) === -1) {\x0d\x0a                                propertiesSpecified = (actual.length === 1) ? actual[0] : (actual.length === 2) ? actual.join(\x22 and \x22) : actual.join(\x22, \x22);\x0d\x0a                                reporter.report(\x22The property \x22 + item + \x22 is compatible with \x22 + propertiesSpecified + \x22 and should be included as well.\x22, value.actualNodes[0].line, value.actualNodes[0].col, rule);\x0d\x0a                            }\x0d\x0a                        }\x0d\x0a\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Certain properties don\x27t play well with certain display values.\x0d\x0a * - float should not be used with inline-block\x0d\x0a * - height, width, margin-top, margin-bottom, float should not be used with inline\x0d\x0a * - vertical-align should not be used with block\x0d\x0a * - margin, float should not be used with table-*\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22display-property-grouping\x22,\x0d\x0a    name: \x22Require properties appropriate for display\x22,\x0d\x0a    desc: \x22Certain properties shouldn\x27t be used with certain display property values.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Require-properties-appropriate-for-display\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        var propertiesToCheck = {\x0d\x0a                display: 1,\x0d\x0a                \x22float\x22: \x22none\x22,\x0d\x0a                height: 1,\x0d\x0a                width: 1,\x0d\x0a                margin: 1,\x0d\x0a                \x22margin-left\x22: 1,\x0d\x0a                \x22margin-right\x22: 1,\x0d\x0a                \x22margin-bottom\x22: 1,\x0d\x0a                \x22margin-top\x22: 1,\x0d\x0a                padding: 1,\x0d\x0a                \x22padding-left\x22: 1,\x0d\x0a                \x22padding-right\x22: 1,\x0d\x0a                \x22padding-bottom\x22: 1,\x0d\x0a                \x22padding-top\x22: 1,\x0d\x0a                \x22vertical-align\x22: 1\x0d\x0a            },\x0d\x0a            properties;\x0d\x0a\x0d\x0a        function reportProperty(name, display, msg) {\x0d\x0a            if (properties[name]) {\x0d\x0a                if (typeof propertiesToCheck[name] !== \x22string\x22 || properties[name].value.toLowerCase() !== propertiesToCheck[name]) {\x0d\x0a                    reporter.report(msg || name + \x22 can\x27t be used with display: \x22 + display + \x22.\x22, properties[name].line, properties[name].col, rule);\x0d\x0a                }\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        function startRule() {\x0d\x0a            properties = {};\x0d\x0a        }\x0d\x0a\x0d\x0a        function endRule() {\x0d\x0a\x0d\x0a            var display = properties.display ? properties.display.value : null;\x0d\x0a            if (display) {\x0d\x0a                switch (display) {\x0d\x0a\x0d\x0a                    case \x22inline\x22:\x0d\x0a                        // height, width, margin-top, margin-bottom, float should not be used with inline\x0d\x0a                        reportProperty(\x22height\x22, display);\x0d\x0a                        reportProperty(\x22width\x22, display);\x0d\x0a                        reportProperty(\x22margin\x22, display);\x0d\x0a                        reportProperty(\x22margin-top\x22, display);\x0d\x0a                        reportProperty(\x22margin-bottom\x22, display);\x0d\x0a                        reportProperty(\x22float\x22, display, \x22display:inline has no effect on floated elements (but may be used to fix the IE6 double-margin bug).\x22);\x0d\x0a                        break;\x0d\x0a\x0d\x0a                    case \x22block\x22:\x0d\x0a                        // vertical-align should not be used with block\x0d\x0a                        reportProperty(\x22vertical-align\x22, display);\x0d\x0a                        break;\x0d\x0a\x0d\x0a                    case \x22inline-block\x22:\x0d\x0a                        // float should not be used with inline-block\x0d\x0a                        reportProperty(\x22float\x22, display);\x0d\x0a                        break;\x0d\x0a\x0d\x0a                    default:\x0d\x0a                        // margin, float should not be used with table\x0d\x0a                        if (display.indexOf(\x22table-\x22) === 0) {\x0d\x0a                            reportProperty(\x22margin\x22, display);\x0d\x0a                            reportProperty(\x22margin-left\x22, display);\x0d\x0a                            reportProperty(\x22margin-right\x22, display);\x0d\x0a                            reportProperty(\x22margin-top\x22, display);\x0d\x0a                            reportProperty(\x22margin-bottom\x22, display);\x0d\x0a                            reportProperty(\x22float\x22, display);\x0d\x0a                        }\x0d\x0a\x0d\x0a                        // otherwise do nothing\x0d\x0a                }\x0d\x0a            }\x0d\x0a\x0d\x0a        }\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, startRule);\x0d\x0a        parser.addListener(\x22startfontface\x22, startRule);\x0d\x0a        parser.addListener(\x22startkeyframerule\x22, startRule);\x0d\x0a        parser.addListener(\x22startpagemargin\x22, startRule);\x0d\x0a        parser.addListener(\x22startpage\x22, startRule);\x0d\x0a        parser.addListener(\x22startviewport\x22, startRule);\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var name = event.property.text.toLowerCase();\x0d\x0a\x0d\x0a            if (propertiesToCheck[name]) {\x0d\x0a                properties[name] = {\x0d\x0a                    value: event.value.text,\x0d\x0a                    line: event.property.line,\x0d\x0a                    col: event.property.col\x0d\x0a                };\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endrule\x22, endRule);\x0d\x0a        parser.addListener(\x22endfontface\x22, endRule);\x0d\x0a        parser.addListener(\x22endkeyframerule\x22, endRule);\x0d\x0a        parser.addListener(\x22endpagemargin\x22, endRule);\x0d\x0a        parser.addListener(\x22endpage\x22, endRule);\x0d\x0a        parser.addListener(\x22endviewport\x22, endRule);\x0d\x0a\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Disallow duplicate background-images (using url).\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22duplicate-background-images\x22,\x0d\x0a    name: \x22Disallow duplicate background images\x22,\x0d\x0a    desc: \x22Every background-image should be unique. Use a common class for e.g. sprites.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-duplicate-background-images\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            stack = {};\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var name = event.property.text,\x0d\x0a                value = event.value,\x0d\x0a                i, len;\x0d\x0a\x0d\x0a            if (name.match(/background/i)) {\x0d\x0a                for (i=0, len=value.parts.length; i \x3c len; i++) {\x0d\x0a                    if (value.parts[i].type === \x22uri\x22) {\x0d\x0a                        if (typeof stack[value.parts[i].uri] === \x22undefined\x22) {\x0d\x0a                            stack[value.parts[i].uri] = event;\x0d\x0a                        } else {\x0d\x0a                            reporter.report(\x22Background image \x27\x22 + value.parts[i].uri + \x22\x27 was used multiple times, first declared at line \x22 + stack[value.parts[i].uri].line + \x22, col \x22 + stack[value.parts[i].uri].col + \x22.\x22, event.line, event.col, rule);\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Duplicate properties must appear one after the other. If an already-defined\x0d\x0a * property appears somewhere else in the rule, then it\x27s likely an error.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22duplicate-properties\x22,\x0d\x0a    name: \x22Disallow duplicate properties\x22,\x0d\x0a    desc: \x22Duplicate properties must appear one after the other.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-duplicate-properties\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            properties,\x0d\x0a            lastProperty;\x0d\x0a\x0d\x0a        function startRule() {\x0d\x0a            properties = {};\x0d\x0a        }\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, startRule);\x0d\x0a        parser.addListener(\x22startfontface\x22, startRule);\x0d\x0a        parser.addListener(\x22startpage\x22, startRule);\x0d\x0a        parser.addListener(\x22startpagemargin\x22, startRule);\x0d\x0a        parser.addListener(\x22startkeyframerule\x22, startRule);\x0d\x0a        parser.addListener(\x22startviewport\x22, startRule);\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var property = event.property,\x0d\x0a                name = property.text.toLowerCase();\x0d\x0a\x0d\x0a            if (properties[name] && (lastProperty !== name || properties[name] === event.value.text)) {\x0d\x0a                reporter.report(\x22Duplicate property \x27\x22 + event.property + \x22\x27 found.\x22, event.line, event.col, rule);\x0d\x0a            }\x0d\x0a\x0d\x0a            properties[name] = event.value.text;\x0d\x0a            lastProperty = name;\x0d\x0a\x0d\x0a        });\x0d\x0a\x0d\x0a\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Style rules without any properties defined should be removed.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22empty-rules\x22,\x0d\x0a    name: \x22Disallow empty rules\x22,\x0d\x0a    desc: \x22Rules without any properties specified should be removed.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-empty-rules\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            count = 0;\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, function() {\x0d\x0a            count=0;\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function() {\x0d\x0a            count++;\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endrule\x22, function(event) {\x0d\x0a            var selectors = event.selectors;\x0d\x0a            if (count === 0) {\x0d\x0a                reporter.report(\x22Rule is empty.\x22, selectors[0].line, selectors[0].col, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: There should be no syntax errors. (Duh.)\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22errors\x22,\x0d\x0a    name: \x22Parsing Errors\x22,\x0d\x0a    desc: \x22This rule looks for recoverable syntax errors.\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        parser.addListener(\x22error\x22, function(event) {\x0d\x0a            reporter.error(event.message, event.line, event.col, rule);\x0d\x0a        });\x0d\x0a\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22fallback-colors\x22,\x0d\x0a    name: \x22Require fallback colors\x22,\x0d\x0a    desc: \x22For older browsers that don\x27t support RGBA, HSL, or HSLA, provide a fallback color.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Require-fallback-colors\x22,\x0d\x0a    browsers: \x22IE6,IE7,IE8\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            lastProperty,\x0d\x0a            propertiesToCheck = {\x0d\x0a                color: 1,\x0d\x0a                background: 1,\x0d\x0a                \x22border-color\x22: 1,\x0d\x0a                \x22border-top-color\x22: 1,\x0d\x0a                \x22border-right-color\x22: 1,\x0d\x0a                \x22border-bottom-color\x22: 1,\x0d\x0a                \x22border-left-color\x22: 1,\x0d\x0a                border: 1,\x0d\x0a                \x22border-top\x22: 1,\x0d\x0a                \x22border-right\x22: 1,\x0d\x0a                \x22border-bottom\x22: 1,\x0d\x0a                \x22border-left\x22: 1,\x0d\x0a                \x22background-color\x22: 1\x0d\x0a            };\x0d\x0a\x0d\x0a        function startRule() {\x0d\x0a            lastProperty = null;\x0d\x0a        }\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, startRule);\x0d\x0a        parser.addListener(\x22startfontface\x22, startRule);\x0d\x0a        parser.addListener(\x22startpage\x22, startRule);\x0d\x0a        parser.addListener(\x22startpagemargin\x22, startRule);\x0d\x0a        parser.addListener(\x22startkeyframerule\x22, startRule);\x0d\x0a        parser.addListener(\x22startviewport\x22, startRule);\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var property = event.property,\x0d\x0a                name = property.text.toLowerCase(),\x0d\x0a                parts = event.value.parts,\x0d\x0a                i = 0,\x0d\x0a                colorType = \x22\x22,\x0d\x0a                len = parts.length;\x0d\x0a\x0d\x0a            if (propertiesToCheck[name]) {\x0d\x0a                while (i \x3c len) {\x0d\x0a                    if (parts[i].type === \x22color\x22) {\x0d\x0a                        if (\x22alpha\x22 in parts[i] || \x22hue\x22 in parts[i]) {\x0d\x0a\x0d\x0a                            if (/([^\x5c)]+)\x5c(/.test(parts[i])) {\x0d\x0a                                colorType = RegExp.$1.toUpperCase();\x0d\x0a                            }\x0d\x0a\x0d\x0a                            if (!lastProperty || (lastProperty.property.text.toLowerCase() !== name || lastProperty.colorType !== \x22compat\x22)) {\x0d\x0a                                reporter.report(\x22Fallback \x22 + name + \x22 (hex or RGB) should precede \x22 + colorType + \x22 \x22 + name + \x22.\x22, event.line, event.col, rule);\x0d\x0a                            }\x0d\x0a                        } else {\x0d\x0a                            event.colorType = \x22compat\x22;\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a\x0d\x0a                    i++;\x0d\x0a                }\x0d\x0a            }\x0d\x0a\x0d\x0a            lastProperty = event;\x0d\x0a        });\x0d\x0a\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: You shouldn\x27t use more than 10 floats. If you do, there\x27s probably\x0d\x0a * room for some abstraction.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22floats\x22,\x0d\x0a    name: \x22Disallow too many floats\x22,\x0d\x0a    desc: \x22This rule tests if the float property is used too many times\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-too-many-floats\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a        var count = 0;\x0d\x0a\x0d\x0a        // count how many times \x22float\x22 is used\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            if (event.property.text.toLowerCase() === \x22float\x22 &&\x0d\x0a                    event.value.text.toLowerCase() !== \x22none\x22) {\x0d\x0a                count++;\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        // report the results\x0d\x0a        parser.addListener(\x22endstylesheet\x22, function() {\x0d\x0a            reporter.stat(\x22floats\x22, count);\x0d\x0a            if (count \x3e= 10) {\x0d\x0a                reporter.rollupWarn(\x22Too many floats (\x22 + count + \x22), you\x27re probably using them for layout. Consider using a grid system instead.\x22, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Avoid too many @font-face declarations in the same stylesheet.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22font-faces\x22,\x0d\x0a    name: \x22Don\x27t use too many web fonts\x22,\x0d\x0a    desc: \x22Too many different web fonts in the same stylesheet.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Don%27t-use-too-many-web-fonts\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            count = 0;\x0d\x0a\x0d\x0a\x0d\x0a        parser.addListener(\x22startfontface\x22, function() {\x0d\x0a            count++;\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endstylesheet\x22, function() {\x0d\x0a            if (count \x3e 5) {\x0d\x0a                reporter.rollupWarn(\x22Too many @font-face declarations (\x22 + count + \x22).\x22, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: You shouldn\x27t need more than 9 font-size declarations.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22font-sizes\x22,\x0d\x0a    name: \x22Disallow too many font sizes\x22,\x0d\x0a    desc: \x22Checks the number of font-size declarations.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Don%27t-use-too-many-font-size-declarations\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            count = 0;\x0d\x0a\x0d\x0a        // check for use of \x22font-size\x22\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            if (event.property.toString() === \x22font-size\x22) {\x0d\x0a                count++;\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        // report the results\x0d\x0a        parser.addListener(\x22endstylesheet\x22, function() {\x0d\x0a            reporter.stat(\x22font-sizes\x22, count);\x0d\x0a            if (count \x3e= 10) {\x0d\x0a                reporter.rollupWarn(\x22Too many font-size declarations (\x22 + count + \x22), abstraction needed.\x22, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: When using a vendor-prefixed gradient, make sure to use them all.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22gradients\x22,\x0d\x0a    name: \x22Require all gradient definitions\x22,\x0d\x0a    desc: \x22When using a vendor-prefixed gradient, make sure to use them all.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Require-all-gradient-definitions\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            gradients;\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, function() {\x0d\x0a            gradients = {\x0d\x0a                moz: 0,\x0d\x0a                webkit: 0,\x0d\x0a                oldWebkit: 0,\x0d\x0a                o: 0\x0d\x0a            };\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a\x0d\x0a            if (/\x5c-(moz|o|webkit)(?:\x5c-(?:linear|radial))\x5c-gradient/i.test(event.value)) {\x0d\x0a                gradients[RegExp.$1] = 1;\x0d\x0a            } else if (/\x5c-webkit\x5c-gradient/i.test(event.value)) {\x0d\x0a                gradients.oldWebkit = 1;\x0d\x0a            }\x0d\x0a\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endrule\x22, function(event) {\x0d\x0a            var missing = [];\x0d\x0a\x0d\x0a            if (!gradients.moz) {\x0d\x0a                missing.push(\x22Firefox 3.6+\x22);\x0d\x0a            }\x0d\x0a\x0d\x0a            if (!gradients.webkit) {\x0d\x0a                missing.push(\x22Webkit (Safari 5+, Chrome)\x22);\x0d\x0a            }\x0d\x0a\x0d\x0a            if (!gradients.oldWebkit) {\x0d\x0a                missing.push(\x22Old Webkit (Safari 4+, Chrome)\x22);\x0d\x0a            }\x0d\x0a\x0d\x0a            if (!gradients.o) {\x0d\x0a                missing.push(\x22Opera 11.1+\x22);\x0d\x0a            }\x0d\x0a\x0d\x0a            if (missing.length && missing.length \x3c 4) {\x0d\x0a                reporter.report(\x22Missing vendor-prefixed CSS gradients for \x22 + missing.join(\x22, \x22) + \x22.\x22, event.selectors[0].line, event.selectors[0].col, rule);\x0d\x0a            }\x0d\x0a\x0d\x0a        });\x0d\x0a\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Don\x27t use IDs for selectors.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22ids\x22,\x0d\x0a    name: \x22Disallow IDs in selectors\x22,\x0d\x0a    desc: \x22Selectors should not contain IDs.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-IDs-in-selectors\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a        parser.addListener(\x22startrule\x22, function(event) {\x0d\x0a            var selectors = event.selectors,\x0d\x0a                selector,\x0d\x0a                part,\x0d\x0a                modifier,\x0d\x0a                idCount,\x0d\x0a                i, j, k;\x0d\x0a\x0d\x0a            for (i=0; i \x3c selectors.length; i++) {\x0d\x0a                selector = selectors[i];\x0d\x0a                idCount = 0;\x0d\x0a\x0d\x0a                for (j=0; j \x3c selector.parts.length; j++) {\x0d\x0a                    part = selector.parts[j];\x0d\x0a                    if (part.type === parser.SELECTOR_PART_TYPE) {\x0d\x0a                        for (k=0; k \x3c part.modifiers.length; k++) {\x0d\x0a                            modifier = part.modifiers[k];\x0d\x0a                            if (modifier.type === \x22id\x22) {\x0d\x0a                                idCount++;\x0d\x0a                            }\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a                if (idCount === 1) {\x0d\x0a                    reporter.report(\x22Don\x27t use IDs in selectors.\x22, selector.line, selector.col, rule);\x0d\x0a                } else if (idCount \x3e 1) {\x0d\x0a                    reporter.report(idCount + \x22 IDs in the selector, really?\x22, selector.line, selector.col, rule);\x0d\x0a                }\x0d\x0a            }\x0d\x0a\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: IE6-9 supports up to 31 stylesheet import.\x0d\x0a * Reference:\x0d\x0a * http://blogs.msdn.com/b/ieinternals/archive/2011/05/14/internet-explorer-stylesheet-rule-selector-import-sheet-limit-maximum.aspx\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22import-ie-limit\x22,\x0d\x0a    name: \x22@import limit on IE6-IE9\x22,\x0d\x0a    desc: \x22IE6-9 supports up to 31 @import per stylesheet\x22,\x0d\x0a    browsers: \x22IE6, IE7, IE8, IE9\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            MAX_IMPORT_COUNT = 31,\x0d\x0a            count = 0;\x0d\x0a\x0d\x0a        function startPage() {\x0d\x0a            count = 0;\x0d\x0a        }\x0d\x0a\x0d\x0a        parser.addListener(\x22startpage\x22, startPage);\x0d\x0a\x0d\x0a        parser.addListener(\x22import\x22, function() {\x0d\x0a            count++;\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endstylesheet\x22, function() {\x0d\x0a            if (count \x3e MAX_IMPORT_COUNT) {\x0d\x0a                reporter.rollupError(\x0d\x0a                    \x22Too many @import rules (\x22 + count + \x22). IE6-9 supports up to 31 import per stylesheet.\x22,\x0d\x0a                    rule\x0d\x0a                );\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Don\x27t use @import, use \x3clink\x3e instead.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22import\x22,\x0d\x0a    name: \x22Disallow @import\x22,\x0d\x0a    desc: \x22Don\x27t use @import, use \x3clink\x3e instead.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-%40import\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        parser.addListener(\x22import\x22, function(event) {\x0d\x0a            reporter.report(\x22@import prevents parallel downloads, use \x3clink\x3e instead.\x22, event.line, event.col, rule);\x0d\x0a        });\x0d\x0a\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Make sure !important is not overused, this could lead to specificity\x0d\x0a * war. Display a warning on !important declarations, an error if it\x27s\x0d\x0a * used more at least 10 times.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22important\x22,\x0d\x0a    name: \x22Disallow !important\x22,\x0d\x0a    desc: \x22Be careful when using !important declaration\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-%21important\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            count = 0;\x0d\x0a\x0d\x0a        // warn that important is used and increment the declaration counter\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            if (event.important === true) {\x0d\x0a                count++;\x0d\x0a                reporter.report(\x22Use of !important\x22, event.line, event.col, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        // if there are more than 10, show an error\x0d\x0a        parser.addListener(\x22endstylesheet\x22, function() {\x0d\x0a            reporter.stat(\x22important\x22, count);\x0d\x0a            if (count \x3e= 10) {\x0d\x0a                reporter.rollupWarn(\x22Too many !important declarations (\x22 + count + \x22), try to use less than 10 to avoid specificity issues.\x22, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Properties should be known (listed in CSS3 specification) or\x0d\x0a * be a vendor-prefixed property.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22known-properties\x22,\x0d\x0a    name: \x22Require use of known properties\x22,\x0d\x0a    desc: \x22Properties should be known (listed in CSS3 specification) or be a vendor-prefixed property.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Require-use-of-known-properties\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a\x0d\x0a            // the check is handled entirely by the parser-lib (https://github.com/nzakas/parser-lib)\x0d\x0a            if (event.invalid) {\x0d\x0a                reporter.report(event.invalid.message, event.line, event.col, rule);\x0d\x0a            }\x0d\x0a\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: All properties should be in alphabetical order.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22order-alphabetical\x22,\x0d\x0a    name: \x22Alphabetical order\x22,\x0d\x0a    desc: \x22Assure properties are in alphabetical order\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            properties;\x0d\x0a\x0d\x0a        var startRule = function () {\x0d\x0a            properties = [];\x0d\x0a        };\x0d\x0a\x0d\x0a        var endRule = function(event) {\x0d\x0a            var currentProperties = properties.join(\x22,\x22),\x0d\x0a                expectedProperties = properties.sort().join(\x22,\x22);\x0d\x0a\x0d\x0a            if (currentProperties !== expectedProperties) {\x0d\x0a                reporter.report(\x22Rule doesn\x27t have all its properties in alphabetical order.\x22, event.line, event.col, rule);\x0d\x0a            }\x0d\x0a        };\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, startRule);\x0d\x0a        parser.addListener(\x22startfontface\x22, startRule);\x0d\x0a        parser.addListener(\x22startpage\x22, startRule);\x0d\x0a        parser.addListener(\x22startpagemargin\x22, startRule);\x0d\x0a        parser.addListener(\x22startkeyframerule\x22, startRule);\x0d\x0a        parser.addListener(\x22startviewport\x22, startRule);\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var name = event.property.text,\x0d\x0a                lowerCasePrefixLessName = name.toLowerCase().replace(/^-.*?-/, \x22\x22);\x0d\x0a\x0d\x0a            properties.push(lowerCasePrefixLessName);\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endrule\x22, endRule);\x0d\x0a        parser.addListener(\x22endfontface\x22, endRule);\x0d\x0a        parser.addListener(\x22endpage\x22, endRule);\x0d\x0a        parser.addListener(\x22endpagemargin\x22, endRule);\x0d\x0a        parser.addListener(\x22endkeyframerule\x22, endRule);\x0d\x0a        parser.addListener(\x22endviewport\x22, endRule);\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: outline: none or outline: 0 should only be used in a :focus rule\x0d\x0a *       and only if there are other properties in the same rule.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22outline-none\x22,\x0d\x0a    name: \x22Disallow outline: none\x22,\x0d\x0a    desc: \x22Use of outline: none or outline: 0 should be limited to :focus rules.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-outline%3Anone\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a    tags: [\x22Accessibility\x22],\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            lastRule;\x0d\x0a\x0d\x0a        function startRule(event) {\x0d\x0a            if (event.selectors) {\x0d\x0a                lastRule = {\x0d\x0a                    line: event.line,\x0d\x0a                    col: event.col,\x0d\x0a                    selectors: event.selectors,\x0d\x0a                    propCount: 0,\x0d\x0a                    outline: false\x0d\x0a                };\x0d\x0a            } else {\x0d\x0a                lastRule = null;\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        function endRule() {\x0d\x0a            if (lastRule) {\x0d\x0a                if (lastRule.outline) {\x0d\x0a                    if (lastRule.selectors.toString().toLowerCase().indexOf(\x22:focus\x22) === -1) {\x0d\x0a                        reporter.report(\x22Outlines should only be modified using :focus.\x22, lastRule.line, lastRule.col, rule);\x0d\x0a                    } else if (lastRule.propCount === 1) {\x0d\x0a                        reporter.report(\x22Outlines shouldn\x27t be hidden unless other visual changes are made.\x22, lastRule.line, lastRule.col, rule);\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, startRule);\x0d\x0a        parser.addListener(\x22startfontface\x22, startRule);\x0d\x0a        parser.addListener(\x22startpage\x22, startRule);\x0d\x0a        parser.addListener(\x22startpagemargin\x22, startRule);\x0d\x0a        parser.addListener(\x22startkeyframerule\x22, startRule);\x0d\x0a        parser.addListener(\x22startviewport\x22, startRule);\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var name = event.property.text.toLowerCase(),\x0d\x0a                value = event.value;\x0d\x0a\x0d\x0a            if (lastRule) {\x0d\x0a                lastRule.propCount++;\x0d\x0a                if (name === \x22outline\x22 && (value.toString() === \x22none\x22 || value.toString() === \x220\x22)) {\x0d\x0a                    lastRule.outline = true;\x0d\x0a                }\x0d\x0a            }\x0d\x0a\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endrule\x22, endRule);\x0d\x0a        parser.addListener(\x22endfontface\x22, endRule);\x0d\x0a        parser.addListener(\x22endpage\x22, endRule);\x0d\x0a        parser.addListener(\x22endpagemargin\x22, endRule);\x0d\x0a        parser.addListener(\x22endkeyframerule\x22, endRule);\x0d\x0a        parser.addListener(\x22endviewport\x22, endRule);\x0d\x0a\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Don\x27t use classes or IDs with elements (a.foo or a#foo).\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22overqualified-elements\x22,\x0d\x0a    name: \x22Disallow overqualified elements\x22,\x0d\x0a    desc: \x22Don\x27t use classes or IDs with elements (a.foo or a#foo).\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-overqualified-elements\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            classes = {};\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, function(event) {\x0d\x0a            var selectors = event.selectors,\x0d\x0a                selector,\x0d\x0a                part,\x0d\x0a                modifier,\x0d\x0a                i, j, k;\x0d\x0a\x0d\x0a            for (i=0; i \x3c selectors.length; i++) {\x0d\x0a                selector = selectors[i];\x0d\x0a\x0d\x0a                for (j=0; j \x3c selector.parts.length; j++) {\x0d\x0a                    part = selector.parts[j];\x0d\x0a                    if (part.type === parser.SELECTOR_PART_TYPE) {\x0d\x0a                        for (k=0; k \x3c part.modifiers.length; k++) {\x0d\x0a                            modifier = part.modifiers[k];\x0d\x0a                            if (part.elementName && modifier.type === \x22id\x22) {\x0d\x0a                                reporter.report(\x22Element (\x22 + part + \x22) is overqualified, just use \x22 + modifier + \x22 without element name.\x22, part.line, part.col, rule);\x0d\x0a                            } else if (modifier.type === \x22class\x22) {\x0d\x0a\x0d\x0a                                if (!classes[modifier]) {\x0d\x0a                                    classes[modifier] = [];\x0d\x0a                                }\x0d\x0a                                classes[modifier].push({\x0d\x0a                                    modifier: modifier,\x0d\x0a                                    part: part\x0d\x0a                                });\x0d\x0a                            }\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endstylesheet\x22, function() {\x0d\x0a\x0d\x0a            var prop;\x0d\x0a            for (prop in classes) {\x0d\x0a                if (classes.hasOwnProperty(prop)) {\x0d\x0a\x0d\x0a                    // one use means that this is overqualified\x0d\x0a                    if (classes[prop].length === 1 && classes[prop][0].part.elementName) {\x0d\x0a                        reporter.report(\x22Element (\x22 + classes[prop][0].part + \x22) is overqualified, just use \x22 + classes[prop][0].modifier + \x22 without element name.\x22, classes[prop][0].part.line, classes[prop][0].part.col, rule);\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Headings (h1-h6) should not be qualified (namespaced).\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22qualified-headings\x22,\x0d\x0a    name: \x22Disallow qualified headings\x22,\x0d\x0a    desc: \x22Headings should not be qualified (namespaced).\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-qualified-headings\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, function(event) {\x0d\x0a            var selectors = event.selectors,\x0d\x0a                selector,\x0d\x0a                part,\x0d\x0a                i, j;\x0d\x0a\x0d\x0a            for (i=0; i \x3c selectors.length; i++) {\x0d\x0a                selector = selectors[i];\x0d\x0a\x0d\x0a                for (j=0; j \x3c selector.parts.length; j++) {\x0d\x0a                    part = selector.parts[j];\x0d\x0a                    if (part.type === parser.SELECTOR_PART_TYPE) {\x0d\x0a                        if (part.elementName && /h[1-6]/.test(part.elementName.toString()) && j \x3e 0) {\x0d\x0a                            reporter.report(\x22Heading (\x22 + part.elementName + \x22) should not be qualified.\x22, part.line, part.col, rule);\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Selectors that look like regular expressions are slow and should be avoided.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22regex-selectors\x22,\x0d\x0a    name: \x22Disallow selectors that look like regexs\x22,\x0d\x0a    desc: \x22Selectors that look like regular expressions are slow and should be avoided.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-selectors-that-look-like-regular-expressions\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, function(event) {\x0d\x0a            var selectors = event.selectors,\x0d\x0a                selector,\x0d\x0a                part,\x0d\x0a                modifier,\x0d\x0a                i, j, k;\x0d\x0a\x0d\x0a            for (i=0; i \x3c selectors.length; i++) {\x0d\x0a                selector = selectors[i];\x0d\x0a                for (j=0; j \x3c selector.parts.length; j++) {\x0d\x0a                    part = selector.parts[j];\x0d\x0a                    if (part.type === parser.SELECTOR_PART_TYPE) {\x0d\x0a                        for (k=0; k \x3c part.modifiers.length; k++) {\x0d\x0a                            modifier = part.modifiers[k];\x0d\x0a                            if (modifier.type === \x22attribute\x22) {\x0d\x0a                                if (/([~\x5c|\x5c^\x5c$\x5c*]=)/.test(modifier)) {\x0d\x0a                                    reporter.report(\x22Attribute selectors with \x22 + RegExp.$1 + \x22 are slow!\x22, modifier.line, modifier.col, rule);\x0d\x0a                                }\x0d\x0a                            }\x0d\x0a\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Total number of rules should not exceed x.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22rules-count\x22,\x0d\x0a    name: \x22Rules Count\x22,\x0d\x0a    desc: \x22Track how many rules there are.\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var count = 0;\x0d\x0a\x0d\x0a        // count each rule\x0d\x0a        parser.addListener(\x22startrule\x22, function() {\x0d\x0a            count++;\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endstylesheet\x22, function() {\x0d\x0a            reporter.stat(\x22rule-count\x22, count);\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Warn people with approaching the IE 4095 limit\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22selector-max-approaching\x22,\x0d\x0a    name: \x22Warn when approaching the 4095 selector limit for IE\x22,\x0d\x0a    desc: \x22Will warn when selector count is \x3e= 3800 selectors.\x22,\x0d\x0a    browsers: \x22IE\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this, count = 0;\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, function(event) {\x0d\x0a            count += event.selectors.length;\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endstylesheet\x22, function() {\x0d\x0a            if (count \x3e= 3800) {\x0d\x0a                reporter.report(\x22You have \x22 + count + \x22 selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.\x22, 0, 0, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Warn people past the IE 4095 limit\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22selector-max\x22,\x0d\x0a    name: \x22Error when past the 4095 selector limit for IE\x22,\x0d\x0a    desc: \x22Will error when selector count is \x3e 4095.\x22,\x0d\x0a    browsers: \x22IE\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this, count = 0;\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, function(event) {\x0d\x0a            count += event.selectors.length;\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endstylesheet\x22, function() {\x0d\x0a            if (count \x3e 4095) {\x0d\x0a                reporter.report(\x22You have \x22 + count + \x22 selectors. Internet Explorer supports a maximum of 4095 selectors per stylesheet. Consider refactoring.\x22, 0, 0, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Avoid new-line characters in selectors.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22selector-newline\x22,\x0d\x0a    name: \x22Disallow new-line characters in selectors\x22,\x0d\x0a    desc: \x22New-line characters in selectors are usually a forgotten comma and not a descendant combinator.\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        function startRule(event) {\x0d\x0a            var i, len, selector, p, n, pLen, part, part2, type, currentLine, nextLine,\x0d\x0a                selectors = event.selectors;\x0d\x0a\x0d\x0a            for (i = 0, len = selectors.length; i \x3c len; i++) {\x0d\x0a                selector = selectors[i];\x0d\x0a                for (p = 0, pLen = selector.parts.length; p \x3c pLen; p++) {\x0d\x0a                    for (n = p + 1; n \x3c pLen; n++) {\x0d\x0a                        part = selector.parts[p];\x0d\x0a                        part2 = selector.parts[n];\x0d\x0a                        type = part.type;\x0d\x0a                        currentLine = part.line;\x0d\x0a                        nextLine = part2.line;\x0d\x0a\x0d\x0a                        if (type === \x22descendant\x22 && nextLine \x3e currentLine) {\x0d\x0a                            reporter.report(\x22newline character found in selector (forgot a comma?)\x22, currentLine, selectors[i].parts[0].col, rule);\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, startRule);\x0d\x0a\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Use shorthand properties where possible.\x0d\x0a *\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22shorthand\x22,\x0d\x0a    name: \x22Require shorthand properties\x22,\x0d\x0a    desc: \x22Use shorthand properties where possible.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Require-shorthand-properties\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            prop, i, len,\x0d\x0a            propertiesToCheck = {},\x0d\x0a            properties,\x0d\x0a            mapping = {\x0d\x0a                \x22margin\x22: [\x0d\x0a                    \x22margin-top\x22,\x0d\x0a                    \x22margin-bottom\x22,\x0d\x0a                    \x22margin-left\x22,\x0d\x0a                    \x22margin-right\x22\x0d\x0a                ],\x0d\x0a                \x22padding\x22: [\x0d\x0a                    \x22padding-top\x22,\x0d\x0a                    \x22padding-bottom\x22,\x0d\x0a                    \x22padding-left\x22,\x0d\x0a                    \x22padding-right\x22\x0d\x0a                ]\x0d\x0a            };\x0d\x0a\x0d\x0a        // initialize propertiesToCheck\x0d\x0a        for (prop in mapping) {\x0d\x0a            if (mapping.hasOwnProperty(prop)) {\x0d\x0a                for (i=0, len=mapping[prop].length; i \x3c len; i++) {\x0d\x0a                    propertiesToCheck[mapping[prop][i]] = prop;\x0d\x0a                }\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        function startRule() {\x0d\x0a            properties = {};\x0d\x0a        }\x0d\x0a\x0d\x0a        // event handler for end of rules\x0d\x0a        function endRule(event) {\x0d\x0a\x0d\x0a            var prop, i, len, total;\x0d\x0a\x0d\x0a            // check which properties this rule has\x0d\x0a            for (prop in mapping) {\x0d\x0a                if (mapping.hasOwnProperty(prop)) {\x0d\x0a                    total=0;\x0d\x0a\x0d\x0a                    for (i=0, len=mapping[prop].length; i \x3c len; i++) {\x0d\x0a                        total += properties[mapping[prop][i]] ? 1 : 0;\x0d\x0a                    }\x0d\x0a\x0d\x0a                    if (total === mapping[prop].length) {\x0d\x0a                        reporter.report(\x22The properties \x22 + mapping[prop].join(\x22, \x22) + \x22 can be replaced by \x22 + prop + \x22.\x22, event.line, event.col, rule);\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, startRule);\x0d\x0a        parser.addListener(\x22startfontface\x22, startRule);\x0d\x0a\x0d\x0a        // check for use of \x22font-size\x22\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var name = event.property.toString().toLowerCase();\x0d\x0a\x0d\x0a            if (propertiesToCheck[name]) {\x0d\x0a                properties[name] = 1;\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endrule\x22, endRule);\x0d\x0a        parser.addListener(\x22endfontface\x22, endRule);\x0d\x0a\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Don\x27t use properties with a star prefix.\x0d\x0a *\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22star-property-hack\x22,\x0d\x0a    name: \x22Disallow properties with a star prefix\x22,\x0d\x0a    desc: \x22Checks for the star property hack (targets IE6/7)\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-star-hack\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        // check if property name starts with \x22*\x22\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var property = event.property;\x0d\x0a\x0d\x0a            if (property.hack === \x22*\x22) {\x0d\x0a                reporter.report(\x22Property with star prefix found.\x22, event.property.line, event.property.col, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Don\x27t use text-indent for image replacement if you need to support rtl.\x0d\x0a *\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22text-indent\x22,\x0d\x0a    name: \x22Disallow negative text-indent\x22,\x0d\x0a    desc: \x22Checks for text indent less than -99px\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-negative-text-indent\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            textIndent,\x0d\x0a            direction;\x0d\x0a\x0d\x0a\x0d\x0a        function startRule() {\x0d\x0a            textIndent = false;\x0d\x0a            direction = \x22inherit\x22;\x0d\x0a        }\x0d\x0a\x0d\x0a        // event handler for end of rules\x0d\x0a        function endRule() {\x0d\x0a            if (textIndent && direction !== \x22ltr\x22) {\x0d\x0a                reporter.report(\x22Negative text-indent doesn\x27t work well with RTL. If you use text-indent for image replacement explicitly set direction for that item to ltr.\x22, textIndent.line, textIndent.col, rule);\x0d\x0a            }\x0d\x0a        }\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, startRule);\x0d\x0a        parser.addListener(\x22startfontface\x22, startRule);\x0d\x0a\x0d\x0a        // check for use of \x22font-size\x22\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var name = event.property.toString().toLowerCase(),\x0d\x0a                value = event.value;\x0d\x0a\x0d\x0a            if (name === \x22text-indent\x22 && value.parts[0].value \x3c -99) {\x0d\x0a                textIndent = event.property;\x0d\x0a            } else if (name === \x22direction\x22 && value.toString() === \x22ltr\x22) {\x0d\x0a                direction = \x22ltr\x22;\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endrule\x22, endRule);\x0d\x0a        parser.addListener(\x22endfontface\x22, endRule);\x0d\x0a\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Don\x27t use properties with a underscore prefix.\x0d\x0a *\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22underscore-property-hack\x22,\x0d\x0a    name: \x22Disallow properties with an underscore prefix\x22,\x0d\x0a    desc: \x22Checks for the underscore property hack (targets IE6)\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-underscore-hack\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        // check if property name starts with \x22_\x22\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var property = event.property;\x0d\x0a\x0d\x0a            if (property.hack === \x22_\x22) {\x0d\x0a                reporter.report(\x22Property with underscore prefix found.\x22, event.property.line, event.property.col, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Headings (h1-h6) should be defined only once.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22unique-headings\x22,\x0d\x0a    name: \x22Headings should only be defined once\x22,\x0d\x0a    desc: \x22Headings should be defined only once.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Headings-should-only-be-defined-once\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        var headings = {\x0d\x0a            h1: 0,\x0d\x0a            h2: 0,\x0d\x0a            h3: 0,\x0d\x0a            h4: 0,\x0d\x0a            h5: 0,\x0d\x0a            h6: 0\x0d\x0a        };\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, function(event) {\x0d\x0a            var selectors = event.selectors,\x0d\x0a                selector,\x0d\x0a                part,\x0d\x0a                pseudo,\x0d\x0a                i, j;\x0d\x0a\x0d\x0a            for (i=0; i \x3c selectors.length; i++) {\x0d\x0a                selector = selectors[i];\x0d\x0a                part = selector.parts[selector.parts.length-1];\x0d\x0a\x0d\x0a                if (part.elementName && /(h[1-6])/i.test(part.elementName.toString())) {\x0d\x0a\x0d\x0a                    for (j=0; j \x3c part.modifiers.length; j++) {\x0d\x0a                        if (part.modifiers[j].type === \x22pseudo\x22) {\x0d\x0a                            pseudo = true;\x0d\x0a                            break;\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a\x0d\x0a                    if (!pseudo) {\x0d\x0a                        headings[RegExp.$1]++;\x0d\x0a                        if (headings[RegExp.$1] \x3e 1) {\x0d\x0a                            reporter.report(\x22Heading (\x22 + part.elementName + \x22) has already been defined.\x22, part.line, part.col, rule);\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endstylesheet\x22, function() {\x0d\x0a            var prop,\x0d\x0a                messages = [];\x0d\x0a\x0d\x0a            for (prop in headings) {\x0d\x0a                if (headings.hasOwnProperty(prop)) {\x0d\x0a                    if (headings[prop] \x3e 1) {\x0d\x0a                        messages.push(headings[prop] + \x22 \x22 + prop + \x22s\x22);\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a\x0d\x0a            if (messages.length) {\x0d\x0a                reporter.rollupWarn(\x22You have \x22 + messages.join(\x22, \x22) + \x22 defined in this stylesheet.\x22, rule);\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Don\x27t use universal selector because it\x27s slow.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22universal-selector\x22,\x0d\x0a    name: \x22Disallow universal selector\x22,\x0d\x0a    desc: \x22The universal selector (*) is known to be slow.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-universal-selector\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, function(event) {\x0d\x0a            var selectors = event.selectors,\x0d\x0a                selector,\x0d\x0a                part,\x0d\x0a                i;\x0d\x0a\x0d\x0a            for (i=0; i \x3c selectors.length; i++) {\x0d\x0a                selector = selectors[i];\x0d\x0a\x0d\x0a                part = selector.parts[selector.parts.length-1];\x0d\x0a                if (part.elementName === \x22*\x22) {\x0d\x0a                    reporter.report(rule.desc, part.line, part.col, rule);\x0d\x0a                }\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: Don\x27t use unqualified attribute selectors because they\x27re just like universal selectors.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22unqualified-attributes\x22,\x0d\x0a    name: \x22Disallow unqualified attribute selectors\x22,\x0d\x0a    desc: \x22Unqualified attribute selectors are known to be slow.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-unqualified-attribute-selectors\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, function(event) {\x0d\x0a\x0d\x0a            var selectors = event.selectors,\x0d\x0a                selectorContainsClassOrId = false,\x0d\x0a                selector,\x0d\x0a                part,\x0d\x0a                modifier,\x0d\x0a                i, k;\x0d\x0a\x0d\x0a            for (i=0; i \x3c selectors.length; i++) {\x0d\x0a                selector = selectors[i];\x0d\x0a\x0d\x0a                part = selector.parts[selector.parts.length-1];\x0d\x0a                if (part.type === parser.SELECTOR_PART_TYPE) {\x0d\x0a                    for (k=0; k \x3c part.modifiers.length; k++) {\x0d\x0a                        modifier = part.modifiers[k];\x0d\x0a\x0d\x0a                        if (modifier.type === \x22class\x22 || modifier.type === \x22id\x22) {\x0d\x0a                            selectorContainsClassOrId = true;\x0d\x0a                            break;\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a\x0d\x0a                    if (!selectorContainsClassOrId) {\x0d\x0a                        for (k=0; k \x3c part.modifiers.length; k++) {\x0d\x0a                            modifier = part.modifiers[k];\x0d\x0a                            if (modifier.type === \x22attribute\x22 && (!part.elementName || part.elementName === \x22*\x22)) {\x0d\x0a                                reporter.report(rule.desc, part.line, part.col, rule);\x0d\x0a                            }\x0d\x0a                        }\x0d\x0a                    }\x0d\x0a                }\x0d\x0a\x0d\x0a            }\x0d\x0a        });\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: When using a vendor-prefixed property, make sure to\x0d\x0a * include the standard one.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22vendor-prefix\x22,\x0d\x0a    name: \x22Require standard property with vendor prefix\x22,\x0d\x0a    desc: \x22When using a vendor-prefixed property, make sure to include the standard one.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Require-standard-property-with-vendor-prefix\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this,\x0d\x0a            properties,\x0d\x0a            num,\x0d\x0a            propertiesToCheck = {\x0d\x0a                \x22-webkit-border-radius\x22: \x22border-radius\x22,\x0d\x0a                \x22-webkit-border-top-left-radius\x22: \x22border-top-left-radius\x22,\x0d\x0a                \x22-webkit-border-top-right-radius\x22: \x22border-top-right-radius\x22,\x0d\x0a                \x22-webkit-border-bottom-left-radius\x22: \x22border-bottom-left-radius\x22,\x0d\x0a                \x22-webkit-border-bottom-right-radius\x22: \x22border-bottom-right-radius\x22,\x0d\x0a\x0d\x0a                \x22-o-border-radius\x22: \x22border-radius\x22,\x0d\x0a                \x22-o-border-top-left-radius\x22: \x22border-top-left-radius\x22,\x0d\x0a                \x22-o-border-top-right-radius\x22: \x22border-top-right-radius\x22,\x0d\x0a                \x22-o-border-bottom-left-radius\x22: \x22border-bottom-left-radius\x22,\x0d\x0a                \x22-o-border-bottom-right-radius\x22: \x22border-bottom-right-radius\x22,\x0d\x0a\x0d\x0a                \x22-moz-border-radius\x22: \x22border-radius\x22,\x0d\x0a                \x22-moz-border-radius-topleft\x22: \x22border-top-left-radius\x22,\x0d\x0a                \x22-moz-border-radius-topright\x22: \x22border-top-right-radius\x22,\x0d\x0a                \x22-moz-border-radius-bottomleft\x22: \x22border-bottom-left-radius\x22,\x0d\x0a                \x22-moz-border-radius-bottomright\x22: \x22border-bottom-right-radius\x22,\x0d\x0a\x0d\x0a                \x22-moz-column-count\x22: \x22column-count\x22,\x0d\x0a                \x22-webkit-column-count\x22: \x22column-count\x22,\x0d\x0a\x0d\x0a                \x22-moz-column-gap\x22: \x22column-gap\x22,\x0d\x0a                \x22-webkit-column-gap\x22: \x22column-gap\x22,\x0d\x0a\x0d\x0a                \x22-moz-column-rule\x22: \x22column-rule\x22,\x0d\x0a                \x22-webkit-column-rule\x22: \x22column-rule\x22,\x0d\x0a\x0d\x0a                \x22-moz-column-rule-style\x22: \x22column-rule-style\x22,\x0d\x0a                \x22-webkit-column-rule-style\x22: \x22column-rule-style\x22,\x0d\x0a\x0d\x0a                \x22-moz-column-rule-color\x22: \x22column-rule-color\x22,\x0d\x0a                \x22-webkit-column-rule-color\x22: \x22column-rule-color\x22,\x0d\x0a\x0d\x0a                \x22-moz-column-rule-width\x22: \x22column-rule-width\x22,\x0d\x0a                \x22-webkit-column-rule-width\x22: \x22column-rule-width\x22,\x0d\x0a\x0d\x0a                \x22-moz-column-width\x22: \x22column-width\x22,\x0d\x0a                \x22-webkit-column-width\x22: \x22column-width\x22,\x0d\x0a\x0d\x0a                \x22-webkit-column-span\x22: \x22column-span\x22,\x0d\x0a                \x22-webkit-columns\x22: \x22columns\x22,\x0d\x0a\x0d\x0a                \x22-moz-box-shadow\x22: \x22box-shadow\x22,\x0d\x0a                \x22-webkit-box-shadow\x22: \x22box-shadow\x22,\x0d\x0a\x0d\x0a                \x22-moz-transform\x22: \x22transform\x22,\x0d\x0a                \x22-webkit-transform\x22: \x22transform\x22,\x0d\x0a                \x22-o-transform\x22: \x22transform\x22,\x0d\x0a                \x22-ms-transform\x22: \x22transform\x22,\x0d\x0a\x0d\x0a                \x22-moz-transform-origin\x22: \x22transform-origin\x22,\x0d\x0a                \x22-webkit-transform-origin\x22: \x22transform-origin\x22,\x0d\x0a                \x22-o-transform-origin\x22: \x22transform-origin\x22,\x0d\x0a                \x22-ms-transform-origin\x22: \x22transform-origin\x22,\x0d\x0a\x0d\x0a                \x22-moz-box-sizing\x22: \x22box-sizing\x22,\x0d\x0a                \x22-webkit-box-sizing\x22: \x22box-sizing\x22\x0d\x0a            };\x0d\x0a\x0d\x0a        // event handler for beginning of rules\x0d\x0a        function startRule() {\x0d\x0a            properties = {};\x0d\x0a            num = 1;\x0d\x0a        }\x0d\x0a\x0d\x0a        // event handler for end of rules\x0d\x0a        function endRule() {\x0d\x0a            var prop,\x0d\x0a                i,\x0d\x0a                len,\x0d\x0a                needed,\x0d\x0a                actual,\x0d\x0a                needsStandard = [];\x0d\x0a\x0d\x0a            for (prop in properties) {\x0d\x0a                if (propertiesToCheck[prop]) {\x0d\x0a                    needsStandard.push({\x0d\x0a                        actual: prop,\x0d\x0a                        needed: propertiesToCheck[prop]\x0d\x0a                    });\x0d\x0a                }\x0d\x0a            }\x0d\x0a\x0d\x0a            for (i=0, len=needsStandard.length; i \x3c len; i++) {\x0d\x0a                needed = needsStandard[i].needed;\x0d\x0a                actual = needsStandard[i].actual;\x0d\x0a\x0d\x0a                if (!properties[needed]) {\x0d\x0a                    reporter.report(\x22Missing standard property \x27\x22 + needed + \x22\x27 to go along with \x27\x22 + actual + \x22\x27.\x22, properties[actual][0].name.line, properties[actual][0].name.col, rule);\x0d\x0a                } else {\x0d\x0a                    // make sure standard property is last\x0d\x0a                    if (properties[needed][0].pos \x3c properties[actual][0].pos) {\x0d\x0a                        reporter.report(\x22Standard property \x27\x22 + needed + \x22\x27 should come after vendor-prefixed property \x27\x22 + actual + \x22\x27.\x22, properties[actual][0].name.line, properties[actual][0].name.col, rule);\x0d\x0a                    }\x0d\x0a                }\x0d\x0a            }\x0d\x0a\x0d\x0a        }\x0d\x0a\x0d\x0a        parser.addListener(\x22startrule\x22, startRule);\x0d\x0a        parser.addListener(\x22startfontface\x22, startRule);\x0d\x0a        parser.addListener(\x22startpage\x22, startRule);\x0d\x0a        parser.addListener(\x22startpagemargin\x22, startRule);\x0d\x0a        parser.addListener(\x22startkeyframerule\x22, startRule);\x0d\x0a        parser.addListener(\x22startviewport\x22, startRule);\x0d\x0a\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var name = event.property.text.toLowerCase();\x0d\x0a\x0d\x0a            if (!properties[name]) {\x0d\x0a                properties[name] = [];\x0d\x0a            }\x0d\x0a\x0d\x0a            properties[name].push({\x0d\x0a                name: event.property,\x0d\x0a                value: event.value,\x0d\x0a                pos: num++\x0d\x0a            });\x0d\x0a        });\x0d\x0a\x0d\x0a        parser.addListener(\x22endrule\x22, endRule);\x0d\x0a        parser.addListener(\x22endfontface\x22, endRule);\x0d\x0a        parser.addListener(\x22endpage\x22, endRule);\x0d\x0a        parser.addListener(\x22endpagemargin\x22, endRule);\x0d\x0a        parser.addListener(\x22endkeyframerule\x22, endRule);\x0d\x0a        parser.addListener(\x22endviewport\x22, endRule);\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a/*\x0d\x0a * Rule: You don\x27t need to specify units when a value is 0.\x0d\x0a */\x0d\x0a\x0d\x0aCSSLint.addRule({\x0d\x0a\x0d\x0a    // rule information\x0d\x0a    id: \x22zero-units\x22,\x0d\x0a    name: \x22Disallow units for 0 values\x22,\x0d\x0a    desc: \x22You don\x27t need to specify units when a value is 0.\x22,\x0d\x0a    url: \x22https://github.com/CSSLint/csslint/wiki/Disallow-units-for-zero-values\x22,\x0d\x0a    browsers: \x22All\x22,\x0d\x0a\x0d\x0a    // initialization\x0d\x0a    init: function(parser, reporter) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var rule = this;\x0d\x0a\x0d\x0a        // count how many times \x22float\x22 is used\x0d\x0a        parser.addListener(\x22property\x22, function(event) {\x0d\x0a            var parts = event.value.parts,\x0d\x0a                i = 0,\x0d\x0a                len = parts.length;\x0d\x0a\x0d\x0a            while (i \x3c len) {\x0d\x0a                if ((parts[i].units || parts[i].type === \x22percentage\x22) && parts[i].value === 0 && parts[i].type !== \x22time\x22) {\x0d\x0a                    reporter.report(\x22Values of 0 shouldn\x27t have units specified.\x22, parts[i].line, parts[i].col, rule);\x0d\x0a                }\x0d\x0a                i++;\x0d\x0a            }\x0d\x0a\x0d\x0a        });\x0d\x0a\x0d\x0a    }\x0d\x0a\x0d\x0a});\x0d\x0a\x0d\x0a(function() {\x0d\x0a    \x22use strict\x22;\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Replace special characters before write to output.\x0d\x0a     *\x0d\x0a     * Rules:\x0d\x0a     *  - single quotes is the escape sequence for double-quotes\x0d\x0a     *  - &amp; is the escape sequence for &\x0d\x0a     *  - &lt; is the escape sequence for \x3c\x0d\x0a     *  - &gt; is the escape sequence for \x3e\x0d\x0a     *\x0d\x0a     * @param {String} message to escape\x0d\x0a     * @return escaped message as {String}\x0d\x0a     */\x0d\x0a    var xmlEscape = function(str) {\x0d\x0a        if (!str || str.constructor !== String) {\x0d\x0a            return \x22\x22;\x0d\x0a        }\x0d\x0a\x0d\x0a        return str.replace(/[\x22&\x3e\x3c]/g, function(match) {\x0d\x0a            switch (match) {\x0d\x0a                case \x22\x5c\x22\x22:\x0d\x0a                    return \x22&quot;\x22;\x0d\x0a                case \x22&\x22:\x0d\x0a                    return \x22&amp;\x22;\x0d\x0a                case \x22\x3c\x22:\x0d\x0a                    return \x22&lt;\x22;\x0d\x0a                case \x22\x3e\x22:\x0d\x0a                    return \x22&gt;\x22;\x0d\x0a            }\x0d\x0a        });\x0d\x0a    };\x0d\x0a\x0d\x0a    CSSLint.addFormatter({\x0d\x0a        // format information\x0d\x0a        id: \x22checkstyle-xml\x22,\x0d\x0a        name: \x22Checkstyle XML format\x22,\x0d\x0a\x0d\x0a        /**\x0d\x0a         * Return opening root XML tag.\x0d\x0a         * @return {String} to prepend before all results\x0d\x0a         */\x0d\x0a        startFormat: function() {\x0d\x0a            return \x22\x3c?xml version=\x5c\x221.0\x5c\x22 encoding=\x5c\x22utf-8\x5c\x22?\x3e\x3ccheckstyle\x3e\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        /**\x0d\x0a         * Return closing root XML tag.\x0d\x0a         * @return {String} to append after all results\x0d\x0a         */\x0d\x0a        endFormat: function() {\x0d\x0a            return \x22\x3c/checkstyle\x3e\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        /**\x0d\x0a         * Returns message when there is a file read error.\x0d\x0a         * @param {String} filename The name of the file that caused the error.\x0d\x0a         * @param {String} message The error message\x0d\x0a         * @return {String} The error message.\x0d\x0a         */\x0d\x0a        readError: function(filename, message) {\x0d\x0a            return \x22\x3cfile name=\x5c\x22\x22 + xmlEscape(filename) + \x22\x5c\x22\x3e\x3cerror line=\x5c\x220\x5c\x22 column=\x5c\x220\x5c\x22 severty=\x5c\x22error\x5c\x22 message=\x5c\x22\x22 + xmlEscape(message) + \x22\x5c\x22\x3e\x3c/error\x3e\x3c/file\x3e\x22;\x0d\x0a        },\x0d\x0a\x0d\x0a        /**\x0d\x0a         * Given CSS Lint results for a file, return output for this format.\x0d\x0a         * @param results {Object} with error and warning messages\x0d\x0a         * @param filename {String} relative file path\x0d\x0a         * @param options {Object} (UNUSED for now) specifies special handling of output\x0d\x0a         * @return {String} output for results\x0d\x0a         */\x0d\x0a        formatResults: function(results, filename/*, options*/) {\x0d\x0a            var messages = results.messages,\x0d\x0a                output = [];\x0d\x0a\x0d\x0a            /**\x0d\x0a             * Generate a source string for a rule.\x0d\x0a             * Checkstyle source strings usually resemble Java class names e.g\x0d\x0a             * net.csslint.SomeRuleName\x0d\x0a             * @param {Object} rule\x0d\x0a             * @return rule source as {String}\x0d\x0a             */\x0d\x0a            var generateSource = function(rule) {\x0d\x0a                if (!rule || !(\x22name\x22 in rule)) {\x0d\x0a                    return \x22\x22;\x0d\x0a                }\x0d\x0a                return \x22net.csslint.\x22 + rule.name.replace(/\x5cs/g, \x22\x22);\x0d\x0a            };\x0d\x0a\x0d\x0a\x0d\x0a            if (messages.length \x3e 0) {\x0d\x0a                output.push(\x22\x3cfile name=\x5c\x22\x22+filename+\x22\x5c\x22\x3e\x22);\x0d\x0a                CSSLint.Util.forEach(messages, function (message) {\x0d\x0a                    // ignore rollups for now\x0d\x0a                    if (!message.rollup) {\x0d\x0a                        output.push(\x22\x3cerror line=\x5c\x22\x22 + message.line + \x22\x5c\x22 column=\x5c\x22\x22 + message.col + \x22\x5c\x22 severity=\x5c\x22\x22 + message.type + \x22\x5c\x22\x22 +\x0d\x0a                          \x22 message=\x5c\x22\x22 + xmlEscape(message.message) + \x22\x5c\x22 source=\x5c\x22\x22 + generateSource(message.rule) +\x22\x5c\x22/\x3e\x22);\x0d\x0a                    }\x0d\x0a                });\x0d\x0a                output.push(\x22\x3c/file\x3e\x22);\x0d\x0a            }\x0d\x0a\x0d\x0a            return output.join(\x22\x22);\x0d\x0a        }\x0d\x0a    });\x0d\x0a\x0d\x0a}());\x0d\x0a\x0d\x0aCSSLint.addFormatter({\x0d\x0a    // format information\x0d\x0a    id: \x22compact\x22,\x0d\x0a    name: \x22Compact, \x27porcelain\x27 format\x22,\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return content to be printed before all file results.\x0d\x0a     * @return {String} to prepend before all results\x0d\x0a     */\x0d\x0a    startFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        return \x22\x22;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return content to be printed after all file results.\x0d\x0a     * @return {String} to append after all results\x0d\x0a     */\x0d\x0a    endFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        return \x22\x22;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Given CSS Lint results for a file, return output for this format.\x0d\x0a     * @param results {Object} with error and warning messages\x0d\x0a     * @param filename {String} relative file path\x0d\x0a     * @param options {Object} (Optional) specifies special handling of output\x0d\x0a     * @return {String} output for results\x0d\x0a     */\x0d\x0a    formatResults: function(results, filename, options) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var messages = results.messages,\x0d\x0a            output = \x22\x22;\x0d\x0a        options = options || {};\x0d\x0a\x0d\x0a        /**\x0d\x0a         * Capitalize and return given string.\x0d\x0a         * @param str {String} to capitalize\x0d\x0a         * @return {String} capitalized\x0d\x0a         */\x0d\x0a        var capitalize = function(str) {\x0d\x0a            return str.charAt(0).toUpperCase() + str.slice(1);\x0d\x0a        };\x0d\x0a\x0d\x0a        if (messages.length === 0) {\x0d\x0a            return options.quiet ? \x22\x22 : filename + \x22: Lint Free!\x22;\x0d\x0a        }\x0d\x0a\x0d\x0a        CSSLint.Util.forEach(messages, function(message) {\x0d\x0a            if (message.rollup) {\x0d\x0a                output += filename + \x22: \x22 + capitalize(message.type) + \x22 - \x22 + message.message + \x22 (\x22 + message.rule.id + \x22)\x5cn\x22;\x0d\x0a            } else {\x0d\x0a                output += filename + \x22: line \x22 + message.line +\x0d\x0a                    \x22, col \x22 + message.col + \x22, \x22 + capitalize(message.type) + \x22 - \x22 + message.message + \x22 (\x22 + message.rule.id + \x22)\x5cn\x22;\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        return output;\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0aCSSLint.addFormatter({\x0d\x0a    // format information\x0d\x0a    id: \x22csslint-xml\x22,\x0d\x0a    name: \x22CSSLint XML format\x22,\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return opening root XML tag.\x0d\x0a     * @return {String} to prepend before all results\x0d\x0a     */\x0d\x0a    startFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        return \x22\x3c?xml version=\x5c\x221.0\x5c\x22 encoding=\x5c\x22utf-8\x5c\x22?\x3e\x3ccsslint\x3e\x22;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return closing root XML tag.\x0d\x0a     * @return {String} to append after all results\x0d\x0a     */\x0d\x0a    endFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        return \x22\x3c/csslint\x3e\x22;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Given CSS Lint results for a file, return output for this format.\x0d\x0a     * @param results {Object} with error and warning messages\x0d\x0a     * @param filename {String} relative file path\x0d\x0a     * @param options {Object} (UNUSED for now) specifies special handling of output\x0d\x0a     * @return {String} output for results\x0d\x0a     */\x0d\x0a    formatResults: function(results, filename/*, options*/) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var messages = results.messages,\x0d\x0a            output = [];\x0d\x0a\x0d\x0a        /**\x0d\x0a         * Replace special characters before write to output.\x0d\x0a         *\x0d\x0a         * Rules:\x0d\x0a         *  - single quotes is the escape sequence for double-quotes\x0d\x0a         *  - &amp; is the escape sequence for &\x0d\x0a         *  - &lt; is the escape sequence for \x3c\x0d\x0a         *  - &gt; is the escape sequence for \x3e\x0d\x0a         *\x0d\x0a         * @param {String} message to escape\x0d\x0a         * @return escaped message as {String}\x0d\x0a         */\x0d\x0a        var escapeSpecialCharacters = function(str) {\x0d\x0a            if (!str || str.constructor !== String) {\x0d\x0a                return \x22\x22;\x0d\x0a            }\x0d\x0a            return str.replace(/\x22/g, \x22\x27\x22).replace(/&/g, \x22&amp;\x22).replace(/\x3c/g, \x22&lt;\x22).replace(/\x3e/g, \x22&gt;\x22);\x0d\x0a        };\x0d\x0a\x0d\x0a        if (messages.length \x3e 0) {\x0d\x0a            output.push(\x22\x3cfile name=\x5c\x22\x22+filename+\x22\x5c\x22\x3e\x22);\x0d\x0a            CSSLint.Util.forEach(messages, function (message) {\x0d\x0a                if (message.rollup) {\x0d\x0a                    output.push(\x22\x3cissue severity=\x5c\x22\x22 + message.type + \x22\x5c\x22 reason=\x5c\x22\x22 + escapeSpecialCharacters(message.message) + \x22\x5c\x22 evidence=\x5c\x22\x22 + escapeSpecialCharacters(message.evidence) + \x22\x5c\x22/\x3e\x22);\x0d\x0a                } else {\x0d\x0a                    output.push(\x22\x3cissue line=\x5c\x22\x22 + message.line + \x22\x5c\x22 char=\x5c\x22\x22 + message.col + \x22\x5c\x22 severity=\x5c\x22\x22 + message.type + \x22\x5c\x22\x22 +\x0d\x0a                        \x22 reason=\x5c\x22\x22 + escapeSpecialCharacters(message.message) + \x22\x5c\x22 evidence=\x5c\x22\x22 + escapeSpecialCharacters(message.evidence) + \x22\x5c\x22/\x3e\x22);\x0d\x0a                }\x0d\x0a            });\x0d\x0a            output.push(\x22\x3c/file\x3e\x22);\x0d\x0a        }\x0d\x0a\x0d\x0a        return output.join(\x22\x22);\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0a/* globals JSON: true */\x0d\x0a\x0d\x0aCSSLint.addFormatter({\x0d\x0a    // format information\x0d\x0a    id: \x22json\x22,\x0d\x0a    name: \x22JSON\x22,\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return content to be printed before all file results.\x0d\x0a     * @return {String} to prepend before all results\x0d\x0a     */\x0d\x0a    startFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        this.json = [];\x0d\x0a        return \x22\x22;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return content to be printed after all file results.\x0d\x0a     * @return {String} to append after all results\x0d\x0a     */\x0d\x0a    endFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var ret = \x22\x22;\x0d\x0a        if (this.json.length \x3e 0) {\x0d\x0a            if (this.json.length === 1) {\x0d\x0a                ret = JSON.stringify(this.json[0]);\x0d\x0a            } else {\x0d\x0a                ret = JSON.stringify(this.json);\x0d\x0a            }\x0d\x0a        }\x0d\x0a        return ret;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Given CSS Lint results for a file, return output for this format.\x0d\x0a     * @param results {Object} with error and warning messages\x0d\x0a     * @param filename {String} relative file path (Unused)\x0d\x0a     * @return {String} output for results\x0d\x0a     */\x0d\x0a    formatResults: function(results, filename, options) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        if (results.messages.length \x3e 0 || !options.quiet) {\x0d\x0a            this.json.push({\x0d\x0a                filename: filename,\x0d\x0a                messages: results.messages,\x0d\x0a                stats: results.stats\x0d\x0a            });\x0d\x0a        }\x0d\x0a        return \x22\x22;\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0aCSSLint.addFormatter({\x0d\x0a    // format information\x0d\x0a    id: \x22junit-xml\x22,\x0d\x0a    name: \x22JUNIT XML format\x22,\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return opening root XML tag.\x0d\x0a     * @return {String} to prepend before all results\x0d\x0a     */\x0d\x0a    startFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        return \x22\x3c?xml version=\x5c\x221.0\x5c\x22 encoding=\x5c\x22utf-8\x5c\x22?\x3e\x3ctestsuites\x3e\x22;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return closing root XML tag.\x0d\x0a     * @return {String} to append after all results\x0d\x0a     */\x0d\x0a    endFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        return \x22\x3c/testsuites\x3e\x22;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Given CSS Lint results for a file, return output for this format.\x0d\x0a     * @param results {Object} with error and warning messages\x0d\x0a     * @param filename {String} relative file path\x0d\x0a     * @param options {Object} (UNUSED for now) specifies special handling of output\x0d\x0a     * @return {String} output for results\x0d\x0a     */\x0d\x0a    formatResults: function(results, filename/*, options*/) {\x0d\x0a        \x22use strict\x22;\x0d\x0a\x0d\x0a        var messages = results.messages,\x0d\x0a            output = [],\x0d\x0a            tests = {\x0d\x0a                \x22error\x22: 0,\x0d\x0a                \x22failure\x22: 0\x0d\x0a            };\x0d\x0a\x0d\x0a        /**\x0d\x0a         * Generate a source string for a rule.\x0d\x0a         * JUNIT source strings usually resemble Java class names e.g\x0d\x0a         * net.csslint.SomeRuleName\x0d\x0a         * @param {Object} rule\x0d\x0a         * @return rule source as {String}\x0d\x0a         */\x0d\x0a        var generateSource = function(rule) {\x0d\x0a            if (!rule || !(\x22name\x22 in rule)) {\x0d\x0a                return \x22\x22;\x0d\x0a            }\x0d\x0a            return \x22net.csslint.\x22 + rule.name.replace(/\x5cs/g, \x22\x22);\x0d\x0a        };\x0d\x0a\x0d\x0a        /**\x0d\x0a         * Replace special characters before write to output.\x0d\x0a         *\x0d\x0a         * Rules:\x0d\x0a         *  - single quotes is the escape sequence for double-quotes\x0d\x0a         *  - &lt; is the escape sequence for \x3c\x0d\x0a         *  - &gt; is the escape sequence for \x3e\x0d\x0a         *\x0d\x0a         * @param {String} message to escape\x0d\x0a         * @return escaped message as {String}\x0d\x0a         */\x0d\x0a        var escapeSpecialCharacters = function(str) {\x0d\x0a\x0d\x0a            if (!str || str.constructor !== String) {\x0d\x0a                return \x22\x22;\x0d\x0a            }\x0d\x0a\x0d\x0a            return str.replace(/\x22/g, \x22\x27\x22).replace(/\x3c/g, \x22&lt;\x22).replace(/\x3e/g, \x22&gt;\x22);\x0d\x0a\x0d\x0a        };\x0d\x0a\x0d\x0a        if (messages.length \x3e 0) {\x0d\x0a\x0d\x0a            messages.forEach(function (message) {\x0d\x0a\x0d\x0a                // since junit has no warning class\x0d\x0a                // all issues as errors\x0d\x0a                var type = message.type === \x22warning\x22 ? \x22error\x22 : message.type;\x0d\x0a\x0d\x0a                // ignore rollups for now\x0d\x0a                if (!message.rollup) {\x0d\x0a\x0d\x0a                    // build the test case separately, once joined\x0d\x0a                    // we\x27ll add it to a custom array filtered by type\x0d\x0a                    output.push(\x22\x3ctestcase time=\x5c\x220\x5c\x22 name=\x5c\x22\x22 + generateSource(message.rule) + \x22\x5c\x22\x3e\x22);\x0d\x0a                    output.push(\x22\x3c\x22 + type + \x22 message=\x5c\x22\x22 + escapeSpecialCharacters(message.message) + \x22\x5c\x22\x3e\x3c![CDATA[\x22 + message.line + \x22:\x22 + message.col + \x22:\x22 + escapeSpecialCharacters(message.evidence) + \x22]]\x3e\x3c/\x22 + type + \x22\x3e\x22);\x0d\x0a                    output.push(\x22\x3c/testcase\x3e\x22);\x0d\x0a\x0d\x0a                    tests[type] += 1;\x0d\x0a\x0d\x0a                }\x0d\x0a\x0d\x0a            });\x0d\x0a\x0d\x0a            output.unshift(\x22\x3ctestsuite time=\x5c\x220\x5c\x22 tests=\x5c\x22\x22 + messages.length + \x22\x5c\x22 skipped=\x5c\x220\x5c\x22 errors=\x5c\x22\x22 + tests.error + \x22\x5c\x22 failures=\x5c\x22\x22 + tests.failure + \x22\x5c\x22 package=\x5c\x22net.csslint\x5c\x22 name=\x5c\x22\x22 + filename + \x22\x5c\x22\x3e\x22);\x0d\x0a            output.push(\x22\x3c/testsuite\x3e\x22);\x0d\x0a\x0d\x0a        }\x0d\x0a\x0d\x0a        return output.join(\x22\x22);\x0d\x0a\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0aCSSLint.addFormatter({\x0d\x0a    // format information\x0d\x0a    id: \x22lint-xml\x22,\x0d\x0a    name: \x22Lint XML format\x22,\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return opening root XML tag.\x0d\x0a     * @return {String} to prepend before all results\x0d\x0a     */\x0d\x0a    startFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        return \x22\x3c?xml version=\x5c\x221.0\x5c\x22 encoding=\x5c\x22utf-8\x5c\x22?\x3e\x3clint\x3e\x22;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return closing root XML tag.\x0d\x0a     * @return {String} to append after all results\x0d\x0a     */\x0d\x0a    endFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        return \x22\x3c/lint\x3e\x22;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Given CSS Lint results for a file, return output for this format.\x0d\x0a     * @param results {Object} with error and warning messages\x0d\x0a     * @param filename {String} relative file path\x0d\x0a     * @param options {Object} (UNUSED for now) specifies special handling of output\x0d\x0a     * @return {String} output for results\x0d\x0a     */\x0d\x0a    formatResults: function(results, filename/*, options*/) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var messages = results.messages,\x0d\x0a            output = [];\x0d\x0a\x0d\x0a        /**\x0d\x0a         * Replace special characters before write to output.\x0d\x0a         *\x0d\x0a         * Rules:\x0d\x0a         *  - single quotes is the escape sequence for double-quotes\x0d\x0a         *  - &amp; is the escape sequence for &\x0d\x0a         *  - &lt; is the escape sequence for \x3c\x0d\x0a         *  - &gt; is the escape sequence for \x3e\x0d\x0a         *\x0d\x0a         * @param {String} message to escape\x0d\x0a         * @return escaped message as {String}\x0d\x0a         */\x0d\x0a        var escapeSpecialCharacters = function(str) {\x0d\x0a            if (!str || str.constructor !== String) {\x0d\x0a                return \x22\x22;\x0d\x0a            }\x0d\x0a            return str.replace(/\x22/g, \x22\x27\x22).replace(/&/g, \x22&amp;\x22).replace(/\x3c/g, \x22&lt;\x22).replace(/\x3e/g, \x22&gt;\x22);\x0d\x0a        };\x0d\x0a\x0d\x0a        if (messages.length \x3e 0) {\x0d\x0a\x0d\x0a            output.push(\x22\x3cfile name=\x5c\x22\x22+filename+\x22\x5c\x22\x3e\x22);\x0d\x0a            CSSLint.Util.forEach(messages, function (message) {\x0d\x0a                if (message.rollup) {\x0d\x0a                    output.push(\x22\x3cissue severity=\x5c\x22\x22 + message.type + \x22\x5c\x22 reason=\x5c\x22\x22 + escapeSpecialCharacters(message.message) + \x22\x5c\x22 evidence=\x5c\x22\x22 + escapeSpecialCharacters(message.evidence) + \x22\x5c\x22/\x3e\x22);\x0d\x0a                } else {\x0d\x0a                    var rule = \x22\x22;\x0d\x0a                    if (message.rule && message.rule.id) {\x0d\x0a                        rule = \x22rule=\x5c\x22\x22 + escapeSpecialCharacters(message.rule.id) + \x22\x5c\x22 \x22;\x0d\x0a                    }\x0d\x0a                    output.push(\x22\x3cissue \x22 + rule + \x22line=\x5c\x22\x22 + message.line + \x22\x5c\x22 char=\x5c\x22\x22 + message.col + \x22\x5c\x22 severity=\x5c\x22\x22 + message.type + \x22\x5c\x22\x22 +\x0d\x0a                        \x22 reason=\x5c\x22\x22 + escapeSpecialCharacters(message.message) + \x22\x5c\x22 evidence=\x5c\x22\x22 + escapeSpecialCharacters(message.evidence) + \x22\x5c\x22/\x3e\x22);\x0d\x0a                }\x0d\x0a            });\x0d\x0a            output.push(\x22\x3c/file\x3e\x22);\x0d\x0a        }\x0d\x0a\x0d\x0a        return output.join(\x22\x22);\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0aCSSLint.addFormatter({\x0d\x0a    // format information\x0d\x0a    id: \x22text\x22,\x0d\x0a    name: \x22Plain Text\x22,\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return content to be printed before all file results.\x0d\x0a     * @return {String} to prepend before all results\x0d\x0a     */\x0d\x0a    startFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        return \x22\x22;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Return content to be printed after all file results.\x0d\x0a     * @return {String} to append after all results\x0d\x0a     */\x0d\x0a    endFormat: function() {\x0d\x0a        \x22use strict\x22;\x0d\x0a        return \x22\x22;\x0d\x0a    },\x0d\x0a\x0d\x0a    /**\x0d\x0a     * Given CSS Lint results for a file, return output for this format.\x0d\x0a     * @param results {Object} with error and warning messages\x0d\x0a     * @param filename {String} relative file path\x0d\x0a     * @param options {Object} (Optional) specifies special handling of output\x0d\x0a     * @return {String} output for results\x0d\x0a     */\x0d\x0a    formatResults: function(results, filename, options) {\x0d\x0a        \x22use strict\x22;\x0d\x0a        var messages = results.messages,\x0d\x0a            output = \x22\x22;\x0d\x0a        options = options || {};\x0d\x0a\x0d\x0a        if (messages.length === 0) {\x0d\x0a            return options.quiet ? \x22\x22 : \x22\x5cn\x5cncsslint: No errors in \x22 + filename + \x22.\x22;\x0d\x0a        }\x0d\x0a\x0d\x0a        output = \x22\x5cn\x5cncsslint: There \x22;\x0d\x0a        if (messages.length === 1) {\x0d\x0a            output += \x22is 1 problem\x22;\x0d\x0a        } else {\x0d\x0a            output += \x22are \x22 + messages.length + \x22 problems\x22;\x0d\x0a        }\x0d\x0a        output += \x22 in \x22 + filename + \x22.\x22;\x0d\x0a\x0d\x0a        var pos = filename.lastIndexOf(\x22/\x22),\x0d\x0a            shortFilename = filename;\x0d\x0a\x0d\x0a        if (pos === -1) {\x0d\x0a            pos = filename.lastIndexOf(\x22\x5c\x5c\x22);\x0d\x0a        }\x0d\x0a        if (pos \x3e -1) {\x0d\x0a            shortFilename = filename.substring(pos+1);\x0d\x0a        }\x0d\x0a\x0d\x0a        CSSLint.Util.forEach(messages, function (message, i) {\x0d\x0a            output = output + \x22\x5cn\x5cn\x22 + shortFilename;\x0d\x0a            if (message.rollup) {\x0d\x0a                output += \x22\x5cn\x22 + (i+1) + \x22: \x22 + message.type;\x0d\x0a                output += \x22\x5cn\x22 + message.message;\x0d\x0a            } else {\x0d\x0a                output += \x22\x5cn\x22 + (i+1) + \x22: \x22 + message.type + \x22 at line \x22 + message.line + \x22, col \x22 + message.col;\x0d\x0a                output += \x22\x5cn\x22 + message.message;\x0d\x0a                output += \x22\x5cn\x22 + message.evidence;\x0d\x0a            }\x0d\x0a        });\x0d\x0a\x0d\x0a        return output;\x0d\x0a    }\x0d\x0a});\x0d\x0a\x0d\x0areturn CSSLint;\x0d\x0a})();unction\xf1\x05'}