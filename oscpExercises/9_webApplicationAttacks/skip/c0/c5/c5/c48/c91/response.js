var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 14:53:14 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Sat, 11 Aug 2018 18:51:24 GMT\x0aETag: \x22b69d-5732d58cb6300-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-10814/10815\x0aContent-Length: 10815\x0aKeep-Alive: timeout=5, max=63\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/**\x0a * @output wp-includes/js/wp-api.js\x0a */\x0a\x0a(function( window, undefined ) {\x0a\x0a\x09\x27use strict\x27;\x0a\x0a\x09/**\x0a\x09 * Initialise the WP_API.\x0a\x09 */\x0a\x09function WP_API() {\x0a\x09\x09/** @namespace wp.api.models */\x0a\x09\x09this.models = {};\x0a\x09\x09/** @namespace wp.api.collections */\x0a\x09\x09this.collections = {};\x0a\x09\x09/** @namespace wp.api.views */\x0a\x09\x09this.views = {};\x0a\x09}\x0a\x0a\x09/** @namespace wp */\x0a\x09window.wp            = window.wp || {};\x0a\x09/** @namespace wp.api */\x0a\x09wp.api               = wp.api || new WP_API();\x0a\x09wp.api.versionString = wp.api.versionString || \x27wp/v2/\x27;\x0a\x0a\x09// Alias _includes to _.contains, ensuring it is available if lodash is used.\x0a\x09if ( ! _.isFunction( _.includes ) && _.isFunction( _.contains ) ) {\x0a\x09  _.includes = _.contains;\x0a\x09}\x0a\x0a})( window );\x0a\x0a(function( window, undefined ) {\x0a\x0a\x09\x27use strict\x27;\x0a\x0a\x09var pad, r;\x0a\x0a\x09/** @namespace wp */\x0a\x09window.wp = window.wp || {};\x0a\x09/** @namespace wp.api */\x0a\x09wp.api = wp.api || {};\x0a\x09/** @namespace wp.api.utils */\x0a\x09wp.api.utils = wp.api.utils || {};\x0a\x0a\x09/**\x0a\x09 * Determine model based on API route.\x0a\x09 *\x0a\x09 * @param {string} route    The API route.\x0a\x09 *\x0a\x09 * @return {Backbone Model} The model found at given route. Undefined if not found.\x0a\x09 */\x0a\x09wp.api.getModelByRoute = function( route ) {\x0a\x09\x09return _.find( wp.api.models, function( model ) {\x0a\x09\x09\x09return model.prototype.route && route === model.prototype.route.index;\x0a\x09\x09} );\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Determine collection based on API route.\x0a\x09 *\x0a\x09 * @param {string} route    The API route.\x0a\x09 *\x0a\x09 * @return {Backbone Model} The collection found at given route. Undefined if not found.\x0a\x09 */\x0a\x09wp.api.getCollectionByRoute = function( route ) {\x0a\x09\x09return _.find( wp.api.collections, function( collection ) {\x0a\x09\x09\x09return collection.prototype.route && route === collection.prototype.route.index;\x0a\x09\x09} );\x0a\x09};\x0a\x0a\x0a\x09/**\x0a\x09 * ECMAScript 5 shim, adapted from MDN.\x0a\x09 * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\x0a\x09 */\x0a\x09if ( ! Date.prototype.toISOString ) {\x0a\x09\x09pad = function( number ) {\x0a\x09\x09\x09r = String( number );\x0a\x09\x09\x09if ( 1 === r.length ) {\x0a\x09\x09\x09\x09r = \x270\x27 + r;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09return r;\x0a\x09\x09};\x0a\x0a\x09\x09Date.prototype.toISOString = function() {\x0a\x09\x09\x09return this.getUTCFullYear() +\x0a\x09\x09\x09\x09\x27-\x27 + pad( this.getUTCMonth() + 1 ) +\x0a\x09\x09\x09\x09\x27-\x27 + pad( this.getUTCDate() ) +\x0a\x09\x09\x09\x09\x27T\x27 + pad( this.getUTCHours() ) +\x0a\x09\x09\x09\x09\x27:\x27 + pad( this.getUTCMinutes() ) +\x0a\x09\x09\x09\x09\x27:\x27 + pad( this.getUTCSeconds() ) +\x0a\x09\x09\x09\x09\x27.\x27 + String( ( this.getUTCMilliseconds() / 1000 ).toFixed( 3 ) ).slice( 2, 5 ) +\x0a\x09\x09\x09\x09\x27Z\x27;\x0a\x09\x09};\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Parse date into ISO8601 format.\x0a\x09 *\x0a\x09 * @param {Date} date.\x0a\x09 */\x0a\x09wp.api.utils.parseISO8601 = function( date ) {\x0a\x09\x09var timestamp, struct, i, k,\x0a\x09\x09\x09minutesOffset = 0,\x0a\x09\x09\x09numericKeys = [ 1, 4, 5, 6, 7, 10, 11 ];\x0a\x0a\x09\x09// ES5 \xc2\xa715.9.4.2 states that the string should attempt to be parsed as a Date Time String Format string\x0a\x09\x09// before falling back to any implementation-specific date parsing, so that\xe2\x80\x99s what we do, even if native\x0a\x09\x09// implementations could be faster.\x0a\x09\x09//              1 YYYY                2 MM       3 DD           4 HH    5 mm       6 ss        7 msec        8 Z 9 \xc2\xb1    10 tzHH    11 tzmm\x0a\x09\x09if ( ( struct = /^(\x5cd{4}|[+\x5c-]\x5cd{6})(?:-(\x5cd{2})(?:-(\x5cd{2}))?)?(?:T(\x5cd{2}):(\x5cd{2})(?::(\x5cd{2})(?:\x5c.(\x5cd{3}))?)?(?:(Z)|([+\x5c-])(\x5cd{2})(?::(\x5cd{2}))?)?)?$/.exec( date ) ) ) {\x0a\x0a\x09\x09\x09// Avoid NaN timestamps caused by \xe2\x80\x9cundefined\xe2\x80\x9d values being passed to Date.UTC.\x0a\x09\x09\x09for ( i = 0; ( k = numericKeys[i] ); ++i ) {\x0a\x09\x09\x09\x09struct[k] = +struct[k] || 0;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Allow undefined days and months.\x0a\x09\x09\x09struct[2] = ( +struct[2] || 1 ) - 1;\x0a\x09\x09\x09struct[3] = +struct[3] || 1;\x0a\x0a\x09\x09\x09if ( \x27Z\x27 !== struct[8]  && undefined !== struct[9] ) {\x0a\x09\x09\x09\x09minutesOffset = struct[10] * 60 + struct[11];\x0a\x0a\x09\x09\x09\x09if ( \x27+\x27 === struct[9] ) {\x0a\x09\x09\x09\x09\x09minutesOffset = 0 - minutesOffset;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09timestamp = Date.UTC( struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7] );\x0a\x09\x09} else {\x0a\x09\x09\x09timestamp = Date.parse ? Date.parse( date ) : NaN;\x0a\x09\x09}\x0a\x0a\x09\x09return timestamp;\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Helper function for getting the root URL.\x0a\x09 * @return {[type]} [description]\x0a\x09 */\x0a\x09wp.api.utils.getRootUrl = function() {\x0a\x09\x09return window.location.origin ?\x0a\x09\x09\x09window.location.origin + \x27/\x27 :\x0a\x09\x09\x09window.location.protocol + \x27//\x27 + window.location.host + \x27/\x27;\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Helper for capitalizing strings.\x0a\x09 */\x0a\x09wp.api.utils.capitalize = function( str ) {\x0a\x09\x09if ( _.isUndefined( str ) ) {\x0a\x09\x09\x09return str;\x0a\x09\x09}\x0a\x09\x09return str.charAt( 0 ).toUpperCase() + str.slice( 1 );\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Helper function that capitalizes the first word and camel cases any words starting\x0a\x09 * after dashes, removing the dashes.\x0a\x09 */\x0a\x09wp.api.utils.capitalizeAndCamelCaseDashes = function( str ) {\x0a\x09\x09if ( _.isUndefined( str ) ) {\x0a\x09\x09\x09return str;\x0a\x09\x09}\x0a\x09\x09str = wp.api.utils.capitalize( str );\x0a\x0a\x09\x09return wp.api.utils.camelCaseDashes( str );\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Helper function to camel case the letter after dashes, removing the dashes.\x0a\x09 */\x0a\x09wp.api.utils.camelCaseDashes = function( str ) {\x0a\x09\x09return str.replace( /-([a-z])/g, function( g ) {\x0a\x09\x09\x09return g[ 1 ].toUpperCase();\x0a\x09\x09} );\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Extract a route part based on negative index.\x0a\x09 *\x0a\x09 * @param {string}   route          The endpoint route.\x0a\x09 * @param {int}      part           The number of parts from the end of the route to retrieve. Default 1.\x0a\x09 *                                  Example route `/a/b/c`: part 1 is `c`, part 2 is `b`, part 3 is `a`.\x0a\x09 * @param {string}  [versionString] Version string, defaults to `wp.api.versionString`.\x0a\x09 * @param {boolean} [reverse]       Whether to reverse the order when extracting the route part. Optional, default false.\x0a\x09 */\x0a\x09wp.api.utils.extractRoutePart = function( route, part, versionString, reverse ) {\x0a\x09\x09var routeParts;\x0a\x0a\x09\x09part = part || 1;\x0a\x09\x09versionString = versionString || wp.api.versionString;\x0a\x0a\x09\x09// Remove versions string from route to avoid returning it.\x0a\x09\x09if ( 0 === route.indexOf( \x27/\x27 + versionString ) ) {\x0a\x09\x09\x09route = route.substr( versionString.length + 1 );\x0a\x09\x09}\x0a\x0a\x09\x09routeParts = route.split( \x27/\x27 );\x0a\x09\x09if ( reverse ) {\x0a\x09\x09\x09routeParts = routeParts.reverse();\x0a\x09\x09}\x0a\x09\x09if ( _.isUndefined( routeParts[ --part ] ) ) {\x0a\x09\x09\x09return \x27\x27;\x0a\x09\x09}\x0a\x09\x09return routeParts[ part ];\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Extract a parent name from a passed route.\x0a\x09 *\x0a\x09 * @param {string} route The route to extract a name from.\x0a\x09 */\x0a\x09wp.api.utils.extractParentName = function( route ) {\x0a\x09\x09var name,\x0a\x09\x09\x09lastSlash = route.lastIndexOf( \x27_id\x3e[\x5c\x5cd]+)/\x27 );\x0a\x0a\x09\x09if ( lastSlash \x3c 0 ) {\x0a\x09\x09\x09return \x27\x27;\x0a\x09\x09}\x0a\x09\x09name = route.substr( 0, lastSlash - 1 );\x0a\x09\x09name = name.split( \x27/\x27 );\x0a\x09\x09name.pop();\x0a\x09\x09name = name.pop();\x0a\x09\x09return name;\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Add args and options to a model prototype from a route\x27s endpoints.\x0a\x09 *\x0a\x09 * @param {array}  routeEndpoints Array of route endpoints.\x0a\x09 * @param {Object} modelInstance  An instance of the model (or collection)\x0a\x09 *                                to add the args to.\x0a\x09 */\x0a\x09wp.api.utils.decorateFromRoute = function( routeEndpoints, modelInstance ) {\x0a\x0a\x09\x09/**\x0a\x09\x09 * Build the args based on route endpoint data.\x0a\x09\x09 */\x0a\x09\x09_.each( routeEndpoints, function( routeEndpoint ) {\x0a\x0a\x09\x09\x09// Add post and edit endpoints as model args.\x0a\x09\x09\x09if ( _.includes( routeEndpoint.methods, \x27POST\x27 ) || _.includes( routeEndpoint.methods, \x27PUT\x27 ) ) {\x0a\x0a\x09\x09\x09\x09// Add any non empty args, merging them into the args object.\x0a\x09\x09\x09\x09if ( ! _.isEmpty( routeEndpoint.args ) ) {\x0a\x0a\x09\x09\x09\x09\x09// Set as default if no args yet.\x0a\x09\x09\x09\x09\x09if ( _.isEmpty( modelInstance.prototype.args ) ) {\x0a\x09\x09\x09\x09\x09\x09modelInstance.prototype.args = routeEndpoint.args;\x0a\x09\x09\x09\x09\x09} else {\x0a\x0a\x09\x09\x09\x09\x09\x09// We already have args, merge these new args in.\x0a\x09\x09\x09\x09\x09\x09modelInstance.prototype.args = _.extend( modelInstance.prototype.args, routeEndpoint.args );\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09} else {\x0a\x0a\x09\x09\x09\x09// Add GET method as model options.\x0a\x09\x09\x09\x09if ( _.includes( routeEndpoint.methods, \x27GET\x27 ) ) {\x0a\x0a\x09\x09\x09\x09\x09// Add any non empty args, merging them into the defaults object.\x0a\x09\x09\x09\x09\x09if ( ! _.isEmpty( routeEndpoint.args ) ) {\x0a\x0a\x09\x09\x09\x09\x09\x09// Set as default if no defaults yet.\x0a\x09\x09\x09\x09\x09\x09if ( _.isEmpty( modelInstance.prototype.options ) ) {\x0a\x09\x09\x09\x09\x09\x09\x09modelInstance.prototype.options = routeEndpoint.args;\x0a\x09\x09\x09\x09\x09\x09} else {\x0a\x0a\x09\x09\x09\x09\x09\x09\x09// We already have options, merge these new args in.\x0a\x09\x09\x09\x09\x09\x09\x09modelInstance.prototype.options = _.extend( modelInstance.prototype.options, routeEndpoint.args );\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09} );\x0a\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Add mixins and helpers to models depending on their defaults.\x0a\x09 *\x0a\x09 * @param {Backbone Model} model          The model to attach helpers and mixins to.\x0a\x09 * @param {string}         modelClassName The classname of the constructed model.\x0a\x09 * @param {Object} \x09       loadingObjects An object containing the models and collections we are building.\x0a\x09 */\x0a\x09wp.api.utils.addMixinsAndHelpers = function( model, modelClassName, loadingObjects ) {\x0a\x0a\x09\x09var hasDate = false,\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Array of parseable dates.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @type {string[]}.\x0a\x09\x09\x09 */\x0a\x09\x09\x09parseableDates = [ \x27date\x27, \x27modified\x27, \x27date_gmt\x27, \x27modified_gmt\x27 ],\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Mixin for all content that is time stamped.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * This mixin converts between mysql timestamps and JavaScript Dates when syncing a model\x0a\x09\x09\x09 * to or from the server. For example, a date stored as `2015-12-27T21:22:24` on the server\x0a\x09\x09\x09 * gets expanded to `Sun Dec 27 2015 14:22:24 GMT-0700 (MST)` when the model is fetched.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @type {{toJSON: toJSON, parse: parse}}.\x0a\x09\x09\x09 */\x0a\x09\x09\x09TimeStampedMixin = {\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Prepare a JavaScript Date for transmitting to the server.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * This helper function accepts a field and Date object. It converts the passed Date\x0a\x09\x09\x09\x09 * to an ISO string and sets that on the model field.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @param {Date}   date   A JavaScript date object. WordPress expects dates in UTC.\x0a\x09\x09\x09\x09 * @param {string} field  The date field to set. One of \x27date\x27, \x27date_gmt\x27, \x27date_modified\x27\x0a\x09\x09\x09\x09 *                        or \x27date_modified_gmt\x27. Optional, defaults to \x27date\x27.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09setDate: function( date, field ) {\x0a\x09\x09\x09\x09\x09var theField = field || \x27date\x27;\x0a\x0a\x09\x09\x09\x09\x09// Don\x27t alter non parsable date fields.\x0a\x09\x09\x09\x09\x09if ( _.indexOf( parseableDates, theField ) \x3c 0 ) {\x0a\x09\x09\x09\x09\x09\x09return false;\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09this.set( theField, date.toISOString() );\x0a\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Get a JavaScript Date from the passed field.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * WordPress returns \x27date\x27 and \x27date_modified\x27 in the timezone of the server as well as\x0a\x09\x09\x09\x09 * UTC dates as \x27date_gmt\x27 and \x27date_modified_gmt\x27. Draft posts do not include UTC dates.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @param {string} field  The date field to set. One of \x27date\x27, \x27date_gmt\x27, \x27date_modified\x27\x0a\x09\x09\x09\x09 *                        or \x27date_modified_gmt\x27. Optional, defaults to \x27date\x27.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09getDate: function( field ) {\x0a\x09\x09\x09\x09\x09var theField   = field || \x27date\x27,\x0a\x09\x09\x09\x09\x09\x09theISODate = this.get( theField );\x0a\x0a\x09\x09\x09\x09\x09// Only get date fields and non null values.\x0a\x09\x09\x09\x09\x09if ( _.indexOf( parseableDates, theField ) \x3c 0 || _.isNull( theISODate ) ) {\x0a\x09\x09\x09\x09\x09\x09return false;\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09return new Date( wp.api.utils.parseISO8601( theISODate ) );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Build a helper function to retrieve related model.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @param  {string} parentModel      The parent model.\x0a\x09\x09\x09 * @param  {int}    modelId          The model ID if the object to request\x0a\x09\x09\x09 * @param  {string} modelName        The model name to use when constructing the model.\x0a\x09\x09\x09 * @param  {string} embedSourcePoint Where to check the embedds object for _embed data.\x0a\x09\x09\x09 * @param  {string} embedCheckField  Which model field to check to see if the model has data.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @return {Deferred.promise}        A promise which resolves to the constructed model.\x0a\x09\x09\x09 */\x0a\x09\x09\x09buildModelGetter = function( parentModel, modelId, modelName, embedSourcePoint, embedCheckField ) {\x0a\x09\x09\x09\x09var getModel, embeddeds, attributes, deferred;\x0a\x0a\x09\x09\x09\x09deferred  = jQuery.Deferred();\x0a\x09\x09\x09\x09embeddeds = parentModel.get( \x27_embedded\x27 ) || {};\x0a\x0a\x09\x09\x09\x09// Verify that we have a valid object id.\x0a\x09\x09\x09\x09if ( ! _.isNumber( modelId ) || 0 === modelId ) {\x0a\x09\x09\x09\x09\x09deferred.reject();\x0a\x09\x09\x09\x09\x09return deferred;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// If we have embedded object data, use that when constructing the getModel.\x0a\x09\x09\x09\x09if ( embeddeds[ embedSourcePoint ] ) {\x0a\x09\x09\x09\x09\x09attributes = _.findWhere( embeddeds[ embedSourcePoint ], { id: modelId } );\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Otherwise use the modelId.\x0a\x09\x09\x09\x09if ( ! attributes ) {\x0a\x09\x09\x09\x09\x09attributes = { id: modelId };\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Create the new getModel model.\x0a\x09\x09\x09\x09getModel = new wp.api.models[ modelName ]( attributes );\x0a\x0a\x09\x09\x09\x09if ( ! getModel.get( embedCheckField ) ) {\x0a\x09\x09\x09\x09\x09getModel.fetch( {\x0a\x09\x09\x09\x09\x09\x09success: function( getModel ) {\x0a\x09\x09\x09\x09\x09\x09\x09deferred.resolve( getModel );\x0a\x09\x09\x09\x09\x09\x09},\x0a\x09\x09\x09\x09\x09\x09error: function( getModel, response ) {\x0a\x09\x09\x09\x09\x09\x09\x09deferred.reject( response );\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09// Resolve with the embedded model.\x0a\x09\x09\x09\x09\x09deferred.resolve( getModel );\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Return a promise.\x0a\x09\x09\x09\x09return deferred.promise();\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Build a helper to retrieve a collection.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @param  {string} parentModel      The parent model.\x0a\x09\x09\x09 * @param  {string} collectionName   The name to use when constructing the collection.\x0a\x09\x09\x09 * @param  {string} embedSourcePoint Where to check the embedds object for _embed data.\x0a\x09\x09\x09 * @param  {string} embedIndex       An addiitonal optional index for the _embed data.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @return {Deferred.promise}        A promise which resolves to the constructed collection.\x0a\x09\x09\x09 */\x0a\x09\x09\x09buildCollectionGetter = function( parentModel, collectionName, embedSourcePoint, embedIndex ) {\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Returns a promise that resolves to the requested collection\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * Uses the embedded data if available, otherwises fetches the\x0a\x09\x09\x09\x09 * data from the server.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @return {Deferred.promise} promise Resolves to a wp.api.collections[ collectionName ]\x0a\x09\x09\x09\x09 * collection.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09var postId, embeddeds, getObjects,\x0a\x09\x09\x09\x09\x09classProperties = \x27\x27,\x0a\x09\x09\x09\x09\x09properties      = \x27\x27,\x0a\x09\x09\x09\x09\x09deferred        = jQuery.Deferred();\x0a\x0a\x09\x09\x09\x09postId    = parentModel.get( \x27id\x27 );\x0a\x09\x09\x09\x09embeddeds = parentModel.get( \x27_embedded\x27 ) || {};\x0a\x0a\x09\x09\x09\x09// Verify that we have a valid post id.\x0a\x09\x09\x09\x09if ( ! _.isNumber( postId ) || 0 === postId ) {\x0a\x09\x09\x09\x09\x09deferred.reject();\x0a\x09\x09\x09\x09\x09return deferred;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// If we have embedded getObjects data, use that when constructing the getObjects.\x0a\x09\x09\x09\x09if ( ! _.isUndefined( embedSourcePoint ) && ! _.isUndefined( embeddeds[ embedSourcePoint ] ) ) {\x0a\x0a\x09\x09\x09\x09\x09// Some embeds also include an index offset, check for that.\x0a\x09\x09\x09\x09\x09if ( _.isUndefined( embedIndex ) ) {\x0a\x0a\x09\x09\x09\x09\x09\x09// Use the embed source point directly.\x0a\x09\x09\x09\x09\x09\x09properties = embeddeds[ embedSourcePoint ];\x0a\x09\x09\x09\x09\x09} else {\x0a\x0a\x09\x09\x09\x09\x09\x09// Add the index to the embed source point.\x0a\x09\x09\x09\x09\x09\x09properties = embeddeds[ embedSourcePoint ][ embedIndex ];\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09} else {\x0a\x0a\x09\x09\x09\x09\x09// Otherwise use the postId.\x0a\x09\x09\x09\x09\x09classProperties = { parent: postId };\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Create the new getObjects collection.\x0a\x09\x09\x09\x09getObjects = new wp.api.collections[ collectionName ]( properties, classProperties );\x0a\x0a\x09\x09\x09\x09// If we didn\xe2\x80\x99t have embedded getObjects, fetch the getObjects data.\x0a\x09\x09\x09\x09if ( _.isUndefined( getObjects.models[0] ) ) {\x0a\x09\x09\x09\x09\x09getObjects.fetch( {\x0a\x09\x09\x09\x09\x09\x09success: function( getObjects ) {\x0a\x0a\x09\x09\x09\x09\x09\x09\x09// Add a helper \x27parent_post\x27 attribute onto the model.\x0a\x09\x09\x09\x09\x09\x09\x09setHelperParentPost( getObjects, postId );\x0a\x09\x09\x09\x09\x09\x09\x09deferred.resolve( getObjects );\x0a\x09\x09\x09\x09\x09\x09},\x0a\x09\x09\x09\x09\x09\x09error: function( getModel, response ) {\x0a\x09\x09\x09\x09\x09\x09\x09deferred.reject( response );\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09} else {\x0a\x0a\x09\x09\x09\x09\x09// Add a helper \x27parent_post\x27 attribute onto the model.\x0a\x09\x09\x09\x09\x09setHelperParentPost( getObjects, postId );\x0a\x09\x09\x09\x09\x09deferred.resolve( getObjects );\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Return a promise.\x0a\x09\x09\x09\x09return deferred.promise();\x0a\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Set the model post parent.\x0a\x09\x09\x09 */\x0a\x09\x09\x09setHelperParentPost = function( collection, postId ) {\x0a\x0a\x09\x09\x09\x09// Attach post_parent id to the collection.\x0a\x09\x09\x09\x09_.each( collection.models, function( model ) {\x0a\x09\x09\x09\x09\x09model.set( \x27parent_post\x27, postId );\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Add a helper function to handle post Meta.\x0a\x09\x09\x09 */\x0a\x09\x09\x09MetaMixin = {\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Get meta by key for a post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @param {string} key The meta key.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @return {object} The post meta value.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09getMeta: function( key ) {\x0a\x09\x09\x09\x09\x09var metas = this.get( \x27meta\x27 );\x0a\x09\x09\x09\x09\x09return metas[ key ];\x0a\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Get all meta key/values for a post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @return {object} The post metas, as a key value pair object.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09getMetas: function() {\x0a\x09\x09\x09\x09\x09return this.get( \x27meta\x27 );\x0a\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Set a group of meta key/values for a post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @param {object} meta The post meta to set, as key/value pairs.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09setMetas: function( meta ) {\x0a\x09\x09\x09\x09\x09var metas = this.get( \x27meta\x27 );\x0a\x09\x09\x09\x09\x09_.extend( metas, meta );\x0a\x09\x09\x09\x09\x09this.set( \x27meta\x27, metas );\x0a\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Set a single meta value for a post, by key.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @param {string} key   The meta key.\x0a\x09\x09\x09\x09 * @param {object} value The meta value.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09setMeta: function( key, value ) {\x0a\x09\x09\x09\x09\x09var metas = this.get( \x27meta\x27 );\x0a\x09\x09\x09\x09\x09metas[ key ] = value;\x0a\x09\x09\x09\x09\x09this.set( \x27meta\x27, metas );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Add a helper function to handle post Revisions.\x0a\x09\x09\x09 */\x0a\x09\x09\x09RevisionsMixin = {\x0a\x09\x09\x09\x09getRevisions: function() {\x0a\x09\x09\x09\x09\x09return buildCollectionGetter( this, \x27PostRevisions\x27 );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Add a helper function to handle post Tags.\x0a\x09\x09\x09 */\x0a\x09\x09\x09TagsMixin = {\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Get the tags for a post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @return {Deferred.promise} promise Resolves to an array of tags.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09getTags: function() {\x0a\x09\x09\x09\x09\x09var tagIds = this.get( \x27tags\x27 ),\x0a\x09\x09\x09\x09\x09\x09tags  = new wp.api.collections.Tags();\x0a\x0a\x09\x09\x09\x09\x09// Resolve with an empty array if no tags.\x0a\x09\x09\x09\x09\x09if ( _.isEmpty( tagIds ) ) {\x0a\x09\x09\x09\x09\x09\x09return jQuery.Deferred().resolve( [] );\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09return tags.fetch( { data: { include: tagIds } } );\x0a\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Set the tags for a post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * Accepts an array of tag slugs, or a Tags collection.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @param {array|Backbone.Collection} tags The tags to set on the post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09setTags: function( tags ) {\x0a\x09\x09\x09\x09\x09var allTags, newTag,\x0a\x09\x09\x09\x09\x09\x09self = this,\x0a\x09\x09\x09\x09\x09\x09newTags = [];\x0a\x0a\x09\x09\x09\x09\x09if ( _.isString( tags ) ) {\x0a\x09\x09\x09\x09\x09\x09return false;\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09// If this is an array of slugs, build a collection.\x0a\x09\x09\x09\x09\x09if ( _.isArray( tags ) ) {\x0a\x0a\x09\x09\x09\x09\x09\x09// Get all the tags.\x0a\x09\x09\x09\x09\x09\x09allTags = new wp.api.collections.Tags();\x0a\x09\x09\x09\x09\x09\x09allTags.fetch( {\x0a\x09\x09\x09\x09\x09\x09\x09data:    { per_page: 100 },\x0a\x09\x09\x09\x09\x09\x09\x09success: function( alltags ) {\x0a\x0a\x09\x09\x09\x09\x09\x09\x09\x09// Find the passed tags and set them up.\x0a\x09\x09\x09\x09\x09\x09\x09\x09_.each( tags, function( tag ) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09newTag = new wp.api.models.Tag( alltags.findWhere( { slug: tag } ) );\x0a\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09// Tie the new tag to the post.\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09newTag.set( \x27parent_post\x27, self.get( \x27id\x27 ) );\x0a\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09// Add the new tag to the collection.\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09newTags.push( newTag );\x0a\x09\x09\x09\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09\x09\x09\x09\x09tags = new wp.api.collections.Tags( newTags );\x0a\x09\x09\x09\x09\x09\x09\x09\x09self.setTagsWithCollection( tags );\x0a\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09this.setTagsWithCollection( tags );\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Set the tags for a post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * Accepts a Tags collection.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @param {array|Backbone.Collection} tags The tags to set on the post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09setTagsWithCollection: function( tags ) {\x0a\x0a\x09\x09\x09\x09\x09// Pluck out the category ids.\x0a\x09\x09\x09\x09\x09this.set( \x27tags\x27, tags.pluck( \x27id\x27 ) );\x0a\x09\x09\x09\x09\x09return this.save();\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Add a helper function to handle post Categories.\x0a\x09\x09\x09 */\x0a\x09\x09\x09CategoriesMixin = {\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Get a the categories for a post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @return {Deferred.promise} promise Resolves to an array of categories.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09getCategories: function() {\x0a\x09\x09\x09\x09\x09var categoryIds = this.get( \x27categories\x27 ),\x0a\x09\x09\x09\x09\x09\x09categories  = new wp.api.collections.Categories();\x0a\x0a\x09\x09\x09\x09\x09// Resolve with an empty array if no categories.\x0a\x09\x09\x09\x09\x09if ( _.isEmpty( categoryIds ) ) {\x0a\x09\x09\x09\x09\x09\x09return jQuery.Deferred().resolve( [] );\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09return categories.fetch( { data: { include: categoryIds } } );\x0a\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Set the categories for a post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * Accepts an array of category slugs, or a Categories collection.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @param {array|Backbone.Collection} categories The categories to set on the post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09setCategories: function( categories ) {\x0a\x09\x09\x09\x09\x09var allCategories, newCategory,\x0a\x09\x09\x09\x09\x09\x09self = this,\x0a\x09\x09\x09\x09\x09\x09newCategories = [];\x0a\x0a\x09\x09\x09\x09\x09if ( _.isString( categories ) ) {\x0a\x09\x09\x09\x09\x09\x09return false;\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09// If this is an array of slugs, build a collection.\x0a\x09\x09\x09\x09\x09if ( _.isArray( categories ) ) {\x0a\x0a\x09\x09\x09\x09\x09\x09// Get all the categories.\x0a\x09\x09\x09\x09\x09\x09allCategories = new wp.api.collections.Categories();\x0a\x09\x09\x09\x09\x09\x09allCategories.fetch( {\x0a\x09\x09\x09\x09\x09\x09\x09data:    { per_page: 100 },\x0a\x09\x09\x09\x09\x09\x09\x09success: function( allcats ) {\x0a\x0a\x09\x09\x09\x09\x09\x09\x09\x09// Find the passed categories and set them up.\x0a\x09\x09\x09\x09\x09\x09\x09\x09_.each( categories, function( category ) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09newCategory = new wp.api.models.Category( allcats.findWhere( { slug: category } ) );\x0a\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09// Tie the new category to the post.\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09newCategory.set( \x27parent_post\x27, self.get( \x27id\x27 ) );\x0a\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09// Add the new category to the collection.\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09newCategories.push( newCategory );\x0a\x09\x09\x09\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09\x09\x09\x09\x09categories = new wp.api.collections.Categories( newCategories );\x0a\x09\x09\x09\x09\x09\x09\x09\x09self.setCategoriesWithCollection( categories );\x0a\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09this.setCategoriesWithCollection( categories );\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09 * Set the categories for a post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * Accepts Categories collection.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 * @param {array|Backbone.Collection} categories The categories to set on the post.\x0a\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09setCategoriesWithCollection: function( categories ) {\x0a\x0a\x09\x09\x09\x09\x09// Pluck out the category ids.\x0a\x09\x09\x09\x09\x09this.set( \x27categories\x27, categories.pluck( \x27id\x27 ) );\x0a\x09\x09\x09\x09\x09return this.save();\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Add a helper function to retrieve the author user model.\x0a\x09\x09\x09 */\x0a\x09\x09\x09AuthorMixin = {\x0a\x09\x09\x09\x09getAuthorUser: function() {\x0a\x09\x09\x09\x09\x09return buildModelGetter( this, this.get( \x27author\x27 ), \x27User\x27, \x27author\x27, \x27name\x27 );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Add a helper function to retrieve the featured media.\x0a\x09\x09\x09 */\x0a\x09\x09\x09FeaturedMediaMixin = {\x0a\x09\x09\x09\x09getFeaturedMedia: function() {\x0a\x09\x09\x09\x09\x09return buildModelGetter( this, this.get( \x27featured_media\x27 ), \x27Media\x27, \x27wp:featuredmedia\x27, \x27source_url\x27 );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09};\x0a\x0a\x09\x09// Exit if we don\x27t have valid model defaults.\x0a\x09\x09if ( _.isUndefined( model.prototype.args ) ) {\x0a\x09\x09\x09return model;\x0a\x09\x09}\x0a\x0a\x09\x09// Go thru the parsable date fields, if our model contains any of them it gets the TimeStampedMixin.\x0a\x09\x09_.each( parseableDates, function( theDateKey ) {\x0a\x09\x09\x09if ( ! _.isUndefined( model.prototype.args[ theDateKey ] ) ) {\x0a\x09\x09\x09\x09hasDate = true;\x0a\x09\x09\x09}\x0a\x09\x09} );\x0a\x0a\x09\x09// Add the TimeStampedMixin for models that contain a date field.\x0a\x09\x09if ( hasDate ) {\x0a\x09\x09\x09model = model.extend( TimeStampedMixin );\x0a\x09\x09}\x0a\x0a\x09\x09// Add the AuthorMixin for models that contain an author.\x0a\x09\x09if ( ! _.isUndefined( model.prototype.args.author ) ) {\x0a\x09\x09\x09model = model.extend( AuthorMixin );\x0a\x09\x09}\x0a\x0a\x09\x09// Add the FeaturedMediaMixin for models that contain a featured_media.\x0a\x09\x09if ( ! _.isUndefined( model.prototype.args.featured_media ) ) {\x0a\x09\x09\x09model = model.extend( FeaturedMediaMixin );\x0a\x09\x09}\x0a\x0a\x09\x09// Add the CategoriesMixin for models that support categories collections.\x0a\x09\x09if ( ! _.isUndefined( model.prototype.args.categories ) ) {\x0a\x09\x09\x09model = model.extend( CategoriesMixin );\x0a\x09\x09}\x0a\x0a\x09\x09// Add the MetaMixin for models that support meta.\x0a\x09\x09if ( ! _.isUndefined( model.prototype.args.meta ) ) {\x0a\x09\x09\x09model = model.extend( MetaMixin );\x0a\x09\x09}\x0a\x0a\x09\x09// Add the TagsMixin for models that support tags collections.\x0a\x09\x09if ( ! _.isUndefined( model.prototype.args.tags ) ) {\x0a\x09\x09\x09model = model.extend( TagsMixin );\x0a\x09\x09}\x0a\x0a\x09\x09// Add the RevisionsMixin for models that support revisions collections.\x0a\x09\x09if ( ! _.isUndefined( loadingObjects.collections[ modelClassName + \x27Revisions\x27 ] ) ) {\x0a\x09\x09\x09model = model.extend( RevisionsMixin );\x0a\x09\x09}\x0a\x0a\x09\x09return model;\x0a\x09};\x0a\x0a})( window );\x0a\x0a/* global wpApiSettings:false */\x0a\x0a// Suppress warning about parse function\x27s unused \x22options\x22 argument:\x0a/* jshint unused:false */\x0a(function() {\x0a\x0a\x09\x27use strict\x27;\x0a\x0a\x09var wpApiSettings = window.wpApiSettings || {},\x0a\x09trashableTypes    = [ \x27Comment\x27, \x27Media\x27, \x27Comment\x27, \x27Post\x27, \x27Page\x27, \x27Status\x27, \x27Taxonomy\x27, \x27Type\x27 ];\x0a\x0a\x09/**\x0a\x09 * Backbone base model for all models.\x0a\x09 */\x0a\x09wp.api.WPApiBaseModel = Backbone.Model.extend(\x0a\x09\x09/** @lends WPApiBaseModel.prototype  */\x0a\x09\x09{\x0a\x0a\x09\x09\x09// Initialize the model.\x0a\x09\x09\x09initialize: function() {\x0a\x0a\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09* Types that don\x27t support trashing require passing ?force=true to delete.\x0a\x09\x09\x09\x09*\x0a\x09\x09\x09\x09*/\x0a\x09\x09\x09\x09if ( -1 === _.indexOf( trashableTypes, this.name ) ) {\x0a\x09\x09\x09\x09\x09this.requireForceForDelete = true;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Set nonce header before every Backbone sync.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @param {string} method.\x0a\x09\x09\x09 * @param {Backbone.Model} model.\x0a\x09\x09\x09 * @param {{beforeSend}, *} options.\x0a\x09\x09\x09 * @returns {*}.\x0a\x09\x09\x09 */\x0a\x09\x09\x09sync: function( method, model, options ) {\x0a\x09\x09\x09\x09var beforeSend;\x0a\x0a\x09\x09\x09\x09options = options || {};\x0a\x0a\x09\x09\x09\x09// Remove date_gmt if null.\x0a\x09\x09\x09\x09if ( _.isNull( model.get( \x27date_gmt\x27 ) ) ) {\x0a\x09\x09\x09\x09\x09model.unset( \x27date_gmt\x27 );\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Remove slug if empty.\x0a\x09\x09\x09\x09if ( _.isEmpty( model.get( \x27slug\x27 ) ) ) {\x0a\x09\x09\x09\x09\x09model.unset( \x27slug\x27 );\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09if ( _.isFunction( model.nonce ) && ! _.isEmpty( model.nonce() ) ) {\x0a\x09\x09\x09\x09\x09beforeSend = options.beforeSend;\x0a\x0a\x09\x09\x09\x09\x09// @todo enable option for jsonp endpoints\x0a\x09\x09\x09\x09\x09// options.dataType = \x27jsonp\x27;\x0a\x0a\x09\x09\x09\x09\x09// Include the nonce with requests.\x0a\x09\x09\x09\x09\x09options.beforeSend = function( xhr ) {\x0a\x09\x09\x09\x09\x09\x09xhr.setRequestHeader( \x27X-WP-Nonce\x27, model.nonce() );\x0a\x0a\x09\x09\x09\x09\x09\x09if ( beforeSend ) {\x0a\x09\x09\x09\x09\x09\x09\x09return beforeSend.apply( this, arguments );\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09};\x0a\x0a\x09\x09\x09\x09\x09// Update the nonce when a new nonce is returned with the response.\x0a\x09\x09\x09\x09\x09options.complete = function( xhr ) {\x0a\x09\x09\x09\x09\x09\x09var returnedNonce = xhr.getResponseHeader( \x27X-WP-Nonce\x27 );\x0a\x0a\x09\x09\x09\x09\x09\x09if ( returnedNonce && _.isFunction( model.nonce ) && model.nonce() !== returnedNonce ) {\x0a\x09\x09\x09\x09\x09\x09\x09model.endpointModel.set( \x27nonce\x27, returnedNonce );\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09};\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Add \x27?force=true\x27 to use delete method when required.\x0a\x09\x09\x09\x09if ( this.requireForceForDelete && \x27delete\x27 === method ) {\x0a\x09\x09\x09\x09\x09model.url = model.url() + \x27?force=true\x27;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09return Backbone.sync( method, model, options );\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Save is only allowed when the PUT OR POST methods are available for the endpoint.\x0a\x09\x09\x09 */\x0a\x09\x09\x09save: function( attrs, options ) {\x0a\x0a\x09\x09\x09\x09// Do we have the put method, then execute the save.\x0a\x09\x09\x09\x09if ( _.includes( this.methods, \x27PUT\x27 ) || _.includes( this.methods, \x27POST\x27 ) ) {\x0a\x0a\x09\x09\x09\x09\x09// Proxy the call to the original save function.\x0a\x09\x09\x09\x09\x09return Backbone.Model.prototype.save.call( this, attrs, options );\x0a\x09\x09\x09\x09} else {\x0a\x0a\x09\x09\x09\x09\x09// Otherwise bail, disallowing action.\x0a\x09\x09\x09\x09\x09return false;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Delete is only allowed when the DELETE method is available for the endpoint.\x0a\x09\x09\x09 */\x0a\x09\x09\x09destroy: function( options ) {\x0a\x0a\x09\x09\x09\x09// Do we have the DELETE method, then execute the destroy.\x0a\x09\x09\x09\x09if ( _.includes( this.methods, \x27DELETE\x27 ) ) {\x0a\x0a\x09\x09\x09\x09\x09// Proxy the call to the original save function.\x0a\x09\x09\x09\x09\x09return Backbone.Model.prototype.destroy.call( this, options );\x0a\x09\x09\x09\x09} else {\x0a\x0a\x09\x09\x09\x09\x09// Otherwise bail, disallowing action.\x0a\x09\x09\x09\x09\x09return false;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09}\x0a\x09);\x0a\x0a\x09/**\x0a\x09 * API Schema model. Contains meta information about the API.\x0a\x09 */\x0a\x09wp.api.models.Schema = wp.api.WPApiBaseModel.extend(\x0a\x09\x09/** @lends Schema.prototype  */\x0a\x09\x09{\x0a\x09\x09\x09defaults: {\x0a\x09\x09\x09\x09_links: {},\x0a\x09\x09\x09\x09namespace: null,\x0a\x09\x09\x09\x09routes: {}\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09initialize: function( attributes, options ) {\x0a\x09\x09\x09\x09var model = this;\x0a\x09\x09\x09\x09options = options || {};\x0a\x0a\x09\x09\x09\x09wp.api.WPApiBaseModel.prototype.initialize.call( model, attributes, options );\x0a\x0a\x09\x09\x09\x09model.apiRoot = options.apiRoot || wpApiSettings.root;\x0a\x09\x09\x09\x09model.versionString = options.versionString || wpApiSettings.versionString;\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09url: function() {\x0a\x09\x09\x09\x09return this.apiRoot + this.versionString;\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09);\x0a})();\x0a\x0a( function() {\x0a\x0a\x09\x27use strict\x27;\x0a\x0a\x09var wpApiSettings = window.wpApiSettings || {};\x0a\x0a\x09/**\x0a\x09 * Contains basic collection functionality such as pagination.\x0a\x09 */\x0a\x09wp.api.WPApiBaseCollection = Backbone.Collection.extend(\x0a\x09\x09/** @lends BaseCollection.prototype  */\x0a\x09\x09{\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Setup default state.\x0a\x09\x09\x09 */\x0a\x09\x09\x09initialize: function( models, options ) {\x0a\x09\x09\x09\x09this.state = {\x0a\x09\x09\x09\x09\x09data: {},\x0a\x09\x09\x09\x09\x09currentPage: null,\x0a\x09\x09\x09\x09\x09totalPages: null,\x0a\x09\x09\x09\x09\x09totalObjects: null\x0a\x09\x09\x09\x09};\x0a\x09\x09\x09\x09if ( _.isUndefined( options ) ) {\x0a\x09\x09\x09\x09\x09this.parent = \x27\x27;\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09this.parent = options.parent;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Extend Backbone.Collection.sync to add nince and pagination support.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * Set nonce header before every Backbone sync.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @param {string} method.\x0a\x09\x09\x09 * @param {Backbone.Model} model.\x0a\x09\x09\x09 * @param {{success}, *} options.\x0a\x09\x09\x09 * @returns {*}.\x0a\x09\x09\x09 */\x0a\x09\x09\x09sync: function( method, model, options ) {\x0a\x09\x09\x09\x09var beforeSend, success,\x0a\x09\x09\x09\x09\x09self = this;\x0a\x0a\x09\x09\x09\x09options = options || {};\x0a\x0a\x09\x09\x09\x09if ( _.isFunction( model.nonce ) && ! _.isEmpty( model.nonce() ) ) {\x0a\x09\x09\x09\x09\x09beforeSend = options.beforeSend;\x0a\x0a\x09\x09\x09\x09\x09// Include the nonce with requests.\x0a\x09\x09\x09\x09\x09options.beforeSend = function( xhr ) {\x0a\x09\x09\x09\x09\x09\x09xhr.setRequestHeader( \x27X-WP-Nonce\x27, model.nonce() );\x0a\x0a\x09\x09\x09\x09\x09\x09if ( beforeSend ) {\x0a\x09\x09\x09\x09\x09\x09\x09return beforeSend.apply( self, arguments );\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09};\x0a\x0a\x09\x09\x09\x09\x09// Update the nonce when a new nonce is returned with the response.\x0a\x09\x09\x09\x09\x09options.complete = function( xhr ) {\x0a\x09\x09\x09\x09\x09\x09var returnedNonce = xhr.getResponseHeader( \x27X-WP-Nonce\x27 );\x0a\x0a\x09\x09\x09\x09\x09\x09if ( returnedNonce && _.isFunction( model.nonce ) && model.nonce() !== returnedNonce ) {\x0a\x09\x09\x09\x09\x09\x09\x09model.endpointModel.set( \x27nonce\x27, returnedNonce );\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09};\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// When reading, add pagination data.\x0a\x09\x09\x09\x09if ( \x27read\x27 === method ) {\x0a\x09\x09\x09\x09\x09if ( options.data ) {\x0a\x09\x09\x09\x09\x09\x09self.state.data = _.clone( options.data );\x0a\x0a\x09\x09\x09\x09\x09\x09delete self.state.data.page;\x0a\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09self.state.data = options.data = {};\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09if ( \x27undefined\x27 === typeof options.data.page ) {\x0a\x09\x09\x09\x09\x09\x09self.state.currentPage  = null;\x0a\x09\x09\x09\x09\x09\x09self.state.totalPages   = null;\x0a\x09\x09\x09\x09\x09\x09self.state.totalObjects = null;\x0a\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09self.state.currentPage = options.data.page - 1;\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09success = options.success;\x0a\x09\x09\x09\x09\x09options.success = function( data, textStatus, request ) {\x0a\x09\x09\x09\x09\x09\x09if ( ! _.isUndefined( request ) ) {\x0a\x09\x09\x09\x09\x09\x09\x09self.state.totalPages   = parseInt( request.getResponseHeader( \x27x-wp-totalpages\x27 ), 10 );\x0a\x09\x09\x09\x09\x09\x09\x09self.state.totalObjects = parseInt( request.getResponseHeader( \x27x-wp-total\x27 ), 10 );\x0a\x09\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09\x09if ( null === self.state.currentPage ) {\x0a\x09\x09\x09\x09\x09\x09\x09self.state.currentPage = 1;\x0a\x09\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09\x09self.state.currentPage++;\x0a\x09\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09\x09if ( success ) {\x0a\x09\x09\x09\x09\x09\x09\x09return success.apply( this, arguments );\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09};\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Continue by calling Bacckbone\x27s sync.\x0a\x09\x09\x09\x09return Backbone.sync( method, model, options );\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Fetches the next page of objects if a new page exists.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @param {data: {page}} options.\x0a\x09\x09\x09 * @returns {*}.\x0a\x09\x09\x09 */\x0a\x09\x09\x09more: function( options ) {\x0a\x09\x09\x09\x09options = options || {};\x0a\x09\x09\x09\x09options.data = options.data || {};\x0a\x0a\x09\x09\x09\x09_.extend( options.data, this.state.data );\x0a\x0a\x09\x09\x09\x09if ( \x27undefined\x27 === typeof options.data.page ) {\x0a\x09\x09\x09\x09\x09if ( ! this.hasMore() ) {\x0a\x09\x09\x09\x09\x09\x09return false;\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09if ( null === this.state.currentPage || this.state.currentPage \x3c= 1 ) {\x0a\x09\x09\x09\x09\x09\x09options.data.page = 2;\x0a\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09options.data.page = this.state.currentPage + 1;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09return this.fetch( options );\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Returns true if there are more pages of objects available.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * @returns null|boolean.\x0a\x09\x09\x09 */\x0a\x09\x09\x09hasMore: function() {\x0a\x09\x09\x09\x09if ( null === this.state.totalPages ||\x0a\x09\x09\x09\x09\x09 null === this.state.totalObjects ||\x0a\x09\x09\x09\x09\x09 null === this.state.currentPage ) {\x0a\x09\x09\x09\x09\x09return null;\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09return ( this.state.currentPage \x3c this.state.totalPages );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09);\x0a\x0a} )();\x0a\x0a( function() {\x0a\x0a\x09\x27use strict\x27;\x0a\x0a\x09var Endpoint, initializedDeferreds = {},\x0a\x09\x09wpApiSettings = window.wpApiSettings || {};\x0a\x0a\x09/** @namespace wp */\x0a\x09window.wp = window.wp || {};\x0a\x0a\x09/** @namespace wp.api */\x0a\x09wp.api    = wp.api || {};\x0a\x0a\x09// If wpApiSettings is unavailable, try the default.\x0a\x09if ( _.isEmpty( wpApiSettings ) ) {\x0a\x09\x09wpApiSettings.root = window.location.origin + \x27/wp-json/\x27;\x0a\x09}\x0a\x0a\x09Endpoint = Backbone.Model.extend(/** @lends Endpoint.prototype */{\x0a\x09\x09defaults: {\x0a\x09\x09\x09apiRoot: wpApiSettings.root,\x0a\x09\x09\x09versionString: wp.api.versionString,\x0a\x09\x09\x09nonce: null,\x0a\x09\x09\x09schema: null,\x0a\x09\x09\x09models: {},\x0a\x09\x09\x09collections: {}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Initialize the Endpoint model.\x0a\x09\x09 */\x0a\x09\x09initialize: function() {\x0a\x09\x09\x09var model = this, deferred;\x0a\x0a\x09\x09\x09Backbone.Model.prototype.initialize.apply( model, arguments );\x0a\x0a\x09\x09\x09deferred = jQuery.Deferred();\x0a\x09\x09\x09model.schemaConstructed = deferred.promise();\x0a\x0a\x09\x09\x09model.schemaModel = new wp.api.models.Schema( null, {\x0a\x09\x09\x09\x09apiRoot:       model.get( \x27apiRoot\x27 ),\x0a\x09\x09\x09\x09versionString: model.get( \x27versionString\x27 ),\x0a\x09\x09\x09\x09nonce:         model.get( \x27nonce\x27 )\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09// When the model loads, resolve the promise.\x0a\x09\x09\x09model.schemaModel.once( \x27change\x27, function() {\x0a\x09\x09\x09\x09model.constructFromSchema();\x0a\x09\x09\x09\x09deferred.resolve( model );\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09if ( model.get( \x27schema\x27 ) ) {\x0a\x0a\x09\x09\x09\x09// Use schema supplied as model attribute.\x0a\x09\x09\x09\x09model.schemaModel.set( model.schemaModel.parse( model.get( \x27schema\x27 ) ) );\x0a\x09\x09\x09} else if (\x0a\x09\x09\x09\x09! _.isUndefined( sessionStorage ) &&\x0a\x09\x09\x09\x09( _.isUndefined( wpApiSettings.cacheSchema ) || wpApiSettings.cacheSchema ) &&\x0a\x09\x09\x09\x09sessionStorage.getItem( \x27wp-api-schema-model\x27 + model.get( \x27apiRoot\x27 ) + model.get( \x27versionString\x27 ) )\x0a\x09\x09\x09) {\x0a\x0a\x09\x09\x09\x09// Used a cached copy of the schema model if available.\x0a\x09\x09\x09\x09model.schemaModel.set( model.schemaModel.parse( JSON.parse( sessionStorage.getItem( \x27wp-api-schema-model\x27 + model.get( \x27apiRoot\x27 ) + model.get( \x27versionString\x27 ) ) ) ) );\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09model.schemaModel.fetch( {\x0a\x09\x09\x09\x09\x09/**\x0a\x09\x09\x09\x09\x09 * When the server returns the schema model data, store the data in a sessionCache so we don\x27t\x0a\x09\x09\x09\x09\x09 * have to retrieve it again for this session. Then, construct the models and collections based\x0a\x09\x09\x09\x09\x09 * on the schema model data.\x0a\x09\x09\x09\x09\x09 *\x0a\x09\x09\x09\x09\x09 * @ignore\x0a\x09\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09\x09success: function( newSchemaModel ) {\x0a\x0a\x09\x09\x09\x09\x09\x09// Store a copy of the schema model in the session cache if available.\x0a\x09\x09\x09\x09\x09\x09if ( ! _.isUndefined( sessionStorage ) && ( _.isUndefined( wpApiSettings.cacheSchema ) || wpApiSettings.cacheSchema ) ) {\x0a\x09\x09\x09\x09\x09\x09\x09try {\x0a\x09\x09\x09\x09\x09\x09\x09\x09sessionStorage.setItem( \x27wp-api-schema-model\x27 + model.get( \x27apiRoot\x27 ) + model.get( \x27versionString\x27 ), JSON.stringify( newSchemaModel ) );\x0a\x09\x09\x09\x09\x09\x09\x09} catch ( error ) {\x0a\x0a\x09\x09\x09\x09\x09\x09\x09\x09// Fail silently, fixes errors in safari private mode.\x0a\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09\x09// Log the error condition.\x0a\x09\x09\x09\x09\x09error: function( err ) {\x0a\x09\x09\x09\x09\x09\x09window.console.log( err );\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09constructFromSchema: function() {\x0a\x09\x09\x09var routeModel = this, modelRoutes, collectionRoutes, schemaRoot, loadingObjects,\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Set up the model and collection name mapping options. As the schema is built, the\x0a\x09\x09\x09 * model and collection names will be adjusted if they are found in the mapping object.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * Localizing a variable wpApiSettings.mapping will over-ride the default mapping options.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 */\x0a\x09\x09\x09mapping = wpApiSettings.mapping || {\x0a\x09\x09\x09\x09models: {\x0a\x09\x09\x09\x09\x09\x27Categories\x27:      \x27Category\x27,\x0a\x09\x09\x09\x09\x09\x27Comments\x27:        \x27Comment\x27,\x0a\x09\x09\x09\x09\x09\x27Pages\x27:           \x27Page\x27,\x0a\x09\x09\x09\x09\x09\x27PagesMeta\x27:       \x27PageMeta\x27,\x0a\x09\x09\x09\x09\x09\x27PagesRevisions\x27:  \x27PageRevision\x27,\x0a\x09\x09\x09\x09\x09\x27Posts\x27:           \x27Post\x27,\x0a\x09\x09\x09\x09\x09\x27PostsCategories\x27: \x27PostCategory\x27,\x0a\x09\x09\x09\x09\x09\x27PostsRevisions\x27:  \x27PostRevision\x27,\x0a\x09\x09\x09\x09\x09\x27PostsTags\x27:       \x27PostTag\x27,\x0a\x09\x09\x09\x09\x09\x27Schema\x27:          \x27Schema\x27,\x0a\x09\x09\x09\x09\x09\x27Statuses\x27:        \x27Status\x27,\x0a\x09\x09\x09\x09\x09\x27Tags\x27:            \x27Tag\x27,\x0a\x09\x09\x09\x09\x09\x27Taxonomies\x27:      \x27Taxonomy\x27,\x0a\x09\x09\x09\x09\x09\x27Types\x27:           \x27Type\x27,\x0a\x09\x09\x09\x09\x09\x27Users\x27:           \x27User\x27\x0a\x09\x09\x09\x09},\x0a\x09\x09\x09\x09collections: {\x0a\x09\x09\x09\x09\x09\x27PagesMeta\x27:       \x27PageMeta\x27,\x0a\x09\x09\x09\x09\x09\x27PagesRevisions\x27:  \x27PageRevisions\x27,\x0a\x09\x09\x09\x09\x09\x27PostsCategories\x27: \x27PostCategories\x27,\x0a\x09\x09\x09\x09\x09\x27PostsMeta\x27:       \x27PostMeta\x27,\x0a\x09\x09\x09\x09\x09\x27PostsRevisions\x27:  \x27PostRevisions\x27,\x0a\x09\x09\x09\x09\x09\x27PostsTags\x27:       \x27PostTags\x27\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09},\x0a\x0a\x09\x09\x09modelEndpoints = routeModel.get( \x27modelEndpoints\x27 ),\x0a\x09\x09\x09modelRegex     = new RegExp( \x27(?:.*[+)]|\x5c/(\x27 + modelEndpoints.join( \x27|\x27 ) + \x27))$\x27 );\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Iterate thru the routes, picking up models and collections to build. Builds two arrays,\x0a\x09\x09\x09 * one for models and one for collections.\x0a\x09\x09\x09 */\x0a\x09\x09\x09modelRoutes      = [];\x0a\x09\x09\x09collectionRoutes = [];\x0a\x09\x09\x09schemaRoot       = routeModel.get( \x27apiRoot\x27 ).replace( wp.api.utils.getRootUrl(), \x27\x27 );\x0a\x09\x09\x09loadingObjects   = {};\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Tracking objects for models and collections.\x0a\x09\x09\x09 */\x0a\x09\x09\x09loadingObjects.models      = {};\x0a\x09\x09\x09loadingObjects.collections = {};\x0a\x0a\x09\x09\x09_.each( routeModel.schemaModel.get( \x27routes\x27 ), function( route, index ) {\x0a\x0a\x09\x09\x09\x09// Skip the schema root if included in the schema.\x0a\x09\x09\x09\x09if ( index !== routeModel.get( \x27 versionString\x27 ) &&\x0a\x09\x09\x09\x09\x09\x09index !== schemaRoot &&\x0a\x09\x09\x09\x09\x09\x09index !== ( \x27/\x27 + routeModel.get( \x27versionString\x27 ).slice( 0, -1 ) )\x0a\x09\x09\x09\x09) {\x0a\x0a\x09\x09\x09\x09\x09// Single items end with a regex, or a special case word.\x0a\x09\x09\x09\x09\x09if ( modelRegex.test( index ) ) {\x0a\x09\x09\x09\x09\x09\x09modelRoutes.push( { index: index, route: route } );\x0a\x09\x09\x09\x09\x09} else {\x0a\x0a\x09\x09\x09\x09\x09\x09// Collections end in a name.\x0a\x09\x09\x09\x09\x09\x09collectionRoutes.push( { index: index, route: route } );\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Construct the models.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * Base the class name on the route endpoint.\x0a\x09\x09\x09 */\x0a\x09\x09\x09_.each( modelRoutes, function( modelRoute ) {\x0a\x0a\x09\x09\x09\x09// Extract the name and any parent from the route.\x0a\x09\x09\x09\x09var modelClassName,\x0a\x09\x09\x09\x09\x09routeName  = wp.api.utils.extractRoutePart( modelRoute.index, 2, routeModel.get( \x27versionString\x27 ), true ),\x0a\x09\x09\x09\x09\x09parentName = wp.api.utils.extractRoutePart( modelRoute.index, 1, routeModel.get( \x27versionString\x27 ), false ),\x0a\x09\x09\x09\x09\x09routeEnd   = wp.api.utils.extractRoutePart( modelRoute.index, 1, routeModel.get( \x27versionString\x27 ), true );\x0a\x0a\x09\x09\x09\x09// Clear the parent part of the rouite if its actually the version string.\x0a\x09\x09\x09\x09if ( parentName === routeModel.get( \x27versionString\x27 ) ) {\x0a\x09\x09\x09\x09\x09parentName = \x27\x27;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Handle the special case of the \x27me\x27 route.\x0a\x09\x09\x09\x09if ( \x27me\x27 === routeEnd ) {\x0a\x09\x09\x09\x09\x09routeName = \x27me\x27;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// If the model has a parent in its route, add that to its class name.\x0a\x09\x09\x09\x09if ( \x27\x27 !== parentName && parentName !== routeName ) {\x0a\x09\x09\x09\x09\x09modelClassName = wp.api.utils.capitalizeAndCamelCaseDashes( parentName ) + wp.api.utils.capitalizeAndCamelCaseDashes( routeName );\x0a\x09\x09\x09\x09\x09modelClassName = mapping.models[ modelClassName ] || modelClassName;\x0a\x09\x09\x09\x09\x09loadingObjects.models[ modelClassName ] = wp.api.WPApiBaseModel.extend( {\x0a\x0a\x09\x09\x09\x09\x09\x09// Return a constructed url based on the parent and id.\x0a\x09\x09\x09\x09\x09\x09url: function() {\x0a\x09\x09\x09\x09\x09\x09\x09var url =\x0a\x09\x09\x09\x09\x09\x09\x09\x09routeModel.get( \x27apiRoot\x27 ) +\x0a\x09\x09\x09\x09\x09\x09\x09\x09routeModel.get( \x27versionString\x27 ) +\x0a\x09\x09\x09\x09\x09\x09\x09\x09parentName +  \x27/\x27 +\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09( ( _.isUndefined( this.get( \x27parent\x27 ) ) || 0 === this.get( \x27parent\x27 ) ) ?\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09\x09( _.isUndefined( this.get( \x27parent_post\x27 ) ) ? \x27\x27 : this.get( \x27parent_post\x27 ) + \x27/\x27 ) :\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09\x09this.get( \x27parent\x27 ) + \x27/\x27 ) +\x0a\x09\x09\x09\x09\x09\x09\x09\x09routeName;\x0a\x0a\x09\x09\x09\x09\x09\x09\x09if ( ! _.isUndefined( this.get( \x27id\x27 ) ) ) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09url +=  \x27/\x27 + this.get( \x27id\x27 );\x0a\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09\x09return url;\x0a\x09\x09\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09\x09\x09// Track nonces on the Endpoint \x27routeModel\x27.\x0a\x09\x09\x09\x09\x09\x09nonce: function() {\x0a\x09\x09\x09\x09\x09\x09\x09return routeModel.get( \x27nonce\x27 );\x0a\x09\x09\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09\x09\x09endpointModel: routeModel,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include a reference to the original route object.\x0a\x09\x09\x09\x09\x09\x09route: modelRoute,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include a reference to the original class name.\x0a\x09\x09\x09\x09\x09\x09name: modelClassName,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include the array of route methods for easy reference.\x0a\x09\x09\x09\x09\x09\x09methods: modelRoute.route.methods,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include the array of route endpoints for easy reference.\x0a\x09\x09\x09\x09\x09\x09endpoints: modelRoute.route.endpoints\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09} else {\x0a\x0a\x09\x09\x09\x09\x09// This is a model without a parent in its route\x0a\x09\x09\x09\x09\x09modelClassName = wp.api.utils.capitalizeAndCamelCaseDashes( routeName );\x0a\x09\x09\x09\x09\x09modelClassName = mapping.models[ modelClassName ] || modelClassName;\x0a\x09\x09\x09\x09\x09loadingObjects.models[ modelClassName ] = wp.api.WPApiBaseModel.extend( {\x0a\x0a\x09\x09\x09\x09\x09\x09// Function that returns a constructed url based on the id.\x0a\x09\x09\x09\x09\x09\x09url: function() {\x0a\x09\x09\x09\x09\x09\x09\x09var url = routeModel.get( \x27apiRoot\x27 ) +\x0a\x09\x09\x09\x09\x09\x09\x09\x09routeModel.get( \x27versionString\x27 ) +\x0a\x09\x09\x09\x09\x09\x09\x09\x09( ( \x27me\x27 === routeName ) ? \x27users/me\x27 : routeName );\x0a\x0a\x09\x09\x09\x09\x09\x09\x09if ( ! _.isUndefined( this.get( \x27id\x27 ) ) ) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09url +=  \x27/\x27 + this.get( \x27id\x27 );\x0a\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09\x09return url;\x0a\x09\x09\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09\x09\x09// Track nonces at the Endpoint level.\x0a\x09\x09\x09\x09\x09\x09nonce: function() {\x0a\x09\x09\x09\x09\x09\x09\x09return routeModel.get( \x27nonce\x27 );\x0a\x09\x09\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09\x09\x09endpointModel: routeModel,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include a reference to the original route object.\x0a\x09\x09\x09\x09\x09\x09route: modelRoute,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include a reference to the original class name.\x0a\x09\x09\x09\x09\x09\x09name: modelClassName,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include the array of route methods for easy reference.\x0a\x09\x09\x09\x09\x09\x09methods: modelRoute.route.methods,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include the array of route endpoints for easy reference.\x0a\x09\x09\x09\x09\x09\x09endpoints: modelRoute.route.endpoints\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Add defaults to the new model, pulled form the endpoint.\x0a\x09\x09\x09\x09wp.api.utils.decorateFromRoute(\x0a\x09\x09\x09\x09\x09modelRoute.route.endpoints,\x0a\x09\x09\x09\x09\x09loadingObjects.models[ modelClassName ],\x0a\x09\x09\x09\x09\x09routeModel.get( \x27versionString\x27 )\x0a\x09\x09\x09\x09);\x0a\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09/**\x0a\x09\x09\x09 * Construct the collections.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * Base the class name on the route endpoint.\x0a\x09\x09\x09 */\x0a\x09\x09\x09_.each( collectionRoutes, function( collectionRoute ) {\x0a\x0a\x09\x09\x09\x09// Extract the name and any parent from the route.\x0a\x09\x09\x09\x09var collectionClassName, modelClassName,\x0a\x09\x09\x09\x09\x09\x09routeName  = collectionRoute.index.slice( collectionRoute.index.lastIndexOf( \x27/\x27 ) + 1 ),\x0a\x09\x09\x09\x09\x09\x09parentName = wp.api.utils.extractRoutePart( collectionRoute.index, 1, routeModel.get( \x27versionString\x27 ), false );\x0a\x0a\x09\x09\x09\x09// If the collection has a parent in its route, add that to its class name.\x0a\x09\x09\x09\x09if ( \x27\x27 !== parentName && parentName !== routeName && routeModel.get( \x27versionString\x27 ) !== parentName ) {\x0a\x0a\x09\x09\x09\x09\x09collectionClassName = wp.api.utils.capitalizeAndCamelCaseDashes( parentName ) + wp.api.utils.capitalizeAndCamelCaseDashes( routeName );\x0a\x09\x09\x09\x09\x09modelClassName      = mapping.models[ collectionClassName ] || collectionClassName;\x0a\x09\x09\x09\x09\x09collectionClassName = mapping.collections[ collectionClassName ] || collectionClassName;\x0a\x09\x09\x09\x09\x09loadingObjects.collections[ collectionClassName ] = wp.api.WPApiBaseCollection.extend( {\x0a\x0a\x09\x09\x09\x09\x09\x09// Function that returns a constructed url passed on the parent.\x0a\x09\x09\x09\x09\x09\x09url: function() {\x0a\x09\x09\x09\x09\x09\x09\x09return routeModel.get( \x27apiRoot\x27 ) + routeModel.get( \x27versionString\x27 ) +\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09parentName + \x27/\x27 + this.parent + \x27/\x27 +\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09routeName;\x0a\x09\x09\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09\x09\x09// Specify the model that this collection contains.\x0a\x09\x09\x09\x09\x09\x09model: function( attrs, options ) {\x0a\x09\x09\x09\x09\x09\x09\x09return new loadingObjects.models[ modelClassName ]( attrs, options );\x0a\x09\x09\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09\x09\x09// Track nonces at the Endpoint level.\x0a\x09\x09\x09\x09\x09\x09nonce: function() {\x0a\x09\x09\x09\x09\x09\x09\x09return routeModel.get( \x27nonce\x27 );\x0a\x09\x09\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09\x09\x09endpointModel: routeModel,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include a reference to the original class name.\x0a\x09\x09\x09\x09\x09\x09name: collectionClassName,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include a reference to the original route object.\x0a\x09\x09\x09\x09\x09\x09route: collectionRoute,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include the array of route methods for easy reference.\x0a\x09\x09\x09\x09\x09\x09methods: collectionRoute.route.methods\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09} else {\x0a\x0a\x09\x09\x09\x09\x09// This is a collection without a parent in its route.\x0a\x09\x09\x09\x09\x09collectionClassName = wp.api.utils.capitalizeAndCamelCaseDashes( routeName );\x0a\x09\x09\x09\x09\x09modelClassName      = mapping.models[ collectionClassName ] || collectionClassName;\x0a\x09\x09\x09\x09\x09collectionClassName = mapping.collections[ collectionClassName ] || collectionClassName;\x0a\x09\x09\x09\x09\x09loadingObjects.collections[ collectionClassName ] = wp.api.WPApiBaseCollection.extend( {\x0a\x0a\x09\x09\x09\x09\x09\x09// For the url of a root level collection, use a string.\x0a\x09\x09\x09\x09\x09\x09url: function() {\x0a\x09\x09\x09\x09\x09\x09\x09return routeModel.get( \x27apiRoot\x27 ) + routeModel.get( \x27versionString\x27 ) + routeName;\x0a\x09\x09\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09\x09\x09// Specify the model that this collection contains.\x0a\x09\x09\x09\x09\x09\x09model: function( attrs, options ) {\x0a\x09\x09\x09\x09\x09\x09\x09return new loadingObjects.models[ modelClassName ]( attrs, options );\x0a\x09\x09\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09\x09\x09// Track nonces at the Endpoint level.\x0a\x09\x09\x09\x09\x09\x09nonce: function() {\x0a\x09\x09\x09\x09\x09\x09\x09return routeModel.get( \x27nonce\x27 );\x0a\x09\x09\x09\x09\x09\x09},\x0a\x0a\x09\x09\x09\x09\x09\x09endpointModel: routeModel,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include a reference to the original class name.\x0a\x09\x09\x09\x09\x09\x09name: collectionClassName,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include a reference to the original route object.\x0a\x09\x09\x09\x09\x09\x09route: collectionRoute,\x0a\x0a\x09\x09\x09\x09\x09\x09// Include the array of route methods for easy reference.\x0a\x09\x09\x09\x09\x09\x09methods: collectionRoute.route.methods\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Add defaults to the new model, pulled form the endpoint.\x0a\x09\x09\x09\x09wp.api.utils.decorateFromRoute( collectionRoute.route.endpoints, loadingObjects.collections[ collectionClassName ] );\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09// Add mixins and helpers for each of the models.\x0a\x09\x09\x09_.each( loadingObjects.models, function( model, index ) {\x0a\x09\x09\x09\x09loadingObjects.models[ index ] = wp.api.utils.addMixinsAndHelpers( model, index, loadingObjects );\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09// Set the routeModel models and collections.\x0a\x09\x09\x09routeModel.set( \x27models\x27, loadingObjects.models );\x0a\x09\x09\x09routeModel.set( \x27collections\x27, loadingObjects.collections );\x0a\x0a\x09\x09}\x0a\x0a\x09} );\x0a\x0a\x09wp.api.endpoints = new Backbone.Collection();\x0a\x0a\x09/**\x0a\x09 * Initialize the wp-api, optionally passing the API root.\x0a\x09 *\x0a\x09 * @param {object} [args]\x0a\x09 * @param {string} [args.nonce] The nonce. Optional, defaults to wpApiSettings.nonce.\x0a\x09 * @param {string} [args.apiRoot] The api root. Optional, defaults to wpApiSettings.root.\x0a\x09 * @param {string} [args.versionString] The version string. Optional, defaults to wpApiSettings.root.\x0a\x09 * @param {object} [args.schema] The schema. Optional, will be fetched from API if not provided.\x0a\x09 */\x0a\x09wp.api.init = function( args ) {\x0a\x09\x09var endpoint, attributes = {}, deferred, promise;\x0a\x0a\x09\x09args                      = args || {};\x0a\x09\x09attributes.nonce          = _.isString( args.nonce ) ? args.nonce : ( wpApiSettings.nonce || \x27\x27 );\x0a\x09\x09attributes.apiRoot        = args.apiRoot || wpApiSettings.root || \x27/wp-json\x27;\x0a\x09\x09attributes.versionString  = args.versionString || wpApiSettings.versionString || \x27wp/v2/\x27;\x0a\x09\x09attributes.schema         = args.schema || null;\x0a\x09\x09attributes.modelEndpoints = args.modelEndpoints || [ \x27me\x27, \x27settings\x27 ];\x0a\x09\x09if ( ! attributes.schema && attributes.apiRoot === wpApiSettings.root && attributes.versionString === wpApiSettings.versionString ) {\x0a\x09\x09\x09attributes.schema = wpApiSettings.schema;\x0a\x09\x09}\x0a\x0a\x09\x09if ( ! initializedDeferreds[ attributes.apiRoot + attributes.versionString ] ) {\x0a\x0a\x09\x09\x09// Look for an existing copy of this endpoint\x0a\x09\x09\x09endpoint = wp.api.endpoints.findWhere( { \x27apiRoot\x27: attributes.apiRoot, \x27versionString\x27: attributes.versionString } );\x0a\x09\x09\x09if ( ! endpoint ) {\x0a\x09\x09\x09\x09endpoint = new Endpoint( attributes );\x0a\x09\x09\x09}\x0a\x09\x09\x09deferred = jQuery.Deferred();\x0a\x09\x09\x09promise = deferred.promise();\x0a\x0a\x09\x09\x09endpoint.schemaConstructed.done( function( resolvedEndpoint ) {\x0a\x09\x09\x09\x09wp.api.endpoints.add( resolvedEndpoint );\x0a\x0a\x09\x09\x09\x09// Map the default endpoints, extending any already present items (including Schema model).\x0a\x09\x09\x09\x09wp.api.models      = _.extend( wp.api.models, resolvedEndpoint.get( \x27models\x27 ) );\x0a\x09\x09\x09\x09wp.api.collections = _.extend( wp.api.collections, resolvedEndpoint.get( \x27collections\x27 ) );\x0a\x09\x09\x09\x09deferred.resolve( resolvedEndpoint );\x0a\x09\x09\x09} );\x0a\x09\x09\x09initializedDeferreds[ attributes.apiRoot + attributes.versionString ] = promise;\x0a\x09\x09}\x0a\x09\x09return initializedDeferreds[ attributes.apiRoot + attributes.versionString ];\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Construct the default endpoints and add to an endpoints collection.\x0a\x09 */\x0a\x0a\x09// The wp.api.init function returns a promise that will resolve with the endpoint once it is ready.\x0a\x09wp.api.loadPromise = wp.api.init();\x0a\x0a} )();\x0a'}