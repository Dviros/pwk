var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:12:19 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Wed, 23 May 2018 10:05:31 GMT\x0aETag: \x2211a2c-56cdcacc8d0c0-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-20274/20275\x0aContent-Length: 20275\x0aKeep-Alive: timeout=5, max=100\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a//     Backbone.js 1.3.3\x0a\x0a//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\x0a//     Backbone may be freely distributed under the MIT license.\x0a//     For all details and documentation:\x0a//     http://backbonejs.org\x0a\x0a(function(factory) {\x0a\x0a  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.\x0a  // We use `self` instead of `window` for `WebWorker` support.\x0a  var root = (typeof self == \x27object\x27 && self.self === self && self) ||\x0a            (typeof global == \x27object\x27 && global.global === global && global);\x0a\x0a  // Set up Backbone appropriately for the environment. Start with AMD.\x0a  if (typeof define === \x27function\x27 && define.amd) {\x0a    define([\x27underscore\x27, \x27jquery\x27, \x27exports\x27], function(_, $, exports) {\x0a      // Export global even in AMD case in case this script is loaded with\x0a      // others that may still expect a global Backbone.\x0a      root.Backbone = factory(root, exports, _, $);\x0a    });\x0a\x0a  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\x0a  } else if (typeof exports !== \x27undefined\x27) {\x0a    var _ = require(\x27underscore\x27), $;\x0a    try { $ = require(\x27jquery\x27); } catch (e) {}\x0a    factory(root, exports, _, $);\x0a\x0a  // Finally, as a browser global.\x0a  } else {\x0a    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));\x0a  }\x0a\x0a})(function(root, Backbone, _, $) {\x0a\x0a  // Initial Setup\x0a  // -------------\x0a\x0a  // Save the previous value of the `Backbone` variable, so that it can be\x0a  // restored later on, if `noConflict` is used.\x0a  var previousBackbone = root.Backbone;\x0a\x0a  // Create a local reference to a common array method we\x27ll want to use later.\x0a  var slice = Array.prototype.slice;\x0a\x0a  // Current version of the library. Keep in sync with `package.json`.\x0a  Backbone.VERSION = \x271.3.3\x27;\x0a\x0a  // For Backbone\x27s purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\x0a  // the `$` variable.\x0a  Backbone.$ = $;\x0a\x0a  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\x0a  // to its previous owner. Returns a reference to this Backbone object.\x0a  Backbone.noConflict = function() {\x0a    root.Backbone = previousBackbone;\x0a    return this;\x0a  };\x0a\x0a  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\x0a  // will fake `\x22PATCH\x22`, `\x22PUT\x22` and `\x22DELETE\x22` requests via the `_method` parameter and\x0a  // set a `X-Http-Method-Override` header.\x0a  Backbone.emulateHTTP = false;\x0a\x0a  // Turn on `emulateJSON` to support legacy servers that can\x27t deal with direct\x0a  // `application/json` requests ... this will encode the body as\x0a  // `application/x-www-form-urlencoded` instead and will send the model in a\x0a  // form param named `model`.\x0a  Backbone.emulateJSON = false;\x0a\x0a  // Proxy Backbone class methods to Underscore functions, wrapping the model\x27s\x0a  // `attributes` object or collection\x27s `models` array behind the scenes.\x0a  //\x0a  // collection.filter(function(model) { return model.get(\x27age\x27) \x3e 10 });\x0a  // collection.each(this.addView);\x0a  //\x0a  // `Function#apply` can be slow so we use the method\x27s arg count, if we know it.\x0a  var addMethod = function(length, method, attribute) {\x0a    switch (length) {\x0a      case 1: return function() {\x0a        return _[method](this[attribute]);\x0a      };\x0a      case 2: return function(value) {\x0a        return _[method](this[attribute], value);\x0a      };\x0a      case 3: return function(iteratee, context) {\x0a        return _[method](this[attribute], cb(iteratee, this), context);\x0a      };\x0a      case 4: return function(iteratee, defaultVal, context) {\x0a        return _[method](this[attribute], cb(iteratee, this), defaultVal, context);\x0a      };\x0a      default: return function() {\x0a        var args = slice.call(arguments);\x0a        args.unshift(this[attribute]);\x0a        return _[method].apply(_, args);\x0a      };\x0a    }\x0a  };\x0a  var addUnderscoreMethods = function(Class, methods, attribute) {\x0a    _.each(methods, function(length, method) {\x0a      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);\x0a    });\x0a  };\x0a\x0a  // Support `collection.sortBy(\x27attr\x27)` and `collection.findWhere({id: 1})`.\x0a  var cb = function(iteratee, instance) {\x0a    if (_.isFunction(iteratee)) return iteratee;\x0a    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\x0a    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };\x0a    return iteratee;\x0a  };\x0a  var modelMatcher = function(attrs) {\x0a    var matcher = _.matches(attrs);\x0a    return function(model) {\x0a      return matcher(model.attributes);\x0a    };\x0a  };\x0a\x0a  // Backbone.Events\x0a  // ---------------\x0a\x0a  // A module that can be mixed in to *any object* in order to provide it with\x0a  // a custom event channel. You may bind a callback to an event with `on` or\x0a  // remove with `off`; `trigger`-ing an event fires all callbacks in\x0a  // succession.\x0a  //\x0a  //     var object = {};\x0a  //     _.extend(object, Backbone.Events);\x0a  //     object.on(\x27expand\x27, function(){ alert(\x27expanded\x27); });\x0a  //     object.trigger(\x27expand\x27);\x0a  //\x0a  var Events = Backbone.Events = {};\x0a\x0a  // Regular expression used to split event strings.\x0a  var eventSplitter = /\x5cs+/;\x0a\x0a  // Iterates over the standard `event, callback` (as well as the fancy multiple\x0a  // space-separated events `\x22change blur\x22, callback` and jQuery-style event\x0a  // maps `{event: callback}`).\x0a  var eventsApi = function(iteratee, events, name, callback, opts) {\x0a    var i = 0, names;\x0a    if (name && typeof name === \x27object\x27) {\x0a      // Handle event maps.\x0a      if (callback !== void 0 && \x27context\x27 in opts && opts.context === void 0) opts.context = callback;\x0a      for (names = _.keys(name); i \x3c names.length ; i++) {\x0a        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\x0a      }\x0a    } else if (name && eventSplitter.test(name)) {\x0a      // Handle space-separated event names by delegating them individually.\x0a      for (names = name.split(eventSplitter); i \x3c names.length; i++) {\x0a        events = iteratee(events, names[i], callback, opts);\x0a      }\x0a    } else {\x0a      // Finally, standard events.\x0a      events = iteratee(events, name, callback, opts);\x0a    }\x0a    return events;\x0a  };\x0a\x0a  // Bind an event to a `callback` function. Passing `\x22all\x22` will bind\x0a  // the callback to all events fired.\x0a  Events.on = function(name, callback, context) {\x0a    return internalOn(this, name, callback, context);\x0a  };\x0a\x0a  // Guard the `listening` argument from the public API.\x0a  var internalOn = function(obj, name, callback, context, listening) {\x0a    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {\x0a      context: context,\x0a      ctx: obj,\x0a      listening: listening\x0a    });\x0a\x0a    if (listening) {\x0a      var listeners = obj._listeners || (obj._listeners = {});\x0a      listeners[listening.id] = listening;\x0a    }\x0a\x0a    return obj;\x0a  };\x0a\x0a  // Inversion-of-control versions of `on`. Tell *this* object to listen to\x0a  // an event in another object... keeping track of what it\x27s listening to\x0a  // for easier unbinding later.\x0a  Events.listenTo = function(obj, name, callback) {\x0a    if (!obj) return this;\x0a    var id = obj._listenId || (obj._listenId = _.uniqueId(\x27l\x27));\x0a    var listeningTo = this._listeningTo || (this._listeningTo = {});\x0a    var listening = listeningTo[id];\x0a\x0a    // This object is not listening to any other events on `obj` yet.\x0a    // Setup the necessary references to track the listening callbacks.\x0a    if (!listening) {\x0a      var thisId = this._listenId || (this._listenId = _.uniqueId(\x27l\x27));\x0a      listening = listeningTo[id] = {obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0};\x0a    }\x0a\x0a    // Bind callbacks on obj, and keep track of them on listening.\x0a    internalOn(obj, name, callback, this, listening);\x0a    return this;\x0a  };\x0a\x0a  // The reducing API that adds a callback to the `events` object.\x0a  var onApi = function(events, name, callback, options) {\x0a    if (callback) {\x0a      var handlers = events[name] || (events[name] = []);\x0a      var context = options.context, ctx = options.ctx, listening = options.listening;\x0a      if (listening) listening.count++;\x0a\x0a      handlers.push({callback: callback, context: context, ctx: context || ctx, listening: listening});\x0a    }\x0a    return events;\x0a  };\x0a\x0a  // Remove one or many callbacks. If `context` is null, removes all\x0a  // callbacks with that function. If `callback` is null, removes all\x0a  // callbacks for the event. If `name` is null, removes all bound\x0a  // callbacks for all events.\x0a  Events.off = function(name, callback, context) {\x0a    if (!this._events) return this;\x0a    this._events = eventsApi(offApi, this._events, name, callback, {\x0a      context: context,\x0a      listeners: this._listeners\x0a    });\x0a    return this;\x0a  };\x0a\x0a  // Tell this object to stop listening to either specific events ... or\x0a  // to every object it\x27s currently listening to.\x0a  Events.stopListening = function(obj, name, callback) {\x0a    var listeningTo = this._listeningTo;\x0a    if (!listeningTo) return this;\x0a\x0a    var ids = obj ? [obj._listenId] : _.keys(listeningTo);\x0a\x0a    for (var i = 0; i \x3c ids.length; i++) {\x0a      var listening = listeningTo[ids[i]];\x0a\x0a      // If listening doesn\x27t exist, this object is not currently\x0a      // listening to obj. Break out early.\x0a      if (!listening) break;\x0a\x0a      listening.obj.off(name, callback, this);\x0a    }\x0a\x0a    return this;\x0a  };\x0a\x0a  // The reducing API that removes a callback from the `events` object.\x0a  var offApi = function(events, name, callback, options) {\x0a    if (!events) return;\x0a\x0a    var i = 0, listening;\x0a    var context = options.context, listeners = options.listeners;\x0a\x0a    // Delete all events listeners and \x22drop\x22 events.\x0a    if (!name && !callback && !context) {\x0a      var ids = _.keys(listeners);\x0a      for (; i \x3c ids.length; i++) {\x0a        listening = listeners[ids[i]];\x0a        delete listeners[listening.id];\x0a        delete listening.listeningTo[listening.objId];\x0a      }\x0a      return;\x0a    }\x0a\x0a    var names = name ? [name] : _.keys(events);\x0a    for (; i \x3c names.length; i++) {\x0a      name = names[i];\x0a      var handlers = events[name];\x0a\x0a      // Bail out if there are no events stored.\x0a      if (!handlers) break;\x0a\x0a      // Replace events if there are any remaining.  Otherwise, clean up.\x0a      var remaining = [];\x0a      for (var j = 0; j \x3c handlers.length; j++) {\x0a        var handler = handlers[j];\x0a        if (\x0a          callback && callback !== handler.callback &&\x0a            callback !== handler.callback._callback ||\x0a              context && context !== handler.context\x0a        ) {\x0a          remaining.push(handler);\x0a        } else {\x0a          listening = handler.listening;\x0a          if (listening && --listening.count === 0) {\x0a            delete listeners[listening.id];\x0a            delete listening.listeningTo[listening.objId];\x0a          }\x0a        }\x0a      }\x0a\x0a      // Update tail event if the list has any events.  Otherwise, clean up.\x0a      if (remaining.length) {\x0a        events[name] = remaining;\x0a      } else {\x0a        delete events[name];\x0a      }\x0a    }\x0a    return events;\x0a  };\x0a\x0a  // Bind an event to only be triggered a single time. After the first time\x0a  // the callback is invoked, its listener will be removed. If multiple events\x0a  // are passed in using the space-separated syntax, the handler will fire\x0a  // once for each event, not once for a combination of all events.\x0a  Events.once = function(name, callback, context) {\x0a    // Map the event into a `{event: once}` object.\x0a    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));\x0a    if (typeof name === \x27string\x27 && context == null) callback = void 0;\x0a    return this.on(events, callback, context);\x0a  };\x0a\x0a  // Inversion-of-control versions of `once`.\x0a  Events.listenToOnce = function(obj, name, callback) {\x0a    // Map the event into a `{event: once}` object.\x0a    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));\x0a    return this.listenTo(obj, events);\x0a  };\x0a\x0a  // Reduces the event callbacks into a map of `{event: onceWrapper}`.\x0a  // `offer` unbinds the `onceWrapper` after it has been called.\x0a  var onceMap = function(map, name, callback, offer) {\x0a    if (callback) {\x0a      var once = map[name] = _.once(function() {\x0a        offer(name, once);\x0a        callback.apply(this, arguments);\x0a      });\x0a      once._callback = callback;\x0a    }\x0a    return map;\x0a  };\x0a\x0a  // Trigger one or many events, firing all bound callbacks. Callbacks are\x0a  // passed the same arguments as `trigger` is, apart from the event name\x0a  // (unless you\x27re listening on `\x22all\x22`, which will cause your callback to\x0a  // receive the true name of the event as the first argument).\x0a  Events.trigger = function(name) {\x0a    if (!this._events) return this;\x0a\x0a    var length = Math.max(0, arguments.length - 1);\x0a    var args = Array(length);\x0a    for (var i = 0; i \x3c length; i++) args[i] = arguments[i + 1];\x0a\x0a    eventsApi(triggerApi, this._events, name, void 0, args);\x0a    return this;\x0a  };\x0a\x0a  // Handles triggering the appropriate event callbacks.\x0a  var triggerApi = function(objEvents, name, callback, args) {\x0a    if (objEvents) {\x0a      var events = objEvents[name];\x0a      var allEvents = objEvents.all;\x0a      if (events && allEvents) allEvents = allEvents.slice();\x0a      if (events) triggerEvents(events, args);\x0a      if (allEvents) triggerEvents(allEvents, [name].concat(args));\x0a    }\x0a    return objEvents;\x0a  };\x0a\x0a  // A difficult-to-believe, but optimized internal dispatch function for\x0a  // triggering events. Tries to keep the usual cases speedy (most internal\x0a  // Backbone events have 3 arguments).\x0a  var triggerEvents = function(events, args) {\x0a    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\x0a    switch (args.length) {\x0a      case 0: while (++i \x3c l) (ev = events[i]).callback.call(ev.ctx); return;\x0a      case 1: while (++i \x3c l) (ev = events[i]).callback.call(ev.ctx, a1); return;\x0a      case 2: while (++i \x3c l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\x0a      case 3: while (++i \x3c l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\x0a      default: while (++i \x3c l) (ev = events[i]).callback.apply(ev.ctx, args); return;\x0a    }\x0a  };\x0a\x0a  // Aliases for backwards compatibility.\x0a  Events.bind   = Events.on;\x0a  Events.unbind = Events.off;\x0a\x0a  // Allow the `Backbone` object to serve as a global event bus, for folks who\x0a  // want global \x22pubsub\x22 in a convenient place.\x0a  _.extend(Backbone, Events);\x0a\x0a  // Backbone.Model\x0a  // --------------\x0a\x0a  // Backbone **Models** are the basic data object in the framework --\x0a  // frequently representing a row in a table in a database on your server.\x0a  // A discrete chunk of data and a bunch of useful, related methods for\x0a  // performing computations and transformations on that data.\x0a\x0a  // Create a new model with the specified attributes. A client id (`cid`)\x0a  // is automatically generated and assigned for you.\x0a  var Model = Backbone.Model = function(attributes, options) {\x0a    var attrs = attributes || {};\x0a    options || (options = {});\x0a    this.cid = _.uniqueId(this.cidPrefix);\x0a    this.attributes = {};\x0a    if (options.collection) this.collection = options.collection;\x0a    if (options.parse) attrs = this.parse(attrs, options) || {};\x0a    var defaults = _.result(this, \x27defaults\x27);\x0a    attrs = _.defaults(_.extend({}, defaults, attrs), defaults);\x0a    this.set(attrs, options);\x0a    this.changed = {};\x0a    this.initialize.apply(this, arguments);\x0a  };\x0a\x0a  // Attach all inheritable methods to the Model prototype.\x0a  _.extend(Model.prototype, Events, {\x0a\x0a    // A hash of attributes whose current and previous value differ.\x0a    changed: null,\x0a\x0a    // The value returned during the last failed validation.\x0a    validationError: null,\x0a\x0a    // The default name for the JSON `id` attribute is `\x22id\x22`. MongoDB and\x0a    // CouchDB users may want to set this to `\x22_id\x22`.\x0a    idAttribute: \x27id\x27,\x0a\x0a    // The prefix is used to create the client id which is used to identify models locally.\x0a    // You may want to override this if you\x27re experiencing name clashes with model ids.\x0a    cidPrefix: \x27c\x27,\x0a\x0a    // Initialize is an empty function by default. Override it with your own\x0a    // initialization logic.\x0a    initialize: function(){},\x0a\x0a    // Return a copy of the model\x27s `attributes` object.\x0a    toJSON: function(options) {\x0a      return _.clone(this.attributes);\x0a    },\x0a\x0a    // Proxy `Backbone.sync` by default -- but override this if you need\x0a    // custom syncing semantics for *this* particular model.\x0a    sync: function() {\x0a      return Backbone.sync.apply(this, arguments);\x0a    },\x0a\x0a    // Get the value of an attribute.\x0a    get: function(attr) {\x0a      return this.attributes[attr];\x0a    },\x0a\x0a    // Get the HTML-escaped value of an attribute.\x0a    escape: function(attr) {\x0a      return _.escape(this.get(attr));\x0a    },\x0a\x0a    // Returns `true` if the attribute contains a value that is not null\x0a    // or undefined.\x0a    has: function(attr) {\x0a      return this.get(attr) != null;\x0a    },\x0a\x0a    // Special-cased proxy to underscore\x27s `_.matches` method.\x0a    matches: function(attrs) {\x0a      return !!_.iteratee(attrs, this)(this.attributes);\x0a    },\x0a\x0a    // Set a hash of model attributes on the object, firing `\x22change\x22`. This is\x0a    // the core primitive operation of a model, updating the data and notifying\x0a    // anyone who needs to know about the change in state. The heart of the beast.\x0a    set: function(key, val, options) {\x0a      if (key == null) return this;\x0a\x0a      // Handle both `\x22key\x22, value` and `{key: value}` -style arguments.\x0a      var attrs;\x0a      if (typeof key === \x27object\x27) {\x0a        attrs = key;\x0a        options = val;\x0a      } else {\x0a        (attrs = {})[key] = val;\x0a      }\x0a\x0a      options || (options = {});\x0a\x0a      // Run validation.\x0a      if (!this._validate(attrs, options)) return false;\x0a\x0a      // Extract attributes and options.\x0a      var unset      = options.unset;\x0a      var silent     = options.silent;\x0a      var changes    = [];\x0a      var changing   = this._changing;\x0a      this._changing = true;\x0a\x0a      if (!changing) {\x0a        this._previousAttributes = _.clone(this.attributes);\x0a        this.changed = {};\x0a      }\x0a\x0a      var current = this.attributes;\x0a      var changed = this.changed;\x0a      var prev    = this._previousAttributes;\x0a\x0a      // For each `set` attribute, update or delete the current value.\x0a      for (var attr in attrs) {\x0a        val = attrs[attr];\x0a        if (!_.isEqual(current[attr], val)) changes.push(attr);\x0a        if (!_.isEqual(prev[attr], val)) {\x0a          changed[attr] = val;\x0a        } else {\x0a          delete changed[attr];\x0a        }\x0a        unset ? delete current[attr] : current[attr] = val;\x0a      }\x0a\x0a      // Update the `id`.\x0a      if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);\x0a\x0a      // Trigger all relevant attribute changes.\x0a      if (!silent) {\x0a        if (changes.length) this._pending = options;\x0a        for (var i = 0; i \x3c changes.length; i++) {\x0a          this.trigger(\x27change:\x27 + changes[i], this, current[changes[i]], options);\x0a        }\x0a      }\x0a\x0a      // You might be wondering why there\x27s a `while` loop here. Changes can\x0a      // be recursively nested within `\x22change\x22` events.\x0a      if (changing) return this;\x0a      if (!silent) {\x0a        while (this._pending) {\x0a          options = this._pending;\x0a          this._pending = false;\x0a          this.trigger(\x27change\x27, this, options);\x0a        }\x0a      }\x0a      this._pending = false;\x0a      this._changing = false;\x0a      return this;\x0a    },\x0a\x0a    // Remove an attribute from the model, firing `\x22change\x22`. `unset` is a noop\x0a    // if the attribute doesn\x27t exist.\x0a    unset: function(attr, options) {\x0a      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\x0a    },\x0a\x0a    // Clear all attributes on the model, firing `\x22change\x22`.\x0a    clear: function(options) {\x0a      var attrs = {};\x0a      for (var key in this.attributes) attrs[key] = void 0;\x0a      return this.set(attrs, _.extend({}, options, {unset: true}));\x0a    },\x0a\x0a    // Determine if the model has changed since the last `\x22change\x22` event.\x0a    // If you specify an attribute name, determine if that attribute has changed.\x0a    hasChanged: function(attr) {\x0a      if (attr == null) return !_.isEmpty(this.changed);\x0a      return _.has(this.changed, attr);\x0a    },\x0a\x0a    // Return an object containing all the attributes that have changed, or\x0a    // false if there are no changed attributes. Useful for determining what\x0a    // parts of a view need to be updated and/or what attributes need to be\x0a    // persisted to the server. Unset attributes will be set to undefined.\x0a    // You can also pass an attributes object to diff against the model,\x0a    // determining if there *would be* a change.\x0a    changedAttributes: function(diff) {\x0a      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\x0a      var old = this._changing ? this._previousAttributes : this.attributes;\x0a      var changed = {};\x0a      for (var attr in diff) {\x0a        var val = diff[attr];\x0a        if (_.isEqual(old[attr], val)) continue;\x0a        changed[attr] = val;\x0a      }\x0a      return _.size(changed) ? changed : false;\x0a    },\x0a\x0a    // Get the previous value of an attribute, recorded at the time the last\x0a    // `\x22change\x22` event was fired.\x0a    previous: function(attr) {\x0a      if (attr == null || !this._previousAttributes) return null;\x0a      return this._previousAttributes[attr];\x0a    },\x0a\x0a    // Get all of the attributes of the model at the time of the previous\x0a    // `\x22change\x22` event.\x0a    previousAttributes: function() {\x0a      return _.clone(this._previousAttributes);\x0a    },\x0a\x0a    // Fetch the model from the server, merging the response with the model\x27s\x0a    // local attributes. Any changed attributes will trigger a \x22change\x22 event.\x0a    fetch: function(options) {\x0a      options = _.extend({parse: true}, options);\x0a      var model = this;\x0a      var success = options.success;\x0a      options.success = function(resp) {\x0a        var serverAttrs = options.parse ? model.parse(resp, options) : resp;\x0a        if (!model.set(serverAttrs, options)) return false;\x0a        if (success) success.call(options.context, model, resp, options);\x0a        model.trigger(\x27sync\x27, model, resp, options);\x0a      };\x0a      wrapError(this, options);\x0a      return this.sync(\x27read\x27, this, options);\x0a    },\x0a\x0a    // Set a hash of model attributes, and sync the model to the server.\x0a    // If the server returns an attributes hash that differs, the model\x27s\x0a    // state will be `set` again.\x0a    save: function(key, val, options) {\x0a      // Handle both `\x22key\x22, value` and `{key: value}` -style arguments.\x0a      var attrs;\x0a      if (key == null || typeof key === \x27object\x27) {\x0a        attrs = key;\x0a        options = val;\x0a      } else {\x0a        (attrs = {})[key] = val;\x0a      }\x0a\x0a      options = _.extend({validate: true, parse: true}, options);\x0a      var wait = options.wait;\x0a\x0a      // If we\x27re not waiting and attributes exist, save acts as\x0a      // `set(attr).save(null, opts)` with validation. Otherwise, check if\x0a      // the model will be valid when the attributes, if any, are set.\x0a      if (attrs && !wait) {\x0a        if (!this.set(attrs, options)) return false;\x0a      } else if (!this._validate(attrs, options)) {\x0a        return false;\x0a      }\x0a\x0a      // After a successful server-side save, the client is (optionally)\x0a      // updated with the server-side state.\x0a      var model = this;\x0a      var success = options.success;\x0a      var attributes = this.attributes;\x0a      options.success = function(resp) {\x0a        // Ensure attributes are restored during synchronous saves.\x0a        model.attributes = attributes;\x0a        var serverAttrs = options.parse ? model.parse(resp, options) : resp;\x0a        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);\x0a        if (serverAttrs && !model.set(serverAttrs, options)) return false;\x0a        if (success) success.call(options.context, model, resp, options);\x0a        model.trigger(\x27sync\x27, model, resp, options);\x0a      };\x0a      wrapError(this, options);\x0a\x0a      // Set temporary attributes if `{wait: true}` to properly find new ids.\x0a      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);\x0a\x0a      var method = this.isNew() ? \x27create\x27 : (options.patch ? \x27patch\x27 : \x27update\x27);\x0a      if (method === \x27patch\x27 && !options.attrs) options.attrs = attrs;\x0a      var xhr = this.sync(method, this, options);\x0a\x0a      // Restore attributes.\x0a      this.attributes = attributes;\x0a\x0a      return xhr;\x0a    },\x0a\x0a    // Destroy this model on the server if it was already persisted.\x0a    // Optimistically removes the model from its collection, if it has one.\x0a    // If `wait: true` is passed, waits for the server to respond before removal.\x0a    destroy: function(options) {\x0a      options = options ? _.clone(options) : {};\x0a      var model = this;\x0a      var success = options.success;\x0a      var wait = options.wait;\x0a\x0a      var destroy = function() {\x0a        model.stopListening();\x0a        model.trigger(\x27destroy\x27, model, model.collection, options);\x0a      };\x0a\x0a      options.success = function(resp) {\x0a        if (wait) destroy();\x0a        if (success) success.call(options.context, model, resp, options);\x0a        if (!model.isNew()) model.trigger(\x27sync\x27, model, resp, options);\x0a      };\x0a\x0a      var xhr = false;\x0a      if (this.isNew()) {\x0a        _.defer(options.success);\x0a      } else {\x0a        wrapError(this, options);\x0a        xhr = this.sync(\x27delete\x27, this, options);\x0a      }\x0a      if (!wait) destroy();\x0a      return xhr;\x0a    },\x0a\x0a    // Default URL for the model\x27s representation on the server -- if you\x27re\x0a    // using Backbone\x27s restful methods, override this to change the endpoint\x0a    // that will be called.\x0a    url: function() {\x0a      var base =\x0a        _.result(this, \x27urlRoot\x27) ||\x0a        _.result(this.collection, \x27url\x27) ||\x0a        urlError();\x0a      if (this.isNew()) return base;\x0a      var id = this.get(this.idAttribute);\x0a      return base.replace(/[^\x5c/]$/, \x27$&/\x27) + encodeURIComponent(id);\x0a    },\x0a\x0a    // **parse** converts a response into the hash of attributes to be `set` on\x0a    // the model. The default implementation is just to pass the response along.\x0a    parse: function(resp, options) {\x0a      return resp;\x0a    },\x0a\x0a    // Create a new model with identical attributes to this one.\x0a    clone: function() {\x0a      return new this.constructor(this.attributes);\x0a    },\x0a\x0a    // A model is new if it has never been saved to the server, and lacks an id.\x0a    isNew: function() {\x0a      return !this.has(this.idAttribute);\x0a    },\x0a\x0a    // Check if the model is currently in a valid state.\x0a    isValid: function(options) {\x0a      return this._validate({}, _.extend({}, options, {validate: true}));\x0a    },\x0a\x0a    // Run validation against the next complete set of model attributes,\x0a    // returning `true` if all is well. Otherwise, fire an `\x22invalid\x22` event.\x0a    _validate: function(attrs, options) {\x0a      if (!options.validate || !this.validate) return true;\x0a      attrs = _.extend({}, this.attributes, attrs);\x0a      var error = this.validationError = this.validate(attrs, options) || null;\x0a      if (!error) return true;\x0a      this.trigger(\x27invalid\x27, this, error, _.extend(options, {validationError: error}));\x0a      return false;\x0a    }\x0a\x0a  });\x0a\x0a  // Underscore methods that we want to implement on the Model, mapped to the\x0a  // number of arguments they take.\x0a  var modelMethods = {keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,\x0a      omit: 0, chain: 1, isEmpty: 1};\x0a\x0a  // Mix in each Underscore method as a proxy to `Model#attributes`.\x0a  addUnderscoreMethods(Model, modelMethods, \x27attributes\x27);\x0a\x0a  // Backbone.Collection\x0a  // -------------------\x0a\x0a  // If models tend to represent a single row of data, a Backbone Collection is\x0a  // more analogous to a table full of data ... or a small slice or page of that\x0a  // table, or a collection of rows that belong together for a particular reason\x0a  // -- all of the messages in this particular folder, all of the documents\x0a  // belonging to this particular author, and so on. Collections maintain\x0a  // indexes of their models, both in order, and for lookup by `id`.\x0a\x0a  // Create a new **Collection**, perhaps to contain a specific type of `model`.\x0a  // If a `comparator` is specified, the Collection will maintain\x0a  // its models in sort order, as they\x27re added and removed.\x0a  var Collection = Backbone.Collection = function(models, options) {\x0a    options || (options = {});\x0a    if (options.model) this.model = options.model;\x0a    if (options.comparator !== void 0) this.comparator = options.comparator;\x0a    this._reset();\x0a    this.initialize.apply(this, arguments);\x0a    if (models) this.reset(models, _.extend({silent: true}, options));\x0a  };\x0a\x0a  // Default options for `Collection#set`.\x0a  var setOptions = {add: true, remove: true, merge: true};\x0a  var addOptions = {add: true, remove: false};\x0a\x0a  // Splices `insert` into `array` at index `at`.\x0a  var splice = function(array, insert, at) {\x0a    at = Math.min(Math.max(at, 0), array.length);\x0a    var tail = Array(array.length - at);\x0a    var length = insert.length;\x0a    var i;\x0a    for (i = 0; i \x3c tail.length; i++) tail[i] = array[i + at];\x0a    for (i = 0; i \x3c length; i++) array[i + at] = insert[i];\x0a    for (i = 0; i \x3c tail.length; i++) array[i + length + at] = tail[i];\x0a  };\x0a\x0a  // Define the Collection\x27s inheritable methods.\x0a  _.extend(Collection.prototype, Events, {\x0a\x0a    // The default model for a collection is just a **Backbone.Model**.\x0a    // This should be overridden in most cases.\x0a    model: Model,\x0a\x0a    // Initialize is an empty function by default. Override it with your own\x0a    // initialization logic.\x0a    initialize: function(){},\x0a\x0a    // The JSON representation of a Collection is an array of the\x0a    // models\x27 attributes.\x0a    toJSON: function(options) {\x0a      return this.map(function(model) { return model.toJSON(options); });\x0a    },\x0a\x0a    // Proxy `Backbone.sync` by default.\x0a    sync: function() {\x0a      return Backbone.sync.apply(this, arguments);\x0a    },\x0a\x0a    // Add a model, or list of models to the set. `models` may be Backbone\x0a    // Models or raw JavaScript objects to be converted to Models, or any\x0a    // combination of the two.\x0a    add: function(models, options) {\x0a      return this.set(models, _.extend({merge: false}, options, addOptions));\x0a    },\x0a\x0a    // Remove a model, or a list of models from the set.\x0a    remove: function(models, options) {\x0a      options = _.extend({}, options);\x0a      var singular = !_.isArray(models);\x0a      models = singular ? [models] : models.slice();\x0a      var removed = this._removeModels(models, options);\x0a      if (!options.silent && removed.length) {\x0a        options.changes = {added: [], merged: [], removed: removed};\x0a        this.trigger(\x27update\x27, this, options);\x0a      }\x0a      return singular ? removed[0] : removed;\x0a    },\x0a\x0a    // Update a collection by `set`-ing a new list of models, adding new ones,\x0a    // removing models that are no longer present, and merging models that\x0a    // already exist in the collection, as necessary. Similar to **Model#set**,\x0a    // the core operation for updating the data contained by the collection.\x0a    set: function(models, options) {\x0a      if (models == null) return;\x0a\x0a      options = _.extend({}, setOptions, options);\x0a      if (options.parse && !this._isModel(models)) {\x0a        models = this.parse(models, options) || [];\x0a      }\x0a\x0a      var singular = !_.isArray(models);\x0a      models = singular ? [models] : models.slice();\x0a\x0a      var at = options.at;\x0a      if (at != null) at = +at;\x0a      if (at \x3e this.length) at = this.length;\x0a      if (at \x3c 0) at += this.length + 1;\x0a\x0a      var set = [];\x0a      var toAdd = [];\x0a      var toMerge = [];\x0a      var toRemove = [];\x0a      var modelMap = {};\x0a\x0a      var add = options.add;\x0a      var merge = options.merge;\x0a      var remove = options.remove;\x0a\x0a      var sort = false;\x0a      var sortable = this.comparator && at == null && options.sort !== false;\x0a      var sortAttr = _.isString(this.comparator) ? this.comparator : null;\x0a\x0a      // Turn bare objects into model references, and prevent invalid models\x0a      // from being added.\x0a      var model, i;\x0a      for (i = 0; i \x3c models.length; i++) {\x0a        model = models[i];\x0a\x0a        // If a duplicate is found, prevent it from being added and\x0a        // optionally merge it into the existing model.\x0a        var existing = this.get(model);\x0a        if (existing) {\x0a          if (merge && model !== existing) {\x0a            var attrs = this._isModel(model) ? model.attributes : model;\x0a            if (options.parse) attrs = existing.parse(attrs, options);\x0a            existing.set(attrs, options);\x0a            toMerge.push(existing);\x0a            if (sortable && !sort) sort = existing.hasChanged(sortAttr);\x0a          }\x0a          if (!modelMap[existing.cid]) {\x0a            modelMap[existing.cid] = true;\x0a            set.push(existing);\x0a          }\x0a          models[i] = existing;\x0a\x0a        // If this is a new, valid model, push it to the `toAdd` list.\x0a        } else if (add) {\x0a          model = models[i] = this._prepareModel(model, options);\x0a          if (model) {\x0a            toAdd.push(model);\x0a            this._addReference(model, options);\x0a            modelMap[model.cid] = true;\x0a            set.push(model);\x0a          }\x0a        }\x0a      }\x0a\x0a      // Remove stale models.\x0a      if (remove) {\x0a        for (i = 0; i \x3c this.length; i++) {\x0a          model = this.models[i];\x0a          if (!modelMap[model.cid]) toRemove.push(model);\x0a        }\x0a        if (toRemove.length) this._removeModels(toRemove, options);\x0a      }\x0a\x0a      // See if sorting is needed, update `length` and splice in new models.\x0a      var orderChanged = false;\x0a      var replace = !sortable && add && remove;\x0a      if (set.length && replace) {\x0a        orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {\x0a          return m !== set[index];\x0a        });\x0a        this.models.length = 0;\x0a        splice(this.models, set, 0);\x0a        this.length = this.models.length;\x0a      } else if (toAdd.length) {\x0a        if (sortable) sort = true;\x0a        splice(this.models, toAdd, at == null ? this.length : at);\x0a        this.length = this.models.length;\x0a      }\x0a\x0a      // Silently sort the collection if appropriate.\x0a      if (sort) this.sort({silent: true});\x0a\x0a      // Unless silenced, it\x27s time to fire all appropriate add/sort/update events.\x0a      if (!options.silent) {\x0a        for (i = 0; i \x3c toAdd.length; i++) {\x0a          if (at != null) options.index = at + i;\x0a          model = toAdd[i];\x0a          model.trigger(\x27add\x27, model, this, options);\x0a        }\x0a        if (sort || orderChanged) this.trigger(\x27sort\x27, this, options);\x0a        if (toAdd.length || toRemove.length || toMerge.length) {\x0a          options.changes = {\x0a            added: toAdd,\x0a            removed: toRemove,\x0a            merged: toMerge\x0a          };\x0a          this.trigger(\x27update\x27, this, options);\x0a        }\x0a      }\x0a\x0a      // Return the added (or merged) model (or models).\x0a      return singular ? models[0] : models;\x0a    },\x0a\x0a    // When you have more items than you want to add or remove individually,\x0a    // you can reset the entire set with a new list of models, without firing\x0a    // any granular `add` or `remove` events. Fires `reset` when finished.\x0a    // Useful for bulk operations and optimizations.\x0a    reset: function(models, options) {\x0a      options = options ? _.clone(options) : {};\x0a      for (var i = 0; i \x3c this.models.length; i++) {\x0a        this._removeReference(this.models[i], options);\x0a      }\x0a      options.previousModels = this.models;\x0a      this._reset();\x0a      models = this.add(models, _.extend({silent: true}, options));\x0a      if (!options.silent) this.trigger(\x27reset\x27, this, options);\x0a      return models;\x0a    },\x0a\x0a    // Add a model to the end of the collection.\x0a    push: function(model, options) {\x0a      return this.add(model, _.extend({at: this.length}, options));\x0a    },\x0a\x0a    // Remove a model from the end of the collection.\x0a    pop: function(options) {\x0a      var model = this.at(this.length - 1);\x0a      return this.remove(model, options);\x0a    },\x0a\x0a    // Add a model to the beginning of the collection.\x0a    unshift: function(model, options) {\x0a      return this.add(model, _.extend({at: 0}, options));\x0a    },\x0a\x0a    // Remove a model from the beginning of the collection.\x0a    shift: function(options) {\x0a      var model = this.at(0);\x0a      return this.remove(model, options);\x0a    },\x0a\x0a    // Slice out a sub-array of models from the collection.\x0a    slice: function() {\x0a      return slice.apply(this.models, arguments);\x0a    },\x0a\x0a    // Get a model from the set by id, cid, model object with id or cid\x0a    // properties, or an attributes object that is transformed through modelId.\x0a    get: function(obj) {\x0a      if (obj == null) return void 0;\x0a      return this._byId[obj] ||\x0a        this._byId[this.modelId(obj.attributes || obj)] ||\x0a        obj.cid && this._byId[obj.cid];\x0a    },\x0a\x0a    // Returns `true` if the model is in the collection.\x0a    has: function(obj) {\x0a      return this.get(obj) != null;\x0a    },\x0a\x0a    // Get the model at the given index.\x0a    at: function(index) {\x0a      if (index \x3c 0) index += this.length;\x0a      return this.models[index];\x0a    },\x0a\x0a    // Return models with matching attributes. Useful for simple cases of\x0a    // `filter`.\x0a    where: function(attrs, first) {\x0a      return this[first ? \x27find\x27 : \x27filter\x27](attrs);\x0a    },\x0a\x0a    // Return the first model with matching attributes. Useful for simple cases\x0a    // of `find`.\x0a    findWhere: function(attrs) {\x0a      return this.where(attrs, true);\x0a    },\x0a\x0a    // Force the collection to re-sort itself. You don\x27t need to call this under\x0a    // normal circumstances, as the set will maintain sort order as each item\x0a    // is added.\x0a    sort: function(options) {\x0a      var comparator = this.comparator;\x0a      if (!comparator) throw new Error(\x27Cannot sort a set without a comparator\x27);\x0a      options || (options = {});\x0a\x0a      var length = comparator.length;\x0a      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);\x0a\x0a      // Run sort based on type of `comparator`.\x0a      if (length === 1 || _.isString(comparator)) {\x0a        this.models = this.sortBy(comparator);\x0a      } else {\x0a        this.models.sort(comparator);\x0a      }\x0a      if (!options.silent) this.trigger(\x27sort\x27, this, options);\x0a      return this;\x0a    },\x0a\x0a    // Pluck an attribute from each model in the collection.\x0a    pluck: function(attr) {\x0a      return this.map(attr + \x27\x27);\x0a    },\x0a\x0a    // Fetch the default set of models for this collection, resetting the\x0a    // collection when they arrive. If `reset: true` is passed, the response\x0a    // data will be passed through the `reset` method instead of `set`.\x0a    fetch: function(options) {\x0a      options = _.extend({parse: true}, options);\x0a      var success = options.success;\x0a      var collection = this;\x0a      options.success = function(resp) {\x0a        var method = options.reset ? \x27reset\x27 : \x27set\x27;\x0a        collection[method](resp, options);\x0a        if (success) success.call(options.context, collection, resp, options);\x0a        collection.trigger(\x27sync\x27, collection, resp, options);\x0a      };\x0a      wrapError(this, options);\x0a      return this.sync(\x27read\x27, this, options);\x0a    },\x0a\x0a    // Create a new instance of a model in this collection. Add the model to the\x0a    // collection immediately, unless `wait: true` is passed, in which case we\x0a    // wait for the server to agree.\x0a    create: function(model, options) {\x0a      options = options ? _.clone(options) : {};\x0a      var wait = options.wait;\x0a      model = this._prepareModel(model, options);\x0a      if (!model) return false;\x0a      if (!wait) this.add(model, options);\x0a      var collection = this;\x0a      var success = options.success;\x0a      options.success = function(m, resp, callbackOpts) {\x0a        if (wait) collection.add(m, callbackOpts);\x0a        if (success) success.call(callbackOpts.context, m, resp, callbackOpts);\x0a      };\x0a      model.save(null, options);\x0a      return model;\x0a    },\x0a\x0a    // **parse** converts a response into a list of models to be added to the\x0a    // collection. The default implementation is just to pass it through.\x0a    parse: function(resp, options) {\x0a      return resp;\x0a    },\x0a\x0a    // Create a new collection with an identical list of models as this one.\x0a    clone: function() {\x0a      return new this.constructor(this.models, {\x0a        model: this.model,\x0a        comparator: this.comparator\x0a      });\x0a    },\x0a\x0a    // Define how to uniquely identify models in the collection.\x0a    modelId: function(attrs) {\x0a      return attrs[this.model.prototype.idAttribute || \x27id\x27];\x0a    },\x0a\x0a    // Private method to reset all internal state. Called when the collection\x0a    // is first initialized or reset.\x0a    _reset: function() {\x0a      this.length = 0;\x0a      this.models = [];\x0a      this._byId  = {};\x0a    },\x0a\x0a    // Prepare a hash of attributes (or other model) to be added to this\x0a    // collection.\x0a    _prepareModel: function(attrs, options) {\x0a      if (this._isModel(attrs)) {\x0a        if (!attrs.collection) attrs.collection = this;\x0a        return attrs;\x0a      }\x0a      options = options ? _.clone(options) : {};\x0a      options.collection = this;\x0a      var model = new this.model(attrs, options);\x0a      if (!model.validationError) return model;\x0a      this.trigger(\x27invalid\x27, this, model.validationError, options);\x0a      return false;\x0a    },\x0a\x0a    // Internal method called by both remove and set.\x0a    _removeModels: function(models, options) {\x0a      var removed = [];\x0a      for (var i = 0; i \x3c models.length; i++) {\x0a        var model = this.get(models[i]);\x0a        if (!model) continue;\x0a\x0a        var index = this.indexOf(model);\x0a        this.models.splice(index, 1);\x0a        this.length--;\x0a\x0a        // Remove references before triggering \x27remove\x27 event to prevent an\x0a        // infinite loop. #3693\x0a        delete this._byId[model.cid];\x0a        var id = this.modelId(model.attributes);\x0a        if (id != null) delete this._byId[id];\x0a\x0a        if (!options.silent) {\x0a          options.index = index;\x0a          model.trigger(\x27remove\x27, model, this, options);\x0a        }\x0a\x0a        removed.push(model);\x0a        this._removeReference(model, options);\x0a      }\x0a      return removed;\x0a    },\x0a\x0a    // Method for checking whether an object should be considered a model for\x0a    // the purposes of adding to the collection.\x0a    _isModel: function(model) {\x0a      return model instanceof Model;\x0a    },\x0a\x0a    // Internal method to create a model\x27s ties to a collection.\x0a    _addReference: function(model, options) {\x0a      this._byId[model.cid] = model;\x0a      var id = this.modelId(model.attributes);\x0a      if (id != null) this._byId[id] = model;\x0a      model.on(\x27all\x27, this._onModelEvent, this);\x0a    },\x0a\x0a    // Internal method to sever a model\x27s ties to a collection.\x0a    _removeReference: function(model, options) {\x0a      delete this._byId[model.cid];\x0a      var id = this.modelId(model.attributes);\x0a      if (id != null) delete this._byId[id];\x0a      if (this === model.collection) delete model.collection;\x0a      model.off(\x27all\x27, this._onModelEvent, this);\x0a    },\x0a\x0a    // Internal method called every time a model in the set fires an event.\x0a    // Sets need to update their indexes when models change ids. All other\x0a    // events simply proxy through. \x22add\x22 and \x22remove\x22 events that originate\x0a    // in other collections are ignored.\x0a    _onModelEvent: function(event, model, collection, options) {\x0a      if (model) {\x0a        if ((event === \x27add\x27 || event === \x27remove\x27) && collection !== this) return;\x0a        if (event === \x27destroy\x27) this.remove(model, options);\x0a        if (event === \x27change\x27) {\x0a          var prevId = this.modelId(model.previousAttributes());\x0a          var id = this.modelId(model.attributes);\x0a          if (prevId !== id) {\x0a            if (prevId != null) delete this._byId[prevId];\x0a            if (id != null) this._byId[id] = model;\x0a          }\x0a        }\x0a      }\x0a      this.trigger.apply(this, arguments);\x0a    }\x0a\x0a  });\x0a\x0a  // Underscore methods that we want to implement on the Collection.\x0a  // 90% of the core usefulness of Backbone Collections is actually implemented\x0a  // right here:\x0a  var collectionMethods = {forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,\x0a      foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,\x0a      select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,\x0a      contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,\x0a      head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,\x0a      without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,\x0a      isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,\x0a      sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3};\x0a\x0a  // Mix in each Underscore method as a proxy to `Collection#models`.\x0a  addUnderscoreMethods(Collection, collectionMethods, \x27models\x27);\x0a\x0a  // Backbone.View\x0a  // -------------\x0a\x0a  // Backbone Views are almost more convention than they are actual code. A View\x0a  // is simply a JavaScript object that represents a logical chunk of UI in the\x0a  // DOM. This might be a single item, an entire list, a sidebar or panel, or\x0a  // even the surrounding frame which wraps your whole app. Defining a chunk of\x0a  // UI as a **View** allows you to define your DOM events declaratively, without\x0a  // having to worry about render order ... and makes it easy for the view to\x0a  // react to specific changes in the state of your models.\x0a\x0a  // Creating a Backbone.View creates its initial element outside of the DOM,\x0a  // if an existing element is not provided...\x0a  var View = Backbone.View = function(options) {\x0a    this.cid = _.uniqueId(\x27view\x27);\x0a    _.extend(this, _.pick(options, viewOptions));\x0a    this._ensureElement();\x0a    this.initialize.apply(this, arguments);\x0a  };\x0a\x0a  // Cached regex to split keys for `delegate`.\x0a  var delegateEventSplitter = /^(\x5cS+)\x5cs*(.*)$/;\x0a\x0a  // List of view options to be set as properties.\x0a  var viewOptions = [\x27model\x27, \x27collection\x27, \x27el\x27, \x27id\x27, \x27attributes\x27, \x27className\x27, \x27tagName\x27, \x27events\x27];\x0a\x0a  // Set up all inheritable **Backbone.View** properties and methods.\x0a  _.extend(View.prototype, Events, {\x0a\x0a    // The default `tagName` of a View\x27s element is `\x22div\x22`.\x0a    tagName: \x27div\x27,\x0a\x0a    // jQuery delegate for element lookup, scoped to DOM elements within the\x0a    // current view. This should be preferred to global lookups where possible.\x0a    $: function(selector) {\x0a      return this.$el.find(selector);\x0a    },\x0a\x0a    // Initialize is an empty function by default. Override it with your own\x0a    // initialization logic.\x0a    initialize: function(){},\x0a\x0a    // **render** is the core function that your view should override, in order\x0a    // to populate its element (`this.el`), with the appropriate HTML. The\x0a    // convention is for **render** to always return `this`.\x0a    render: function() {\x0a      return this;\x0a    },\x0a\x0a    // Remove this view by taking the element out of the DOM, and removing any\x0a    // applicable Backbone.Events listeners.\x0a    remove: function() {\x0a      this._removeElement();\x0a      this.stopListening();\x0a      return this;\x0a    },\x0a\x0a    // Remove this view\x27s element from the document and all event listeners\x0a    // attached to it. Exposed for subclasses using an alternative DOM\x0a    // manipulation API.\x0a    _removeElement: function() {\x0a      this.$el.remove();\x0a    },\x0a\x0a    // Change the view\x27s element (`this.el` property) and re-delegate the\x0a    // view\x27s events on the new element.\x0a    setElement: function(element) {\x0a      this.undelegateEvents();\x0a      this._setElement(element);\x0a      this.delegateEvents();\x0a      return this;\x0a    },\x0a\x0a    // Creates the `this.el` and `this.$el` references for this view using the\x0a    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery\x0a    // context or an element. Subclasses can override this to utilize an\x0a    // alternative DOM manipulation API and are only required to set the\x0a    // `this.el` property.\x0a    _setElement: function(el) {\x0a      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);\x0a      this.el = this.$el[0];\x0a    },\x0a\x0a    // Set callbacks, where `this.events` is a hash of\x0a    //\x0a    // *{\x22event selector\x22: \x22callback\x22}*\x0a    //\x0a    //     {\x0a    //       \x27mousedown .title\x27:  \x27edit\x27,\x0a    //       \x27click .button\x27:     \x27save\x27,\x0a    //       \x27click .open\x27:       function(e) { ... }\x0a    //     }\x0a    //\x0a    // pairs. Callbacks will be bound to the view, with `this` set properly.\x0a    // Uses event delegation for efficiency.\x0a    // Omitting the selector binds the event to `this.el`.\x0a    delegateEvents: function(events) {\x0a      events || (events = _.result(this, \x27events\x27));\x0a      if (!events) return this;\x0a      this.undelegateEvents();\x0a      for (var key in events) {\x0a        var method = events[key];\x0a        if (!_.isFunction(method)) method = this[method];\x0a        if (!method) continue;\x0a        var match = key.match(delegateEventSplitter);\x0a        this.delegate(match[1], match[2], _.bind(method, this));\x0a      }\x0a      return this;\x0a    },\x0a\x0a    // Add a single event listener to the view\x27s element (or a child element\x0a    // using `selector`). This only works for delegate-able events: not `focus`,\x0a    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\x0a    delegate: function(eventName, selector, listener) {\x0a      this.$el.on(eventName + \x27.delegateEvents\x27 + this.cid, selector, listener);\x0a      return this;\x0a    },\x0a\x0a    // Clears all callbacks previously bound to the view by `delegateEvents`.\x0a    // You usually don\x27t need to use this, but may wish to if you have multiple\x0a    // Backbone views attached to the same DOM element.\x0a    undelegateEvents: function() {\x0a      if (this.$el) this.$el.off(\x27.delegateEvents\x27 + this.cid);\x0a      return this;\x0a    },\x0a\x0a    // A finer-grained `undelegateEvents` for removing a single delegated event.\x0a    // `selector` and `listener` are both optional.\x0a    undelegate: function(eventName, selector, listener) {\x0a      this.$el.off(eventName + \x27.delegateEvents\x27 + this.cid, selector, listener);\x0a      return this;\x0a    },\x0a\x0a    // Produces a DOM element to be assigned to your view. Exposed for\x0a    // subclasses using an alternative DOM manipulation API.\x0a    _createElement: function(tagName) {\x0a      return document.createElement(tagName);\x0a    },\x0a\x0a    // Ensure that the View has a DOM element to render into.\x0a    // If `this.el` is a string, pass it through `$()`, take the first\x0a    // matching element, and re-assign it to `el`. Otherwise, create\x0a    // an element from the `id`, `className` and `tagName` properties.\x0a    _ensureElement: function() {\x0a      if (!this.el) {\x0a        var attrs = _.extend({}, _.result(this, \x27attributes\x27));\x0a        if (this.id) attrs.id = _.result(this, \x27id\x27);\x0a        if (this.className) attrs[\x27class\x27] = _.result(this, \x27className\x27);\x0a        this.setElement(this._createElement(_.result(this, \x27tagName\x27)));\x0a        this._setAttributes(attrs);\x0a      } else {\x0a        this.setElement(_.result(this, \x27el\x27));\x0a      }\x0a    },\x0a\x0a    // Set attributes from a hash on this view\x27s element.  Exposed for\x0a    // subclasses using an alternative DOM manipulation API.\x0a    _setAttributes: function(attributes) {\x0a      this.$el.attr(attributes);\x0a    }\x0a\x0a  });\x0a\x0a  // Backbone.sync\x0a  // -------------\x0a\x0a  // Override this function to change the manner in which Backbone persists\x0a  // models to the server. You will be passed the type of request, and the\x0a  // model in question. By default, makes a RESTful Ajax request\x0a  // to the model\x27s `url()`. Some possible customizations could be:\x0a  //\x0a  // * Use `setTimeout` to batch rapid-fire updates into a single request.\x0a  // * Send up the models as XML instead of JSON.\x0a  // * Persist models via WebSockets instead of Ajax.\x0a  //\x0a  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\x0a  // as `POST`, with a `_method` parameter containing the true HTTP method,\x0a  // as well as all requests with the body as `application/x-www-form-urlencoded`\x0a  // instead of `application/json` with the model in a param named `model`.\x0a  // Useful when interfacing with server-side languages like **PHP** that make\x0a  // it difficult to read the body of `PUT` requests.\x0a  Backbone.sync = function(method, model, options) {\x0a    var type = methodMap[method];\x0a\x0a    // Default options, unless specified.\x0a    _.defaults(options || (options = {}), {\x0a      emulateHTTP: Backbone.emulateHTTP,\x0a      emulateJSON: Backbone.emulateJSON\x0a    });\x0a\x0a    // Default JSON-request options.\x0a    var params = {type: type, dataType: \x27json\x27};\x0a\x0a    // Ensure that we have a URL.\x0a    if (!options.url) {\x0a      params.url = _.result(model, \x27url\x27) || urlError();\x0a    }\x0a\x0a    // Ensure that we have the appropriate request data.\x0a    if (options.data == null && model && (method === \x27create\x27 || method === \x27update\x27 || method === \x27patch\x27)) {\x0a      params.contentType = \x27application/json\x27;\x0a      params.data = JSON.stringify(options.attrs || model.toJSON(options));\x0a    }\x0a\x0a    // For older servers, emulate JSON by encoding the request into an HTML-form.\x0a    if (options.emulateJSON) {\x0a      params.contentType = \x27application/x-www-form-urlencoded\x27;\x0a      params.data = params.data ? {model: params.data} : {};\x0a    }\x0a\x0a    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\x0a    // And an `X-HTTP-Method-Override` header.\x0a    if (options.emulateHTTP && (type === \x27PUT\x27 || type === \x27DELETE\x27 || type === \x27PATCH\x27)) {\x0a      params.type = \x27POST\x27;\x0a      if (options.emulateJSON) params.data._method = type;\x0a      var beforeSend = options.beforeSend;\x0a      options.beforeSend = function(xhr) {\x0a        xhr.setRequestHeader(\x27X-HTTP-Method-Override\x27, type);\x0a        if (beforeSend) return beforeSend.apply(this, arguments);\x0a      };\x0a    }\x0a\x0a    // Don\x27t process data on a non-GET request.\x0a    if (params.type !== \x27GET\x27 && !options.emulateJSON) {\x0a      params.processData = false;\x0a    }\x0a\x0a    // Pass along `textStatus` and `errorThrown` from jQuery.\x0a    var error = options.error;\x0a    options.error = function(xhr, textStatus, errorThrown) {\x0a      options.textStatus = textStatus;\x0a      options.errorThrown = errorThrown;\x0a      if (error) error.call(options.context, xhr, textStatus, errorThrown);\x0a    };\x0a\x0a    // Make the request, allowing the user to override any Ajax options.\x0a    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\x0a    model.trigger(\x27request\x27, model, xhr, options);\x0a    return xhr;\x0a  };\x0a\x0a  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\x0a  var methodMap = {\x0a    \x27create\x27: \x27POST\x27,\x0a    \x27update\x27: \x27PUT\x27,\x0a    \x27patch\x27: \x27PATCH\x27,\x0a    \x27delete\x27: \x27DELETE\x27,\x0a    \x27read\x27: \x27GET\x27\x0a  };\x0a\x0a  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\x0a  // Override this if you\x27d like to use a different library.\x0a  Backbone.ajax = function() {\x0a    return Backbone.$.ajax.apply(Backbone.$, arguments);\x0a  };\x0a\x0a  // Backbone.Router\x0a  // ---------------\x0a\x0a  // Routers map faux-URLs to actions, and fire events when routes are\x0a  // matched. Creating a new one sets its `routes` hash, if not set statically.\x0a  var Router = Backbone.Router = function(options) {\x0a    options || (options = {});\x0a    if (options.routes) this.routes = options.routes;\x0a    this._bindRoutes();\x0a    this.initialize.apply(this, arguments);\x0a  };\x0a\x0a  // Cached regular expressions for matching named param parts and splatted\x0a  // parts of route strings.\x0a  var optionalParam = /\x5c((.*?)\x5c)/g;\x0a  var namedParam    = /(\x5c(\x5c?)?:\x5cw+/g;\x0a  var splatParam    = /\x5c*\x5cw+/g;\x0a  var escapeRegExp  = /[\x5c-{}\x5c[\x5c]+?.,\x5c\x5c\x5c^$|#\x5cs]/g;\x0a\x0a  // Set up all inheritable **Backbone.Router** properties and methods.\x0a  _.extend(Router.prototype, Events, {\x0a\x0a    // Initialize is an empty function by default. Override it with your own\x0a    // initialization logic.\x0a    initialize: function(){},\x0a\x0a    // Manually bind a single named route to a callback. For example:\x0a    //\x0a    //     this.route(\x27search/:query/p:num\x27, \x27search\x27, function(query, num) {\x0a    //       ...\x0a    //     });\x0a    //\x0a    route: function(route, name, callback) {\x0a      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\x0a      if (_.isFunction(name)) {\x0a        callback = name;\x0a        name = \x27\x27;\x0a      }\x0a      if (!callback) callback = this[name];\x0a      var router = this;\x0a      Backbone.history.route(route, function(fragment) {\x0a        var args = router._extractParameters(route, fragment);\x0a        if (router.execute(callback, args, name) !== false) {\x0a          router.trigger.apply(router, [\x27route:\x27 + name].concat(args));\x0a          router.trigger(\x27route\x27, name, args);\x0a          Backbone.history.trigger(\x27route\x27, router, name, args);\x0a        }\x0a      });\x0a      return this;\x0a    },\x0a\x0a    // Execute a route handler with the provided parameters.  This is an\x0a    // excellent place to do pre-route setup or post-route cleanup.\x0a    execute: function(callback, args, name) {\x0a      if (callback) callback.apply(this, args);\x0a    },\x0a\x0a    // Simple proxy to `Backbone.history` to save a fragment into the history.\x0a    navigate: function(fragment, options) {\x0a      Backbone.history.navigate(fragment, options);\x0a      return this;\x0a    },\x0a\x0a    // Bind all defined routes to `Backbone.history`. We have to reverse the\x0a    // order of the routes here to support behavior where the most general\x0a    // routes can be defined at the bottom of the route map.\x0a    _bindRoutes: function() {\x0a      if (!this.routes) return;\x0a      this.routes = _.result(this, \x27routes\x27);\x0a      var route, routes = _.keys(this.routes);\x0a      while ((route = routes.pop()) != null) {\x0a        this.route(route, this.routes[route]);\x0a      }\x0a    },\x0a\x0a    // Convert a route string into a regular expression, suitable for matching\x0a    // against the current location hash.\x0a    _routeToRegExp: function(route) {\x0a      route = route.replace(escapeRegExp, \x27\x5c\x5c$&\x27)\x0a                   .replace(optionalParam, \x27(?:$1)?\x27)\x0a                   .replace(namedParam, function(match, optional) {\x0a                     return optional ? match : \x27([^/?]+)\x27;\x0a                   })\x0a                   .replace(splatParam, \x27([^?]*?)\x27);\x0a      return new RegExp(\x27^\x27 + route + \x27(?:\x5c\x5c?([\x5c\x5cs\x5c\x5cS]*))?$\x27);\x0a    },\x0a\x0a    // Given a route, and a URL fragment that it matches, return the array of\x0a    // extracted decoded parameters. Empty or unmatched parameters will be\x0a    // treated as `null` to normalize cross-browser behavior.\x0a    _extractParameters: function(route, fragment) {\x0a      var params = route.exec(fragment).slice(1);\x0a      return _.map(params, function(param, i) {\x0a        // Don\x27t decode the search params.\x0a        if (i === params.length - 1) return param || null;\x0a        return param ? decodeURIComponent(param) : null;\x0a      });\x0a    }\x0a\x0a  });\x0a\x0a  // Backbone.History\x0a  // ----------------\x0a\x0a  // Handles cross-browser history management, based on either\x0a  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\x0a  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\x0a  // and URL fragments. If the browser supports neither (old IE, natch),\x0a  // falls back to polling.\x0a  var History = Backbone.History = function() {\x0a    this.handlers = [];\x0a    this.checkUrl = _.bind(this.checkUrl, this);\x0a\x0a    // Ensure that `History` can be used outside of the browser.\x0a    if (typeof window !== \x27undefined\x27) {\x0a      this.location = window.location;\x0a      this.history = window.history;\x0a    }\x0a  };\x0a\x0a  // Cached regex for stripping a leading hash/slash and trailing space.\x0a  var routeStripper = /^[#\x5c/]|\x5cs+$/g;\x0a\x0a  // Cached regex for stripping leading and trailing slashes.\x0a  var rootStripper = /^\x5c/+|\x5c/+$/g;\x0a\x0a  // Cached regex for stripping urls of hash.\x0a  var pathStripper = /#.*$/;\x0a\x0a  // Has the history handling already been started?\x0a  History.started = false;\x0a\x0a  // Set up all inheritable **Backbone.History** properties and methods.\x0a  _.extend(History.prototype, Events, {\x0a\x0a    // The default interval to poll for hash changes, if necessary, is\x0a    // twenty times a second.\x0a    interval: 50,\x0a\x0a    // Are we at the app root?\x0a    atRoot: function() {\x0a      var path = this.location.pathname.replace(/[^\x5c/]$/, \x27$&/\x27);\x0a      return path === this.root && !this.getSearch();\x0a    },\x0a\x0a    // Does the pathname match the root?\x0a    matchRoot: function() {\x0a      var path = this.decodeFragment(this.location.pathname);\x0a      var rootPath = path.slice(0, this.root.length - 1) + \x27/\x27;\x0a      return rootPath === this.root;\x0a    },\x0a\x0a    // Unicode characters in `location.pathname` are percent encoded so they\x27re\x0a    // decoded for comparison. `%25` should not be decoded since it may be part\x0a    // of an encoded parameter.\x0a    decodeFragment: function(fragment) {\x0a      return decodeURI(fragment.replace(/%25/g, \x27%2525\x27));\x0a    },\x0a\x0a    // In IE6, the hash fragment and search params are incorrect if the\x0a    // fragment contains `?`.\x0a    getSearch: function() {\x0a      var match = this.location.href.replace(/#.*/, \x27\x27).match(/\x5c?.+/);\x0a      return match ? match[0] : \x27\x27;\x0a    },\x0a\x0a    // Gets the true hash value. Cannot use location.hash directly due to bug\x0a    // in Firefox where location.hash will always be decoded.\x0a    getHash: function(window) {\x0a      var match = (window || this).location.href.match(/#(.*)$/);\x0a      return match ? match[1] : \x27\x27;\x0a    },\x0a\x0a    // Get the pathname and search params, without the root.\x0a    getPath: function() {\x0a      var path = this.decodeFragment(\x0a        this.location.pathname + this.getSearch()\x0a      ).slice(this.root.length - 1);\x0a      return path.charAt(0) === \x27/\x27 ? path.slice(1) : path;\x0a    },\x0a\x0a    // Get the cross-browser normalized URL fragment from the path or hash.\x0a    getFragment: function(fragment) {\x0a      if (fragment == null) {\x0a        if (this._usePushState || !this._wantsHashChange) {\x0a          fragment = this.getPath();\x0a        } else {\x0a          fragment = this.getHash();\x0a        }\x0a      }\x0a      return fragment.replace(routeStripper, \x27\x27);\x0a    },\x0a\x0a    // Start the hash change handling, returning `true` if the current URL matches\x0a    // an existing route, and `false` otherwise.\x0a    start: function(options) {\x0a      if (History.started) throw new Error(\x27Backbone.history has already been started\x27);\x0a      History.started = true;\x0a\x0a      // Figure out the initial configuration. Do we need an iframe?\x0a      // Is pushState desired ... is it available?\x0a      this.options          = _.extend({root: \x27/\x27}, this.options, options);\x0a      this.root             = this.options.root;\x0a      this._wantsHashChange = this.options.hashChange !== false;\x0a      this._hasHashChange   = \x27onhashchange\x27 in window && (document.documentMode === void 0 || document.documentMode \x3e 7);\x0a      this._useHashChange   = this._wantsHashChange && this._hasHashChange;\x0a      this._wantsPushState  = !!this.options.pushState;\x0a      this._hasPushState    = !!(this.history && this.history.pushState);\x0a      this._usePushState    = this._wantsPushState && this._hasPushState;\x0a      this.fragment         = this.getFragment();\x0a\x0a      // Normalize root to always include a leading and trailing slash.\x0a      this.root = (\x27/\x27 + this.root + \x27/\x27).replace(rootStripper, \x27/\x27);\x0a\x0a      // Transition from hashChange to pushState or vice versa if both are\x0a      // requested.\x0a      if (this._wantsHashChange && this._wantsPushState) {\x0a\x0a        // If we\x27ve started off with a route from a `pushState`-enabled\x0a        // browser, but we\x27re currently in a browser that doesn\x27t support it...\x0a        if (!this._hasPushState && !this.atRoot()) {\x0a          var rootPath = this.root.slice(0, -1) || \x27/\x27;\x0a          this.location.replace(rootPath + \x27#\x27 + this.getPath());\x0a          // Return immediately as browser will do redirect to new url\x0a          return true;\x0a\x0a        // Or if we\x27ve started out with a hash-based route, but we\x27re currently\x0a        // in a browser where it could be `pushState`-based instead...\x0a        } else if (this._hasPushState && this.atRoot()) {\x0a          this.navigate(this.getHash(), {replace: true});\x0a        }\x0a\x0a      }\x0a\x0a      // Proxy an iframe to handle location events if the browser doesn\x27t\x0a      // support the `hashchange` event, HTML5 history, or the user wants\x0a      // `hashChange` but not `pushState`.\x0a      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {\x0a        this.iframe = document.createElement(\x27iframe\x27);\x0a        this.iframe.src = \x27javascript:0\x27;\x0a        this.iframe.style.display = \x27none\x27;\x0a        this.iframe.tabIndex = -1;\x0a        var body = document.body;\x0a        // Using `appendChild` will throw on IE \x3c 9 if the document is not ready.\x0a        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;\x0a        iWindow.document.open();\x0a        iWindow.document.close();\x0a        iWindow.location.hash = \x27#\x27 + this.fragment;\x0a      }\x0a\x0a      // Add a cross-platform `addEventListener` shim for older browsers.\x0a      var addEventListener = window.addEventListener || function(eventName, listener) {\x0a        return attachEvent(\x27on\x27 + eventName, listener);\x0a      };\x0a\x0a      // Depending on whether we\x27re using pushState or hashes, and whether\x0a      // \x27onhashchange\x27 is supported, determine how we check the URL state.\x0a      if (this._usePushState) {\x0a        addEventListener(\x27popstate\x27, this.checkUrl, false);\x0a      } else if (this._useHashChange && !this.iframe) {\x0a        addEventListener(\x27hashchange\x27, this.checkUrl, false);\x0a      } else if (this._wantsHashChange) {\x0a        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\x0a      }\x0a\x0a      if (!this.options.silent) return this.loadUrl();\x0a    },\x0a\x0a    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\x0a    // but possibly useful for unit testing Routers.\x0a    stop: function() {\x0a      // Add a cross-platform `removeEventListener` shim for older browsers.\x0a      var removeEventListener = window.removeEventListener || function(eventName, listener) {\x0a        return detachEvent(\x27on\x27 + eventName, listener);\x0a      };\x0a\x0a      // Remove window listeners.\x0a      if (this._usePushState) {\x0a        removeEventListener(\x27popstate\x27, this.checkUrl, false);\x0a      } else if (this._useHashChange && !this.iframe) {\x0a        removeEventListener(\x27hashchange\x27, this.checkUrl, false);\x0a      }\x0a\x0a      // Clean up the iframe if necessary.\x0a      if (this.iframe) {\x0a        document.body.removeChild(this.iframe);\x0a        this.iframe = null;\x0a      }\x0a\x0a      // Some environments will throw when clearing an undefined interval.\x0a      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\x0a      History.started = false;\x0a    },\x0a\x0a    // Add a route to be tested when the fragment changes. Routes added later\x0a    // may override previous routes.\x0a    route: function(route, callback) {\x0a      this.handlers.unshift({route: route, callback: callback});\x0a    },\x0a\x0a    // Checks the current URL to see if it has changed, and if it has,\x0a    // calls `loadUrl`, normalizing across the hidden iframe.\x0a    checkUrl: function(e) {\x0a      var current = this.getFragment();\x0a\x0a      // If the user pressed the back button, the iframe\x27s hash will have\x0a      // changed and we should use that for comparison.\x0a      if (current === this.fragment && this.iframe) {\x0a        current = this.getHash(this.iframe.contentWindow);\x0a      }\x0a\x0a      if (current === this.fragment) return false;\x0a      if (this.iframe) this.navigate(current);\x0a      this.loadUrl();\x0a    },\x0a\x0a    // Attempt to load the current URL fragment. If a route succeeds with a\x0a    // match, returns `true`. If no defined routes matches the fragment,\x0a    // returns `false`.\x0a    loadUrl: function(fragment) {\x0a      // If the root doesn\x27t match, no routes can match either.\x0a      if (!this.matchRoot()) return false;\x0a      fragment = this.fragment = this.getFragment(fragment);\x0a      return _.some(this.handlers, function(handler) {\x0a        if (handler.route.test(fragment)) {\x0a          handler.callback(fragment);\x0a          return true;\x0a        }\x0a      });\x0a    },\x0a\x0a    // Save a fragment into the hash history, or replace the URL state if the\x0a    // \x27replace\x27 option is passed. You are responsible for properly URL-encoding\x0a    // the fragment in advance.\x0a    //\x0a    // The options object can contain `trigger: true` if you wish to have the\x0a    // route callback be fired (not usually desirable), or `replace: true`, if\x0a    // you wish to modify the current URL without adding an entry to the history.\x0a    navigate: function(fragment, options) {\x0a      if (!History.started) return false;\x0a      if (!options || options === true) options = {trigger: !!options};\x0a\x0a      // Normalize the fragment.\x0a      fragment = this.getFragment(fragment || \x27\x27);\x0a\x0a      // Don\x27t include a trailing slash on the root.\x0a      var rootPath = this.root;\x0a      if (fragment === \x27\x27 || fragment.charAt(0) === \x27?\x27) {\x0a        rootPath = rootPath.slice(0, -1) || \x27/\x27;\x0a      }\x0a      var url = rootPath + fragment;\x0a\x0a      // Strip the hash and decode for matching.\x0a      fragment = this.decodeFragment(fragment.replace(pathStripper, \x27\x27));\x0a\x0a      if (this.fragment === fragment) return;\x0a      this.fragment = fragment;\x0a\x0a      // If pushState is available, we use it to set the fragment as a real URL.\x0a      if (this._usePushState) {\x0a        this.history[options.replace ? \x27replaceState\x27 : \x27pushState\x27]({}, document.title, url);\x0a\x0a      // If hash changes haven\x27t been explicitly disabled, update the hash\x0a      // fragment to store history.\x0a      } else if (this._wantsHashChange) {\x0a        this._updateHash(this.location, fragment, options.replace);\x0a        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {\x0a          var iWindow = this.iframe.contentWindow;\x0a\x0a          // Opening and closing the iframe tricks IE7 and earlier to push a\x0a          // history entry on hash-tag change.  When replace is true, we don\x27t\x0a          // want this.\x0a          if (!options.replace) {\x0a            iWindow.document.open();\x0a            iWindow.document.close();\x0a          }\x0a\x0a          this._updateHash(iWindow.location, fragment, options.replace);\x0a        }\x0a\x0a      // If you\x27ve told us that you explicitly don\x27t want fallback hashchange-\x0a      // based history, then `navigate` becomes a page refresh.\x0a      } else {\x0a        return this.location.assign(url);\x0a      }\x0a      if (options.trigger) return this.loadUrl(fragment);\x0a    },\x0a\x0a    // Update the hash location, either replacing the current entry, or adding\x0a    // a new one to the browser history.\x0a    _updateHash: function(location, fragment, replace) {\x0a      if (replace) {\x0a        var href = location.href.replace(/(javascript:|#).*$/, \x27\x27);\x0a        location.replace(href + \x27#\x27 + fragment);\x0a      } else {\x0a        // Some browsers require that `hash` contains a leading #.\x0a        location.hash = \x27#\x27 + fragment;\x0a      }\x0a    }\x0a\x0a  });\x0a\x0a  // Create the default Backbone.history.\x0a  Backbone.history = new History;\x0a\x0a  // Helpers\x0a  // -------\x0a\x0a  // Helper function to correctly set up the prototype chain for subclasses.\x0a  // Similar to `goog.inherits`, but uses a hash of prototype properties and\x0a  // class properties to be extended.\x0a  var extend = function(protoProps, staticProps) {\x0a    var parent = this;\x0a    var child;\x0a\x0a    // The constructor function for the new subclass is either defined by you\x0a    // (the \x22constructor\x22 property in your `extend` definition), or defaulted\x0a    // by us to simply call the parent constructor.\x0a    if (protoProps && _.has(protoProps, \x27constructor\x27)) {\x0a      child = protoProps.constructor;\x0a    } else {\x0a      child = function(){ return parent.apply(this, arguments); };\x0a    }\x0a\x0a    // Add static properties to the constructor function, if supplied.\x0a    _.extend(child, parent, staticProps);\x0a\x0a    // Set the prototype chain to inherit from `parent`, without calling\x0a    // `parent`\x27s constructor function and add the prototype properties.\x0a    child.prototype = _.create(parent.prototype, protoProps);\x0a    child.prototype.constructor = child;\x0a\x0a    // Set a convenience property in case the parent\x27s prototype is needed\x0a    // later.\x0a    child.__super__ = parent.prototype;\x0a\x0a    return child;\x0a  };\x0a\x0a  // Set up inheritance for the model, collection, router, view and history.\x0a  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\x0a\x0a  // Throw an error when a URL is needed, and none is supplied.\x0a  var urlError = function() {\x0a    throw new Error(\x27A \x22url\x22 property or function must be specified\x27);\x0a  };\x0a\x0a  // Wrap an optional error callback with a fallback error event.\x0a  var wrapError = function(model, options) {\x0a    var error = options.error;\x0a    options.error = function(resp) {\x0a      if (error) error.call(options.context, model, resp, options);\x0a      model.trigger(\x27error\x27, model, resp, options);\x0a    };\x0a  };\x0a\x0a  return Backbone;\x0a});\x0a'}