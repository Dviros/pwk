var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:05:09 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 21 Mar 2019 12:48:00 GMT\x0aETag: \x2218f58-5849a25f20000-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-26558/26559\x0aContent-Length: 26559\x0aKeep-Alive: timeout=5, max=86\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/** @license React v16.8.4\x0a * react.development.js\x0a *\x0a * Copyright (c) Facebook, Inc. and its affiliates.\x0a *\x0a * This source code is licensed under the MIT license found in the\x0a * LICENSE file in the root directory of this source tree.\x0a */\x0a\x0a\x27use strict\x27;\x0a\x0a(function (global, factory) {\x0a\x09typeof exports === \x27object\x27 && typeof module !== \x27undefined\x27 ? module.exports = factory() :\x0a\x09typeof define === \x27function\x27 && define.amd ? define(factory) :\x0a\x09(global.React = factory());\x0a}(this, (function () { \x27use strict\x27;\x0a\x0a// TODO: this is special because it gets imported during build.\x0a\x0avar ReactVersion = \x2716.8.4\x27;\x0a\x0a// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\x0a// nor polyfill, then a plain number is used for performance.\x0avar hasSymbol = typeof Symbol === \x27function\x27 && Symbol.for;\x0a\x0avar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\x27react.element\x27) : 0xeac7;\x0avar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\x27react.portal\x27) : 0xeaca;\x0avar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\x27react.fragment\x27) : 0xeacb;\x0avar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\x27react.strict_mode\x27) : 0xeacc;\x0avar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\x27react.profiler\x27) : 0xead2;\x0avar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\x27react.provider\x27) : 0xeacd;\x0avar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\x27react.context\x27) : 0xeace;\x0a\x0avar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\x27react.concurrent_mode\x27) : 0xeacf;\x0avar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\x27react.forward_ref\x27) : 0xead0;\x0avar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\x27react.suspense\x27) : 0xead1;\x0avar REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\x27react.memo\x27) : 0xead3;\x0avar REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\x27react.lazy\x27) : 0xead4;\x0a\x0avar MAYBE_ITERATOR_SYMBOL = typeof Symbol === \x27function\x27 && Symbol.iterator;\x0avar FAUX_ITERATOR_SYMBOL = \x27@@iterator\x27;\x0a\x0afunction getIteratorFn(maybeIterable) {\x0a  if (maybeIterable === null || typeof maybeIterable !== \x27object\x27) {\x0a    return null;\x0a  }\x0a  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\x0a  if (typeof maybeIterator === \x27function\x27) {\x0a    return maybeIterator;\x0a  }\x0a  return null;\x0a}\x0a\x0a/*\x0aobject-assign\x0a(c) Sindre Sorhus\x0a@license MIT\x0a*/\x0a\x0a\x0a/* eslint-disable no-unused-vars */\x0avar getOwnPropertySymbols = Object.getOwnPropertySymbols;\x0avar hasOwnProperty = Object.prototype.hasOwnProperty;\x0avar propIsEnumerable = Object.prototype.propertyIsEnumerable;\x0a\x0afunction toObject(val) {\x0a\x09if (val === null || val === undefined) {\x0a\x09\x09throw new TypeError(\x27Object.assign cannot be called with null or undefined\x27);\x0a\x09}\x0a\x0a\x09return Object(val);\x0a}\x0a\x0afunction shouldUseNative() {\x0a\x09try {\x0a\x09\x09if (!Object.assign) {\x0a\x09\x09\x09return false;\x0a\x09\x09}\x0a\x0a\x09\x09// Detect buggy property enumeration order in older V8 versions.\x0a\x0a\x09\x09// https://bugs.chromium.org/p/v8/issues/detail?id=4118\x0a\x09\x09var test1 = new String(\x27abc\x27);  // eslint-disable-line no-new-wrappers\x0a\x09\x09test1[5] = \x27de\x27;\x0a\x09\x09if (Object.getOwnPropertyNames(test1)[0] === \x275\x27) {\x0a\x09\x09\x09return false;\x0a\x09\x09}\x0a\x0a\x09\x09// https://bugs.chromium.org/p/v8/issues/detail?id=3056\x0a\x09\x09var test2 = {};\x0a\x09\x09for (var i = 0; i \x3c 10; i++) {\x0a\x09\x09\x09test2[\x27_\x27 + String.fromCharCode(i)] = i;\x0a\x09\x09}\x0a\x09\x09var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\x0a\x09\x09\x09return test2[n];\x0a\x09\x09});\x0a\x09\x09if (order2.join(\x27\x27) !== \x270123456789\x27) {\x0a\x09\x09\x09return false;\x0a\x09\x09}\x0a\x0a\x09\x09// https://bugs.chromium.org/p/v8/issues/detail?id=3056\x0a\x09\x09var test3 = {};\x0a\x09\x09\x27abcdefghijklmnopqrst\x27.split(\x27\x27).forEach(function (letter) {\x0a\x09\x09\x09test3[letter] = letter;\x0a\x09\x09});\x0a\x09\x09if (Object.keys(Object.assign({}, test3)).join(\x27\x27) !==\x0a\x09\x09\x09\x09\x27abcdefghijklmnopqrst\x27) {\x0a\x09\x09\x09return false;\x0a\x09\x09}\x0a\x0a\x09\x09return true;\x0a\x09} catch (err) {\x0a\x09\x09// We don\x27t expect any of the above to throw, but better to be safe.\x0a\x09\x09return false;\x0a\x09}\x0a}\x0a\x0avar objectAssign = shouldUseNative() ? Object.assign : function (target, source) {\x0a\x09var from;\x0a\x09var to = toObject(target);\x0a\x09var symbols;\x0a\x0a\x09for (var s = 1; s \x3c arguments.length; s++) {\x0a\x09\x09from = Object(arguments[s]);\x0a\x0a\x09\x09for (var key in from) {\x0a\x09\x09\x09if (hasOwnProperty.call(from, key)) {\x0a\x09\x09\x09\x09to[key] = from[key];\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09if (getOwnPropertySymbols) {\x0a\x09\x09\x09symbols = getOwnPropertySymbols(from);\x0a\x09\x09\x09for (var i = 0; i \x3c symbols.length; i++) {\x0a\x09\x09\x09\x09if (propIsEnumerable.call(from, symbols[i])) {\x0a\x09\x09\x09\x09\x09to[symbols[i]] = from[symbols[i]];\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09return to;\x0a};\x0a\x0a/**\x0a * Use invariant() to assert state which your program assumes to be true.\x0a *\x0a * Provide sprintf-style format (only %s is supported) and arguments\x0a * to provide information about what broke and what you were\x0a * expecting.\x0a *\x0a * The invariant message will be stripped in production, but the invariant\x0a * will remain to ensure logic does not differ in production.\x0a */\x0a\x0avar validateFormat = function () {};\x0a\x0a{\x0a  validateFormat = function (format) {\x0a    if (format === undefined) {\x0a      throw new Error(\x27invariant requires an error message argument\x27);\x0a    }\x0a  };\x0a}\x0a\x0afunction invariant(condition, format, a, b, c, d, e, f) {\x0a  validateFormat(format);\x0a\x0a  if (!condition) {\x0a    var error = void 0;\x0a    if (format === undefined) {\x0a      error = new Error(\x27Minified exception occurred; use the non-minified dev environment \x27 + \x27for the full error message and additional helpful warnings.\x27);\x0a    } else {\x0a      var args = [a, b, c, d, e, f];\x0a      var argIndex = 0;\x0a      error = new Error(format.replace(/%s/g, function () {\x0a        return args[argIndex++];\x0a      }));\x0a      error.name = \x27Invariant Violation\x27;\x0a    }\x0a\x0a    error.framesToPop = 1; // we don\x27t care about invariant\x27s own frame\x0a    throw error;\x0a  }\x0a}\x0a\x0a// Relying on the `invariant()` implementation lets us\x0a// preserve the format and params in the www builds.\x0a\x0a/**\x0a * Forked from fbjs/warning:\x0a * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\x0a *\x0a * Only change is we use console.warn instead of console.error,\x0a * and do nothing when \x27console\x27 is not supported.\x0a * This really simplifies the code.\x0a * ---\x0a * Similar to invariant but only logs a warning if the condition is not met.\x0a * This can be used to log issues in development environments in critical\x0a * paths. Removing the logging code for production environments will keep the\x0a * same logic and follow the same code paths.\x0a */\x0a\x0avar lowPriorityWarning = function () {};\x0a\x0a{\x0a  var printWarning = function (format) {\x0a    for (var _len = arguments.length, args = Array(_len \x3e 1 ? _len - 1 : 0), _key = 1; _key \x3c _len; _key++) {\x0a      args[_key - 1] = arguments[_key];\x0a    }\x0a\x0a    var argIndex = 0;\x0a    var message = \x27Warning: \x27 + format.replace(/%s/g, function () {\x0a      return args[argIndex++];\x0a    });\x0a    if (typeof console !== \x27undefined\x27) {\x0a      console.warn(message);\x0a    }\x0a    try {\x0a      // --- Welcome to debugging React ---\x0a      // This error was thrown as a convenience so that you can use this stack\x0a      // to find the callsite that caused this warning to fire.\x0a      throw new Error(message);\x0a    } catch (x) {}\x0a  };\x0a\x0a  lowPriorityWarning = function (condition, format) {\x0a    if (format === undefined) {\x0a      throw new Error(\x27`lowPriorityWarning(condition, format, ...args)` requires a warning \x27 + \x27message argument\x27);\x0a    }\x0a    if (!condition) {\x0a      for (var _len2 = arguments.length, args = Array(_len2 \x3e 2 ? _len2 - 2 : 0), _key2 = 2; _key2 \x3c _len2; _key2++) {\x0a        args[_key2 - 2] = arguments[_key2];\x0a      }\x0a\x0a      printWarning.apply(undefined, [format].concat(args));\x0a    }\x0a  };\x0a}\x0a\x0avar lowPriorityWarning$1 = lowPriorityWarning;\x0a\x0a/**\x0a * Similar to invariant but only logs a warning if the condition is not met.\x0a * This can be used to log issues in development environments in critical\x0a * paths. Removing the logging code for production environments will keep the\x0a * same logic and follow the same code paths.\x0a */\x0a\x0avar warningWithoutStack = function () {};\x0a\x0a{\x0a  warningWithoutStack = function (condition, format) {\x0a    for (var _len = arguments.length, args = Array(_len \x3e 2 ? _len - 2 : 0), _key = 2; _key \x3c _len; _key++) {\x0a      args[_key - 2] = arguments[_key];\x0a    }\x0a\x0a    if (format === undefined) {\x0a      throw new Error(\x27`warningWithoutStack(condition, format, ...args)` requires a warning \x27 + \x27message argument\x27);\x0a    }\x0a    if (args.length \x3e 8) {\x0a      // Check before the condition to catch violations early.\x0a      throw new Error(\x27warningWithoutStack() currently supports at most 8 arguments.\x27);\x0a    }\x0a    if (condition) {\x0a      return;\x0a    }\x0a    if (typeof console !== \x27undefined\x27) {\x0a      var argsWithFormat = args.map(function (item) {\x0a        return \x27\x27 + item;\x0a      });\x0a      argsWithFormat.unshift(\x27Warning: \x27 + format);\x0a\x0a      // We intentionally don\x27t use spread (or .apply) directly because it\x0a      // breaks IE9: https://github.com/facebook/react/issues/13610\x0a      Function.prototype.apply.call(console.error, console, argsWithFormat);\x0a    }\x0a    try {\x0a      // --- Welcome to debugging React ---\x0a      // This error was thrown as a convenience so that you can use this stack\x0a      // to find the callsite that caused this warning to fire.\x0a      var argIndex = 0;\x0a      var message = \x27Warning: \x27 + format.replace(/%s/g, function () {\x0a        return args[argIndex++];\x0a      });\x0a      throw new Error(message);\x0a    } catch (x) {}\x0a  };\x0a}\x0a\x0avar warningWithoutStack$1 = warningWithoutStack;\x0a\x0avar didWarnStateUpdateForUnmountedComponent = {};\x0a\x0afunction warnNoop(publicInstance, callerName) {\x0a  {\x0a    var _constructor = publicInstance.constructor;\x0a    var componentName = _constructor && (_constructor.displayName || _constructor.name) || \x27ReactClass\x27;\x0a    var warningKey = componentName + \x27.\x27 + callerName;\x0a    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\x0a      return;\x0a    }\x0a    warningWithoutStack$1(false, \x22Can\x27t call %s on a component that is not yet mounted. \x22 + \x27This is a no-op, but it might indicate a bug in your application. \x27 + \x27Instead, assign to `this.state` directly or define a `state = {};` \x27 + \x27class property with the desired state in the %s component.\x27, callerName, componentName);\x0a    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\x0a  }\x0a}\x0a\x0a/**\x0a * This is the abstract API for an update queue.\x0a */\x0avar ReactNoopUpdateQueue = {\x0a  /**\x0a   * Checks whether or not this composite component is mounted.\x0a   * @param {ReactClass} publicInstance The instance we want to test.\x0a   * @return {boolean} True if mounted, false otherwise.\x0a   * @protected\x0a   * @final\x0a   */\x0a  isMounted: function (publicInstance) {\x0a    return false;\x0a  },\x0a\x0a  /**\x0a   * Forces an update. This should only be invoked when it is known with\x0a   * certainty that we are **not** in a DOM transaction.\x0a   *\x0a   * You may want to call this when you know that some deeper aspect of the\x0a   * component\x27s state has changed but `setState` was not called.\x0a   *\x0a   * This will not invoke `shouldComponentUpdate`, but it will invoke\x0a   * `componentWillUpdate` and `componentDidUpdate`.\x0a   *\x0a   * @param {ReactClass} publicInstance The instance that should rerender.\x0a   * @param {?function} callback Called after component is updated.\x0a   * @param {?string} callerName name of the calling function in the public API.\x0a   * @internal\x0a   */\x0a  enqueueForceUpdate: function (publicInstance, callback, callerName) {\x0a    warnNoop(publicInstance, \x27forceUpdate\x27);\x0a  },\x0a\x0a  /**\x0a   * Replaces all of the state. Always use this or `setState` to mutate state.\x0a   * You should treat `this.state` as immutable.\x0a   *\x0a   * There is no guarantee that `this.state` will be immediately updated, so\x0a   * accessing `this.state` after calling this method may return the old value.\x0a   *\x0a   * @param {ReactClass} publicInstance The instance that should rerender.\x0a   * @param {object} completeState Next state.\x0a   * @param {?function} callback Called after component is updated.\x0a   * @param {?string} callerName name of the calling function in the public API.\x0a   * @internal\x0a   */\x0a  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\x0a    warnNoop(publicInstance, \x27replaceState\x27);\x0a  },\x0a\x0a  /**\x0a   * Sets a subset of the state. This only exists because _pendingState is\x0a   * internal. This provides a merging strategy that is not available to deep\x0a   * properties which is confusing. TODO: Expose pendingState or don\x27t use it\x0a   * during the merge.\x0a   *\x0a   * @param {ReactClass} publicInstance The instance that should rerender.\x0a   * @param {object} partialState Next partial state to be merged with state.\x0a   * @param {?function} callback Called after component is updated.\x0a   * @param {?string} Name of the calling function in the public API.\x0a   * @internal\x0a   */\x0a  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\x0a    warnNoop(publicInstance, \x27setState\x27);\x0a  }\x0a};\x0a\x0avar emptyObject = {};\x0a{\x0a  Object.freeze(emptyObject);\x0a}\x0a\x0a/**\x0a * Base class helpers for the updating state of a component.\x0a */\x0afunction Component(props, context, updater) {\x0a  this.props = props;\x0a  this.context = context;\x0a  // If a component has string refs, we will assign a different object later.\x0a  this.refs = emptyObject;\x0a  // We initialize the default updater but the real one gets injected by the\x0a  // renderer.\x0a  this.updater = updater || ReactNoopUpdateQueue;\x0a}\x0a\x0aComponent.prototype.isReactComponent = {};\x0a\x0a/**\x0a * Sets a subset of the state. Always use this to mutate\x0a * state. You should treat `this.state` as immutable.\x0a *\x0a * There is no guarantee that `this.state` will be immediately updated, so\x0a * accessing `this.state` after calling this method may return the old value.\x0a *\x0a * There is no guarantee that calls to `setState` will run synchronously,\x0a * as they may eventually be batched together.  You can provide an optional\x0a * callback that will be executed when the call to setState is actually\x0a * completed.\x0a *\x0a * When a function is provided to setState, it will be called at some point in\x0a * the future (not synchronously). It will be called with the up to date\x0a * component arguments (state, props, context). These values can be different\x0a * from this.* because your function may be called after receiveProps but before\x0a * shouldComponentUpdate, and this new state, props, and context will not yet be\x0a * assigned to this.\x0a *\x0a * @param {object|function} partialState Next partial state or function to\x0a *        produce next partial state to be merged with current state.\x0a * @param {?function} callback Called after state is updated.\x0a * @final\x0a * @protected\x0a */\x0aComponent.prototype.setState = function (partialState, callback) {\x0a  !(typeof partialState === \x27object\x27 || typeof partialState === \x27function\x27 || partialState == null) ? invariant(false, \x27setState(...): takes an object of state variables to update or a function which returns an object of state variables.\x27) : void 0;\x0a  this.updater.enqueueSetState(this, partialState, callback, \x27setState\x27);\x0a};\x0a\x0a/**\x0a * Forces an update. This should only be invoked when it is known with\x0a * certainty that we are **not** in a DOM transaction.\x0a *\x0a * You may want to call this when you know that some deeper aspect of the\x0a * component\x27s state has changed but `setState` was not called.\x0a *\x0a * This will not invoke `shouldComponentUpdate`, but it will invoke\x0a * `componentWillUpdate` and `componentDidUpdate`.\x0a *\x0a * @param {?function} callback Called after update is complete.\x0a * @final\x0a * @protected\x0a */\x0aComponent.prototype.forceUpdate = function (callback) {\x0a  this.updater.enqueueForceUpdate(this, callback, \x27forceUpdate\x27);\x0a};\x0a\x0a/**\x0a * Deprecated APIs. These APIs used to exist on classic React classes but since\x0a * we would like to deprecate them, we\x27re not going to move them over to this\x0a * modern base class. Instead, we define a getter that warns if it\x27s accessed.\x0a */\x0a{\x0a  var deprecatedAPIs = {\x0a    isMounted: [\x27isMounted\x27, \x27Instead, make sure to clean up subscriptions and pending requests in \x27 + \x27componentWillUnmount to prevent memory leaks.\x27],\x0a    replaceState: [\x27replaceState\x27, \x27Refactor your code to use setState instead (see \x27 + \x27https://github.com/facebook/react/issues/3236).\x27]\x0a  };\x0a  var defineDeprecationWarning = function (methodName, info) {\x0a    Object.defineProperty(Component.prototype, methodName, {\x0a      get: function () {\x0a        lowPriorityWarning$1(false, \x27%s(...) is deprecated in plain JavaScript React classes. %s\x27, info[0], info[1]);\x0a        return undefined;\x0a      }\x0a    });\x0a  };\x0a  for (var fnName in deprecatedAPIs) {\x0a    if (deprecatedAPIs.hasOwnProperty(fnName)) {\x0a      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\x0a    }\x0a  }\x0a}\x0a\x0afunction ComponentDummy() {}\x0aComponentDummy.prototype = Component.prototype;\x0a\x0a/**\x0a * Convenience component with default shallow equality check for sCU.\x0a */\x0afunction PureComponent(props, context, updater) {\x0a  this.props = props;\x0a  this.context = context;\x0a  // If a component has string refs, we will assign a different object later.\x0a  this.refs = emptyObject;\x0a  this.updater = updater || ReactNoopUpdateQueue;\x0a}\x0a\x0avar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\x0apureComponentPrototype.constructor = PureComponent;\x0a// Avoid an extra prototype jump for these methods.\x0aobjectAssign(pureComponentPrototype, Component.prototype);\x0apureComponentPrototype.isPureReactComponent = true;\x0a\x0a// an immutable object with a single mutable value\x0afunction createRef() {\x0a  var refObject = {\x0a    current: null\x0a  };\x0a  {\x0a    Object.seal(refObject);\x0a  }\x0a  return refObject;\x0a}\x0a\x0avar enableSchedulerDebugging = false;\x0a\x0a/* eslint-disable no-var */\x0a\x0a// TODO: Use symbols?\x0avar ImmediatePriority = 1;\x0avar UserBlockingPriority = 2;\x0avar NormalPriority = 3;\x0avar LowPriority = 4;\x0avar IdlePriority = 5;\x0a\x0a// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\x0a// Math.pow(2, 30) - 1\x0a// 0b111111111111111111111111111111\x0avar maxSigned31BitInt = 1073741823;\x0a\x0a// Times out immediately\x0avar IMMEDIATE_PRIORITY_TIMEOUT = -1;\x0a// Eventually times out\x0avar USER_BLOCKING_PRIORITY = 250;\x0avar NORMAL_PRIORITY_TIMEOUT = 5000;\x0avar LOW_PRIORITY_TIMEOUT = 10000;\x0a// Never times out\x0avar IDLE_PRIORITY = maxSigned31BitInt;\x0a\x0a// Callbacks are stored as a circular, doubly linked list.\x0avar firstCallbackNode = null;\x0a\x0avar currentDidTimeout = false;\x0a// Pausing the scheduler is useful for debugging.\x0avar isSchedulerPaused = false;\x0a\x0avar currentPriorityLevel = NormalPriority;\x0avar currentEventStartTime = -1;\x0avar currentExpirationTime = -1;\x0a\x0a// This is set when a callback is being executed, to prevent re-entrancy.\x0avar isExecutingCallback = false;\x0a\x0avar isHostCallbackScheduled = false;\x0a\x0avar hasNativePerformanceNow = typeof performance === \x27object\x27 && typeof performance.now === \x27function\x27;\x0a\x0afunction ensureHostCallbackIsScheduled() {\x0a  if (isExecutingCallback) {\x0a    // Don\x27t schedule work yet; wait until the next time we yield.\x0a    return;\x0a  }\x0a  // Schedule the host callback using the earliest expiration in the list.\x0a  var expirationTime = firstCallbackNode.expirationTime;\x0a  if (!isHostCallbackScheduled) {\x0a    isHostCallbackScheduled = true;\x0a  } else {\x0a    // Cancel the existing host callback.\x0a    cancelHostCallback();\x0a  }\x0a  requestHostCallback(flushWork, expirationTime);\x0a}\x0a\x0afunction flushFirstCallback() {\x0a  var flushedNode = firstCallbackNode;\x0a\x0a  // Remove the node from the list before calling the callback. That way the\x0a  // list is in a consistent state even if the callback throws.\x0a  var next = firstCallbackNode.next;\x0a  if (firstCallbackNode === next) {\x0a    // This is the last callback in the list.\x0a    firstCallbackNode = null;\x0a    next = null;\x0a  } else {\x0a    var lastCallbackNode = firstCallbackNode.previous;\x0a    firstCallbackNode = lastCallbackNode.next = next;\x0a    next.previous = lastCallbackNode;\x0a  }\x0a\x0a  flushedNode.next = flushedNode.previous = null;\x0a\x0a  // Now it\x27s safe to call the callback.\x0a  var callback = flushedNode.callback;\x0a  var expirationTime = flushedNode.expirationTime;\x0a  var priorityLevel = flushedNode.priorityLevel;\x0a  var previousPriorityLevel = currentPriorityLevel;\x0a  var previousExpirationTime = currentExpirationTime;\x0a  currentPriorityLevel = priorityLevel;\x0a  currentExpirationTime = expirationTime;\x0a  var continuationCallback;\x0a  try {\x0a    continuationCallback = callback();\x0a  } finally {\x0a    currentPriorityLevel = previousPriorityLevel;\x0a    currentExpirationTime = previousExpirationTime;\x0a  }\x0a\x0a  // A callback may return a continuation. The continuation should be scheduled\x0a  // with the same priority and expiration as the just-finished callback.\x0a  if (typeof continuationCallback === \x27function\x27) {\x0a    var continuationNode = {\x0a      callback: continuationCallback,\x0a      priorityLevel: priorityLevel,\x0a      expirationTime: expirationTime,\x0a      next: null,\x0a      previous: null\x0a    };\x0a\x0a    // Insert the new callback into the list, sorted by its expiration. This is\x0a    // almost the same as the code in `scheduleCallback`, except the callback\x0a    // is inserted into the list *before* callbacks of equal expiration instead\x0a    // of after.\x0a    if (firstCallbackNode === null) {\x0a      // This is the first callback in the list.\x0a      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\x0a    } else {\x0a      var nextAfterContinuation = null;\x0a      var node = firstCallbackNode;\x0a      do {\x0a        if (node.expirationTime \x3e= expirationTime) {\x0a          // This callback expires at or after the continuation. We will insert\x0a          // the continuation *before* this callback.\x0a          nextAfterContinuation = node;\x0a          break;\x0a        }\x0a        node = node.next;\x0a      } while (node !== firstCallbackNode);\x0a\x0a      if (nextAfterContinuation === null) {\x0a        // No equal or lower priority callback was found, which means the new\x0a        // callback is the lowest priority callback in the list.\x0a        nextAfterContinuation = firstCallbackNode;\x0a      } else if (nextAfterContinuation === firstCallbackNode) {\x0a        // The new callback is the highest priority callback in the list.\x0a        firstCallbackNode = continuationNode;\x0a        ensureHostCallbackIsScheduled();\x0a      }\x0a\x0a      var previous = nextAfterContinuation.previous;\x0a      previous.next = nextAfterContinuation.previous = continuationNode;\x0a      continuationNode.next = nextAfterContinuation;\x0a      continuationNode.previous = previous;\x0a    }\x0a  }\x0a}\x0a\x0afunction flushImmediateWork() {\x0a  if (\x0a  // Confirm we\x27ve exited the outer most event handler\x0a  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\x0a    isExecutingCallback = true;\x0a    try {\x0a      do {\x0a        flushFirstCallback();\x0a      } while (\x0a      // Keep flushing until there are no more immediate callbacks\x0a      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\x0a    } finally {\x0a      isExecutingCallback = false;\x0a      if (firstCallbackNode !== null) {\x0a        // There\x27s still work remaining. Request another callback.\x0a        ensureHostCallbackIsScheduled();\x0a      } else {\x0a        isHostCallbackScheduled = false;\x0a      }\x0a    }\x0a  }\x0a}\x0a\x0afunction flushWork(didTimeout) {\x0a  // Exit right away if we\x27re currently paused\x0a\x0a  if (enableSchedulerDebugging && isSchedulerPaused) {\x0a    return;\x0a  }\x0a\x0a  isExecutingCallback = true;\x0a  var previousDidTimeout = currentDidTimeout;\x0a  currentDidTimeout = didTimeout;\x0a  try {\x0a    if (didTimeout) {\x0a      // Flush all the expired callbacks without yielding.\x0a      while (firstCallbackNode !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {\x0a        // TODO Wrap in feature flag\x0a        // Read the current time. Flush all the callbacks that expire at or\x0a        // earlier than that time. Then read the current time again and repeat.\x0a        // This optimizes for as few performance.now calls as possible.\x0a        var currentTime = getCurrentTime();\x0a        if (firstCallbackNode.expirationTime \x3c= currentTime) {\x0a          do {\x0a            flushFirstCallback();\x0a          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime \x3c= currentTime && !(enableSchedulerDebugging && isSchedulerPaused));\x0a          continue;\x0a        }\x0a        break;\x0a      }\x0a    } else {\x0a      // Keep flushing callbacks until we run out of time in the frame.\x0a      if (firstCallbackNode !== null) {\x0a        do {\x0a          if (enableSchedulerDebugging && isSchedulerPaused) {\x0a            break;\x0a          }\x0a          flushFirstCallback();\x0a        } while (firstCallbackNode !== null && !shouldYieldToHost());\x0a      }\x0a    }\x0a  } finally {\x0a    isExecutingCallback = false;\x0a    currentDidTimeout = previousDidTimeout;\x0a    if (firstCallbackNode !== null) {\x0a      // There\x27s still work remaining. Request another callback.\x0a      ensureHostCallbackIsScheduled();\x0a    } else {\x0a      isHostCallbackScheduled = false;\x0a    }\x0a    // Before exiting, flush all the immediate work that was scheduled.\x0a    flushImmediateWork();\x0a  }\x0a}\x0a\x0afunction unstable_runWithPriority(priorityLevel, eventHandler) {\x0a  switch (priorityLevel) {\x0a    case ImmediatePriority:\x0a    case UserBlockingPriority:\x0a    case NormalPriority:\x0a    case LowPriority:\x0a    case IdlePriority:\x0a      break;\x0a    default:\x0a      priorityLevel = NormalPriority;\x0a  }\x0a\x0a  var previousPriorityLevel = currentPriorityLevel;\x0a  var previousEventStartTime = currentEventStartTime;\x0a  currentPriorityLevel = priorityLevel;\x0a  currentEventStartTime = getCurrentTime();\x0a\x0a  try {\x0a    return eventHandler();\x0a  } finally {\x0a    currentPriorityLevel = previousPriorityLevel;\x0a    currentEventStartTime = previousEventStartTime;\x0a\x0a    // Before exiting, flush all the immediate work that was scheduled.\x0a    flushImmediateWork();\x0a  }\x0a}\x0a\x0afunction unstable_next(eventHandler) {\x0a  var priorityLevel = void 0;\x0a  switch (currentPriorityLevel) {\x0a    case ImmediatePriority:\x0a    case UserBlockingPriority:\x0a    case NormalPriority:\x0a      // Shift down to normal priority\x0a      priorityLevel = NormalPriority;\x0a      break;\x0a    default:\x0a      // Anything lower than normal priority should remain at the current level.\x0a      priorityLevel = currentPriorityLevel;\x0a      break;\x0a  }\x0a\x0a  var previousPriorityLevel = currentPriorityLevel;\x0a  var previousEventStartTime = currentEventStartTime;\x0a  currentPriorityLevel = priorityLevel;\x0a  currentEventStartTime = getCurrentTime();\x0a\x0a  try {\x0a    return eventHandler();\x0a  } finally {\x0a    currentPriorityLevel = previousPriorityLevel;\x0a    currentEventStartTime = previousEventStartTime;\x0a\x0a    // Before exiting, flush all the immediate work that was scheduled.\x0a    flushImmediateWork();\x0a  }\x0a}\x0a\x0afunction unstable_wrapCallback(callback) {\x0a  var parentPriorityLevel = currentPriorityLevel;\x0a  return function () {\x0a    // This is a fork of runWithPriority, inlined for performance.\x0a    var previousPriorityLevel = currentPriorityLevel;\x0a    var previousEventStartTime = currentEventStartTime;\x0a    currentPriorityLevel = parentPriorityLevel;\x0a    currentEventStartTime = getCurrentTime();\x0a\x0a    try {\x0a      return callback.apply(this, arguments);\x0a    } finally {\x0a      currentPriorityLevel = previousPriorityLevel;\x0a      currentEventStartTime = previousEventStartTime;\x0a      flushImmediateWork();\x0a    }\x0a  };\x0a}\x0a\x0afunction unstable_scheduleCallback(callback, deprecated_options) {\x0a  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : getCurrentTime();\x0a\x0a  var expirationTime;\x0a  if (typeof deprecated_options === \x27object\x27 && deprecated_options !== null && typeof deprecated_options.timeout === \x27number\x27) {\x0a    // FIXME: Remove this branch once we lift expiration times out of React.\x0a    expirationTime = startTime + deprecated_options.timeout;\x0a  } else {\x0a    switch (currentPriorityLevel) {\x0a      case ImmediatePriority:\x0a        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\x0a        break;\x0a      case UserBlockingPriority:\x0a        expirationTime = startTime + USER_BLOCKING_PRIORITY;\x0a        break;\x0a      case IdlePriority:\x0a        expirationTime = startTime + IDLE_PRIORITY;\x0a        break;\x0a      case LowPriority:\x0a        expirationTime = startTime + LOW_PRIORITY_TIMEOUT;\x0a        break;\x0a      case NormalPriority:\x0a      default:\x0a        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\x0a    }\x0a  }\x0a\x0a  var newNode = {\x0a    callback: callback,\x0a    priorityLevel: currentPriorityLevel,\x0a    expirationTime: expirationTime,\x0a    next: null,\x0a    previous: null\x0a  };\x0a\x0a  // Insert the new callback into the list, ordered first by expiration, then\x0a  // by insertion. So the new callback is inserted any other callback with\x0a  // equal expiration.\x0a  if (firstCallbackNode === null) {\x0a    // This is the first callback in the list.\x0a    firstCallbackNode = newNode.next = newNode.previous = newNode;\x0a    ensureHostCallbackIsScheduled();\x0a  } else {\x0a    var next = null;\x0a    var node = firstCallbackNode;\x0a    do {\x0a      if (node.expirationTime \x3e expirationTime) {\x0a        // The new callback expires before this one.\x0a        next = node;\x0a        break;\x0a      }\x0a      node = node.next;\x0a    } while (node !== firstCallbackNode);\x0a\x0a    if (next === null) {\x0a      // No callback with a later expiration was found, which means the new\x0a      // callback has the latest expiration in the list.\x0a      next = firstCallbackNode;\x0a    } else if (next === firstCallbackNode) {\x0a      // The new callback has the earliest expiration in the entire list.\x0a      firstCallbackNode = newNode;\x0a      ensureHostCallbackIsScheduled();\x0a    }\x0a\x0a    var previous = next.previous;\x0a    previous.next = next.previous = newNode;\x0a    newNode.next = next;\x0a    newNode.previous = previous;\x0a  }\x0a\x0a  return newNode;\x0a}\x0a\x0afunction unstable_pauseExecution() {\x0a  isSchedulerPaused = true;\x0a}\x0a\x0afunction unstable_continueExecution() {\x0a  isSchedulerPaused = false;\x0a  if (firstCallbackNode !== null) {\x0a    ensureHostCallbackIsScheduled();\x0a  }\x0a}\x0a\x0afunction unstable_getFirstCallbackNode() {\x0a  return firstCallbackNode;\x0a}\x0a\x0afunction unstable_cancelCallback(callbackNode) {\x0a  var next = callbackNode.next;\x0a  if (next === null) {\x0a    // Already cancelled.\x0a    return;\x0a  }\x0a\x0a  if (next === callbackNode) {\x0a    // This is the only scheduled callback. Clear the list.\x0a    firstCallbackNode = null;\x0a  } else {\x0a    // Remove the callback from its position in the list.\x0a    if (callbackNode === firstCallbackNode) {\x0a      firstCallbackNode = next;\x0a    }\x0a    var previous = callbackNode.previous;\x0a    previous.next = next;\x0a    next.previous = previous;\x0a  }\x0a\x0a  callbackNode.next = callbackNode.previous = null;\x0a}\x0a\x0afunction unstable_getCurrentPriorityLevel() {\x0a  return currentPriorityLevel;\x0a}\x0a\x0afunction unstable_shouldYield() {\x0a  return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime \x3c currentExpirationTime || shouldYieldToHost());\x0a}\x0a\x0a// The remaining code is essentially a polyfill for requestIdleCallback. It\x0a// works by scheduling a requestAnimationFrame, storing the time for the start\x0a// of the frame, then scheduling a postMessage which gets scheduled after paint.\x0a// Within the postMessage handler do as much work as possible until time + frame\x0a// rate. By separating the idle call into a separate event tick we ensure that\x0a// layout, paint and other browser work is counted against the available time.\x0a// The frame rate is dynamically adjusted.\x0a\x0a// We capture a local reference to any global, in case it gets polyfilled after\x0a// this module is initially evaluated. We want to be using a\x0a// consistent implementation.\x0avar localDate = Date;\x0a\x0a// This initialization code may run even on server environments if a component\x0a// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\x0a// have setTimeout or clearTimeout. However, we always expect them to be defined\x0a// on the client. https://github.com/facebook/react/pull/13088\x0avar localSetTimeout = typeof setTimeout === \x27function\x27 ? setTimeout : undefined;\x0avar localClearTimeout = typeof clearTimeout === \x27function\x27 ? clearTimeout : undefined;\x0a\x0a// We don\x27t expect either of these to necessarily be defined, but we will error\x0a// later if they are missing on the client.\x0avar localRequestAnimationFrame = typeof requestAnimationFrame === \x27function\x27 ? requestAnimationFrame : undefined;\x0avar localCancelAnimationFrame = typeof cancelAnimationFrame === \x27function\x27 ? cancelAnimationFrame : undefined;\x0a\x0avar getCurrentTime;\x0a\x0a// requestAnimationFrame does not run when the tab is in the background. If\x0a// we\x27re backgrounded we prefer for that work to happen so that the page\x0a// continues to load in the background. So we also schedule a \x27setTimeout\x27 as\x0a// a fallback.\x0a// TODO: Need a better heuristic for backgrounded work.\x0avar ANIMATION_FRAME_TIMEOUT = 100;\x0avar rAFID;\x0avar rAFTimeoutID;\x0avar requestAnimationFrameWithTimeout = function (callback) {\x0a  // schedule rAF and also a setTimeout\x0a  rAFID = localRequestAnimationFrame(function (timestamp) {\x0a    // cancel the setTimeout\x0a    localClearTimeout(rAFTimeoutID);\x0a    callback(timestamp);\x0a  });\x0a  rAFTimeoutID = localSetTimeout(function () {\x0a    // cancel the requestAnimationFrame\x0a    localCancelAnimationFrame(rAFID);\x0a    callback(getCurrentTime());\x0a  }, ANIMATION_FRAME_TIMEOUT);\x0a};\x0a\x0aif (hasNativePerformanceNow) {\x0a  var Performance = performance;\x0a  getCurrentTime = function () {\x0a    return Performance.now();\x0a  };\x0a} else {\x0a  getCurrentTime = function () {\x0a    return localDate.now();\x0a  };\x0a}\x0a\x0avar requestHostCallback;\x0avar cancelHostCallback;\x0avar shouldYieldToHost;\x0a\x0avar globalValue = null;\x0aif (typeof window !== \x27undefined\x27) {\x0a  globalValue = window;\x0a} else if (typeof global !== \x27undefined\x27) {\x0a  globalValue = global;\x0a}\x0a\x0aif (globalValue && globalValue._schedMock) {\x0a  // Dynamic injection, only for testing purposes.\x0a  var globalImpl = globalValue._schedMock;\x0a  requestHostCallback = globalImpl[0];\x0a  cancelHostCallback = globalImpl[1];\x0a  shouldYieldToHost = globalImpl[2];\x0a  getCurrentTime = globalImpl[3];\x0a} else if (\x0a// If Scheduler runs in a non-DOM environment, it falls back to a naive\x0a// implementation using setTimeout.\x0atypeof window === \x27undefined\x27 ||\x0a// Check if MessageChannel is supported, too.\x0atypeof MessageChannel !== \x27function\x27) {\x0a  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\x0a  // fallback to a naive implementation.\x0a  var _callback = null;\x0a  var _flushCallback = function (didTimeout) {\x0a    if (_callback !== null) {\x0a      try {\x0a        _callback(didTimeout);\x0a      } finally {\x0a        _callback = null;\x0a      }\x0a    }\x0a  };\x0a  requestHostCallback = function (cb, ms) {\x0a    if (_callback !== null) {\x0a      // Protect against re-entrancy.\x0a      setTimeout(requestHostCallback, 0, cb);\x0a    } else {\x0a      _callback = cb;\x0a      setTimeout(_flushCallback, 0, false);\x0a    }\x0a  };\x0a  cancelHostCallback = function () {\x0a    _callback = null;\x0a  };\x0a  shouldYieldToHost = function () {\x0a    return false;\x0a  };\x0a} else {\x0a  if (typeof console !== \x27undefined\x27) {\x0a    // TODO: Remove fb.me link\x0a    if (typeof localRequestAnimationFrame !== \x27function\x27) {\x0a      console.error(\x22This browser doesn\x27t support requestAnimationFrame. \x22 + \x27Make sure that you load a \x27 + \x27polyfill in older browsers. https://fb.me/react-polyfills\x27);\x0a    }\x0a    if (typeof localCancelAnimationFrame !== \x27function\x27) {\x0a      console.error(\x22This browser doesn\x27t support cancelAnimationFrame. \x22 + \x27Make sure that you load a \x27 + \x27polyfill in older browsers. https://fb.me/react-polyfills\x27);\x0a    }\x0a  }\x0a\x0a  var scheduledHostCallback = null;\x0a  var isMessageEventScheduled = false;\x0a  var timeoutTime = -1;\x0a\x0a  var isAnimationFrameScheduled = false;\x0a\x0a  var isFlushingHostCallback = false;\x0a\x0a  var frameDeadline = 0;\x0a  // We start out assuming that we run at 30fps but then the heuristic tracking\x0a  // will adjust this value to a faster fps if we get more frequent animation\x0a  // frames.\x0a  var previousFrameTime = 33;\x0a  var activeFrameTime = 33;\x0a\x0a  shouldYieldToHost = function () {\x0a    return frameDeadline \x3c= getCurrentTime();\x0a  };\x0a\x0a  // We use the postMessage trick to defer idle work until after the repaint.\x0a  var channel = new MessageChannel();\x0a  var port = channel.port2;\x0a  channel.port1.onmessage = function (event) {\x0a    isMessageEventScheduled = false;\x0a\x0a    var prevScheduledCallback = scheduledHostCallback;\x0a    var prevTimeoutTime = timeoutTime;\x0a    scheduledHostCallback = null;\x0a    timeoutTime = -1;\x0a\x0a    var currentTime = getCurrentTime();\x0a\x0a    var didTimeout = false;\x0a    if (frameDeadline - currentTime \x3c= 0) {\x0a      // There\x27s no time left in this idle period. Check if the callback has\x0a      // a timeout and whether it\x27s been exceeded.\x0a      if (prevTimeoutTime !== -1 && prevTimeoutTime \x3c= currentTime) {\x0a        // Exceeded the timeout. Invoke the callback even though there\x27s no\x0a        // time left.\x0a        didTimeout = true;\x0a      } else {\x0a        // No timeout.\x0a        if (!isAnimationFrameScheduled) {\x0a          // Schedule another animation callback so we retry later.\x0a          isAnimationFrameScheduled = true;\x0a          requestAnimationFrameWithTimeout(animationTick);\x0a        }\x0a        // Exit without invoking the callback.\x0a        scheduledHostCallback = prevScheduledCallback;\x0a        timeoutTime = prevTimeoutTime;\x0a        return;\x0a      }\x0a    }\x0a\x0a    if (prevScheduledCallback !== null) {\x0a      isFlushingHostCallback = true;\x0a      try {\x0a        prevScheduledCallback(didTimeout);\x0a      } finally {\x0a        isFlushingHostCallback = false;\x0a      }\x0a    }\x0a  };\x0a\x0a  var animationTick = function (rafTime) {\x0a    if (scheduledHostCallback !== null) {\x0a      // Eagerly schedule the next animation callback at the beginning of the\x0a      // frame. If the scheduler queue is not empty at the end of the frame, it\x0a      // will continue flushing inside that callback. If the queue *is* empty,\x0a      // then it will exit immediately. Posting the callback at the start of the\x0a      // frame ensures it\x27s fired within the earliest possible frame. If we\x0a      // waited until the end of the frame to post the callback, we risk the\x0a      // browser skipping a frame and not firing the callback until the frame\x0a      // after that.\x0a      requestAnimationFrameWithTimeout(animationTick);\x0a    } else {\x0a      // No pending work. Exit.\x0a      isAnimationFrameScheduled = false;\x0a      return;\x0a    }\x0a\x0a    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\x0a    if (nextFrameTime \x3c activeFrameTime && previousFrameTime \x3c activeFrameTime) {\x0a      if (nextFrameTime \x3c 8) {\x0a        // Defensive coding. We don\x27t support higher frame rates than 120hz.\x0a        // If the calculated frame time gets lower than 8, it is probably a bug.\x0a        nextFrameTime = 8;\x0a      }\x0a      // If one frame goes long, then the next one can be short to catch up.\x0a      // If two frames are short in a row, then that\x27s an indication that we\x0a      // actually have a higher frame rate than what we\x27re currently optimizing.\x0a      // We adjust our heuristic dynamically accordingly. For example, if we\x27re\x0a      // running on 120hz display or 90hz VR display.\x0a      // Take the max of the two in case one of them was an anomaly due to\x0a      // missed frame deadlines.\x0a      activeFrameTime = nextFrameTime \x3c previousFrameTime ? previousFrameTime : nextFrameTime;\x0a    } else {\x0a      previousFrameTime = nextFrameTime;\x0a    }\x0a    frameDeadline = rafTime + activeFrameTime;\x0a    if (!isMessageEventScheduled) {\x0a      isMessageEventScheduled = true;\x0a      port.postMessage(undefined);\x0a    }\x0a  };\x0a\x0a  requestHostCallback = function (callback, absoluteTimeout) {\x0a    scheduledHostCallback = callback;\x0a    timeoutTime = absoluteTimeout;\x0a    if (isFlushingHostCallback || absoluteTimeout \x3c 0) {\x0a      // Don\x27t wait for the next frame. Continue working ASAP, in a new event.\x0a      port.postMessage(undefined);\x0a    } else if (!isAnimationFrameScheduled) {\x0a      // If rAF didn\x27t already schedule one, we need to schedule a frame.\x0a      // TODO: If this rAF doesn\x27t materialize because the browser throttles, we\x0a      // might want to still have setTimeout trigger rIC as a backup to ensure\x0a      // that we keep performing work.\x0a      isAnimationFrameScheduled = true;\x0a      requestAnimationFrameWithTimeout(animationTick);\x0a    }\x0a  };\x0a\x0a  cancelHostCallback = function () {\x0a    scheduledHostCallback = null;\x0a    isMessageEventScheduled = false;\x0a    timeoutTime = -1;\x0a  };\x0a}\x0a\x0a// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\x0a\x0a\x0a// In some cases, StrictMode should also double-render lifecycles.\x0a// This can be confusing for tests though,\x0a// And it can be bad for performance in production.\x0a// This feature flag can be used to control the behavior:\x0a\x0a\x0a// To preserve the \x22Pause on caught exceptions\x22 behavior of the debugger, we\x0a// replay the begin phase of a failed component inside invokeGuardedCallback.\x0a\x0a\x0a// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\x0a\x0a\x0a// Gather advanced timing metrics for Profiler subtrees.\x0a\x0a\x0a// Trace which interactions trigger each commit.\x0avar enableSchedulerTracing = true;\x0a\x0a// Only used in www builds.\x0a // TODO: true? Here it might just be false.\x0a\x0a// Only used in www builds.\x0a\x0a\x0a// Only used in www builds.\x0a\x0a\x0a// React Fire: prevent the value and checked attributes from syncing\x0a// with their related DOM properties\x0a\x0a\x0a// These APIs will no longer be \x22unstable\x22 in the upcoming 16.7 release,\x0a// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.\x0avar enableStableConcurrentModeAPIs = false;\x0a\x0avar DEFAULT_THREAD_ID = 0;\x0a\x0a// Counters used to generate unique IDs.\x0avar interactionIDCounter = 0;\x0avar threadIDCounter = 0;\x0a\x0a// Set of currently traced interactions.\x0a// Interactions \x22stack\x22\xe2\x80\x93\x0a// Meaning that newly traced interactions are appended to the previously active set.\x0a// When an interaction goes out of scope, the previous set (if any) is restored.\x0avar interactionsRef = null;\x0a\x0a// Listener(s) to notify when interactions begin and end.\x0avar subscriberRef = null;\x0a\x0aif (enableSchedulerTracing) {\x0a  interactionsRef = {\x0a    current: new Set()\x0a  };\x0a  subscriberRef = {\x0a    current: null\x0a  };\x0a}\x0a\x0afunction unstable_clear(callback) {\x0a  if (!enableSchedulerTracing) {\x0a    return callback();\x0a  }\x0a\x0a  var prevInteractions = interactionsRef.current;\x0a  interactionsRef.current = new Set();\x0a\x0a  try {\x0a    return callback();\x0a  } finally {\x0a    interactionsRef.current = prevInteractions;\x0a  }\x0a}\x0a\x0afunction unstable_getCurrent() {\x0a  if (!enableSchedulerTracing) {\x0a    return null;\x0a  } else {\x0a    return interactionsRef.current;\x0a  }\x0a}\x0a\x0afunction unstable_getThreadID() {\x0a  return ++threadIDCounter;\x0a}\x0a\x0afunction unstable_trace(name, timestamp, callback) {\x0a  var threadID = arguments.length \x3e 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\x0a\x0a  if (!enableSchedulerTracing) {\x0a    return callback();\x0a  }\x0a\x0a  var interaction = {\x0a    __count: 1,\x0a    id: interactionIDCounter++,\x0a    name: name,\x0a    timestamp: timestamp\x0a  };\x0a\x0a  var prevInteractions = interactionsRef.current;\x0a\x0a  // Traced interactions should stack/accumulate.\x0a  // To do that, clone the current interactions.\x0a  // The previous set will be restored upon completion.\x0a  var interactions = new Set(prevInteractions);\x0a  interactions.add(interaction);\x0a  interactionsRef.current = interactions;\x0a\x0a  var subscriber = subscriberRef.current;\x0a  var returnValue = void 0;\x0a\x0a  try {\x0a    if (subscriber !== null) {\x0a      subscriber.onInteractionTraced(interaction);\x0a    }\x0a  } finally {\x0a    try {\x0a      if (subscriber !== null) {\x0a        subscriber.onWorkStarted(interactions, threadID);\x0a      }\x0a    } finally {\x0a      try {\x0a        returnValue = callback();\x0a      } finally {\x0a        interactionsRef.current = prevInteractions;\x0a\x0a        try {\x0a          if (subscriber !== null) {\x0a            subscriber.onWorkStopped(interactions, threadID);\x0a          }\x0a        } finally {\x0a          interaction.__count--;\x0a\x0a          // If no async work was scheduled for this interaction,\x0a          // Notify subscribers that it\x27s completed.\x0a          if (subscriber !== null && interaction.__count === 0) {\x0a            subscriber.onInteractionScheduledWorkCompleted(interaction);\x0a          }\x0a        }\x0a      }\x0a    }\x0a  }\x0a\x0a  return returnValue;\x0a}\x0a\x0afunction unstable_wrap(callback) {\x0a  var threadID = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\x0a\x0a  if (!enableSchedulerTracing) {\x0a    return callback;\x0a  }\x0a\x0a  var wrappedInteractions = interactionsRef.current;\x0a\x0a  var subscriber = subscriberRef.current;\x0a  if (subscriber !== null) {\x0a    subscriber.onWorkScheduled(wrappedInteractions, threadID);\x0a  }\x0a\x0a  // Update the pending async work count for the current interactions.\x0a  // Update after calling subscribers in case of error.\x0a  wrappedInteractions.forEach(function (interaction) {\x0a    interaction.__count++;\x0a  });\x0a\x0a  var hasRun = false;\x0a\x0a  function wrapped() {\x0a    var prevInteractions = interactionsRef.current;\x0a    interactionsRef.current = wrappedInteractions;\x0a\x0a    subscriber = subscriberRef.current;\x0a\x0a    try {\x0a      var returnValue = void 0;\x0a\x0a      try {\x0a        if (subscriber !== null) {\x0a          subscriber.onWorkStarted(wrappedInteractions, threadID);\x0a        }\x0a      } finally {\x0a        try {\x0a          returnValue = callback.apply(undefined, arguments);\x0a        } finally {\x0a          interactionsRef.current = prevInteractions;\x0a\x0a          if (subscriber !== null) {\x0a            subscriber.onWorkStopped(wrappedInteractions, threadID);\x0a          }\x0a        }\x0a      }\x0a\x0a      return returnValue;\x0a    } finally {\x0a      if (!hasRun) {\x0a        // We only expect a wrapped function to be executed once,\x0a        // But in the event that it\x27s executed more than once\xe2\x80\x93\x0a        // Only decrement the outstanding interaction counts once.\x0a        hasRun = true;\x0a\x0a        // Update pending async counts for all wrapped interactions.\x0a        // If this was the last scheduled async work for any of them,\x0a        // Mark them as completed.\x0a        wrappedInteractions.forEach(function (interaction) {\x0a          interaction.__count--;\x0a\x0a          if (subscriber !== null && interaction.__count === 0) {\x0a            subscriber.onInteractionScheduledWorkCompleted(interaction);\x0a          }\x0a        });\x0a      }\x0a    }\x0a  }\x0a\x0a  wrapped.cancel = function cancel() {\x0a    subscriber = subscriberRef.current;\x0a\x0a    try {\x0a      if (subscriber !== null) {\x0a        subscriber.onWorkCanceled(wrappedInteractions, threadID);\x0a      }\x0a    } finally {\x0a      // Update pending async counts for all wrapped interactions.\x0a      // If this was the last scheduled async work for any of them,\x0a      // Mark them as completed.\x0a      wrappedInteractions.forEach(function (interaction) {\x0a        interaction.__count--;\x0a\x0a        if (subscriber && interaction.__count === 0) {\x0a          subscriber.onInteractionScheduledWorkCompleted(interaction);\x0a        }\x0a      });\x0a    }\x0a  };\x0a\x0a  return wrapped;\x0a}\x0a\x0avar subscribers = null;\x0aif (enableSchedulerTracing) {\x0a  subscribers = new Set();\x0a}\x0a\x0afunction unstable_subscribe(subscriber) {\x0a  if (enableSchedulerTracing) {\x0a    subscribers.add(subscriber);\x0a\x0a    if (subscribers.size === 1) {\x0a      subscriberRef.current = {\x0a        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\x0a        onInteractionTraced: onInteractionTraced,\x0a        onWorkCanceled: onWorkCanceled,\x0a        onWorkScheduled: onWorkScheduled,\x0a        onWorkStarted: onWorkStarted,\x0a        onWorkStopped: onWorkStopped\x0a      };\x0a    }\x0a  }\x0a}\x0a\x0afunction unstable_unsubscribe(subscriber) {\x0a  if (enableSchedulerTracing) {\x0a    subscribers.delete(subscriber);\x0a\x0a    if (subscribers.size === 0) {\x0a      subscriberRef.current = null;\x0a    }\x0a  }\x0a}\x0a\x0afunction onInteractionTraced(interaction) {\x0a  var didCatchError = false;\x0a  var caughtError = null;\x0a\x0a  subscribers.forEach(function (subscriber) {\x0a    try {\x0a      subscriber.onInteractionTraced(interaction);\x0a    } catch (error) {\x0a      if (!didCatchError) {\x0a        didCatchError = true;\x0a        caughtError = error;\x0a      }\x0a    }\x0a  });\x0a\x0a  if (didCatchError) {\x0a    throw caughtError;\x0a  }\x0a}\x0a\x0afunction onInteractionScheduledWorkCompleted(interaction) {\x0a  var didCatchError = false;\x0a  var caughtError = null;\x0a\x0a  subscribers.forEach(function (subscriber) {\x0a    try {\x0a      subscriber.onInteractionScheduledWorkCompleted(interaction);\x0a    } catch (error) {\x0a      if (!didCatchError) {\x0a        didCatchError = true;\x0a        caughtError = error;\x0a      }\x0a    }\x0a  });\x0a\x0a  if (didCatchError) {\x0a    throw caughtError;\x0a  }\x0a}\x0a\x0afunction onWorkScheduled(interactions, threadID) {\x0a  var didCatchError = false;\x0a  var caughtError = null;\x0a\x0a  subscribers.forEach(function (subscriber) {\x0a    try {\x0a      subscriber.onWorkScheduled(interactions, threadID);\x0a    } catch (error) {\x0a      if (!didCatchError) {\x0a        didCatchError = true;\x0a        caughtError = error;\x0a      }\x0a    }\x0a  });\x0a\x0a  if (didCatchError) {\x0a    throw caughtError;\x0a  }\x0a}\x0a\x0afunction onWorkStarted(interactions, threadID) {\x0a  var didCatchError = false;\x0a  var caughtError = null;\x0a\x0a  subscribers.forEach(function (subscriber) {\x0a    try {\x0a      subscriber.onWorkStarted(interactions, threadID);\x0a    } catch (error) {\x0a      if (!didCatchError) {\x0a        didCatchError = true;\x0a        caughtError = error;\x0a      }\x0a    }\x0a  });\x0a\x0a  if (didCatchError) {\x0a    throw caughtError;\x0a  }\x0a}\x0a\x0afunction onWorkStopped(interactions, threadID) {\x0a  var didCatchError = false;\x0a  var caughtError = null;\x0a\x0a  subscribers.forEach(function (subscriber) {\x0a    try {\x0a      subscriber.onWorkStopped(interactions, threadID);\x0a    } catch (error) {\x0a      if (!didCatchError) {\x0a        didCatchError = true;\x0a        caughtError = error;\x0a      }\x0a    }\x0a  });\x0a\x0a  if (didCatchError) {\x0a    throw caughtError;\x0a  }\x0a}\x0a\x0afunction onWorkCanceled(interactions, threadID) {\x0a  var didCatchError = false;\x0a  var caughtError = null;\x0a\x0a  subscribers.forEach(function (subscriber) {\x0a    try {\x0a      subscriber.onWorkCanceled(interactions, threadID);\x0a    } catch (error) {\x0a      if (!didCatchError) {\x0a        didCatchError = true;\x0a        caughtError = error;\x0a      }\x0a    }\x0a  });\x0a\x0a  if (didCatchError) {\x0a    throw caughtError;\x0a  }\x0a}\x0a\x0a/**\x0a * Keeps track of the current dispatcher.\x0a */\x0avar ReactCurrentDispatcher = {\x0a  /**\x0a   * @internal\x0a   * @type {ReactComponent}\x0a   */\x0a  current: null\x0a};\x0a\x0a/**\x0a * Keeps track of the current owner.\x0a *\x0a * The current owner is the component who should own any components that are\x0a * currently being constructed.\x0a */\x0avar ReactCurrentOwner = {\x0a  /**\x0a   * @internal\x0a   * @type {ReactComponent}\x0a   */\x0a  current: null\x0a};\x0a\x0avar BEFORE_SLASH_RE = /^(.*)[\x5c\x5c\x5c/]/;\x0a\x0avar describeComponentFrame = function (name, source, ownerName) {\x0a  var sourceInfo = \x27\x27;\x0a  if (source) {\x0a    var path = source.fileName;\x0a    var fileName = path.replace(BEFORE_SLASH_RE, \x27\x27);\x0a    {\x0a      // In DEV, include code for a common special case:\x0a      // prefer \x22folder/index.js\x22 instead of just \x22index.js\x22.\x0a      if (/^index\x5c./.test(fileName)) {\x0a        var match = path.match(BEFORE_SLASH_RE);\x0a        if (match) {\x0a          var pathBeforeSlash = match[1];\x0a          if (pathBeforeSlash) {\x0a            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, \x27\x27);\x0a            fileName = folderName + \x27/\x27 + fileName;\x0a          }\x0a        }\x0a      }\x0a    }\x0a    sourceInfo = \x27 (at \x27 + fileName + \x27:\x27 + source.lineNumber + \x27)\x27;\x0a  } else if (ownerName) {\x0a    sourceInfo = \x27 (created by \x27 + ownerName + \x27)\x27;\x0a  }\x0a  return \x27\x5cn    in \x27 + (name || \x27Unknown\x27) + sourceInfo;\x0a};\x0a\x0avar Resolved = 1;\x0a\x0a\x0afunction refineResolvedLazyComponent(lazyComponent) {\x0a  return lazyComponent._status === Resolved ? lazyComponent._result : null;\x0a}\x0a\x0afunction getWrappedName(outerType, innerType, wrapperName) {\x0a  var functionName = innerType.displayName || innerType.name || \x27\x27;\x0a  return outerType.displayName || (functionName !== \x27\x27 ? wrapperName + \x27(\x27 + functionName + \x27)\x27 : wrapperName);\x0a}\x0a\x0afunction getComponentName(type) {\x0a  if (type == null) {\x0a    // Host root, text node or just invalid type.\x0a    return null;\x0a  }\x0a  {\x0a    if (typeof type.tag === \x27number\x27) {\x0a      warningWithoutStack$1(false, \x27Received an unexpected object in getComponentName(). \x27 + \x27This is likely a bug in React. Please file an issue.\x27);\x0a    }\x0a  }\x0a  if (typeof type === \x27function\x27) {\x0a    return type.displayName || type.name || null;\x0a  }\x0a  if (typeof type === \x27string\x27) {\x0a    return type;\x0a  }\x0a  switch (type) {\x0a    case REACT_CONCURRENT_MODE_TYPE:\x0a      return \x27ConcurrentMode\x27;\x0a    case REACT_FRAGMENT_TYPE:\x0a      return \x27Fragment\x27;\x0a    case REACT_PORTAL_TYPE:\x0a      return \x27Portal\x27;\x0a    case REACT_PROFILER_TYPE:\x0a      return \x27Profiler\x27;\x0a    case REACT_STRICT_MODE_TYPE:\x0a      return \x27StrictMode\x27;\x0a    case REACT_SUSPENSE_TYPE:\x0a      return \x27Suspense\x27;\x0a  }\x0a  if (typeof type === \x27object\x27) {\x0a    switch (type.$$typeof) {\x0a      case REACT_CONTEXT_TYPE:\x0a        return \x27Context.Consumer\x27;\x0a      case REACT_PROVIDER_TYPE:\x0a        return \x27Context.Provider\x27;\x0a      case REACT_FORWARD_REF_TYPE:\x0a        return getWrappedName(type, type.render, \x27ForwardRef\x27);\x0a      case REACT_MEMO_TYPE:\x0a        return getComponentName(type.type);\x0a      case REACT_LAZY_TYPE:\x0a        {\x0a          var thenable = type;\x0a          var resolvedThenable = refineResolvedLazyComponent(thenable);\x0a          if (resolvedThenable) {\x0a            return getComponentName(resolvedThenable);\x0a          }\x0a        }\x0a    }\x0a  }\x0a  return null;\x0a}\x0a\x0avar ReactDebugCurrentFrame = {};\x0a\x0avar currentlyValidatingElement = null;\x0a\x0afunction setCurrentlyValidatingElement(element) {\x0a  {\x0a    currentlyValidatingElement = element;\x0a  }\x0a}\x0a\x0a{\x0a  // Stack implementation injected by the current renderer.\x0a  ReactDebugCurrentFrame.getCurrentStack = null;\x0a\x0a  ReactDebugCurrentFrame.getStackAddendum = function () {\x0a    var stack = \x27\x27;\x0a\x0a    // Add an extra top frame while an element is being validated\x0a    if (currentlyValidatingElement) {\x0a      var name = getComponentName(currentlyValidatingElement.type);\x0a      var owner = currentlyValidatingElement._owner;\x0a      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));\x0a    }\x0a\x0a    // Delegate to the injected renderer-specific implementation\x0a    var impl = ReactDebugCurrentFrame.getCurrentStack;\x0a    if (impl) {\x0a      stack += impl() || \x27\x27;\x0a    }\x0a\x0a    return stack;\x0a  };\x0a}\x0a\x0avar ReactSharedInternals = {\x0a  ReactCurrentDispatcher: ReactCurrentDispatcher,\x0a  ReactCurrentOwner: ReactCurrentOwner,\x0a  // Used by renderers to avoid bundling object-assign twice in UMD bundles:\x0a  assign: objectAssign\x0a};\x0a\x0a{\x0a  // Re-export the schedule API(s) for UMD bundles.\x0a  // This avoids introducing a dependency on a new UMD global in a minor update,\x0a  // Since that would be a breaking change (e.g. for all existing CodeSandboxes).\x0a  // This re-export is only required for UMD bundles;\x0a  // CJS bundles use the shared NPM package.\x0a  objectAssign(ReactSharedInternals, {\x0a    Scheduler: {\x0a      unstable_cancelCallback: unstable_cancelCallback,\x0a      unstable_shouldYield: unstable_shouldYield,\x0a      unstable_now: getCurrentTime,\x0a      unstable_scheduleCallback: unstable_scheduleCallback,\x0a      unstable_runWithPriority: unstable_runWithPriority,\x0a      unstable_next: unstable_next,\x0a      unstable_wrapCallback: unstable_wrapCallback,\x0a      unstable_getFirstCallbackNode: unstable_getFirstCallbackNode,\x0a      unstable_pauseExecution: unstable_pauseExecution,\x0a      unstable_continueExecution: unstable_continueExecution,\x0a      unstable_getCurrentPriorityLevel: unstable_getCurrentPriorityLevel,\x0a      unstable_IdlePriority: IdlePriority,\x0a      unstable_ImmediatePriority: ImmediatePriority,\x0a      unstable_LowPriority: LowPriority,\x0a      unstable_NormalPriority: NormalPriority,\x0a      unstable_UserBlockingPriority: UserBlockingPriority\x0a    },\x0a    SchedulerTracing: {\x0a      __interactionsRef: interactionsRef,\x0a      __subscriberRef: subscriberRef,\x0a      unstable_clear: unstable_clear,\x0a      unstable_getCurrent: unstable_getCurrent,\x0a      unstable_getThreadID: unstable_getThreadID,\x0a      unstable_subscribe: unstable_subscribe,\x0a      unstable_trace: unstable_trace,\x0a      unstable_unsubscribe: unstable_unsubscribe,\x0a      unstable_wrap: unstable_wrap\x0a    }\x0a  });\x0a}\x0a\x0a{\x0a  objectAssign(ReactSharedInternals, {\x0a    // These should not be included in production.\x0a    ReactDebugCurrentFrame: ReactDebugCurrentFrame,\x0a    // Shim for React DOM 16.0.0 which still destructured (but not used) this.\x0a    // TODO: remove in React 17.0.\x0a    ReactComponentTreeHook: {}\x0a  });\x0a}\x0a\x0a/**\x0a * Similar to invariant but only logs a warning if the condition is not met.\x0a * This can be used to log issues in development environments in critical\x0a * paths. Removing the logging code for production environments will keep the\x0a * same logic and follow the same code paths.\x0a */\x0a\x0avar warning = warningWithoutStack$1;\x0a\x0a{\x0a  warning = function (condition, format) {\x0a    if (condition) {\x0a      return;\x0a    }\x0a    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\x0a    var stack = ReactDebugCurrentFrame.getStackAddendum();\x0a    // eslint-disable-next-line react-internal/warning-and-invariant-args\x0a\x0a    for (var _len = arguments.length, args = Array(_len \x3e 2 ? _len - 2 : 0), _key = 2; _key \x3c _len; _key++) {\x0a      args[_key - 2] = arguments[_key];\x0a    }\x0a\x0a    warningWithoutStack$1.apply(undefined, [false, format + \x27%s\x27].concat(args, [stack]));\x0a  };\x0a}\x0a\x0avar warning$1 = warning;\x0a\x0avar hasOwnProperty$1 = Object.prototype.hasOwnProperty;\x0a\x0avar RESERVED_PROPS = {\x0a  key: true,\x0a  ref: true,\x0a  __self: true,\x0a  __source: true\x0a};\x0a\x0avar specialPropKeyWarningShown = void 0;\x0avar specialPropRefWarningShown = void 0;\x0a\x0afunction hasValidRef(config) {\x0a  {\x0a    if (hasOwnProperty$1.call(config, \x27ref\x27)) {\x0a      var getter = Object.getOwnPropertyDescriptor(config, \x27ref\x27).get;\x0a      if (getter && getter.isReactWarning) {\x0a        return false;\x0a      }\x0a    }\x0a  }\x0a  return config.ref !== undefined;\x0a}\x0a\x0afunction hasValidKey(config) {\x0a  {\x0a    if (hasOwnProperty$1.call(config, \x27key\x27)) {\x0a      var getter = Object.getOwnPropertyDescriptor(config, \x27key\x27).get;\x0a      if (getter && getter.isReactWarning) {\x0a        return false;\x0a      }\x0a    }\x0a  }\x0a  return config.key !== undefined;\x0a}\x0a\x0afunction defineKeyPropWarningGetter(props, displayName) {\x0a  var warnAboutAccessingKey = function () {\x0a    if (!specialPropKeyWarningShown) {\x0a      specialPropKeyWarningShown = true;\x0a      warningWithoutStack$1(false, \x27%s: `key` is not a prop. Trying to access it will result \x27 + \x27in `undefined` being returned. If you need to access the same \x27 + \x27value within the child component, you should pass it as a different \x27 + \x27prop. (https://fb.me/react-special-props)\x27, displayName);\x0a    }\x0a  };\x0a  warnAboutAccessingKey.isReactWarning = true;\x0a  Object.defineProperty(props, \x27key\x27, {\x0a    get: warnAboutAccessingKey,\x0a    configurable: true\x0a  });\x0a}\x0a\x0afunction defineRefPropWarningGetter(props, displayName) {\x0a  var warnAboutAccessingRef = function () {\x0a    if (!specialPropRefWarningShown) {\x0a      specialPropRefWarningShown = true;\x0a      warningWithoutStack$1(false, \x27%s: `ref` is not a prop. Trying to access it will result \x27 + \x27in `undefined` being returned. If you need to access the same \x27 + \x27value within the child component, you should pass it as a different \x27 + \x27prop. (https://fb.me/react-special-props)\x27, displayName);\x0a    }\x0a  };\x0a  warnAboutAccessingRef.isReactWarning = true;\x0a  Object.defineProperty(props, \x27ref\x27, {\x0a    get: warnAboutAccessingRef,\x0a    configurable: true\x0a  });\x0a}\x0a\x0a/**\x0a * Factory method to create a new React element. This no longer adheres to\x0a * the class pattern, so do not use new to call it. Also, no instanceof check\x0a * will work. Instead test $$typeof field against Symbol.for(\x27react.element\x27) to check\x0a * if something is a React Element.\x0a *\x0a * @param {*} type\x0a * @param {*} key\x0a * @param {string|object} ref\x0a * @param {*} self A *temporary* helper to detect places where `this` is\x0a * different from the `owner` when React.createElement is called, so that we\x0a * can warn. We want to get rid of owner and replace string `ref`s with arrow\x0a * functions, and as long as `this` and owner are the same, there will be no\x0a * change in behavior.\x0a * @param {*} source An annotation object (added by a transpiler or otherwise)\x0a * indicating filename, line number, and/or other information.\x0a * @param {*} owner\x0a * @param {*} props\x0a * @internal\x0a */\x0avar ReactElement = function (type, key, ref, self, source, owner, props) {\x0a  var element = {\x0a    // This tag allows us to uniquely identify this as a React Element\x0a    $$typeof: REACT_ELEMENT_TYPE,\x0a\x0a    // Built-in properties that belong on the element\x0a    type: type,\x0a    key: key,\x0a    ref: ref,\x0a    props: props,\x0a\x0a    // Record the component responsible for creating this element.\x0a    _owner: owner\x0a  };\x0a\x0a  {\x0a    // The validation flag is currently mutative. We put it on\x0a    // an external backing store so that we can freeze the whole object.\x0a    // This can be replaced with a WeakMap once they are implemented in\x0a    // commonly used development environments.\x0a    element._store = {};\x0a\x0a    // To make comparing ReactElements easier for testing purposes, we make\x0a    // the validation flag non-enumerable (where possible, which should\x0a    // include every environment we run tests in), so the test framework\x0a    // ignores it.\x0a    Object.defineProperty(element._store, \x27validated\x27, {\x0a      configurable: false,\x0a      enumerable: false,\x0a      writable: true,\x0a      value: false\x0a    });\x0a    // self and source are DEV only properties.\x0a    Object.defineProperty(element, \x27_self\x27, {\x0a      configurable: false,\x0a      enumerable: false,\x0a      writable: false,\x0a      value: self\x0a    });\x0a    // Two elements created in two different places should be considered\x0a    // equal for testing purposes and therefore we hide it from enumeration.\x0a    Object.defineProperty(element, \x27_source\x27, {\x0a      configurable: false,\x0a      enumerable: false,\x0a      writable: false,\x0a      value: source\x0a    });\x0a    if (Object.freeze) {\x0a      Object.freeze(element.props);\x0a      Object.freeze(element);\x0a    }\x0a  }\x0a\x0a  return element;\x0a};\x0a\x0a/**\x0a * Create and return a new ReactElement of the given type.\x0a * See https://reactjs.org/docs/react-api.html#createelement\x0a */\x0afunction createElement(type, config, children) {\x0a  var propName = void 0;\x0a\x0a  // Reserved names are extracted\x0a  var props = {};\x0a\x0a  var key = null;\x0a  var ref = null;\x0a  var self = null;\x0a  var source = null;\x0a\x0a  if (config != null) {\x0a    if (hasValidRef(config)) {\x0a      ref = config.ref;\x0a    }\x0a    if (hasValidKey(config)) {\x0a      key = \x27\x27 + config.key;\x0a    }\x0a\x0a    self = config.__self === undefined ? null : config.__self;\x0a    source = config.__source === undefined ? null : config.__source;\x0a    // Remaining properties are added to a new props object\x0a    for (propName in config) {\x0a      if (hasOwnProperty$1.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\x0a        props[propName] = config[propName];\x0a      }\x0a    }\x0a  }\x0a\x0a  // Children can be more than one argument, and those are transferred onto\x0a  // the newly allocated props object.\x0a  var childrenLength = arguments.length - 2;\x0a  if (childrenLength === 1) {\x0a    props.children = children;\x0a  } else if (childrenLength \x3e 1) {\x0a    var childArray = Array(childrenLength);\x0a    for (var i = 0; i \x3c childrenLength; i++) {\x0a      childArray[i] = arguments[i + 2];\x0a    }\x0a    {\x0a      if (Object.freeze) {\x0a        Object.freeze(childArray);\x0a      }\x0a    }\x0a    props.children = childArray;\x0a  }\x0a\x0a  // Resolve default props\x0a  if (type && type.defaultProps) {\x0a    var defaultProps = type.defaultProps;\x0a    for (propName in defaultProps) {\x0a      if (props[propName] === undefined) {\x0a        props[propName] = defaultProps[propName];\x0a      }\x0a    }\x0a  }\x0a  {\x0a    if (key || ref) {\x0a      var displayName = typeof type === \x27function\x27 ? type.displayName || type.name || \x27Unknown\x27 : type;\x0a      if (key) {\x0a        defineKeyPropWarningGetter(props, displayName);\x0a      }\x0a      if (ref) {\x0a        defineRefPropWarningGetter(props, displayName);\x0a      }\x0a    }\x0a  }\x0a  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\x0a}\x0a\x0a/**\x0a * Return a function that produces ReactElements of a given type.\x0a * See https://reactjs.org/docs/react-api.html#createfactory\x0a */\x0a\x0a\x0afunction cloneAndReplaceKey(oldElement, newKey) {\x0a  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\x0a\x0a  return newElement;\x0a}\x0a\x0a/**\x0a * Clone and return a new ReactElement using element as the starting point.\x0a * See https://reactjs.org/docs/react-api.html#cloneelement\x0a */\x0afunction cloneElement(element, config, children) {\x0a  !!(element === null || element === undefined) ? invariant(false, \x27React.cloneElement(...): The argument must be a React element, but you passed %s.\x27, element) : void 0;\x0a\x0a  var propName = void 0;\x0a\x0a  // Original props are copied\x0a  var props = objectAssign({}, element.props);\x0a\x0a  // Reserved names are extracted\x0a  var key = element.key;\x0a  var ref = element.ref;\x0a  // Self is preserved since the owner is preserved.\x0a  var self = element._self;\x0a  // Source is preserved since cloneElement is unlikely to be targeted by a\x0a  // transpiler, and the original source is probably a better indicator of the\x0a  // true owner.\x0a  var source = element._source;\x0a\x0a  // Owner will be preserved, unless ref is overridden\x0a  var owner = element._owner;\x0a\x0a  if (config != null) {\x0a    if (hasValidRef(config)) {\x0a      // Silently steal the ref from the parent.\x0a      ref = config.ref;\x0a      owner = ReactCurrentOwner.current;\x0a    }\x0a    if (hasValidKey(config)) {\x0a      key = \x27\x27 + config.key;\x0a    }\x0a\x0a    // Remaining properties override existing props\x0a    var defaultProps = void 0;\x0a    if (element.type && element.type.defaultProps) {\x0a      defaultProps = element.type.defaultProps;\x0a    }\x0a    for (propName in config) {\x0a      if (hasOwnProperty$1.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\x0a        if (config[propName] === undefined && defaultProps !== undefined) {\x0a          // Resolve default props\x0a          props[propName] = defaultProps[propName];\x0a        } else {\x0a          props[propName] = config[propName];\x0a        }\x0a      }\x0a    }\x0a  }\x0a\x0a  // Children can be more than one argument, and those are transferred onto\x0a  // the newly allocated props object.\x0a  var childrenLength = arguments.length - 2;\x0a  if (childrenLength === 1) {\x0a    props.children = children;\x0a  } else if (childrenLength \x3e 1) {\x0a    var childArray = Array(childrenLength);\x0a    for (var i = 0; i \x3c childrenLength; i++) {\x0a      childArray[i] = arguments[i + 2];\x0a    }\x0a    props.children = childArray;\x0a  }\x0a\x0a  return ReactElement(element.type, key, ref, self, source, owner, props);\x0a}\x0a\x0a/**\x0a * Verifies the object is a ReactElement.\x0a * See https://reactjs.org/docs/react-api.html#isvalidelement\x0a * @param {?object} object\x0a * @return {boolean} True if `object` is a ReactElement.\x0a * @final\x0a */\x0afunction isValidElement(object) {\x0a  return typeof object === \x27object\x27 && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\x0a}\x0a\x0avar SEPARATOR = \x27.\x27;\x0avar SUBSEPARATOR = \x27:\x27;\x0a\x0a/**\x0a * Escape and wrap key so it is safe to use as a reactid\x0a *\x0a * @param {string} key to be escaped.\x0a * @return {string} the escaped key.\x0a */\x0afunction escape(key) {\x0a  var escapeRegex = /[=:]/g;\x0a  var escaperLookup = {\x0a    \x27=\x27: \x27=0\x27,\x0a    \x27:\x27: \x27=2\x27\x0a  };\x0a  var escapedString = (\x27\x27 + key).replace(escapeRegex, function (match) {\x0a    return escaperLookup[match];\x0a  });\x0a\x0a  return \x27$\x27 + escapedString;\x0a}\x0a\x0a/**\x0a * TODO: Test that a single child and an array with one item have the same key\x0a * pattern.\x0a */\x0a\x0avar didWarnAboutMaps = false;\x0a\x0avar userProvidedKeyEscapeRegex = /\x5c/+/g;\x0afunction escapeUserProvidedKey(text) {\x0a  return (\x27\x27 + text).replace(userProvidedKeyEscapeRegex, \x27$&/\x27);\x0a}\x0a\x0avar POOL_SIZE = 10;\x0avar traverseContextPool = [];\x0afunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\x0a  if (traverseContextPool.length) {\x0a    var traverseContext = traverseContextPool.pop();\x0a    traverseContext.result = mapResult;\x0a    traverseContext.keyPrefix = keyPrefix;\x0a    traverseContext.func = mapFunction;\x0a    traverseContext.context = mapContext;\x0a    traverseContext.count = 0;\x0a    return traverseContext;\x0a  } else {\x0a    return {\x0a      result: mapResult,\x0a      keyPrefix: keyPrefix,\x0a      func: mapFunction,\x0a      context: mapContext,\x0a      count: 0\x0a    };\x0a  }\x0a}\x0a\x0afunction releaseTraverseContext(traverseContext) {\x0a  traverseContext.result = null;\x0a  traverseContext.keyPrefix = null;\x0a  traverseContext.func = null;\x0a  traverseContext.context = null;\x0a  traverseContext.count = 0;\x0a  if (traverseContextPool.length \x3c POOL_SIZE) {\x0a    traverseContextPool.push(traverseContext);\x0a  }\x0a}\x0a\x0a/**\x0a * @param {?*} children Children tree container.\x0a * @param {!string} nameSoFar Name of the key path so far.\x0a * @param {!function} callback Callback to invoke with each child found.\x0a * @param {?*} traverseContext Used to pass information throughout the traversal\x0a * process.\x0a * @return {!number} The number of children in this subtree.\x0a */\x0afunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\x0a  var type = typeof children;\x0a\x0a  if (type === \x27undefined\x27 || type === \x27boolean\x27) {\x0a    // All of the above are perceived as null.\x0a    children = null;\x0a  }\x0a\x0a  var invokeCallback = false;\x0a\x0a  if (children === null) {\x0a    invokeCallback = true;\x0a  } else {\x0a    switch (type) {\x0a      case \x27string\x27:\x0a      case \x27number\x27:\x0a        invokeCallback = true;\x0a        break;\x0a      case \x27object\x27:\x0a        switch (children.$$typeof) {\x0a          case REACT_ELEMENT_TYPE:\x0a          case REACT_PORTAL_TYPE:\x0a            invokeCallback = true;\x0a        }\x0a    }\x0a  }\x0a\x0a  if (invokeCallback) {\x0a    callback(traverseContext, children,\x0a    // If it\x27s the only child, treat the name as if it was wrapped in an array\x0a    // so that it\x27s consistent if the number of children grows.\x0a    nameSoFar === \x27\x27 ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\x0a    return 1;\x0a  }\x0a\x0a  var child = void 0;\x0a  var nextName = void 0;\x0a  var subtreeCount = 0; // Count of children found in the current subtree.\x0a  var nextNamePrefix = nameSoFar === \x27\x27 ? SEPARATOR : nameSoFar + SUBSEPARATOR;\x0a\x0a  if (Array.isArray(children)) {\x0a    for (var i = 0; i \x3c children.length; i++) {\x0a      child = children[i];\x0a      nextName = nextNamePrefix + getComponentKey(child, i);\x0a      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\x0a    }\x0a  } else {\x0a    var iteratorFn = getIteratorFn(children);\x0a    if (typeof iteratorFn === \x27function\x27) {\x0a      {\x0a        // Warn about using Maps as children\x0a        if (iteratorFn === children.entries) {\x0a          !didWarnAboutMaps ? warning$1(false, \x27Using Maps as children is unsupported and will likely yield \x27 + \x27unexpected results. Convert it to a sequence/iterable of keyed \x27 + \x27ReactElements instead.\x27) : void 0;\x0a          didWarnAboutMaps = true;\x0a        }\x0a      }\x0a\x0a      var iterator = iteratorFn.call(children);\x0a      var step = void 0;\x0a      var ii = 0;\x0a      while (!(step = iterator.next()).done) {\x0a        child = step.value;\x0a        nextName = nextNamePrefix + getComponentKey(child, ii++);\x0a        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\x0a      }\x0a    } else if (type === \x27object\x27) {\x0a      var addendum = \x27\x27;\x0a      {\x0a        addendum = \x27 If you meant to render a collection of children, use an array \x27 + \x27instead.\x27 + ReactDebugCurrentFrame.getStackAddendum();\x0a      }\x0a      var childrenString = \x27\x27 + children;\x0a      invariant(false, \x27Objects are not valid as a React child (found: %s).%s\x27, childrenString === \x27[object Object]\x27 ? \x27object with keys {\x27 + Object.keys(children).join(\x27, \x27) + \x27}\x27 : childrenString, addendum);\x0a    }\x0a  }\x0a\x0a  return subtreeCount;\x0a}\x0a\x0a/**\x0a * Traverses children that are typically specified as `props.children`, but\x0a * might also be specified through attributes:\x0a *\x0a * - `traverseAllChildren(this.props.children, ...)`\x0a * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\x0a *\x0a * The `traverseContext` is an optional argument that is passed through the\x0a * entire traversal. It can be used to store accumulations or anything else that\x0a * the callback might find relevant.\x0a *\x0a * @param {?*} children Children tree object.\x0a * @param {!function} callback To invoke upon traversing each child.\x0a * @param {?*} traverseContext Context for traversal.\x0a * @return {!number} The number of children in this subtree.\x0a */\x0afunction traverseAllChildren(children, callback, traverseContext) {\x0a  if (children == null) {\x0a    return 0;\x0a  }\x0a\x0a  return traverseAllChildrenImpl(children, \x27\x27, callback, traverseContext);\x0a}\x0a\x0a/**\x0a * Generate a key string that identifies a component within a set.\x0a *\x0a * @param {*} component A component that could contain a manual key.\x0a * @param {number} index Index that is used if a manual key is not provided.\x0a * @return {string}\x0a */\x0afunction getComponentKey(component, index) {\x0a  // Do some typechecking here since we call this blindly. We want to ensure\x0a  // that we don\x27t block potential future ES APIs.\x0a  if (typeof component === \x27object\x27 && component !== null && component.key != null) {\x0a    // Explicit key\x0a    return escape(component.key);\x0a  }\x0a  // Implicit key determined by the index in the set\x0a  return index.toString(36);\x0a}\x0a\x0afunction forEachSingleChild(bookKeeping, child, name) {\x0a  var func = bookKeeping.func,\x0a      context = bookKeeping.context;\x0a\x0a  func.call(context, child, bookKeeping.count++);\x0a}\x0a\x0a/**\x0a * Iterates through children that are typically specified as `props.children`.\x0a *\x0a * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\x0a *\x0a * The provided forEachFunc(child, index) will be called for each\x0a * leaf child.\x0a *\x0a * @param {?*} children Children tree container.\x0a * @param {function(*, int)} forEachFunc\x0a * @param {*} forEachContext Context for forEachContext.\x0a */\x0afunction forEachChildren(children, forEachFunc, forEachContext) {\x0a  if (children == null) {\x0a    return children;\x0a  }\x0a  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\x0a  traverseAllChildren(children, forEachSingleChild, traverseContext);\x0a  releaseTraverseContext(traverseContext);\x0a}\x0a\x0afunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\x0a  var result = bookKeeping.result,\x0a      keyPrefix = bookKeeping.keyPrefix,\x0a      func = bookKeeping.func,\x0a      context = bookKeeping.context;\x0a\x0a\x0a  var mappedChild = func.call(context, child, bookKeeping.count++);\x0a  if (Array.isArray(mappedChild)) {\x0a    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {\x0a      return c;\x0a    });\x0a  } else if (mappedChild != null) {\x0a    if (isValidElement(mappedChild)) {\x0a      mappedChild = cloneAndReplaceKey(mappedChild,\x0a      // Keep both the (mapped) and old keys if they differ, just as\x0a      // traverseAllChildren used to do for objects as children\x0a      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + \x27/\x27 : \x27\x27) + childKey);\x0a    }\x0a    result.push(mappedChild);\x0a  }\x0a}\x0a\x0afunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\x0a  var escapedPrefix = \x27\x27;\x0a  if (prefix != null) {\x0a    escapedPrefix = escapeUserProvidedKey(prefix) + \x27/\x27;\x0a  }\x0a  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\x0a  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\x0a  releaseTraverseContext(traverseContext);\x0a}\x0a\x0a/**\x0a * Maps children that are typically specified as `props.children`.\x0a *\x0a * See https://reactjs.org/docs/react-api.html#reactchildrenmap\x0a *\x0a * The provided mapFunction(child, key, index) will be called for each\x0a * leaf child.\x0a *\x0a * @param {?*} children Children tree container.\x0a * @param {function(*, int)} func The map function.\x0a * @param {*} context Context for mapFunction.\x0a * @return {object} Object containing the ordered map of results.\x0a */\x0afunction mapChildren(children, func, context) {\x0a  if (children == null) {\x0a    return children;\x0a  }\x0a  var result = [];\x0a  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\x0a  return result;\x0a}\x0a\x0a/**\x0a * Count the number of children that are typically specified as\x0a * `props.children`.\x0a *\x0a * See https://reactjs.org/docs/react-api.html#reactchildrencount\x0a *\x0a * @param {?*} children Children tree container.\x0a * @return {number} The number of children.\x0a */\x0afunction countChildren(children) {\x0a  return traverseAllChildren(children, function () {\x0a    return null;\x0a  }, null);\x0a}\x0a\x0a/**\x0a * Flatten a children object (typically specified as `props.children`) and\x0a * return an array with appropriately re-keyed children.\x0a *\x0a * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\x0a */\x0afunction toArray(children) {\x0a  var result = [];\x0a  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {\x0a    return child;\x0a  });\x0a  return result;\x0a}\x0a\x0a/**\x0a * Returns the first child in a collection of children and verifies that there\x0a * is only one child in the collection.\x0a *\x0a * See https://reactjs.org/docs/react-api.html#reactchildrenonly\x0a *\x0a * The current implementation of this function assumes that a single child gets\x0a * passed without a wrapper, but the purpose of this helper function is to\x0a * abstract away the particular structure of children.\x0a *\x0a * @param {?object} children Child collection structure.\x0a * @return {ReactElement} The first and only `ReactElement` contained in the\x0a * structure.\x0a */\x0afunction onlyChild(children) {\x0a  !isValidElement(children) ? invariant(false, \x27React.Children.only expected to receive a single React element child.\x27) : void 0;\x0a  return children;\x0a}\x0a\x0afunction createContext(defaultValue, calculateChangedBits) {\x0a  if (calculateChangedBits === undefined) {\x0a    calculateChangedBits = null;\x0a  } else {\x0a    {\x0a      !(calculateChangedBits === null || typeof calculateChangedBits === \x27function\x27) ? warningWithoutStack$1(false, \x27createContext: Expected the optional second argument to be a \x27 + \x27function. Instead received: %s\x27, calculateChangedBits) : void 0;\x0a    }\x0a  }\x0a\x0a  var context = {\x0a    $$typeof: REACT_CONTEXT_TYPE,\x0a    _calculateChangedBits: calculateChangedBits,\x0a    // As a workaround to support multiple concurrent renderers, we categorize\x0a    // some renderers as primary and others as secondary. We only expect\x0a    // there to be two concurrent renderers at most: React Native (primary) and\x0a    // Fabric (secondary); React DOM (primary) and React ART (secondary).\x0a    // Secondary renderers store their context values on separate fields.\x0a    _currentValue: defaultValue,\x0a    _currentValue2: defaultValue,\x0a    // Used to track how many concurrent renderers this context currently\x0a    // supports within in a single renderer. Such as parallel server rendering.\x0a    _threadCount: 0,\x0a    // These are circular\x0a    Provider: null,\x0a    Consumer: null\x0a  };\x0a\x0a  context.Provider = {\x0a    $$typeof: REACT_PROVIDER_TYPE,\x0a    _context: context\x0a  };\x0a\x0a  var hasWarnedAboutUsingNestedContextConsumers = false;\x0a  var hasWarnedAboutUsingConsumerProvider = false;\x0a\x0a  {\x0a    // A separate object, but proxies back to the original context object for\x0a    // backwards compatibility. It has a different $$typeof, so we can properly\x0a    // warn for the incorrect usage of Context as a Consumer.\x0a    var Consumer = {\x0a      $$typeof: REACT_CONTEXT_TYPE,\x0a      _context: context,\x0a      _calculateChangedBits: context._calculateChangedBits\x0a    };\x0a    // $FlowFixMe: Flow complains about not setting a value, which is intentional here\x0a    Object.defineProperties(Consumer, {\x0a      Provider: {\x0a        get: function () {\x0a          if (!hasWarnedAboutUsingConsumerProvider) {\x0a            hasWarnedAboutUsingConsumerProvider = true;\x0a            warning$1(false, \x27Rendering \x3cContext.Consumer.Provider\x3e is not supported and will be removed in \x27 + \x27a future major release. Did you mean to render \x3cContext.Provider\x3e instead?\x27);\x0a          }\x0a          return context.Provider;\x0a        },\x0a        set: function (_Provider) {\x0a          context.Provider = _Provider;\x0a        }\x0a      },\x0a      _currentValue: {\x0a        get: function () {\x0a          return context._currentValue;\x0a        },\x0a        set: function (_currentValue) {\x0a          context._currentValue = _currentValue;\x0a        }\x0a      },\x0a      _currentValue2: {\x0a        get: function () {\x0a          return context._currentValue2;\x0a        },\x0a        set: function (_currentValue2) {\x0a          context._currentValue2 = _currentValue2;\x0a        }\x0a      },\x0a      _threadCount: {\x0a        get: function () {\x0a          return context._threadCount;\x0a        },\x0a        set: function (_threadCount) {\x0a          context._threadCount = _threadCount;\x0a        }\x0a      },\x0a      Consumer: {\x0a        get: function () {\x0a          if (!hasWarnedAboutUsingNestedContextConsumers) {\x0a            hasWarnedAboutUsingNestedContextConsumers = true;\x0a            warning$1(false, \x27Rendering \x3cContext.Consumer.Consumer\x3e is not supported and will be removed in \x27 + \x27a future major release. Did you mean to render \x3cContext.Consumer\x3e instead?\x27);\x0a          }\x0a          return context.Consumer;\x0a        }\x0a      }\x0a    });\x0a    // $FlowFixMe: Flow complains about missing properties because it doesn\x27t understand defineProperty\x0a    context.Consumer = Consumer;\x0a  }\x0a\x0a  {\x0a    context._currentRenderer = null;\x0a    context._currentRenderer2 = null;\x0a  }\x0a\x0a  return context;\x0a}\x0a\x0afunction lazy(ctor) {\x0a  var lazyType = {\x0a    $$typeof: REACT_LAZY_TYPE,\x0a    _ctor: ctor,\x0a    // React uses these fields to store the result.\x0a    _status: -1,\x0a    _result: null\x0a  };\x0a\x0a  {\x0a    // In production, this would just set it on the object.\x0a    var defaultProps = void 0;\x0a    var propTypes = void 0;\x0a    Object.defineProperties(lazyType, {\x0a      defaultProps: {\x0a        configurable: true,\x0a        get: function () {\x0a          return defaultProps;\x0a        },\x0a        set: function (newDefaultProps) {\x0a          warning$1(false, \x27React.lazy(...): It is not supported to assign `defaultProps` to \x27 + \x27a lazy component import. Either specify them where the component \x27 + \x27is defined, or create a wrapping component around it.\x27);\x0a          defaultProps = newDefaultProps;\x0a          // Match production behavior more closely:\x0a          Object.defineProperty(lazyType, \x27defaultProps\x27, {\x0a            enumerable: true\x0a          });\x0a        }\x0a      },\x0a      propTypes: {\x0a        configurable: true,\x0a        get: function () {\x0a          return propTypes;\x0a        },\x0a        set: function (newPropTypes) {\x0a          warning$1(false, \x27React.lazy(...): It is not supported to assign `propTypes` to \x27 + \x27a lazy component import. Either specify them where the component \x27 + \x27is defined, or create a wrapping component around it.\x27);\x0a          propTypes = newPropTypes;\x0a          // Match production behavior more closely:\x0a          Object.defineProperty(lazyType, \x27propTypes\x27, {\x0a            enumerable: true\x0a          });\x0a        }\x0a      }\x0a    });\x0a  }\x0a\x0a  return lazyType;\x0a}\x0a\x0afunction forwardRef(render) {\x0a  {\x0a    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\x0a      warningWithoutStack$1(false, \x27forwardRef requires a render function but received a `memo` \x27 + \x27component. Instead of forwardRef(memo(...)), use \x27 + \x27memo(forwardRef(...)).\x27);\x0a    } else if (typeof render !== \x27function\x27) {\x0a      warningWithoutStack$1(false, \x27forwardRef requires a render function but was given %s.\x27, render === null ? \x27null\x27 : typeof render);\x0a    } else {\x0a      !(\x0a      // Do not warn for 0 arguments because it could be due to usage of the \x27arguments\x27 object\x0a      render.length === 0 || render.length === 2) ? warningWithoutStack$1(false, \x27forwardRef render functions accept exactly two parameters: props and ref. %s\x27, render.length === 1 ? \x27Did you forget to use the ref parameter?\x27 : \x27Any additional parameter will be undefined.\x27) : void 0;\x0a    }\x0a\x0a    if (render != null) {\x0a      !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, \x27forwardRef render functions do not support propTypes or defaultProps. \x27 + \x27Did you accidentally pass a React component?\x27) : void 0;\x0a    }\x0a  }\x0a\x0a  return {\x0a    $$typeof: REACT_FORWARD_REF_TYPE,\x0a    render: render\x0a  };\x0a}\x0a\x0afunction isValidElementType(type) {\x0a  return typeof type === \x27string\x27 || typeof type === \x27function\x27 ||\x0a  // Note: its typeof might be other than \x27symbol\x27 or \x27number\x27 if it\x27s a polyfill.\x0a  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === \x27object\x27 && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\x0a}\x0a\x0afunction memo(type, compare) {\x0a  {\x0a    if (!isValidElementType(type)) {\x0a      warningWithoutStack$1(false, \x27memo: The first argument must be a component. Instead \x27 + \x27received: %s\x27, type === null ? \x27null\x27 : typeof type);\x0a    }\x0a  }\x0a  return {\x0a    $$typeof: REACT_MEMO_TYPE,\x0a    type: type,\x0a    compare: compare === undefined ? null : compare\x0a  };\x0a}\x0a\x0afunction resolveDispatcher() {\x0a  var dispatcher = ReactCurrentDispatcher.current;\x0a  !(dispatcher !== null) ? invariant(false, \x27Hooks can only be called inside the body of a function component. (https://fb.me/react-invalid-hook-call)\x27) : void 0;\x0a  return dispatcher;\x0a}\x0a\x0afunction useContext(Context, unstable_observedBits) {\x0a  var dispatcher = resolveDispatcher();\x0a  {\x0a    !(unstable_observedBits === undefined) ? warning$1(false, \x27useContext() second argument is reserved for future \x27 + \x27use in React. Passing it is not supported. \x27 + \x27You passed: %s.%s\x27, unstable_observedBits, typeof unstable_observedBits === \x27number\x27 && Array.isArray(arguments[2]) ? \x27\x5cn\x5cnDid you call array.map(useContext)? \x27 + \x27Calling Hooks inside a loop is not supported. \x27 + \x27Learn more at https://fb.me/rules-of-hooks\x27 : \x27\x27) : void 0;\x0a\x0a    // TODO: add a more generic warning for invalid values.\x0a    if (Context._context !== undefined) {\x0a      var realContext = Context._context;\x0a      // Don\x27t deduplicate because this legitimately causes bugs\x0a      // and nobody should be using this in existing code.\x0a      if (realContext.Consumer === Context) {\x0a        warning$1(false, \x27Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be \x27 + \x27removed in a future major release. Did you mean to call useContext(Context) instead?\x27);\x0a      } else if (realContext.Provider === Context) {\x0a        warning$1(false, \x27Calling useContext(Context.Provider) is not supported. \x27 + \x27Did you mean to call useContext(Context) instead?\x27);\x0a      }\x0a    }\x0a  }\x0a  return dispatcher.useContext(Context, unstable_observedBits);\x0a}\x0a\x0afunction useState(initialState) {\x0a  var dispatcher = resolveDispatcher();\x0a  return dispatcher.useState(initialState);\x0a}\x0a\x0afunction useReducer(reducer, initialArg, init) {\x0a  var dispatcher = resolveDispatcher();\x0a  return dispatcher.useReducer(reducer, initialArg, init);\x0a}\x0a\x0afunction useRef(initialValue) {\x0a  var dispatcher = resolveDispatcher();\x0a  return dispatcher.useRef(initialValue);\x0a}\x0a\x0afunction useEffect(create, inputs) {\x0a  var dispatcher = resolveDispatcher();\x0a  return dispatcher.useEffect(create, inputs);\x0a}\x0a\x0afunction useLayoutEffect(create, inputs) {\x0a  var dispatcher = resolveDispatcher();\x0a  return dispatcher.useLayoutEffect(create, inputs);\x0a}\x0a\x0afunction useCallback(callback, inputs) {\x0a  var dispatcher = resolveDispatcher();\x0a  return dispatcher.useCallback(callback, inputs);\x0a}\x0a\x0afunction useMemo(create, inputs) {\x0a  var dispatcher = resolveDispatcher();\x0a  return dispatcher.useMemo(create, inputs);\x0a}\x0a\x0afunction useImperativeHandle(ref, create, inputs) {\x0a  var dispatcher = resolveDispatcher();\x0a  return dispatcher.useImperativeHandle(ref, create, inputs);\x0a}\x0a\x0afunction useDebugValue(value, formatterFn) {\x0a  {\x0a    var dispatcher = resolveDispatcher();\x0a    return dispatcher.useDebugValue(value, formatterFn);\x0a  }\x0a}\x0a\x0a/**\x0a * Copyright (c) 2013-present, Facebook, Inc.\x0a *\x0a * This source code is licensed under the MIT license found in the\x0a * LICENSE file in the root directory of this source tree.\x0a */\x0a\x0a\x0a\x0avar ReactPropTypesSecret$1 = \x27SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\x27;\x0a\x0avar ReactPropTypesSecret_1 = ReactPropTypesSecret$1;\x0a\x0a/**\x0a * Copyright (c) 2013-present, Facebook, Inc.\x0a *\x0a * This source code is licensed under the MIT license found in the\x0a * LICENSE file in the root directory of this source tree.\x0a */\x0a\x0a\x0a\x0avar printWarning$1 = function() {};\x0a\x0a{\x0a  var ReactPropTypesSecret = ReactPropTypesSecret_1;\x0a  var loggedTypeFailures = {};\x0a\x0a  printWarning$1 = function(text) {\x0a    var message = \x27Warning: \x27 + text;\x0a    if (typeof console !== \x27undefined\x27) {\x0a      console.error(message);\x0a    }\x0a    try {\x0a      // --- Welcome to debugging React ---\x0a      // This error was thrown as a convenience so that you can use this stack\x0a      // to find the callsite that caused this warning to fire.\x0a      throw new Error(message);\x0a    } catch (x) {}\x0a  };\x0a}\x0a\x0a/**\x0a * Assert that the values match with the type specs.\x0a * Error messages are memorized and will only be shown once.\x0a *\x0a * @param {object} typeSpecs Map of name to a ReactPropType\x0a * @param {object} values Runtime values that need to be type-checked\x0a * @param {string} location e.g. \x22prop\x22, \x22context\x22, \x22child context\x22\x0a * @param {string} componentName Name of the component for error messages.\x0a * @param {?Function} getStack Returns the component stack.\x0a * @private\x0a */\x0afunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\x0a  {\x0a    for (var typeSpecName in typeSpecs) {\x0a      if (typeSpecs.hasOwnProperty(typeSpecName)) {\x0a        var error;\x0a        // Prop type validation may throw. In case they do, we don\x27t want to\x0a        // fail the render phase where it didn\x27t fail before. So we log it.\x0a        // After these have been cleaned up, we\x27ll let them throw.\x0a        try {\x0a          // This is intentionally an invariant that gets caught. It\x27s the same\x0a          // behavior as without this statement except with a better message.\x0a          if (typeof typeSpecs[typeSpecName] !== \x27function\x27) {\x0a            var err = Error(\x0a              (componentName || \x27React class\x27) + \x27: \x27 + location + \x27 type `\x27 + typeSpecName + \x27` is invalid; \x27 +\x0a              \x27it must be a function, usually from the `prop-types` package, but received `\x27 + typeof typeSpecs[typeSpecName] + \x27`.\x27\x0a            );\x0a            err.name = \x27Invariant Violation\x27;\x0a            throw err;\x0a          }\x0a          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\x0a        } catch (ex) {\x0a          error = ex;\x0a        }\x0a        if (error && !(error instanceof Error)) {\x0a          printWarning$1(\x0a            (componentName || \x27React class\x27) + \x27: type specification of \x27 +\x0a            location + \x27 `\x27 + typeSpecName + \x27` is invalid; the type checker \x27 +\x0a            \x27function must return `null` or an `Error` but returned a \x27 + typeof error + \x27. \x27 +\x0a            \x27You may have forgotten to pass an argument to the type checker \x27 +\x0a            \x27creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \x27 +\x0a            \x27shape all require an argument).\x27\x0a          );\x0a\x0a        }\x0a        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\x0a          // Only monitor this failure once because there tends to be a lot of the\x0a          // same error.\x0a          loggedTypeFailures[error.message] = true;\x0a\x0a          var stack = getStack ? getStack() : \x27\x27;\x0a\x0a          printWarning$1(\x0a            \x27Failed \x27 + location + \x27 type: \x27 + error.message + (stack != null ? stack : \x27\x27)\x0a          );\x0a        }\x0a      }\x0a    }\x0a  }\x0a}\x0a\x0avar checkPropTypes_1 = checkPropTypes;\x0a\x0a/**\x0a * ReactElementValidator provides a wrapper around a element factory\x0a * which validates the props passed to the element. This is intended to be\x0a * used only in DEV and could be replaced by a static type checker for languages\x0a * that support it.\x0a */\x0a\x0avar propTypesMisspellWarningShown = void 0;\x0a\x0a{\x0a  propTypesMisspellWarningShown = false;\x0a}\x0a\x0afunction getDeclarationErrorAddendum() {\x0a  if (ReactCurrentOwner.current) {\x0a    var name = getComponentName(ReactCurrentOwner.current.type);\x0a    if (name) {\x0a      return \x27\x5cn\x5cnCheck the render method of `\x27 + name + \x27`.\x27;\x0a    }\x0a  }\x0a  return \x27\x27;\x0a}\x0a\x0afunction getSourceInfoErrorAddendum(elementProps) {\x0a  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\x0a    var source = elementProps.__source;\x0a    var fileName = source.fileName.replace(/^.*[\x5c\x5c\x5c/]/, \x27\x27);\x0a    var lineNumber = source.lineNumber;\x0a    return \x27\x5cn\x5cnCheck your code at \x27 + fileName + \x27:\x27 + lineNumber + \x27.\x27;\x0a  }\x0a  return \x27\x27;\x0a}\x0a\x0a/**\x0a * Warn if there\x27s no key explicitly set on dynamic arrays of children or\x0a * object keys are not valid. This allows us to keep track of children between\x0a * updates.\x0a */\x0avar ownerHasKeyUseWarning = {};\x0a\x0afunction getCurrentComponentErrorInfo(parentType) {\x0a  var info = getDeclarationErrorAddendum();\x0a\x0a  if (!info) {\x0a    var parentName = typeof parentType === \x27string\x27 ? parentType : parentType.displayName || parentType.name;\x0a    if (parentName) {\x0a      info = \x27\x5cn\x5cnCheck the top-level render call using \x3c\x27 + parentName + \x27\x3e.\x27;\x0a    }\x0a  }\x0a  return info;\x0a}\x0a\x0a/**\x0a * Warn if the element doesn\x27t have an explicit key assigned to it.\x0a * This element is in an array. The array could grow and shrink or be\x0a * reordered. All children that haven\x27t already been validated are required to\x0a * have a \x22key\x22 property assigned to it. Error statuses are cached so a warning\x0a * will only be shown once.\x0a *\x0a * @internal\x0a * @param {ReactElement} element Element that requires a key.\x0a * @param {*} parentType element\x27s parent\x27s type.\x0a */\x0afunction validateExplicitKey(element, parentType) {\x0a  if (!element._store || element._store.validated || element.key != null) {\x0a    return;\x0a  }\x0a  element._store.validated = true;\x0a\x0a  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\x0a  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\x0a    return;\x0a  }\x0a  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\x0a\x0a  // Usually the current owner is the offender, but if it accepts children as a\x0a  // property, it may be the creator of the child that\x27s responsible for\x0a  // assigning it a key.\x0a  var childOwner = \x27\x27;\x0a  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\x0a    // Give the component that originally created this child.\x0a    childOwner = \x27 It was passed a child from \x27 + getComponentName(element._owner.type) + \x27.\x27;\x0a  }\x0a\x0a  setCurrentlyValidatingElement(element);\x0a  {\x0a    warning$1(false, \x27Each child in a list should have a unique \x22key\x22 prop.\x27 + \x27%s%s See https://fb.me/react-warning-keys for more information.\x27, currentComponentErrorInfo, childOwner);\x0a  }\x0a  setCurrentlyValidatingElement(null);\x0a}\x0a\x0a/**\x0a * Ensure that every element either is passed in a static location, in an\x0a * array with an explicit keys property defined, or in an object literal\x0a * with valid key property.\x0a *\x0a * @internal\x0a * @param {ReactNode} node Statically passed child of any type.\x0a * @param {*} parentType node\x27s parent\x27s type.\x0a */\x0afunction validateChildKeys(node, parentType) {\x0a  if (typeof node !== \x27object\x27) {\x0a    return;\x0a  }\x0a  if (Array.isArray(node)) {\x0a    for (var i = 0; i \x3c node.length; i++) {\x0a      var child = node[i];\x0a      if (isValidElement(child)) {\x0a        validateExplicitKey(child, parentType);\x0a      }\x0a    }\x0a  } else if (isValidElement(node)) {\x0a    // This element was passed in a valid location.\x0a    if (node._store) {\x0a      node._store.validated = true;\x0a    }\x0a  } else if (node) {\x0a    var iteratorFn = getIteratorFn(node);\x0a    if (typeof iteratorFn === \x27function\x27) {\x0a      // Entry iterators used to provide implicit keys,\x0a      // but now we print a separate warning for them later.\x0a      if (iteratorFn !== node.entries) {\x0a        var iterator = iteratorFn.call(node);\x0a        var step = void 0;\x0a        while (!(step = iterator.next()).done) {\x0a          if (isValidElement(step.value)) {\x0a            validateExplicitKey(step.value, parentType);\x0a          }\x0a        }\x0a      }\x0a    }\x0a  }\x0a}\x0a\x0a/**\x0a * Given an element, validate that its props follow the propTypes definition,\x0a * provided by the type.\x0a *\x0a * @param {ReactElement} element\x0a */\x0afunction validatePropTypes(element) {\x0a  var type = element.type;\x0a  if (type === null || type === undefined || typeof type === \x27string\x27) {\x0a    return;\x0a  }\x0a  var name = getComponentName(type);\x0a  var propTypes = void 0;\x0a  if (typeof type === \x27function\x27) {\x0a    propTypes = type.propTypes;\x0a  } else if (typeof type === \x27object\x27 && (type.$$typeof === REACT_FORWARD_REF_TYPE ||\x0a  // Note: Memo only checks outer props here.\x0a  // Inner props are checked in the reconciler.\x0a  type.$$typeof === REACT_MEMO_TYPE)) {\x0a    propTypes = type.propTypes;\x0a  } else {\x0a    return;\x0a  }\x0a  if (propTypes) {\x0a    setCurrentlyValidatingElement(element);\x0a    checkPropTypes_1(propTypes, element.props, \x27prop\x27, name, ReactDebugCurrentFrame.getStackAddendum);\x0a    setCurrentlyValidatingElement(null);\x0a  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\x0a    propTypesMisspellWarningShown = true;\x0a    warningWithoutStack$1(false, \x27Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\x27, name || \x27Unknown\x27);\x0a  }\x0a  if (typeof type.getDefaultProps === \x27function\x27) {\x0a    !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, \x27getDefaultProps is only used on classic React.createClass \x27 + \x27definitions. Use a static property named `defaultProps` instead.\x27) : void 0;\x0a  }\x0a}\x0a\x0a/**\x0a * Given a fragment, validate that it can only be provided with fragment props\x0a * @param {ReactElement} fragment\x0a */\x0afunction validateFragmentProps(fragment) {\x0a  setCurrentlyValidatingElement(fragment);\x0a\x0a  var keys = Object.keys(fragment.props);\x0a  for (var i = 0; i \x3c keys.length; i++) {\x0a    var key = keys[i];\x0a    if (key !== \x27children\x27 && key !== \x27key\x27) {\x0a      warning$1(false, \x27Invalid prop `%s` supplied to `React.Fragment`. \x27 + \x27React.Fragment can only have `key` and `children` props.\x27, key);\x0a      break;\x0a    }\x0a  }\x0a\x0a  if (fragment.ref !== null) {\x0a    warning$1(false, \x27Invalid attribute `ref` supplied to `React.Fragment`.\x27);\x0a  }\x0a\x0a  setCurrentlyValidatingElement(null);\x0a}\x0a\x0afunction createElementWithValidation(type, props, children) {\x0a  var validType = isValidElementType(type);\x0a\x0a  // We warn in this case but don\x27t throw. We expect the element creation to\x0a  // succeed and there will likely be errors in render.\x0a  if (!validType) {\x0a    var info = \x27\x27;\x0a    if (type === undefined || typeof type === \x27object\x27 && type !== null && Object.keys(type).length === 0) {\x0a      info += \x27 You likely forgot to export your component from the file \x27 + \x22it\x27s defined in, or you might have mixed up default and named imports.\x22;\x0a    }\x0a\x0a    var sourceInfo = getSourceInfoErrorAddendum(props);\x0a    if (sourceInfo) {\x0a      info += sourceInfo;\x0a    } else {\x0a      info += getDeclarationErrorAddendum();\x0a    }\x0a\x0a    var typeString = void 0;\x0a    if (type === null) {\x0a      typeString = \x27null\x27;\x0a    } else if (Array.isArray(type)) {\x0a      typeString = \x27array\x27;\x0a    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\x0a      typeString = \x27\x3c\x27 + (getComponentName(type.type) || \x27Unknown\x27) + \x27 /\x3e\x27;\x0a      info = \x27 Did you accidentally export a JSX literal instead of a component?\x27;\x0a    } else {\x0a      typeString = typeof type;\x0a    }\x0a\x0a    warning$1(false, \x27React.createElement: type is invalid -- expected a string (for \x27 + \x27built-in components) or a class/function (for composite \x27 + \x27components) but got: %s.%s\x27, typeString, info);\x0a  }\x0a\x0a  var element = createElement.apply(this, arguments);\x0a\x0a  // The result can be nullish if a mock or a custom function is used.\x0a  // TODO: Drop this when these are no longer allowed as the type argument.\x0a  if (element == null) {\x0a    return element;\x0a  }\x0a\x0a  // Skip key warning if the type isn\x27t valid since our key validation logic\x0a  // doesn\x27t expect a non-string/function type and can throw confusing errors.\x0a  // We don\x27t want exception behavior to differ between dev and prod.\x0a  // (Rendering will throw with a helpful message and as soon as the type is\x0a  // fixed, the key warnings will appear.)\x0a  if (validType) {\x0a    for (var i = 2; i \x3c arguments.length; i++) {\x0a      validateChildKeys(arguments[i], type);\x0a    }\x0a  }\x0a\x0a  if (type === REACT_FRAGMENT_TYPE) {\x0a    validateFragmentProps(element);\x0a  } else {\x0a    validatePropTypes(element);\x0a  }\x0a\x0a  return element;\x0a}\x0a\x0afunction createFactoryWithValidation(type) {\x0a  var validatedFactory = createElementWithValidation.bind(null, type);\x0a  validatedFactory.type = type;\x0a  // Legacy hook: remove it\x0a  {\x0a    Object.defineProperty(validatedFactory, \x27type\x27, {\x0a      enumerable: false,\x0a      get: function () {\x0a        lowPriorityWarning$1(false, \x27Factory.type is deprecated. Access the class directly \x27 + \x27before passing it to createFactory.\x27);\x0a        Object.defineProperty(this, \x27type\x27, {\x0a          value: type\x0a        });\x0a        return type;\x0a      }\x0a    });\x0a  }\x0a\x0a  return validatedFactory;\x0a}\x0a\x0afunction cloneElementWithValidation(element, props, children) {\x0a  var newElement = cloneElement.apply(this, arguments);\x0a  for (var i = 2; i \x3c arguments.length; i++) {\x0a    validateChildKeys(arguments[i], newElement.type);\x0a  }\x0a  validatePropTypes(newElement);\x0a  return newElement;\x0a}\x0a\x0avar React = {\x0a  Children: {\x0a    map: mapChildren,\x0a    forEach: forEachChildren,\x0a    count: countChildren,\x0a    toArray: toArray,\x0a    only: onlyChild\x0a  },\x0a\x0a  createRef: createRef,\x0a  Component: Component,\x0a  PureComponent: PureComponent,\x0a\x0a  createContext: createContext,\x0a  forwardRef: forwardRef,\x0a  lazy: lazy,\x0a  memo: memo,\x0a\x0a  useCallback: useCallback,\x0a  useContext: useContext,\x0a  useEffect: useEffect,\x0a  useImperativeHandle: useImperativeHandle,\x0a  useDebugValue: useDebugValue,\x0a  useLayoutEffect: useLayoutEffect,\x0a  useMemo: useMemo,\x0a  useReducer: useReducer,\x0a  useRef: useRef,\x0a  useState: useState,\x0a\x0a  Fragment: REACT_FRAGMENT_TYPE,\x0a  StrictMode: REACT_STRICT_MODE_TYPE,\x0a  Suspense: REACT_SUSPENSE_TYPE,\x0a\x0a  createElement: createElementWithValidation,\x0a  cloneElement: cloneElementWithValidation,\x0a  createFactory: createFactoryWithValidation,\x0a  isValidElement: isValidElement,\x0a\x0a  version: ReactVersion,\x0a\x0a  unstable_ConcurrentMode: REACT_CONCURRENT_MODE_TYPE,\x0a  unstable_Profiler: REACT_PROFILER_TYPE,\x0a\x0a  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals\x0a};\x0a\x0a// Note: some APIs are added with feature flags.\x0a// Make sure that stable builds for open source\x0a// don\x27t modify the React object to avoid deopts.\x0a// Also let\x27s not expose their names in stable builds.\x0a\x0aif (enableStableConcurrentModeAPIs) {\x0a  React.ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\x0a  React.Profiler = REACT_PROFILER_TYPE;\x0a  React.unstable_ConcurrentMode = undefined;\x0a  React.unstable_Profiler = undefined;\x0a}\x0a\x0a\x0a\x0avar React$2 = Object.freeze({\x0a\x09default: React\x0a});\x0a\x0avar React$3 = ( React$2 && React ) || React$2;\x0a\x0a// TODO: decide on the top-level export form.\x0a// This is hacky but makes it work with both Rollup and Jest.\x0avar react = React$3.default || React$3;\x0a\x0areturn react;\x0a\x0a})));\x0a'}