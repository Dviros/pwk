var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 14:56:31 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Fri, 17 May 2019 04:49:54 GMT\x0aETag: \x2211359-5890e1d14c080-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-14663/14664\x0aContent-Length: 14664\x0aKeep-Alive: timeout=5, max=56\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a(function () {\x0avar lists = (function (domGlobals) {\x0a    \x27use strict\x27;\x0a\x0a    var global = tinymce.util.Tools.resolve(\x27tinymce.PluginManager\x27);\x0a\x0a    var global$1 = tinymce.util.Tools.resolve(\x27tinymce.dom.RangeUtils\x27);\x0a\x0a    var global$2 = tinymce.util.Tools.resolve(\x27tinymce.dom.TreeWalker\x27);\x0a\x0a    var global$3 = tinymce.util.Tools.resolve(\x27tinymce.util.VK\x27);\x0a\x0a    var global$4 = tinymce.util.Tools.resolve(\x27tinymce.dom.BookmarkManager\x27);\x0a\x0a    var global$5 = tinymce.util.Tools.resolve(\x27tinymce.util.Tools\x27);\x0a\x0a    var global$6 = tinymce.util.Tools.resolve(\x27tinymce.dom.DOMUtils\x27);\x0a\x0a    var isTextNode = function (node) {\x0a      return node && node.nodeType === 3;\x0a    };\x0a    var isListNode = function (node) {\x0a      return node && /^(OL|UL|DL)$/.test(node.nodeName);\x0a    };\x0a    var isOlUlNode = function (node) {\x0a      return node && /^(OL|UL)$/.test(node.nodeName);\x0a    };\x0a    var isListItemNode = function (node) {\x0a      return node && /^(LI|DT|DD)$/.test(node.nodeName);\x0a    };\x0a    var isDlItemNode = function (node) {\x0a      return node && /^(DT|DD)$/.test(node.nodeName);\x0a    };\x0a    var isTableCellNode = function (node) {\x0a      return node && /^(TH|TD)$/.test(node.nodeName);\x0a    };\x0a    var isBr = function (node) {\x0a      return node && node.nodeName === \x27BR\x27;\x0a    };\x0a    var isFirstChild = function (node) {\x0a      return node.parentNode.firstChild === node;\x0a    };\x0a    var isLastChild = function (node) {\x0a      return node.parentNode.lastChild === node;\x0a    };\x0a    var isTextBlock = function (editor, node) {\x0a      return node && !!editor.schema.getTextBlockElements()[node.nodeName];\x0a    };\x0a    var isBlock = function (node, blockElements) {\x0a      return node && node.nodeName in blockElements;\x0a    };\x0a    var isBogusBr = function (dom, node) {\x0a      if (!isBr(node)) {\x0a        return false;\x0a      }\x0a      if (dom.isBlock(node.nextSibling) && !isBr(node.previousSibling)) {\x0a        return true;\x0a      }\x0a      return false;\x0a    };\x0a    var isEmpty = function (dom, elm, keepBookmarks) {\x0a      var empty = dom.isEmpty(elm);\x0a      if (keepBookmarks && dom.select(\x27span[data-mce-type=bookmark]\x27, elm).length \x3e 0) {\x0a        return false;\x0a      }\x0a      return empty;\x0a    };\x0a    var isChildOfBody = function (dom, elm) {\x0a      return dom.isChildOf(elm, dom.getRoot());\x0a    };\x0a    var NodeType = {\x0a      isTextNode: isTextNode,\x0a      isListNode: isListNode,\x0a      isOlUlNode: isOlUlNode,\x0a      isDlItemNode: isDlItemNode,\x0a      isListItemNode: isListItemNode,\x0a      isTableCellNode: isTableCellNode,\x0a      isBr: isBr,\x0a      isFirstChild: isFirstChild,\x0a      isLastChild: isLastChild,\x0a      isTextBlock: isTextBlock,\x0a      isBlock: isBlock,\x0a      isBogusBr: isBogusBr,\x0a      isEmpty: isEmpty,\x0a      isChildOfBody: isChildOfBody\x0a    };\x0a\x0a    var getNormalizedPoint = function (container, offset) {\x0a      if (NodeType.isTextNode(container)) {\x0a        return {\x0a          container: container,\x0a          offset: offset\x0a        };\x0a      }\x0a      var node = global$1.getNode(container, offset);\x0a      if (NodeType.isTextNode(node)) {\x0a        return {\x0a          container: node,\x0a          offset: offset \x3e= container.childNodes.length ? node.data.length : 0\x0a        };\x0a      } else if (node.previousSibling && NodeType.isTextNode(node.previousSibling)) {\x0a        return {\x0a          container: node.previousSibling,\x0a          offset: node.previousSibling.data.length\x0a        };\x0a      } else if (node.nextSibling && NodeType.isTextNode(node.nextSibling)) {\x0a        return {\x0a          container: node.nextSibling,\x0a          offset: 0\x0a        };\x0a      }\x0a      return {\x0a        container: container,\x0a        offset: offset\x0a      };\x0a    };\x0a    var normalizeRange = function (rng) {\x0a      var outRng = rng.cloneRange();\x0a      var rangeStart = getNormalizedPoint(rng.startContainer, rng.startOffset);\x0a      outRng.setStart(rangeStart.container, rangeStart.offset);\x0a      var rangeEnd = getNormalizedPoint(rng.endContainer, rng.endOffset);\x0a      outRng.setEnd(rangeEnd.container, rangeEnd.offset);\x0a      return outRng;\x0a    };\x0a    var Range = {\x0a      getNormalizedPoint: getNormalizedPoint,\x0a      normalizeRange: normalizeRange\x0a    };\x0a\x0a    var DOM = global$6.DOM;\x0a    var createBookmark = function (rng) {\x0a      var bookmark = {};\x0a      var setupEndPoint = function (start) {\x0a        var offsetNode, container, offset;\x0a        container = rng[start ? \x27startContainer\x27 : \x27endContainer\x27];\x0a        offset = rng[start ? \x27startOffset\x27 : \x27endOffset\x27];\x0a        if (container.nodeType === 1) {\x0a          offsetNode = DOM.create(\x27span\x27, { \x27data-mce-type\x27: \x27bookmark\x27 });\x0a          if (container.hasChildNodes()) {\x0a            offset = Math.min(offset, container.childNodes.length - 1);\x0a            if (start) {\x0a              container.insertBefore(offsetNode, container.childNodes[offset]);\x0a            } else {\x0a              DOM.insertAfter(offsetNode, container.childNodes[offset]);\x0a            }\x0a          } else {\x0a            container.appendChild(offsetNode);\x0a          }\x0a          container = offsetNode;\x0a          offset = 0;\x0a        }\x0a        bookmark[start ? \x27startContainer\x27 : \x27endContainer\x27] = container;\x0a        bookmark[start ? \x27startOffset\x27 : \x27endOffset\x27] = offset;\x0a      };\x0a      setupEndPoint(true);\x0a      if (!rng.collapsed) {\x0a        setupEndPoint();\x0a      }\x0a      return bookmark;\x0a    };\x0a    var resolveBookmark = function (bookmark) {\x0a      function restoreEndPoint(start) {\x0a        var container, offset, node;\x0a        var nodeIndex = function (container) {\x0a          var node = container.parentNode.firstChild, idx = 0;\x0a          while (node) {\x0a            if (node === container) {\x0a              return idx;\x0a            }\x0a            if (node.nodeType !== 1 || node.getAttribute(\x27data-mce-type\x27) !== \x27bookmark\x27) {\x0a              idx++;\x0a            }\x0a            node = node.nextSibling;\x0a          }\x0a          return -1;\x0a        };\x0a        container = node = bookmark[start ? \x27startContainer\x27 : \x27endContainer\x27];\x0a        offset = bookmark[start ? \x27startOffset\x27 : \x27endOffset\x27];\x0a        if (!container) {\x0a          return;\x0a        }\x0a        if (container.nodeType === 1) {\x0a          offset = nodeIndex(container);\x0a          container = container.parentNode;\x0a          DOM.remove(node);\x0a          if (!container.hasChildNodes() && DOM.isBlock(container)) {\x0a            container.appendChild(DOM.create(\x27br\x27));\x0a          }\x0a        }\x0a        bookmark[start ? \x27startContainer\x27 : \x27endContainer\x27] = container;\x0a        bookmark[start ? \x27startOffset\x27 : \x27endOffset\x27] = offset;\x0a      }\x0a      restoreEndPoint(true);\x0a      restoreEndPoint();\x0a      var rng = DOM.createRng();\x0a      rng.setStart(bookmark.startContainer, bookmark.startOffset);\x0a      if (bookmark.endContainer) {\x0a        rng.setEnd(bookmark.endContainer, bookmark.endOffset);\x0a      }\x0a      return Range.normalizeRange(rng);\x0a    };\x0a    var Bookmark = {\x0a      createBookmark: createBookmark,\x0a      resolveBookmark: resolveBookmark\x0a    };\x0a\x0a    var constant = function (value) {\x0a      return function () {\x0a        return value;\x0a      };\x0a    };\x0a    var not = function (f) {\x0a      return function () {\x0a        var args = [];\x0a        for (var _i = 0; _i \x3c arguments.length; _i++) {\x0a          args[_i] = arguments[_i];\x0a        }\x0a        return !f.apply(null, args);\x0a      };\x0a    };\x0a    var never = constant(false);\x0a    var always = constant(true);\x0a\x0a    var never$1 = never;\x0a    var always$1 = always;\x0a    var none = function () {\x0a      return NONE;\x0a    };\x0a    var NONE = function () {\x0a      var eq = function (o) {\x0a        return o.isNone();\x0a      };\x0a      var call = function (thunk) {\x0a        return thunk();\x0a      };\x0a      var id = function (n) {\x0a        return n;\x0a      };\x0a      var noop = function () {\x0a      };\x0a      var nul = function () {\x0a        return null;\x0a      };\x0a      var undef = function () {\x0a        return undefined;\x0a      };\x0a      var me = {\x0a        fold: function (n, s) {\x0a          return n();\x0a        },\x0a        is: never$1,\x0a        isSome: never$1,\x0a        isNone: always$1,\x0a        getOr: id,\x0a        getOrThunk: call,\x0a        getOrDie: function (msg) {\x0a          throw new Error(msg || \x27error: getOrDie called on none.\x27);\x0a        },\x0a        getOrNull: nul,\x0a        getOrUndefined: undef,\x0a        or: id,\x0a        orThunk: call,\x0a        map: none,\x0a        ap: none,\x0a        each: noop,\x0a        bind: none,\x0a        flatten: none,\x0a        exists: never$1,\x0a        forall: always$1,\x0a        filter: none,\x0a        equals: eq,\x0a        equals_: eq,\x0a        toArray: function () {\x0a          return [];\x0a        },\x0a        toString: constant(\x27none()\x27)\x0a      };\x0a      if (Object.freeze)\x0a        Object.freeze(me);\x0a      return me;\x0a    }();\x0a    var some = function (a) {\x0a      var constant_a = function () {\x0a        return a;\x0a      };\x0a      var self = function () {\x0a        return me;\x0a      };\x0a      var map = function (f) {\x0a        return some(f(a));\x0a      };\x0a      var bind = function (f) {\x0a        return f(a);\x0a      };\x0a      var me = {\x0a        fold: function (n, s) {\x0a          return s(a);\x0a        },\x0a        is: function (v) {\x0a          return a === v;\x0a        },\x0a        isSome: always$1,\x0a        isNone: never$1,\x0a        getOr: constant_a,\x0a        getOrThunk: constant_a,\x0a        getOrDie: constant_a,\x0a        getOrNull: constant_a,\x0a        getOrUndefined: constant_a,\x0a        or: self,\x0a        orThunk: self,\x0a        map: map,\x0a        ap: function (optfab) {\x0a          return optfab.fold(none, function (fab) {\x0a            return some(fab(a));\x0a          });\x0a        },\x0a        each: function (f) {\x0a          f(a);\x0a        },\x0a        bind: bind,\x0a        flatten: constant_a,\x0a        exists: bind,\x0a        forall: bind,\x0a        filter: function (f) {\x0a          return f(a) ? me : NONE;\x0a        },\x0a        equals: function (o) {\x0a          return o.is(a);\x0a        },\x0a        equals_: function (o, elementEq) {\x0a          return o.fold(never$1, function (b) {\x0a            return elementEq(a, b);\x0a          });\x0a        },\x0a        toArray: function () {\x0a          return [a];\x0a        },\x0a        toString: function () {\x0a          return \x27some(\x27 + a + \x27)\x27;\x0a        }\x0a      };\x0a      return me;\x0a    };\x0a    var from = function (value) {\x0a      return value === null || value === undefined ? NONE : some(value);\x0a    };\x0a    var Option = {\x0a      some: some,\x0a      none: none,\x0a      from: from\x0a    };\x0a\x0a    var typeOf = function (x) {\x0a      if (x === null)\x0a        return \x27null\x27;\x0a      var t = typeof x;\x0a      if (t === \x27object\x27 && Array.prototype.isPrototypeOf(x))\x0a        return \x27array\x27;\x0a      if (t === \x27object\x27 && String.prototype.isPrototypeOf(x))\x0a        return \x27string\x27;\x0a      return t;\x0a    };\x0a    var isType = function (type) {\x0a      return function (value) {\x0a        return typeOf(value) === type;\x0a      };\x0a    };\x0a    var isString = isType(\x27string\x27);\x0a    var isBoolean = isType(\x27boolean\x27);\x0a    var isFunction = isType(\x27function\x27);\x0a    var isNumber = isType(\x27number\x27);\x0a\x0a    var map = function (xs, f) {\x0a      var len = xs.length;\x0a      var r = new Array(len);\x0a      for (var i = 0; i \x3c len; i++) {\x0a        var x = xs[i];\x0a        r[i] = f(x, i, xs);\x0a      }\x0a      return r;\x0a    };\x0a    var each = function (xs, f) {\x0a      for (var i = 0, len = xs.length; i \x3c len; i++) {\x0a        var x = xs[i];\x0a        f(x, i, xs);\x0a      }\x0a    };\x0a    var filter = function (xs, pred) {\x0a      var r = [];\x0a      for (var i = 0, len = xs.length; i \x3c len; i++) {\x0a        var x = xs[i];\x0a        if (pred(x, i, xs)) {\x0a          r.push(x);\x0a        }\x0a      }\x0a      return r;\x0a    };\x0a    var groupBy = function (xs, f) {\x0a      if (xs.length === 0) {\x0a        return [];\x0a      } else {\x0a        var wasType = f(xs[0]);\x0a        var r = [];\x0a        var group = [];\x0a        for (var i = 0, len = xs.length; i \x3c len; i++) {\x0a          var x = xs[i];\x0a          var type = f(x);\x0a          if (type !== wasType) {\x0a            r.push(group);\x0a            group = [];\x0a          }\x0a          wasType = type;\x0a          group.push(x);\x0a        }\x0a        if (group.length !== 0) {\x0a          r.push(group);\x0a        }\x0a        return r;\x0a      }\x0a    };\x0a    var foldl = function (xs, f, acc) {\x0a      each(xs, function (x) {\x0a        acc = f(acc, x);\x0a      });\x0a      return acc;\x0a    };\x0a    var find = function (xs, pred) {\x0a      for (var i = 0, len = xs.length; i \x3c len; i++) {\x0a        var x = xs[i];\x0a        if (pred(x, i, xs)) {\x0a          return Option.some(x);\x0a        }\x0a      }\x0a      return Option.none();\x0a    };\x0a    var push = Array.prototype.push;\x0a    var flatten = function (xs) {\x0a      var r = [];\x0a      for (var i = 0, len = xs.length; i \x3c len; ++i) {\x0a        if (!Array.prototype.isPrototypeOf(xs[i]))\x0a          throw new Error(\x27Arr.flatten item \x27 + i + \x27 was not an array, input: \x27 + xs);\x0a        push.apply(r, xs[i]);\x0a      }\x0a      return r;\x0a    };\x0a    var bind = function (xs, f) {\x0a      var output = map(xs, f);\x0a      return flatten(output);\x0a    };\x0a    var slice = Array.prototype.slice;\x0a    var reverse = function (xs) {\x0a      var r = slice.call(xs, 0);\x0a      r.reverse();\x0a      return r;\x0a    };\x0a    var head = function (xs) {\x0a      return xs.length === 0 ? Option.none() : Option.some(xs[0]);\x0a    };\x0a    var last = function (xs) {\x0a      return xs.length === 0 ? Option.none() : Option.some(xs[xs.length - 1]);\x0a    };\x0a    var from$1 = isFunction(Array.from) ? Array.from : function (x) {\x0a      return slice.call(x);\x0a    };\x0a\x0a    var Global = typeof domGlobals.window !== \x27undefined\x27 ? domGlobals.window : Function(\x27return this;\x27)();\x0a\x0a    var path = function (parts, scope) {\x0a      var o = scope !== undefined && scope !== null ? scope : Global;\x0a      for (var i = 0; i \x3c parts.length && o !== undefined && o !== null; ++i)\x0a        o = o[parts[i]];\x0a      return o;\x0a    };\x0a    var resolve = function (p, scope) {\x0a      var parts = p.split(\x27.\x27);\x0a      return path(parts, scope);\x0a    };\x0a\x0a    var unsafe = function (name, scope) {\x0a      return resolve(name, scope);\x0a    };\x0a    var getOrDie = function (name, scope) {\x0a      var actual = unsafe(name, scope);\x0a      if (actual === undefined || actual === null)\x0a        throw name + \x27 not available on this browser\x27;\x0a      return actual;\x0a    };\x0a    var Global$1 = { getOrDie: getOrDie };\x0a\x0a    var htmlElement = function (scope) {\x0a      return Global$1.getOrDie(\x27HTMLElement\x27, scope);\x0a    };\x0a    var isPrototypeOf = function (x) {\x0a      var scope = resolve(\x27ownerDocument.defaultView\x27, x);\x0a      return htmlElement(scope).prototype.isPrototypeOf(x);\x0a    };\x0a    var HTMLElement = { isPrototypeOf: isPrototypeOf };\x0a\x0a    var global$7 = tinymce.util.Tools.resolve(\x27tinymce.dom.DomQuery\x27);\x0a\x0a    var getParentList = function (editor) {\x0a      var selectionStart = editor.selection.getStart(true);\x0a      return editor.dom.getParent(selectionStart, \x27OL,UL,DL\x27, getClosestListRootElm(editor, selectionStart));\x0a    };\x0a    var isParentListSelected = function (parentList, selectedBlocks) {\x0a      return parentList && selectedBlocks.length === 1 && selectedBlocks[0] === parentList;\x0a    };\x0a    var findSubLists = function (parentList) {\x0a      return global$5.grep(parentList.querySelectorAll(\x27ol,ul,dl\x27), function (elm) {\x0a        return NodeType.isListNode(elm);\x0a      });\x0a    };\x0a    var getSelectedSubLists = function (editor) {\x0a      var parentList = getParentList(editor);\x0a      var selectedBlocks = editor.selection.getSelectedBlocks();\x0a      if (isParentListSelected(parentList, selectedBlocks)) {\x0a        return findSubLists(parentList);\x0a      } else {\x0a        return global$5.grep(selectedBlocks, function (elm) {\x0a          return NodeType.isListNode(elm) && parentList !== elm;\x0a        });\x0a      }\x0a    };\x0a    var findParentListItemsNodes = function (editor, elms) {\x0a      var listItemsElms = global$5.map(elms, function (elm) {\x0a        var parentLi = editor.dom.getParent(elm, \x27li,dd,dt\x27, getClosestListRootElm(editor, elm));\x0a        return parentLi ? parentLi : elm;\x0a      });\x0a      return global$7.unique(listItemsElms);\x0a    };\x0a    var getSelectedListItems = function (editor) {\x0a      var selectedBlocks = editor.selection.getSelectedBlocks();\x0a      return global$5.grep(findParentListItemsNodes(editor, selectedBlocks), function (block) {\x0a        return NodeType.isListItemNode(block);\x0a      });\x0a    };\x0a    var getSelectedDlItems = function (editor) {\x0a      return filter(getSelectedListItems(editor), NodeType.isDlItemNode);\x0a    };\x0a    var getClosestListRootElm = function (editor, elm) {\x0a      var parentTableCell = editor.dom.getParents(elm, \x27TD,TH\x27);\x0a      var root = parentTableCell.length \x3e 0 ? parentTableCell[0] : editor.getBody();\x0a      return root;\x0a    };\x0a    var findLastParentListNode = function (editor, elm) {\x0a      var parentLists = editor.dom.getParents(elm, \x27ol,ul\x27, getClosestListRootElm(editor, elm));\x0a      return last(parentLists);\x0a    };\x0a    var getSelectedLists = function (editor) {\x0a      var firstList = findLastParentListNode(editor, editor.selection.getStart());\x0a      var subsequentLists = filter(editor.selection.getSelectedBlocks(), NodeType.isOlUlNode);\x0a      return firstList.toArray().concat(subsequentLists);\x0a    };\x0a    var getSelectedListRoots = function (editor) {\x0a      var selectedLists = getSelectedLists(editor);\x0a      return getUniqueListRoots(editor, selectedLists);\x0a    };\x0a    var getUniqueListRoots = function (editor, lists) {\x0a      var listRoots = map(lists, function (list) {\x0a        return findLastParentListNode(editor, list).getOr(list);\x0a      });\x0a      return global$7.unique(listRoots);\x0a    };\x0a    var isList = function (editor) {\x0a      var list = getParentList(editor);\x0a      return HTMLElement.isPrototypeOf(list);\x0a    };\x0a    var Selection = {\x0a      isList: isList,\x0a      getParentList: getParentList,\x0a      getSelectedSubLists: getSelectedSubLists,\x0a      getSelectedListItems: getSelectedListItems,\x0a      getClosestListRootElm: getClosestListRootElm,\x0a      getSelectedDlItems: getSelectedDlItems,\x0a      getSelectedListRoots: getSelectedListRoots\x0a    };\x0a\x0a    var fromHtml = function (html, scope) {\x0a      var doc = scope || domGlobals.document;\x0a      var div = doc.createElement(\x27div\x27);\x0a      div.innerHTML = html;\x0a      if (!div.hasChildNodes() || div.childNodes.length \x3e 1) {\x0a        domGlobals.console.error(\x27HTML does not have a single root node\x27, html);\x0a        throw new Error(\x27HTML must have a single root node\x27);\x0a      }\x0a      return fromDom(div.childNodes[0]);\x0a    };\x0a    var fromTag = function (tag, scope) {\x0a      var doc = scope || domGlobals.document;\x0a      var node = doc.createElement(tag);\x0a      return fromDom(node);\x0a    };\x0a    var fromText = function (text, scope) {\x0a      var doc = scope || domGlobals.document;\x0a      var node = doc.createTextNode(text);\x0a      return fromDom(node);\x0a    };\x0a    var fromDom = function (node) {\x0a      if (node === null || node === undefined) {\x0a        throw new Error(\x27Node cannot be null or undefined\x27);\x0a      }\x0a      return { dom: constant(node) };\x0a    };\x0a    var fromPoint = function (docElm, x, y) {\x0a      var doc = docElm.dom();\x0a      return Option.from(doc.elementFromPoint(x, y)).map(fromDom);\x0a    };\x0a    var Element = {\x0a      fromHtml: fromHtml,\x0a      fromTag: fromTag,\x0a      fromText: fromText,\x0a      fromDom: fromDom,\x0a      fromPoint: fromPoint\x0a    };\x0a\x0a    var liftN = function (arr, f) {\x0a      var r = [];\x0a      for (var i = 0; i \x3c arr.length; i++) {\x0a        var x = arr[i];\x0a        if (x.isSome()) {\x0a          r.push(x.getOrDie());\x0a        } else {\x0a          return Option.none();\x0a        }\x0a      }\x0a      return Option.some(f.apply(null, r));\x0a    };\x0a\x0a    var fromElements = function (elements, scope) {\x0a      var doc = scope || domGlobals.document;\x0a      var fragment = doc.createDocumentFragment();\x0a      each(elements, function (element) {\x0a        fragment.appendChild(element.dom());\x0a      });\x0a      return Element.fromDom(fragment);\x0a    };\x0a\x0a    var Immutable = function () {\x0a      var fields = [];\x0a      for (var _i = 0; _i \x3c arguments.length; _i++) {\x0a        fields[_i] = arguments[_i];\x0a      }\x0a      return function () {\x0a        var values = [];\x0a        for (var _i = 0; _i \x3c arguments.length; _i++) {\x0a          values[_i] = arguments[_i];\x0a        }\x0a        if (fields.length !== values.length) {\x0a          throw new Error(\x27Wrong number of arguments to struct. Expected \x22[\x27 + fields.length + \x27]\x22, got \x27 + values.length + \x27 arguments\x27);\x0a        }\x0a        var struct = {};\x0a        each(fields, function (name, i) {\x0a          struct[name] = constant(values[i]);\x0a        });\x0a        return struct;\x0a      };\x0a    };\x0a\x0a    var keys = Object.keys;\x0a    var each$1 = function (obj, f) {\x0a      var props = keys(obj);\x0a      for (var k = 0, len = props.length; k \x3c len; k++) {\x0a        var i = props[k];\x0a        var x = obj[i];\x0a        f(x, i, obj);\x0a      }\x0a    };\x0a\x0a    var node = function () {\x0a      var f = Global$1.getOrDie(\x27Node\x27);\x0a      return f;\x0a    };\x0a    var compareDocumentPosition = function (a, b, match) {\x0a      return (a.compareDocumentPosition(b) & match) !== 0;\x0a    };\x0a    var documentPositionPreceding = function (a, b) {\x0a      return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_PRECEDING);\x0a    };\x0a    var documentPositionContainedBy = function (a, b) {\x0a      return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_CONTAINED_BY);\x0a    };\x0a    var Node = {\x0a      documentPositionPreceding: documentPositionPreceding,\x0a      documentPositionContainedBy: documentPositionContainedBy\x0a    };\x0a\x0a    var cached = function (f) {\x0a      var called = false;\x0a      var r;\x0a      return function () {\x0a        var args = [];\x0a        for (var _i = 0; _i \x3c arguments.length; _i++) {\x0a          args[_i] = arguments[_i];\x0a        }\x0a        if (!called) {\x0a          called = true;\x0a          r = f.apply(null, args);\x0a        }\x0a        return r;\x0a      };\x0a    };\x0a\x0a    var firstMatch = function (regexes, s) {\x0a      for (var i = 0; i \x3c regexes.length; i++) {\x0a        var x = regexes[i];\x0a        if (x.test(s))\x0a          return x;\x0a      }\x0a      return undefined;\x0a    };\x0a    var find$1 = function (regexes, agent) {\x0a      var r = firstMatch(regexes, agent);\x0a      if (!r)\x0a        return {\x0a          major: 0,\x0a          minor: 0\x0a        };\x0a      var group = function (i) {\x0a        return Number(agent.replace(r, \x27$\x27 + i));\x0a      };\x0a      return nu(group(1), group(2));\x0a    };\x0a    var detect = function (versionRegexes, agent) {\x0a      var cleanedAgent = String(agent).toLowerCase();\x0a      if (versionRegexes.length === 0)\x0a        return unknown();\x0a      return find$1(versionRegexes, cleanedAgent);\x0a    };\x0a    var unknown = function () {\x0a      return nu(0, 0);\x0a    };\x0a    var nu = function (major, minor) {\x0a      return {\x0a        major: major,\x0a        minor: minor\x0a      };\x0a    };\x0a    var Version = {\x0a      nu: nu,\x0a      detect: detect,\x0a      unknown: unknown\x0a    };\x0a\x0a    var edge = \x27Edge\x27;\x0a    var chrome = \x27Chrome\x27;\x0a    var ie = \x27IE\x27;\x0a    var opera = \x27Opera\x27;\x0a    var firefox = \x27Firefox\x27;\x0a    var safari = \x27Safari\x27;\x0a    var isBrowser = function (name, current) {\x0a      return function () {\x0a        return current === name;\x0a      };\x0a    };\x0a    var unknown$1 = function () {\x0a      return nu$1({\x0a        current: undefined,\x0a        version: Version.unknown()\x0a      });\x0a    };\x0a    var nu$1 = function (info) {\x0a      var current = info.current;\x0a      var version = info.version;\x0a      return {\x0a        current: current,\x0a        version: version,\x0a        isEdge: isBrowser(edge, current),\x0a        isChrome: isBrowser(chrome, current),\x0a        isIE: isBrowser(ie, current),\x0a        isOpera: isBrowser(opera, current),\x0a        isFirefox: isBrowser(firefox, current),\x0a        isSafari: isBrowser(safari, current)\x0a      };\x0a    };\x0a    var Browser = {\x0a      unknown: unknown$1,\x0a      nu: nu$1,\x0a      edge: constant(edge),\x0a      chrome: constant(chrome),\x0a      ie: constant(ie),\x0a      opera: constant(opera),\x0a      firefox: constant(firefox),\x0a      safari: constant(safari)\x0a    };\x0a\x0a    var windows = \x27Windows\x27;\x0a    var ios = \x27iOS\x27;\x0a    var android = \x27Android\x27;\x0a    var linux = \x27Linux\x27;\x0a    var osx = \x27OSX\x27;\x0a    var solaris = \x27Solaris\x27;\x0a    var freebsd = \x27FreeBSD\x27;\x0a    var isOS = function (name, current) {\x0a      return function () {\x0a        return current === name;\x0a      };\x0a    };\x0a    var unknown$2 = function () {\x0a      return nu$2({\x0a        current: undefined,\x0a        version: Version.unknown()\x0a      });\x0a    };\x0a    var nu$2 = function (info) {\x0a      var current = info.current;\x0a      var version = info.version;\x0a      return {\x0a        current: current,\x0a        version: version,\x0a        isWindows: isOS(windows, current),\x0a        isiOS: isOS(ios, current),\x0a        isAndroid: isOS(android, current),\x0a        isOSX: isOS(osx, current),\x0a        isLinux: isOS(linux, current),\x0a        isSolaris: isOS(solaris, current),\x0a        isFreeBSD: isOS(freebsd, current)\x0a      };\x0a    };\x0a    var OperatingSystem = {\x0a      unknown: unknown$2,\x0a      nu: nu$2,\x0a      windows: constant(windows),\x0a      ios: constant(ios),\x0a      android: constant(android),\x0a      linux: constant(linux),\x0a      osx: constant(osx),\x0a      solaris: constant(solaris),\x0a      freebsd: constant(freebsd)\x0a    };\x0a\x0a    var DeviceType = function (os, browser, userAgent) {\x0a      var isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\x0a      var isiPhone = os.isiOS() && !isiPad;\x0a      var isAndroid3 = os.isAndroid() && os.version.major === 3;\x0a      var isAndroid4 = os.isAndroid() && os.version.major === 4;\x0a      var isTablet = isiPad || isAndroid3 || isAndroid4 && /mobile/i.test(userAgent) === true;\x0a      var isTouch = os.isiOS() || os.isAndroid();\x0a      var isPhone = isTouch && !isTablet;\x0a      var iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\x0a      return {\x0a        isiPad: constant(isiPad),\x0a        isiPhone: constant(isiPhone),\x0a        isTablet: constant(isTablet),\x0a        isPhone: constant(isPhone),\x0a        isTouch: constant(isTouch),\x0a        isAndroid: os.isAndroid,\x0a        isiOS: os.isiOS,\x0a        isWebView: constant(iOSwebview)\x0a      };\x0a    };\x0a\x0a    var detect$1 = function (candidates, userAgent) {\x0a      var agent = String(userAgent).toLowerCase();\x0a      return find(candidates, function (candidate) {\x0a        return candidate.search(agent);\x0a      });\x0a    };\x0a    var detectBrowser = function (browsers, userAgent) {\x0a      return detect$1(browsers, userAgent).map(function (browser) {\x0a        var version = Version.detect(browser.versionRegexes, userAgent);\x0a        return {\x0a          current: browser.name,\x0a          version: version\x0a        };\x0a      });\x0a    };\x0a    var detectOs = function (oses, userAgent) {\x0a      return detect$1(oses, userAgent).map(function (os) {\x0a        var version = Version.detect(os.versionRegexes, userAgent);\x0a        return {\x0a          current: os.name,\x0a          version: version\x0a        };\x0a      });\x0a    };\x0a    var UaString = {\x0a      detectBrowser: detectBrowser,\x0a      detectOs: detectOs\x0a    };\x0a\x0a    var contains = function (str, substr) {\x0a      return str.indexOf(substr) !== -1;\x0a    };\x0a\x0a    var normalVersionRegex = /.*?version\x5c/\x5c ?([0-9]+)\x5c.([0-9]+).*/;\x0a    var checkContains = function (target) {\x0a      return function (uastring) {\x0a        return contains(uastring, target);\x0a      };\x0a    };\x0a    var browsers = [\x0a      {\x0a        name: \x27Edge\x27,\x0a        versionRegexes: [/.*?edge\x5c/ ?([0-9]+)\x5c.([0-9]+)$/],\x0a        search: function (uastring) {\x0a          var monstrosity = contains(uastring, \x27edge/\x27) && contains(uastring, \x27chrome\x27) && contains(uastring, \x27safari\x27) && contains(uastring, \x27applewebkit\x27);\x0a          return monstrosity;\x0a        }\x0a      },\x0a      {\x0a        name: \x27Chrome\x27,\x0a        versionRegexes: [\x0a          /.*?chrome\x5c/([0-9]+)\x5c.([0-9]+).*/,\x0a          normalVersionRegex\x0a        ],\x0a        search: function (uastring) {\x0a          return contains(uastring, \x27chrome\x27) && !contains(uastring, \x27chromeframe\x27);\x0a        }\x0a      },\x0a      {\x0a        name: \x27IE\x27,\x0a        versionRegexes: [\x0a          /.*?msie\x5c ?([0-9]+)\x5c.([0-9]+).*/,\x0a          /.*?rv:([0-9]+)\x5c.([0-9]+).*/\x0a        ],\x0a        search: function (uastring) {\x0a          return contains(uastring, \x27msie\x27) || contains(uastring, \x27trident\x27);\x0a        }\x0a      },\x0a      {\x0a        name: \x27Opera\x27,\x0a        versionRegexes: [\x0a          normalVersionRegex,\x0a          /.*?opera\x5c/([0-9]+)\x5c.([0-9]+).*/\x0a        ],\x0a        search: checkContains(\x27opera\x27)\x0a      },\x0a      {\x0a        name: \x27Firefox\x27,\x0a        versionRegexes: [/.*?firefox\x5c/\x5c ?([0-9]+)\x5c.([0-9]+).*/],\x0a        search: checkContains(\x27firefox\x27)\x0a      },\x0a      {\x0a        name: \x27Safari\x27,\x0a        versionRegexes: [\x0a          normalVersionRegex,\x0a          /.*?cpu os ([0-9]+)_([0-9]+).*/\x0a        ],\x0a        search: function (uastring) {\x0a          return (contains(uastring, \x27safari\x27) || contains(uastring, \x27mobile/\x27)) && contains(uastring, \x27applewebkit\x27);\x0a        }\x0a      }\x0a    ];\x0a    var oses = [\x0a      {\x0a        name: \x27Windows\x27,\x0a        search: checkContains(\x27win\x27),\x0a        versionRegexes: [/.*?windows\x5c nt\x5c ?([0-9]+)\x5c.([0-9]+).*/]\x0a      },\x0a      {\x0a        name: \x27iOS\x27,\x0a        search: function (uastring) {\x0a          return contains(uastring, \x27iphone\x27) || contains(uastring, \x27ipad\x27);\x0a        },\x0a        versionRegexes: [\x0a          /.*?version\x5c/\x5c ?([0-9]+)\x5c.([0-9]+).*/,\x0a          /.*cpu os ([0-9]+)_([0-9]+).*/,\x0a          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\x0a        ]\x0a      },\x0a      {\x0a        name: \x27Android\x27,\x0a        search: checkContains(\x27android\x27),\x0a        versionRegexes: [/.*?android\x5c ?([0-9]+)\x5c.([0-9]+).*/]\x0a      },\x0a      {\x0a        name: \x27OSX\x27,\x0a        search: checkContains(\x27os x\x27),\x0a        versionRegexes: [/.*?os\x5c x\x5c ?([0-9]+)_([0-9]+).*/]\x0a      },\x0a      {\x0a        name: \x27Linux\x27,\x0a        search: checkContains(\x27linux\x27),\x0a        versionRegexes: []\x0a      },\x0a      {\x0a        name: \x27Solaris\x27,\x0a        search: checkContains(\x27sunos\x27),\x0a        versionRegexes: []\x0a      },\x0a      {\x0a        name: \x27FreeBSD\x27,\x0a        search: checkContains(\x27freebsd\x27),\x0a        versionRegexes: []\x0a      }\x0a    ];\x0a    var PlatformInfo = {\x0a      browsers: constant(browsers),\x0a      oses: constant(oses)\x0a    };\x0a\x0a    var detect$2 = function (userAgent) {\x0a      var browsers = PlatformInfo.browsers();\x0a      var oses = PlatformInfo.oses();\x0a      var browser = UaString.detectBrowser(browsers, userAgent).fold(Browser.unknown, Browser.nu);\x0a      var os = UaString.detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\x0a      var deviceType = DeviceType(os, browser, userAgent);\x0a      return {\x0a        browser: browser,\x0a        os: os,\x0a        deviceType: deviceType\x0a      };\x0a    };\x0a    var PlatformDetection = { detect: detect$2 };\x0a\x0a    var detect$3 = cached(function () {\x0a      var userAgent = domGlobals.navigator.userAgent;\x0a      return PlatformDetection.detect(userAgent);\x0a    });\x0a    var PlatformDetection$1 = { detect: detect$3 };\x0a\x0a    var ATTRIBUTE = domGlobals.Node.ATTRIBUTE_NODE;\x0a    var CDATA_SECTION = domGlobals.Node.CDATA_SECTION_NODE;\x0a    var COMMENT = domGlobals.Node.COMMENT_NODE;\x0a    var DOCUMENT = domGlobals.Node.DOCUMENT_NODE;\x0a    var DOCUMENT_TYPE = domGlobals.Node.DOCUMENT_TYPE_NODE;\x0a    var DOCUMENT_FRAGMENT = domGlobals.Node.DOCUMENT_FRAGMENT_NODE;\x0a    var ELEMENT = domGlobals.Node.ELEMENT_NODE;\x0a    var TEXT = domGlobals.Node.TEXT_NODE;\x0a    var PROCESSING_INSTRUCTION = domGlobals.Node.PROCESSING_INSTRUCTION_NODE;\x0a    var ENTITY_REFERENCE = domGlobals.Node.ENTITY_REFERENCE_NODE;\x0a    var ENTITY = domGlobals.Node.ENTITY_NODE;\x0a    var NOTATION = domGlobals.Node.NOTATION_NODE;\x0a\x0a    var ELEMENT$1 = ELEMENT;\x0a    var is = function (element, selector) {\x0a      var elem = element.dom();\x0a      if (elem.nodeType !== ELEMENT$1) {\x0a        return false;\x0a      } else if (elem.matches !== undefined) {\x0a        return elem.matches(selector);\x0a      } else if (elem.msMatchesSelector !== undefined) {\x0a        return elem.msMatchesSelector(selector);\x0a      } else if (elem.webkitMatchesSelector !== undefined) {\x0a        return elem.webkitMatchesSelector(selector);\x0a      } else if (elem.mozMatchesSelector !== undefined) {\x0a        return elem.mozMatchesSelector(selector);\x0a      } else {\x0a        throw new Error(\x27Browser lacks native selectors\x27);\x0a      }\x0a    };\x0a\x0a    var eq = function (e1, e2) {\x0a      return e1.dom() === e2.dom();\x0a    };\x0a    var regularContains = function (e1, e2) {\x0a      var d1 = e1.dom();\x0a      var d2 = e2.dom();\x0a      return d1 === d2 ? false : d1.contains(d2);\x0a    };\x0a    var ieContains = function (e1, e2) {\x0a      return Node.documentPositionContainedBy(e1.dom(), e2.dom());\x0a    };\x0a    var browser = PlatformDetection$1.detect().browser;\x0a    var contains$1 = browser.isIE() ? ieContains : regularContains;\x0a    var is$1 = is;\x0a\x0a    var parent = function (element) {\x0a      var dom = element.dom();\x0a      return Option.from(dom.parentNode).map(Element.fromDom);\x0a    };\x0a    var children = function (element) {\x0a      var dom = element.dom();\x0a      return map(dom.childNodes, Element.fromDom);\x0a    };\x0a    var child = function (element, index) {\x0a      var cs = element.dom().childNodes;\x0a      return Option.from(cs[index]).map(Element.fromDom);\x0a    };\x0a    var firstChild = function (element) {\x0a      return child(element, 0);\x0a    };\x0a    var lastChild = function (element) {\x0a      return child(element, element.dom().childNodes.length - 1);\x0a    };\x0a    var spot = Immutable(\x27element\x27, \x27offset\x27);\x0a\x0a    var before = function (marker, element) {\x0a      var parent$1 = parent(marker);\x0a      parent$1.each(function (v) {\x0a        v.dom().insertBefore(element.dom(), marker.dom());\x0a      });\x0a    };\x0a    var append = function (parent, element) {\x0a      parent.dom().appendChild(element.dom());\x0a    };\x0a\x0a    var before$1 = function (marker, elements) {\x0a      each(elements, function (x) {\x0a        before(marker, x);\x0a      });\x0a    };\x0a    var append$1 = function (parent, elements) {\x0a      each(elements, function (x) {\x0a        append(parent, x);\x0a      });\x0a    };\x0a\x0a    var remove = function (element) {\x0a      var dom = element.dom();\x0a      if (dom.parentNode !== null) {\x0a        dom.parentNode.removeChild(dom);\x0a      }\x0a    };\x0a\x0a    var name = function (element) {\x0a      var r = element.dom().nodeName;\x0a      return r.toLowerCase();\x0a    };\x0a\x0a    var rawSet = function (dom, key, value) {\x0a      if (isString(value) || isBoolean(value) || isNumber(value)) {\x0a        dom.setAttribute(key, value + \x27\x27);\x0a      } else {\x0a        domGlobals.console.error(\x27Invalid call to Attr.set. Key \x27, key, \x27:: Value \x27, value, \x27:: Element \x27, dom);\x0a        throw new Error(\x27Attribute value was not simple\x27);\x0a      }\x0a    };\x0a    var setAll = function (element, attrs) {\x0a      var dom = element.dom();\x0a      each$1(attrs, function (v, k) {\x0a        rawSet(dom, k, v);\x0a      });\x0a    };\x0a    var clone = function (element) {\x0a      return foldl(element.dom().attributes, function (acc, attr) {\x0a        acc[attr.name] = attr.value;\x0a        return acc;\x0a      }, {});\x0a    };\x0a\x0a    var isSupported = function (dom) {\x0a      return dom.style !== undefined;\x0a    };\x0a\x0a    var internalSet = function (dom, property, value) {\x0a      if (!isString(value)) {\x0a        domGlobals.console.error(\x27Invalid call to CSS.set. Property \x27, property, \x27:: Value \x27, value, \x27:: Element \x27, dom);\x0a        throw new Error(\x27CSS value must be a string: \x27 + value);\x0a      }\x0a      if (isSupported(dom)) {\x0a        dom.style.setProperty(property, value);\x0a      }\x0a    };\x0a    var set = function (element, property, value) {\x0a      var dom = element.dom();\x0a      internalSet(dom, property, value);\x0a    };\x0a\x0a    var clone$1 = function (original, isDeep) {\x0a      return Element.fromDom(original.dom().cloneNode(isDeep));\x0a    };\x0a    var deep = function (original) {\x0a      return clone$1(original, true);\x0a    };\x0a    var shallowAs = function (original, tag) {\x0a      var nu = Element.fromTag(tag);\x0a      var attributes = clone(original);\x0a      setAll(nu, attributes);\x0a      return nu;\x0a    };\x0a    var mutate = function (original, tag) {\x0a      var nu = shallowAs(original, tag);\x0a      before(original, nu);\x0a      var children$1 = children(original);\x0a      append$1(nu, children$1);\x0a      remove(original);\x0a      return nu;\x0a    };\x0a\x0a    var joinSegment = function (parent, child) {\x0a      append(parent.item, child.list);\x0a    };\x0a    var joinSegments = function (segments) {\x0a      for (var i = 1; i \x3c segments.length; i++) {\x0a        joinSegment(segments[i - 1], segments[i]);\x0a      }\x0a    };\x0a    var appendSegments = function (head$1, tail) {\x0a      liftN([\x0a        last(head$1),\x0a        head(tail)\x0a      ], joinSegment);\x0a    };\x0a    var createSegment = function (scope, listType) {\x0a      var segment = {\x0a        list: Element.fromTag(listType, scope),\x0a        item: Element.fromTag(\x27li\x27, scope)\x0a      };\x0a      append(segment.list, segment.item);\x0a      return segment;\x0a    };\x0a    var createSegments = function (scope, entry, size) {\x0a      var segments = [];\x0a      for (var i = 0; i \x3c size; i++) {\x0a        segments.push(createSegment(scope, entry.listType));\x0a      }\x0a      return segments;\x0a    };\x0a    var populateSegments = function (segments, entry) {\x0a      for (var i = 0; i \x3c segments.length - 1; i++) {\x0a        set(segments[i].item, \x27list-style-type\x27, \x27none\x27);\x0a      }\x0a      last(segments).each(function (segment) {\x0a        setAll(segment.list, entry.listAttributes);\x0a        setAll(segment.item, entry.itemAttributes);\x0a        append$1(segment.item, entry.content);\x0a      });\x0a    };\x0a    var normalizeSegment = function (segment, entry) {\x0a      if (name(segment.list) !== entry.listType) {\x0a        segment.list = mutate(segment.list, entry.listType);\x0a      }\x0a      setAll(segment.list, entry.listAttributes);\x0a    };\x0a    var createItem = function (scope, attr, content) {\x0a      var item = Element.fromTag(\x27li\x27, scope);\x0a      setAll(item, attr);\x0a      append$1(item, content);\x0a      return item;\x0a    };\x0a    var appendItem = function (segment, item) {\x0a      append(segment.list, item);\x0a      segment.item = item;\x0a    };\x0a    var writeShallow = function (scope, cast, entry) {\x0a      var newCast = cast.slice(0, entry.depth);\x0a      last(newCast).each(function (segment) {\x0a        var item = createItem(scope, entry.itemAttributes, entry.content);\x0a        appendItem(segment, item);\x0a        normalizeSegment(segment, entry);\x0a      });\x0a      return newCast;\x0a    };\x0a    var writeDeep = function (scope, cast, entry) {\x0a      var segments = createSegments(scope, entry, entry.depth - cast.length);\x0a      joinSegments(segments);\x0a      populateSegments(segments, entry);\x0a      appendSegments(cast, segments);\x0a      return cast.concat(segments);\x0a    };\x0a    var composeList = function (scope, entries) {\x0a      var cast = foldl(entries, function (cast, entry) {\x0a        return entry.depth \x3e cast.length ? writeDeep(scope, cast, entry) : writeShallow(scope, cast, entry);\x0a      }, []);\x0a      return head(cast).map(function (segment) {\x0a        return segment.list;\x0a      });\x0a    };\x0a\x0a    var isList$1 = function (el) {\x0a      return is$1(el, \x27OL,UL\x27);\x0a    };\x0a    var hasFirstChildList = function (el) {\x0a      return firstChild(el).map(isList$1).getOr(false);\x0a    };\x0a    var hasLastChildList = function (el) {\x0a      return lastChild(el).map(isList$1).getOr(false);\x0a    };\x0a\x0a    var isIndented = function (entry) {\x0a      return entry.depth \x3e 0;\x0a    };\x0a    var isSelected = function (entry) {\x0a      return entry.isSelected;\x0a    };\x0a    var cloneItemContent = function (li) {\x0a      var children$1 = children(li);\x0a      var content = hasLastChildList(li) ? children$1.slice(0, -1) : children$1;\x0a      return map(content, deep);\x0a    };\x0a    var createEntry = function (li, depth, isSelected) {\x0a      return parent(li).map(function (list) {\x0a        return {\x0a          depth: depth,\x0a          isSelected: isSelected,\x0a          content: cloneItemContent(li),\x0a          itemAttributes: clone(li),\x0a          listAttributes: clone(list),\x0a          listType: name(list)\x0a        };\x0a      });\x0a    };\x0a\x0a    var indentEntry = function (indentation, entry) {\x0a      switch (indentation) {\x0a      case \x27Indent\x27:\x0a        entry.depth++;\x0a        break;\x0a      case \x27Outdent\x27:\x0a        entry.depth--;\x0a        break;\x0a      case \x27Flatten\x27:\x0a        entry.depth = 0;\x0a      }\x0a    };\x0a\x0a    var hasOwnProperty = Object.prototype.hasOwnProperty;\x0a    var shallow = function (old, nu) {\x0a      return nu;\x0a    };\x0a    var baseMerge = function (merger) {\x0a      return function () {\x0a        var objects = new Array(arguments.length);\x0a        for (var i = 0; i \x3c objects.length; i++)\x0a          objects[i] = arguments[i];\x0a        if (objects.length === 0)\x0a          throw new Error(\x27Can\x5c\x27t merge zero objects\x27);\x0a        var ret = {};\x0a        for (var j = 0; j \x3c objects.length; j++) {\x0a          var curObject = objects[j];\x0a          for (var key in curObject)\x0a            if (hasOwnProperty.call(curObject, key)) {\x0a              ret[key] = merger(ret[key], curObject[key]);\x0a            }\x0a        }\x0a        return ret;\x0a      };\x0a    };\x0a    var merge = baseMerge(shallow);\x0a\x0a    var cloneListProperties = function (target, source) {\x0a      target.listType = source.listType;\x0a      target.listAttributes = merge({}, source.listAttributes);\x0a    };\x0a    var previousSiblingEntry = function (entries, start) {\x0a      var depth = entries[start].depth;\x0a      for (var i = start - 1; i \x3e= 0; i--) {\x0a        if (entries[i].depth === depth) {\x0a          return Option.some(entries[i]);\x0a        }\x0a        if (entries[i].depth \x3c depth) {\x0a          break;\x0a        }\x0a      }\x0a      return Option.none();\x0a    };\x0a    var normalizeEntries = function (entries) {\x0a      each(entries, function (entry, i) {\x0a        previousSiblingEntry(entries, i).each(function (matchingEntry) {\x0a          cloneListProperties(entry, matchingEntry);\x0a        });\x0a      });\x0a    };\x0a\x0a    var Cell = function (initial) {\x0a      var value = initial;\x0a      var get = function () {\x0a        return value;\x0a      };\x0a      var set = function (v) {\x0a        value = v;\x0a      };\x0a      var clone = function () {\x0a        return Cell(get());\x0a      };\x0a      return {\x0a        get: get,\x0a        set: set,\x0a        clone: clone\x0a      };\x0a    };\x0a\x0a    var parseItem = function (depth, itemSelection, selectionState, item) {\x0a      return firstChild(item).filter(isList$1).fold(function () {\x0a        itemSelection.each(function (selection) {\x0a          if (eq(selection.start, item)) {\x0a            selectionState.set(true);\x0a          }\x0a        });\x0a        var currentItemEntry = createEntry(item, depth, selectionState.get());\x0a        itemSelection.each(function (selection) {\x0a          if (eq(selection.end, item)) {\x0a            selectionState.set(false);\x0a          }\x0a        });\x0a        var childListEntries = lastChild(item).filter(isList$1).map(function (list) {\x0a          return parseList(depth, itemSelection, selectionState, list);\x0a        }).getOr([]);\x0a        return currentItemEntry.toArray().concat(childListEntries);\x0a      }, function (list) {\x0a        return parseList(depth, itemSelection, selectionState, list);\x0a      });\x0a    };\x0a    var parseList = function (depth, itemSelection, selectionState, list) {\x0a      return bind(children(list), function (element) {\x0a        var parser = isList$1(element) ? parseList : parseItem;\x0a        var newDepth = depth + 1;\x0a        return parser(newDepth, itemSelection, selectionState, element);\x0a      });\x0a    };\x0a    var parseLists = function (lists, itemSelection) {\x0a      var selectionState = Cell(false);\x0a      var initialDepth = 0;\x0a      return map(lists, function (list) {\x0a        return {\x0a          sourceList: list,\x0a          entries: parseList(initialDepth, itemSelection, selectionState, list)\x0a        };\x0a      });\x0a    };\x0a\x0a    var global$8 = tinymce.util.Tools.resolve(\x27tinymce.Env\x27);\x0a\x0a    var createTextBlock = function (editor, contentNode) {\x0a      var dom = editor.dom;\x0a      var blockElements = editor.schema.getBlockElements();\x0a      var fragment = dom.createFragment();\x0a      var node, textBlock, blockName, hasContentNode;\x0a      if (editor.settings.forced_root_block) {\x0a        blockName = editor.settings.forced_root_block;\x0a      }\x0a      if (blockName) {\x0a        textBlock = dom.create(blockName);\x0a        if (textBlock.tagName === editor.settings.forced_root_block) {\x0a          dom.setAttribs(textBlock, editor.settings.forced_root_block_attrs);\x0a        }\x0a        if (!NodeType.isBlock(contentNode.firstChild, blockElements)) {\x0a          fragment.appendChild(textBlock);\x0a        }\x0a      }\x0a      if (contentNode) {\x0a        while (node = contentNode.firstChild) {\x0a          var nodeName = node.nodeName;\x0a          if (!hasContentNode && (nodeName !== \x27SPAN\x27 || node.getAttribute(\x27data-mce-type\x27) !== \x27bookmark\x27)) {\x0a            hasContentNode = true;\x0a          }\x0a          if (NodeType.isBlock(node, blockElements)) {\x0a            fragment.appendChild(node);\x0a            textBlock = null;\x0a          } else {\x0a            if (blockName) {\x0a              if (!textBlock) {\x0a                textBlock = dom.create(blockName);\x0a                fragment.appendChild(textBlock);\x0a              }\x0a              textBlock.appendChild(node);\x0a            } else {\x0a              fragment.appendChild(node);\x0a            }\x0a          }\x0a        }\x0a      }\x0a      if (!editor.settings.forced_root_block) {\x0a        fragment.appendChild(dom.create(\x27br\x27));\x0a      } else {\x0a        if (!hasContentNode && (!global$8.ie || global$8.ie \x3e 10)) {\x0a          textBlock.appendChild(dom.create(\x27br\x27, { \x27data-mce-bogus\x27: \x271\x27 }));\x0a        }\x0a      }\x0a      return fragment;\x0a    };\x0a\x0a    var outdentedComposer = function (editor, entries) {\x0a      return map(entries, function (entry) {\x0a        var content = fromElements(entry.content);\x0a        return Element.fromDom(createTextBlock(editor, content.dom()));\x0a      });\x0a    };\x0a    var indentedComposer = function (editor, entries) {\x0a      normalizeEntries(entries);\x0a      return composeList(editor.contentDocument, entries).toArray();\x0a    };\x0a    var composeEntries = function (editor, entries) {\x0a      return bind(groupBy(entries, isIndented), function (entries) {\x0a        var groupIsIndented = head(entries).map(isIndented).getOr(false);\x0a        return groupIsIndented ? indentedComposer(editor, entries) : outdentedComposer(editor, entries);\x0a      });\x0a    };\x0a    var indentSelectedEntries = function (entries, indentation) {\x0a      each(filter(entries, isSelected), function (entry) {\x0a        return indentEntry(indentation, entry);\x0a      });\x0a    };\x0a    var getItemSelection = function (editor) {\x0a      var selectedListItems = map(Selection.getSelectedListItems(editor), Element.fromDom);\x0a      return liftN([\x0a        find(selectedListItems, not(hasFirstChildList)),\x0a        find(reverse(selectedListItems), not(hasFirstChildList))\x0a      ], function (start, end) {\x0a        return {\x0a          start: start,\x0a          end: end\x0a        };\x0a      });\x0a    };\x0a    var listsIndentation = function (editor, lists, indentation) {\x0a      var entrySets = parseLists(lists, getItemSelection(editor));\x0a      each(entrySets, function (entrySet) {\x0a        indentSelectedEntries(entrySet.entries, indentation);\x0a        before$1(entrySet.sourceList, composeEntries(editor, entrySet.entries));\x0a        remove(entrySet.sourceList);\x0a      });\x0a    };\x0a\x0a    var DOM$1 = global$6.DOM;\x0a    var splitList = function (editor, ul, li) {\x0a      var tmpRng, fragment, bookmarks, node, newBlock;\x0a      var removeAndKeepBookmarks = function (targetNode) {\x0a        global$5.each(bookmarks, function (node) {\x0a          targetNode.parentNode.insertBefore(node, li.parentNode);\x0a        });\x0a        DOM$1.remove(targetNode);\x0a      };\x0a      bookmarks = DOM$1.select(\x27span[data-mce-type=\x22bookmark\x22]\x27, ul);\x0a      newBlock = createTextBlock(editor, li);\x0a      tmpRng = DOM$1.createRng();\x0a      tmpRng.setStartAfter(li);\x0a      tmpRng.setEndAfter(ul);\x0a      fragment = tmpRng.extractContents();\x0a      for (node = fragment.firstChild; node; node = node.firstChild) {\x0a        if (node.nodeName === \x27LI\x27 && editor.dom.isEmpty(node)) {\x0a          DOM$1.remove(node);\x0a          break;\x0a        }\x0a      }\x0a      if (!editor.dom.isEmpty(fragment)) {\x0a        DOM$1.insertAfter(fragment, ul);\x0a      }\x0a      DOM$1.insertAfter(newBlock, ul);\x0a      if (NodeType.isEmpty(editor.dom, li.parentNode)) {\x0a        removeAndKeepBookmarks(li.parentNode);\x0a      }\x0a      DOM$1.remove(li);\x0a      if (NodeType.isEmpty(editor.dom, ul)) {\x0a        DOM$1.remove(ul);\x0a      }\x0a    };\x0a    var SplitList = { splitList: splitList };\x0a\x0a    var outdentDlItem = function (editor, item) {\x0a      if (is$1(item, \x27DD\x27)) {\x0a        mutate(item, \x27DT\x27);\x0a      } else if (is$1(item, \x27DT\x27)) {\x0a        parent(item).each(function (dl) {\x0a          return SplitList.splitList(editor, dl.dom(), item.dom());\x0a        });\x0a      }\x0a    };\x0a    var indentDlItem = function (item) {\x0a      if (is$1(item, \x27DT\x27)) {\x0a        mutate(item, \x27DD\x27);\x0a      }\x0a    };\x0a    var dlIndentation = function (editor, indentation, dlItems) {\x0a      if (indentation === \x27Indent\x27) {\x0a        each(dlItems, indentDlItem);\x0a      } else {\x0a        each(dlItems, function (item) {\x0a          return outdentDlItem(editor, item);\x0a        });\x0a      }\x0a    };\x0a\x0a    var selectionIndentation = function (editor, indentation) {\x0a      var lists = map(Selection.getSelectedListRoots(editor), Element.fromDom);\x0a      var dlItems = map(Selection.getSelectedDlItems(editor), Element.fromDom);\x0a      var isHandled = false;\x0a      if (lists.length || dlItems.length) {\x0a        var bookmark = editor.selection.getBookmark();\x0a        listsIndentation(editor, lists, indentation);\x0a        dlIndentation(editor, indentation, dlItems);\x0a        editor.selection.moveToBookmark(bookmark);\x0a        editor.selection.setRng(Range.normalizeRange(editor.selection.getRng()));\x0a        editor.nodeChanged();\x0a        isHandled = true;\x0a      }\x0a      return isHandled;\x0a    };\x0a    var indentListSelection = function (editor) {\x0a      return selectionIndentation(editor, \x27Indent\x27);\x0a    };\x0a    var outdentListSelection = function (editor) {\x0a      return selectionIndentation(editor, \x27Outdent\x27);\x0a    };\x0a    var flattenListSelection = function (editor) {\x0a      return selectionIndentation(editor, \x27Flatten\x27);\x0a    };\x0a\x0a    var updateListStyle = function (dom, el, detail) {\x0a      var type = detail[\x27list-style-type\x27] ? detail[\x27list-style-type\x27] : null;\x0a      dom.setStyle(el, \x27list-style-type\x27, type);\x0a    };\x0a    var setAttribs = function (elm, attrs) {\x0a      global$5.each(attrs, function (value, key) {\x0a        elm.setAttribute(key, value);\x0a      });\x0a    };\x0a    var updateListAttrs = function (dom, el, detail) {\x0a      setAttribs(el, detail[\x27list-attributes\x27]);\x0a      global$5.each(dom.select(\x27li\x27, el), function (li) {\x0a        setAttribs(li, detail[\x27list-item-attributes\x27]);\x0a      });\x0a    };\x0a    var updateListWithDetails = function (dom, el, detail) {\x0a      updateListStyle(dom, el, detail);\x0a      updateListAttrs(dom, el, detail);\x0a    };\x0a    var removeStyles = function (dom, element, styles) {\x0a      global$5.each(styles, function (style) {\x0a        var _a;\x0a        return dom.setStyle(element, (_a = {}, _a[style] = \x27\x27, _a));\x0a      });\x0a    };\x0a    var getEndPointNode = function (editor, rng, start, root) {\x0a      var container, offset;\x0a      container = rng[start ? \x27startContainer\x27 : \x27endContainer\x27];\x0a      offset = rng[start ? \x27startOffset\x27 : \x27endOffset\x27];\x0a      if (container.nodeType === 1) {\x0a        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\x0a      }\x0a      if (!start && NodeType.isBr(container.nextSibling)) {\x0a        container = container.nextSibling;\x0a      }\x0a      while (container.parentNode !== root) {\x0a        if (NodeType.isTextBlock(editor, container)) {\x0a          return container;\x0a        }\x0a        if (/^(TD|TH)$/.test(container.parentNode.nodeName)) {\x0a          return container;\x0a        }\x0a        container = container.parentNode;\x0a      }\x0a      return container;\x0a    };\x0a    var getSelectedTextBlocks = function (editor, rng, root) {\x0a      var textBlocks = [], dom = editor.dom;\x0a      var startNode = getEndPointNode(editor, rng, true, root);\x0a      var endNode = getEndPointNode(editor, rng, false, root);\x0a      var block;\x0a      var siblings = [];\x0a      for (var node = startNode; node; node = node.nextSibling) {\x0a        siblings.push(node);\x0a        if (node === endNode) {\x0a          break;\x0a        }\x0a      }\x0a      global$5.each(siblings, function (node) {\x0a        if (NodeType.isTextBlock(editor, node)) {\x0a          textBlocks.push(node);\x0a          block = null;\x0a          return;\x0a        }\x0a        if (dom.isBlock(node) || NodeType.isBr(node)) {\x0a          if (NodeType.isBr(node)) {\x0a            dom.remove(node);\x0a          }\x0a          block = null;\x0a          return;\x0a        }\x0a        var nextSibling = node.nextSibling;\x0a        if (global$4.isBookmarkNode(node)) {\x0a          if (NodeType.isTextBlock(editor, nextSibling) || !nextSibling && node.parentNode === root) {\x0a            block = null;\x0a            return;\x0a          }\x0a        }\x0a        if (!block) {\x0a          block = dom.create(\x27p\x27);\x0a          node.parentNode.insertBefore(block, node);\x0a          textBlocks.push(block);\x0a        }\x0a        block.appendChild(node);\x0a      });\x0a      return textBlocks;\x0a    };\x0a    var hasCompatibleStyle = function (dom, sib, detail) {\x0a      var sibStyle = dom.getStyle(sib, \x27list-style-type\x27);\x0a      var detailStyle = detail ? detail[\x27list-style-type\x27] : \x27\x27;\x0a      detailStyle = detailStyle === null ? \x27\x27 : detailStyle;\x0a      return sibStyle === detailStyle;\x0a    };\x0a    var applyList = function (editor, listName, detail) {\x0a      if (detail === void 0) {\x0a        detail = {};\x0a      }\x0a      var rng = editor.selection.getRng(true);\x0a      var bookmark;\x0a      var listItemName = \x27LI\x27;\x0a      var root = Selection.getClosestListRootElm(editor, editor.selection.getStart(true));\x0a      var dom = editor.dom;\x0a      if (dom.getContentEditable(editor.selection.getNode()) === \x27false\x27) {\x0a        return;\x0a      }\x0a      listName = listName.toUpperCase();\x0a      if (listName === \x27DL\x27) {\x0a        listItemName = \x27DT\x27;\x0a      }\x0a      bookmark = Bookmark.createBookmark(rng);\x0a      global$5.each(getSelectedTextBlocks(editor, rng, root), function (block) {\x0a        var listBlock, sibling;\x0a        sibling = block.previousSibling;\x0a        if (sibling && NodeType.isListNode(sibling) && sibling.nodeName === listName && hasCompatibleStyle(dom, sibling, detail)) {\x0a          listBlock = sibling;\x0a          block = dom.rename(block, listItemName);\x0a          sibling.appendChild(block);\x0a        } else {\x0a          listBlock = dom.create(listName);\x0a          block.parentNode.insertBefore(listBlock, block);\x0a          listBlock.appendChild(block);\x0a          block = dom.rename(block, listItemName);\x0a        }\x0a        removeStyles(dom, block, [\x0a          \x27margin\x27,\x0a          \x27margin-right\x27,\x0a          \x27margin-bottom\x27,\x0a          \x27margin-left\x27,\x0a          \x27margin-top\x27,\x0a          \x27padding\x27,\x0a          \x27padding-right\x27,\x0a          \x27padding-bottom\x27,\x0a          \x27padding-left\x27,\x0a          \x27padding-top\x27\x0a        ]);\x0a        updateListWithDetails(dom, listBlock, detail);\x0a        mergeWithAdjacentLists(editor.dom, listBlock);\x0a      });\x0a      editor.selection.setRng(Bookmark.resolveBookmark(bookmark));\x0a    };\x0a    var isValidLists = function (list1, list2) {\x0a      return list1 && list2 && NodeType.isListNode(list1) && list1.nodeName === list2.nodeName;\x0a    };\x0a    var hasSameListStyle = function (dom, list1, list2) {\x0a      var targetStyle = dom.getStyle(list1, \x27list-style-type\x27, true);\x0a      var style = dom.getStyle(list2, \x27list-style-type\x27, true);\x0a      return targetStyle === style;\x0a    };\x0a    var hasSameClasses = function (elm1, elm2) {\x0a      return elm1.className === elm2.className;\x0a    };\x0a    var shouldMerge = function (dom, list1, list2) {\x0a      return isValidLists(list1, list2) && hasSameListStyle(dom, list1, list2) && hasSameClasses(list1, list2);\x0a    };\x0a    var mergeWithAdjacentLists = function (dom, listBlock) {\x0a      var sibling, node;\x0a      sibling = listBlock.nextSibling;\x0a      if (shouldMerge(dom, listBlock, sibling)) {\x0a        while (node = sibling.firstChild) {\x0a          listBlock.appendChild(node);\x0a        }\x0a        dom.remove(sibling);\x0a      }\x0a      sibling = listBlock.previousSibling;\x0a      if (shouldMerge(dom, listBlock, sibling)) {\x0a        while (node = sibling.lastChild) {\x0a          listBlock.insertBefore(node, listBlock.firstChild);\x0a        }\x0a        dom.remove(sibling);\x0a      }\x0a    };\x0a    var updateList = function (dom, list, listName, detail) {\x0a      if (list.nodeName !== listName) {\x0a        var newList = dom.rename(list, listName);\x0a        updateListWithDetails(dom, newList, detail);\x0a      } else {\x0a        updateListWithDetails(dom, list, detail);\x0a      }\x0a    };\x0a    var toggleMultipleLists = function (editor, parentList, lists, listName, detail) {\x0a      if (parentList.nodeName === listName && !hasListStyleDetail(detail)) {\x0a        flattenListSelection(editor);\x0a      } else {\x0a        var bookmark = Bookmark.createBookmark(editor.selection.getRng(true));\x0a        global$5.each([parentList].concat(lists), function (elm) {\x0a          updateList(editor.dom, elm, listName, detail);\x0a        });\x0a        editor.selection.setRng(Bookmark.resolveBookmark(bookmark));\x0a      }\x0a    };\x0a    var hasListStyleDetail = function (detail) {\x0a      return \x27list-style-type\x27 in detail;\x0a    };\x0a    var toggleSingleList = function (editor, parentList, listName, detail) {\x0a      if (parentList === editor.getBody()) {\x0a        return;\x0a      }\x0a      if (parentList) {\x0a        if (parentList.nodeName === listName && !hasListStyleDetail(detail)) {\x0a          flattenListSelection(editor);\x0a        } else {\x0a          var bookmark = Bookmark.createBookmark(editor.selection.getRng(true));\x0a          updateListWithDetails(editor.dom, parentList, detail);\x0a          mergeWithAdjacentLists(editor.dom, editor.dom.rename(parentList, listName));\x0a          editor.selection.setRng(Bookmark.resolveBookmark(bookmark));\x0a        }\x0a      } else {\x0a        applyList(editor, listName, detail);\x0a      }\x0a    };\x0a    var toggleList = function (editor, listName, detail) {\x0a      var parentList = Selection.getParentList(editor);\x0a      var selectedSubLists = Selection.getSelectedSubLists(editor);\x0a      detail = detail ? detail : {};\x0a      if (parentList && selectedSubLists.length \x3e 0) {\x0a        toggleMultipleLists(editor, parentList, selectedSubLists, listName, detail);\x0a      } else {\x0a        toggleSingleList(editor, parentList, listName, detail);\x0a      }\x0a    };\x0a    var ToggleList = {\x0a      toggleList: toggleList,\x0a      mergeWithAdjacentLists: mergeWithAdjacentLists\x0a    };\x0a\x0a    var DOM$2 = global$6.DOM;\x0a    var normalizeList = function (dom, ul) {\x0a      var sibling;\x0a      var parentNode = ul.parentNode;\x0a      if (parentNode.nodeName === \x27LI\x27 && parentNode.firstChild === ul) {\x0a        sibling = parentNode.previousSibling;\x0a        if (sibling && sibling.nodeName === \x27LI\x27) {\x0a          sibling.appendChild(ul);\x0a          if (NodeType.isEmpty(dom, parentNode)) {\x0a            DOM$2.remove(parentNode);\x0a          }\x0a        } else {\x0a          DOM$2.setStyle(parentNode, \x27listStyleType\x27, \x27none\x27);\x0a        }\x0a      }\x0a      if (NodeType.isListNode(parentNode)) {\x0a        sibling = parentNode.previousSibling;\x0a        if (sibling && sibling.nodeName === \x27LI\x27) {\x0a          sibling.appendChild(ul);\x0a        }\x0a      }\x0a    };\x0a    var normalizeLists = function (dom, element) {\x0a      global$5.each(global$5.grep(dom.select(\x27ol,ul\x27, element)), function (ul) {\x0a        normalizeList(dom, ul);\x0a      });\x0a    };\x0a    var NormalizeLists = {\x0a      normalizeList: normalizeList,\x0a      normalizeLists: normalizeLists\x0a    };\x0a\x0a    var findNextCaretContainer = function (editor, rng, isForward, root) {\x0a      var node = rng.startContainer;\x0a      var offset = rng.startOffset;\x0a      var nonEmptyBlocks, walker;\x0a      if (node.nodeType === 3 && (isForward ? offset \x3c node.data.length : offset \x3e 0)) {\x0a        return node;\x0a      }\x0a      nonEmptyBlocks = editor.schema.getNonEmptyElements();\x0a      if (node.nodeType === 1) {\x0a        node = global$1.getNode(node, offset);\x0a      }\x0a      walker = new global$2(node, root);\x0a      if (isForward) {\x0a        if (NodeType.isBogusBr(editor.dom, node)) {\x0a          walker.next();\x0a        }\x0a      }\x0a      while (node = walker[isForward ? \x27next\x27 : \x27prev2\x27]()) {\x0a        if (node.nodeName === \x27LI\x27 && !node.hasChildNodes()) {\x0a          return node;\x0a        }\x0a        if (nonEmptyBlocks[node.nodeName]) {\x0a          return node;\x0a        }\x0a        if (node.nodeType === 3 && node.data.length \x3e 0) {\x0a          return node;\x0a        }\x0a      }\x0a    };\x0a    var hasOnlyOneBlockChild = function (dom, elm) {\x0a      var childNodes = elm.childNodes;\x0a      return childNodes.length === 1 && !NodeType.isListNode(childNodes[0]) && dom.isBlock(childNodes[0]);\x0a    };\x0a    var unwrapSingleBlockChild = function (dom, elm) {\x0a      if (hasOnlyOneBlockChild(dom, elm)) {\x0a        dom.remove(elm.firstChild, true);\x0a      }\x0a    };\x0a    var moveChildren = function (dom, fromElm, toElm) {\x0a      var node, targetElm;\x0a      targetElm = hasOnlyOneBlockChild(dom, toElm) ? toElm.firstChild : toElm;\x0a      unwrapSingleBlockChild(dom, fromElm);\x0a      if (!NodeType.isEmpty(dom, fromElm, true)) {\x0a        while (node = fromElm.firstChild) {\x0a          targetElm.appendChild(node);\x0a        }\x0a      }\x0a    };\x0a    var mergeLiElements = function (dom, fromElm, toElm) {\x0a      var node, listNode;\x0a      var ul = fromElm.parentNode;\x0a      if (!NodeType.isChildOfBody(dom, fromElm) || !NodeType.isChildOfBody(dom, toElm)) {\x0a        return;\x0a      }\x0a      if (NodeType.isListNode(toElm.lastChild)) {\x0a        listNode = toElm.lastChild;\x0a      }\x0a      if (ul === toElm.lastChild) {\x0a        if (NodeType.isBr(ul.previousSibling)) {\x0a          dom.remove(ul.previousSibling);\x0a        }\x0a      }\x0a      node = toElm.lastChild;\x0a      if (node && NodeType.isBr(node) && fromElm.hasChildNodes()) {\x0a        dom.remove(node);\x0a      }\x0a      if (NodeType.isEmpty(dom, toElm, true)) {\x0a        dom.$(toElm).empty();\x0a      }\x0a      moveChildren(dom, fromElm, toElm);\x0a      if (listNode) {\x0a        toElm.appendChild(listNode);\x0a      }\x0a      var contains = contains$1(Element.fromDom(toElm), Element.fromDom(fromElm));\x0a      var nestedLists = contains ? dom.getParents(fromElm, NodeType.isListNode, toElm) : [];\x0a      dom.remove(fromElm);\x0a      each(nestedLists, function (list) {\x0a        if (NodeType.isEmpty(dom, list) && list !== dom.getRoot()) {\x0a          dom.remove(list);\x0a        }\x0a      });\x0a    };\x0a    var mergeIntoEmptyLi = function (editor, fromLi, toLi) {\x0a      editor.dom.$(toLi).empty();\x0a      mergeLiElements(editor.dom, fromLi, toLi);\x0a      editor.selection.setCursorLocation(toLi);\x0a    };\x0a    var mergeForward = function (editor, rng, fromLi, toLi) {\x0a      var dom = editor.dom;\x0a      if (dom.isEmpty(toLi)) {\x0a        mergeIntoEmptyLi(editor, fromLi, toLi);\x0a      } else {\x0a        var bookmark = Bookmark.createBookmark(rng);\x0a        mergeLiElements(dom, fromLi, toLi);\x0a        editor.selection.setRng(Bookmark.resolveBookmark(bookmark));\x0a      }\x0a    };\x0a    var mergeBackward = function (editor, rng, fromLi, toLi) {\x0a      var bookmark = Bookmark.createBookmark(rng);\x0a      mergeLiElements(editor.dom, fromLi, toLi);\x0a      var resolvedBookmark = Bookmark.resolveBookmark(bookmark);\x0a      editor.selection.setRng(resolvedBookmark);\x0a    };\x0a    var backspaceDeleteFromListToListCaret = function (editor, isForward) {\x0a      var dom = editor.dom, selection = editor.selection;\x0a      var selectionStartElm = selection.getStart();\x0a      var root = Selection.getClosestListRootElm(editor, selectionStartElm);\x0a      var li = dom.getParent(selection.getStart(), \x27LI\x27, root);\x0a      var ul, rng, otherLi;\x0a      if (li) {\x0a        ul = li.parentNode;\x0a        if (ul === editor.getBody() && NodeType.isEmpty(dom, ul)) {\x0a          return true;\x0a        }\x0a        rng = Range.normalizeRange(selection.getRng(true));\x0a        otherLi = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), \x27LI\x27, root);\x0a        if (otherLi && otherLi !== li) {\x0a          if (isForward) {\x0a            mergeForward(editor, rng, otherLi, li);\x0a          } else {\x0a            mergeBackward(editor, rng, li, otherLi);\x0a          }\x0a          return true;\x0a        } else if (!otherLi) {\x0a          if (!isForward) {\x0a            flattenListSelection(editor);\x0a            return true;\x0a          }\x0a        }\x0a      }\x0a      return false;\x0a    };\x0a    var removeBlock = function (dom, block, root) {\x0a      var parentBlock = dom.getParent(block.parentNode, dom.isBlock, root);\x0a      dom.remove(block);\x0a      if (parentBlock && dom.isEmpty(parentBlock)) {\x0a        dom.remove(parentBlock);\x0a      }\x0a    };\x0a    var backspaceDeleteIntoListCaret = function (editor, isForward) {\x0a      var dom = editor.dom;\x0a      var selectionStartElm = editor.selection.getStart();\x0a      var root = Selection.getClosestListRootElm(editor, selectionStartElm);\x0a      var block = dom.getParent(selectionStartElm, dom.isBlock, root);\x0a      if (block && dom.isEmpty(block)) {\x0a        var rng = Range.normalizeRange(editor.selection.getRng(true));\x0a        var otherLi_1 = dom.getParent(findNextCaretContainer(editor, rng, isForward, root), \x27LI\x27, root);\x0a        if (otherLi_1) {\x0a          editor.undoManager.transact(function () {\x0a            removeBlock(dom, block, root);\x0a            ToggleList.mergeWithAdjacentLists(dom, otherLi_1.parentNode);\x0a            editor.selection.select(otherLi_1, true);\x0a            editor.selection.collapse(isForward);\x0a          });\x0a          return true;\x0a        }\x0a      }\x0a      return false;\x0a    };\x0a    var backspaceDeleteCaret = function (editor, isForward) {\x0a      return backspaceDeleteFromListToListCaret(editor, isForward) || backspaceDeleteIntoListCaret(editor, isForward);\x0a    };\x0a    var backspaceDeleteRange = function (editor) {\x0a      var selectionStartElm = editor.selection.getStart();\x0a      var root = Selection.getClosestListRootElm(editor, selectionStartElm);\x0a      var startListParent = editor.dom.getParent(selectionStartElm, \x27LI,DT,DD\x27, root);\x0a      if (startListParent || Selection.getSelectedListItems(editor).length \x3e 0) {\x0a        editor.undoManager.transact(function () {\x0a          editor.execCommand(\x27Delete\x27);\x0a          NormalizeLists.normalizeLists(editor.dom, editor.getBody());\x0a        });\x0a        return true;\x0a      }\x0a      return false;\x0a    };\x0a    var backspaceDelete = function (editor, isForward) {\x0a      return editor.selection.isCollapsed() ? backspaceDeleteCaret(editor, isForward) : backspaceDeleteRange(editor);\x0a    };\x0a    var setup = function (editor) {\x0a      editor.on(\x27keydown\x27, function (e) {\x0a        if (e.keyCode === global$3.BACKSPACE) {\x0a          if (backspaceDelete(editor, false)) {\x0a            e.preventDefault();\x0a          }\x0a        } else if (e.keyCode === global$3.DELETE) {\x0a          if (backspaceDelete(editor, true)) {\x0a            e.preventDefault();\x0a          }\x0a        }\x0a      });\x0a    };\x0a    var Delete = {\x0a      setup: setup,\x0a      backspaceDelete: backspaceDelete\x0a    };\x0a\x0a    var get = function (editor) {\x0a      return {\x0a        backspaceDelete: function (isForward) {\x0a          Delete.backspaceDelete(editor, isForward);\x0a        }\x0a      };\x0a    };\x0a    var Api = { get: get };\x0a\x0a    var queryListCommandState = function (editor, listName) {\x0a      return function () {\x0a        var parentList = editor.dom.getParent(editor.selection.getStart(), \x27UL,OL,DL\x27);\x0a        return parentList && parentList.nodeName === listName;\x0a      };\x0a    };\x0a    var register = function (editor) {\x0a      editor.on(\x27BeforeExecCommand\x27, function (e) {\x0a        var cmd = e.command.toLowerCase();\x0a        if (cmd === \x27indent\x27) {\x0a          indentListSelection(editor);\x0a        } else if (cmd === \x27outdent\x27) {\x0a          outdentListSelection(editor);\x0a        }\x0a      });\x0a      editor.addCommand(\x27InsertUnorderedList\x27, function (ui, detail) {\x0a        ToggleList.toggleList(editor, \x27UL\x27, detail);\x0a      });\x0a      editor.addCommand(\x27InsertOrderedList\x27, function (ui, detail) {\x0a        ToggleList.toggleList(editor, \x27OL\x27, detail);\x0a      });\x0a      editor.addCommand(\x27InsertDefinitionList\x27, function (ui, detail) {\x0a        ToggleList.toggleList(editor, \x27DL\x27, detail);\x0a      });\x0a      editor.addCommand(\x27RemoveList\x27, function () {\x0a        flattenListSelection(editor);\x0a      });\x0a      editor.addQueryStateHandler(\x27InsertUnorderedList\x27, queryListCommandState(editor, \x27UL\x27));\x0a      editor.addQueryStateHandler(\x27InsertOrderedList\x27, queryListCommandState(editor, \x27OL\x27));\x0a      editor.addQueryStateHandler(\x27InsertDefinitionList\x27, queryListCommandState(editor, \x27DL\x27));\x0a    };\x0a    var Commands = { register: register };\x0a\x0a    var shouldIndentOnTab = function (editor) {\x0a      return editor.getParam(\x27lists_indent_on_tab\x27, true);\x0a    };\x0a    var Settings = { shouldIndentOnTab: shouldIndentOnTab };\x0a\x0a    var setupTabKey = function (editor) {\x0a      editor.on(\x27keydown\x27, function (e) {\x0a        if (e.keyCode !== global$3.TAB || global$3.metaKeyPressed(e)) {\x0a          return;\x0a        }\x0a        editor.undoManager.transact(function () {\x0a          if (e.shiftKey ? outdentListSelection(editor) : indentListSelection(editor)) {\x0a            e.preventDefault();\x0a          }\x0a        });\x0a      });\x0a    };\x0a    var setup$1 = function (editor) {\x0a      if (Settings.shouldIndentOnTab(editor)) {\x0a        setupTabKey(editor);\x0a      }\x0a      Delete.setup(editor);\x0a    };\x0a    var Keyboard = { setup: setup$1 };\x0a\x0a    var findIndex = function (list, predicate) {\x0a      for (var index = 0; index \x3c list.length; index++) {\x0a        var element = list[index];\x0a        if (predicate(element)) {\x0a          return index;\x0a        }\x0a      }\x0a      return -1;\x0a    };\x0a    var listState = function (editor, listName) {\x0a      return function (e) {\x0a        var ctrl = e.control;\x0a        editor.on(\x27NodeChange\x27, function (e) {\x0a          var tableCellIndex = findIndex(e.parents, NodeType.isTableCellNode);\x0a          var parents = tableCellIndex !== -1 ? e.parents.slice(0, tableCellIndex) : e.parents;\x0a          var lists = global$5.grep(parents, NodeType.isListNode);\x0a          ctrl.active(lists.length \x3e 0 && lists[0].nodeName === listName);\x0a        });\x0a      };\x0a    };\x0a    var register$1 = function (editor) {\x0a      var hasPlugin = function (editor, plugin) {\x0a        var plugins = editor.settings.plugins ? editor.settings.plugins : \x27\x27;\x0a        return global$5.inArray(plugins.split(/[ ,]/), plugin) !== -1;\x0a      };\x0a      if (!hasPlugin(editor, \x27advlist\x27)) {\x0a        editor.addButton(\x27numlist\x27, {\x0a          active: false,\x0a          title: \x27Numbered list\x27,\x0a          cmd: \x27InsertOrderedList\x27,\x0a          onPostRender: listState(editor, \x27OL\x27)\x0a        });\x0a        editor.addButton(\x27bullist\x27, {\x0a          active: false,\x0a          title: \x27Bullet list\x27,\x0a          cmd: \x27InsertUnorderedList\x27,\x0a          onPostRender: listState(editor, \x27UL\x27)\x0a        });\x0a      }\x0a      editor.addButton(\x27indent\x27, {\x0a        icon: \x27indent\x27,\x0a        title: \x27Increase indent\x27,\x0a        cmd: \x27Indent\x27\x0a      });\x0a    };\x0a    var Buttons = { register: register$1 };\x0a\x0a    global.add(\x27lists\x27, function (editor) {\x0a      Keyboard.setup(editor);\x0a      Buttons.register(editor);\x0a      Commands.register(editor);\x0a      return Api.get(editor);\x0a    });\x0a    function Plugin () {\x0a    }\x0a\x0a    return Plugin;\x0a\x0a}(window));\x0a})();\x0a'}