var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:10:21 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 16 May 2019 18:12:57 GMT\x0aETag: \x228b70-58905372b9c40-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-9353/9354\x0aContent-Length: 9354\x0aKeep-Alive: timeout=5, max=2\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0athis[\x22wp\x22] = this[\x22wp\x22] || {}; this[\x22wp\x22][\x22dom\x22] =\x0a/******/ (function(modules) { // webpackBootstrap\x0a/******/ \x09// The module cache\x0a/******/ \x09var installedModules = {};\x0a/******/\x0a/******/ \x09// The require function\x0a/******/ \x09function __webpack_require__(moduleId) {\x0a/******/\x0a/******/ \x09\x09// Check if module is in cache\x0a/******/ \x09\x09if(installedModules[moduleId]) {\x0a/******/ \x09\x09\x09return installedModules[moduleId].exports;\x0a/******/ \x09\x09}\x0a/******/ \x09\x09// Create a new module (and put it into the cache)\x0a/******/ \x09\x09var module = installedModules[moduleId] = {\x0a/******/ \x09\x09\x09i: moduleId,\x0a/******/ \x09\x09\x09l: false,\x0a/******/ \x09\x09\x09exports: {}\x0a/******/ \x09\x09};\x0a/******/\x0a/******/ \x09\x09// Execute the module function\x0a/******/ \x09\x09modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\x0a/******/\x0a/******/ \x09\x09// Flag the module as loaded\x0a/******/ \x09\x09module.l = true;\x0a/******/\x0a/******/ \x09\x09// Return the exports of the module\x0a/******/ \x09\x09return module.exports;\x0a/******/ \x09}\x0a/******/\x0a/******/\x0a/******/ \x09// expose the modules object (__webpack_modules__)\x0a/******/ \x09__webpack_require__.m = modules;\x0a/******/\x0a/******/ \x09// expose the module cache\x0a/******/ \x09__webpack_require__.c = installedModules;\x0a/******/\x0a/******/ \x09// define getter function for harmony exports\x0a/******/ \x09__webpack_require__.d = function(exports, name, getter) {\x0a/******/ \x09\x09if(!__webpack_require__.o(exports, name)) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, name, { enumerable: true, get: getter });\x0a/******/ \x09\x09}\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// define __esModule on exports\x0a/******/ \x09__webpack_require__.r = function(exports) {\x0a/******/ \x09\x09if(typeof Symbol !== \x27undefined\x27 && Symbol.toStringTag) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, Symbol.toStringTag, { value: \x27Module\x27 });\x0a/******/ \x09\x09}\x0a/******/ \x09\x09Object.defineProperty(exports, \x27__esModule\x27, { value: true });\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// create a fake namespace object\x0a/******/ \x09// mode & 1: value is a module id, require it\x0a/******/ \x09// mode & 2: merge all properties of value into the ns\x0a/******/ \x09// mode & 4: return value when already ns object\x0a/******/ \x09// mode & 8|1: behave like require\x0a/******/ \x09__webpack_require__.t = function(value, mode) {\x0a/******/ \x09\x09if(mode & 1) value = __webpack_require__(value);\x0a/******/ \x09\x09if(mode & 8) return value;\x0a/******/ \x09\x09if((mode & 4) && typeof value === \x27object\x27 && value && value.__esModule) return value;\x0a/******/ \x09\x09var ns = Object.create(null);\x0a/******/ \x09\x09__webpack_require__.r(ns);\x0a/******/ \x09\x09Object.defineProperty(ns, \x27default\x27, { enumerable: true, value: value });\x0a/******/ \x09\x09if(mode & 2 && typeof value != \x27string\x27) for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\x0a/******/ \x09\x09return ns;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// getDefaultExport function for compatibility with non-harmony modules\x0a/******/ \x09__webpack_require__.n = function(module) {\x0a/******/ \x09\x09var getter = module && module.__esModule ?\x0a/******/ \x09\x09\x09function getDefault() { return module[\x27default\x27]; } :\x0a/******/ \x09\x09\x09function getModuleExports() { return module; };\x0a/******/ \x09\x09__webpack_require__.d(getter, \x27a\x27, getter);\x0a/******/ \x09\x09return getter;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// Object.prototype.hasOwnProperty.call\x0a/******/ \x09__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\x0a/******/\x0a/******/ \x09// __webpack_public_path__\x0a/******/ \x09__webpack_require__.p = \x22\x22;\x0a/******/\x0a/******/\x0a/******/ \x09// Load entry module and return exports\x0a/******/ \x09return __webpack_require__(__webpack_require__.s = 379);\x0a/******/ })\x0a/************************************************************************/\x0a/******/ ({\x0a\x0a/***/ 17:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\x0afunction _arrayWithoutHoles(arr) {\x0a  if (Array.isArray(arr)) {\x0a    for (var i = 0, arr2 = new Array(arr.length); i \x3c arr.length; i++) {\x0a      arr2[i] = arr[i];\x0a    }\x0a\x0a    return arr2;\x0a  }\x0a}\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js\x0avar iterableToArray = __webpack_require__(34);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\x0afunction _nonIterableSpread() {\x0a  throw new TypeError(\x22Invalid attempt to spread non-iterable instance\x22);\x0a}\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _toConsumableArray; });\x0a\x0a\x0a\x0afunction _toConsumableArray(arr) {\x0a  return _arrayWithoutHoles(arr) || Object(iterableToArray[\x22a\x22 /* default */])(arr) || _nonIterableSpread();\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 2:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22lodash\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 34:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _iterableToArray; });\x0afunction _iterableToArray(iter) {\x0a  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \x22[object Arguments]\x22) return Array.from(iter);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 379:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0avar focusable_namespaceObject = {};\x0a__webpack_require__.r(focusable_namespaceObject);\x0a__webpack_require__.d(focusable_namespaceObject, \x22find\x22, function() { return find; });\x0avar tabbable_namespaceObject = {};\x0a__webpack_require__.r(tabbable_namespaceObject);\x0a__webpack_require__.d(tabbable_namespaceObject, \x22isTabbableIndex\x22, function() { return isTabbableIndex; });\x0a__webpack_require__.d(tabbable_namespaceObject, \x22find\x22, function() { return tabbable_find; });\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules\x0avar toConsumableArray = __webpack_require__(17);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/dom/build-module/focusable.js\x0a\x0a\x0a/**\x0a * References:\x0a *\x0a * Focusable:\x0a *  - https://www.w3.org/TR/html5/editing.html#focus-management\x0a *\x0a * Sequential focus navigation:\x0a *  - https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute\x0a *\x0a * Disabled elements:\x0a *  - https://www.w3.org/TR/html5/disabled-elements.html#disabled-elements\x0a *\x0a * getClientRects algorithm (requiring layout box):\x0a *  - https://www.w3.org/TR/cssom-view-1/#extension-to-the-element-interface\x0a *\x0a * AREA elements associated with an IMG:\x0a *  - https://w3c.github.io/html/editing.html#data-model\x0a */\x0avar SELECTOR = [\x27[tabindex]\x27, \x27a[href]\x27, \x27button:not([disabled])\x27, \x27input:not([type=\x22hidden\x22]):not([disabled])\x27, \x27select:not([disabled])\x27, \x27textarea:not([disabled])\x27, \x27iframe\x27, \x27object\x27, \x27embed\x27, \x27area[href]\x27, \x27[contenteditable]:not([contenteditable=false])\x27].join(\x27,\x27);\x0a/**\x0a * Returns true if the specified element is visible (i.e. neither display: none\x0a * nor visibility: hidden).\x0a *\x0a * @param {Element} element DOM element to test.\x0a *\x0a * @return {boolean} Whether element is visible.\x0a */\x0a\x0afunction isVisible(element) {\x0a  return element.offsetWidth \x3e 0 || element.offsetHeight \x3e 0 || element.getClientRects().length \x3e 0;\x0a}\x0a/**\x0a * Returns true if the specified area element is a valid focusable element, or\x0a * false otherwise. Area is only focusable if within a map where a named map\x0a * referenced by an image somewhere in the document.\x0a *\x0a * @param {Element} element DOM area element to test.\x0a *\x0a * @return {boolean} Whether area element is valid for focus.\x0a */\x0a\x0a\x0afunction isValidFocusableArea(element) {\x0a  var map = element.closest(\x27map[name]\x27);\x0a\x0a  if (!map) {\x0a    return false;\x0a  }\x0a\x0a  var img = document.querySelector(\x27img[usemap=\x22#\x27 + map.name + \x27\x22]\x27);\x0a  return !!img && isVisible(img);\x0a}\x0a/**\x0a * Returns all focusable elements within a given context.\x0a *\x0a * @param {Element} context Element in which to search.\x0a *\x0a * @return {Element[]} Focusable elements.\x0a */\x0a\x0a\x0afunction find(context) {\x0a  var elements = context.querySelectorAll(SELECTOR);\x0a  return Object(toConsumableArray[\x22a\x22 /* default */])(elements).filter(function (element) {\x0a    if (!isVisible(element)) {\x0a      return false;\x0a    }\x0a\x0a    var nodeName = element.nodeName;\x0a\x0a    if (\x27AREA\x27 === nodeName) {\x0a      return isValidFocusableArea(element);\x0a    }\x0a\x0a    return true;\x0a  });\x0a}\x0a\x0a// EXTERNAL MODULE: external \x22lodash\x22\x0avar external_lodash_ = __webpack_require__(2);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/dom/build-module/tabbable.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Returns the tab index of the given element. In contrast with the tabIndex\x0a * property, this normalizes the default (0) to avoid browser inconsistencies,\x0a * operating under the assumption that this function is only ever called with a\x0a * focusable node.\x0a *\x0a * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1190261\x0a *\x0a * @param {Element} element Element from which to retrieve.\x0a *\x0a * @return {?number} Tab index of element (default 0).\x0a */\x0a\x0afunction getTabIndex(element) {\x0a  var tabIndex = element.getAttribute(\x27tabindex\x27);\x0a  return tabIndex === null ? 0 : parseInt(tabIndex, 10);\x0a}\x0a/**\x0a * Returns true if the specified element is tabbable, or false otherwise.\x0a *\x0a * @param {Element} element Element to test.\x0a *\x0a * @return {boolean} Whether element is tabbable.\x0a */\x0a\x0a\x0afunction isTabbableIndex(element) {\x0a  return getTabIndex(element) !== -1;\x0a}\x0a/**\x0a * Returns a stateful reducer function which constructs a filtered array of\x0a * tabbable elements, where at most one radio input is selected for a given\x0a * name, giving priority to checked input, falling back to the first\x0a * encountered.\x0a *\x0a * @return {Function} Radio group collapse reducer.\x0a */\x0a\x0afunction createStatefulCollapseRadioGroup() {\x0a  var CHOSEN_RADIO_BY_NAME = {};\x0a  return function collapseRadioGroup(result, element) {\x0a    var nodeName = element.nodeName,\x0a        type = element.type,\x0a        checked = element.checked,\x0a        name = element.name; // For all non-radio tabbables, construct to array by concatenating.\x0a\x0a    if (nodeName !== \x27INPUT\x27 || type !== \x27radio\x27 || !name) {\x0a      return result.concat(element);\x0a    }\x0a\x0a    var hasChosen = CHOSEN_RADIO_BY_NAME.hasOwnProperty(name); // Omit by skipping concatenation if the radio element is not chosen.\x0a\x0a    var isChosen = checked || !hasChosen;\x0a\x0a    if (!isChosen) {\x0a      return result;\x0a    } // At this point, if there had been a chosen element, the current\x0a    // element is checked and should take priority. Retroactively remove\x0a    // the element which had previously been considered the chosen one.\x0a\x0a\x0a    if (hasChosen) {\x0a      var hadChosenElement = CHOSEN_RADIO_BY_NAME[name];\x0a      result = Object(external_lodash_[\x22without\x22])(result, hadChosenElement);\x0a    }\x0a\x0a    CHOSEN_RADIO_BY_NAME[name] = element;\x0a    return result.concat(element);\x0a  };\x0a}\x0a/**\x0a * An array map callback, returning an object with the element value and its\x0a * array index location as properties. This is used to emulate a proper stable\x0a * sort where equal tabIndex should be left in order of their occurrence in the\x0a * document.\x0a *\x0a * @param {Element} element Element.\x0a * @param {number}  index   Array index of element.\x0a *\x0a * @return {Object} Mapped object with element, index.\x0a */\x0a\x0a\x0afunction mapElementToObjectTabbable(element, index) {\x0a  return {\x0a    element: element,\x0a    index: index\x0a  };\x0a}\x0a/**\x0a * An array map callback, returning an element of the given mapped object\x27s\x0a * element value.\x0a *\x0a * @param {Object} object Mapped object with index.\x0a *\x0a * @return {Element} Mapped object element.\x0a */\x0a\x0a\x0afunction mapObjectTabbableToElement(object) {\x0a  return object.element;\x0a}\x0a/**\x0a * A sort comparator function used in comparing two objects of mapped elements.\x0a *\x0a * @see mapElementToObjectTabbable\x0a *\x0a * @param {Object} a First object to compare.\x0a * @param {Object} b Second object to compare.\x0a *\x0a * @return {number} Comparator result.\x0a */\x0a\x0a\x0afunction compareObjectTabbables(a, b) {\x0a  var aTabIndex = getTabIndex(a.element);\x0a  var bTabIndex = getTabIndex(b.element);\x0a\x0a  if (aTabIndex === bTabIndex) {\x0a    return a.index - b.index;\x0a  }\x0a\x0a  return aTabIndex - bTabIndex;\x0a}\x0a\x0afunction tabbable_find(context) {\x0a  return find(context).filter(isTabbableIndex).map(mapElementToObjectTabbable).sort(compareObjectTabbables).map(mapObjectTabbableToElement).reduce(createStatefulCollapseRadioGroup(), []);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/dom/build-module/dom.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Browser dependencies\x0a */\x0a\x0avar _window = window,\x0a    getComputedStyle = _window.getComputedStyle;\x0avar _window$Node = window.Node,\x0a    TEXT_NODE = _window$Node.TEXT_NODE,\x0a    ELEMENT_NODE = _window$Node.ELEMENT_NODE,\x0a    DOCUMENT_POSITION_PRECEDING = _window$Node.DOCUMENT_POSITION_PRECEDING,\x0a    DOCUMENT_POSITION_FOLLOWING = _window$Node.DOCUMENT_POSITION_FOLLOWING;\x0a/**\x0a * Returns true if the given selection object is in the forward direction, or\x0a * false otherwise.\x0a *\x0a * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\x0a *\x0a * @param {Selection} selection Selection object to check.\x0a *\x0a * @return {boolean} Whether the selection is forward.\x0a */\x0a\x0afunction isSelectionForward(selection) {\x0a  var anchorNode = selection.anchorNode,\x0a      focusNode = selection.focusNode,\x0a      anchorOffset = selection.anchorOffset,\x0a      focusOffset = selection.focusOffset;\x0a  var position = anchorNode.compareDocumentPosition(focusNode); // Disable reason: `Node#compareDocumentPosition` returns a bitmask value,\x0a  // so bitwise operators are intended.\x0a\x0a  /* eslint-disable no-bitwise */\x0a  // Compare whether anchor node precedes focus node. If focus node (where\x0a  // end of selection occurs) is after the anchor node, it is forward.\x0a\x0a  if (position & DOCUMENT_POSITION_PRECEDING) {\x0a    return false;\x0a  }\x0a\x0a  if (position & DOCUMENT_POSITION_FOLLOWING) {\x0a    return true;\x0a  }\x0a  /* eslint-enable no-bitwise */\x0a  // `compareDocumentPosition` returns 0 when passed the same node, in which\x0a  // case compare offsets.\x0a\x0a\x0a  if (position === 0) {\x0a    return anchorOffset \x3c= focusOffset;\x0a  } // This should never be reached, but return true as default case.\x0a\x0a\x0a  return true;\x0a}\x0a/**\x0a * Check whether the selection is at the edge of the container. Checks for\x0a * horizontal position by default. Set `onlyVertical` to true to check only\x0a * vertically.\x0a *\x0a * @param {Element} container    Focusable element.\x0a * @param {boolean} isReverse    Set to true to check left, false to check right.\x0a * @param {boolean} onlyVertical Set to true to check only vertical position.\x0a *\x0a * @return {boolean} True if at the edge, false if not.\x0a */\x0a\x0a\x0afunction isEdge(container, isReverse, onlyVertical) {\x0a  if (Object(external_lodash_[\x22includes\x22])([\x27INPUT\x27, \x27TEXTAREA\x27], container.tagName)) {\x0a    if (container.selectionStart !== container.selectionEnd) {\x0a      return false;\x0a    }\x0a\x0a    if (isReverse) {\x0a      return container.selectionStart === 0;\x0a    }\x0a\x0a    return container.value.length === container.selectionStart;\x0a  }\x0a\x0a  if (!container.isContentEditable) {\x0a    return true;\x0a  }\x0a\x0a  var selection = window.getSelection();\x0a\x0a  if (!selection.rangeCount) {\x0a    return false;\x0a  }\x0a\x0a  var range = selection.getRangeAt(0).cloneRange();\x0a  var isForward = isSelectionForward(selection);\x0a  var isCollapsed = selection.isCollapsed; // Collapse in direction of selection.\x0a\x0a  if (!isCollapsed) {\x0a    range.collapse(!isForward);\x0a  }\x0a\x0a  var rangeRect = getRectangleFromRange(range);\x0a\x0a  if (!rangeRect) {\x0a    return false;\x0a  }\x0a\x0a  var computedStyle = window.getComputedStyle(container);\x0a  var lineHeight = parseInt(computedStyle.lineHeight, 10) || 0; // Only consider the multiline selection at the edge if the direction is\x0a  // towards the edge.\x0a\x0a  if (!isCollapsed && rangeRect.height \x3e lineHeight && isForward === isReverse) {\x0a    return false;\x0a  }\x0a\x0a  var padding = parseInt(computedStyle[\x22padding\x22.concat(isReverse ? \x27Top\x27 : \x27Bottom\x27)], 10) || 0; // Calculate a buffer that is half the line height. In some browsers, the\x0a  // selection rectangle may not fill the entire height of the line, so we add\x0a  // 3/4 the line height to the selection rectangle to ensure that it is well\x0a  // over its line boundary.\x0a\x0a  var buffer = 3 * parseInt(lineHeight, 10) / 4;\x0a  var containerRect = container.getBoundingClientRect();\x0a  var verticalEdge = isReverse ? containerRect.top + padding \x3e rangeRect.top - buffer : containerRect.bottom - padding \x3c rangeRect.bottom + buffer;\x0a\x0a  if (!verticalEdge) {\x0a    return false;\x0a  }\x0a\x0a  if (onlyVertical) {\x0a    return true;\x0a  } // In the case of RTL scripts, the horizontal edge is at the opposite side.\x0a\x0a\x0a  var direction = computedStyle.direction;\x0a  var isReverseDir = direction === \x27rtl\x27 ? !isReverse : isReverse; // To calculate the horizontal position, we insert a test range and see if\x0a  // this test range has the same horizontal position. This method proves to\x0a  // be better than a DOM-based calculation, because it ignores empty text\x0a  // nodes and a trailing line break element. In other words, we need to check\x0a  // visual positioning, not DOM positioning.\x0a\x0a  var x = isReverseDir ? containerRect.left + 1 : containerRect.right - 1;\x0a  var y = isReverse ? containerRect.top + buffer : containerRect.bottom - buffer;\x0a  var testRange = hiddenCaretRangeFromPoint(document, x, y, container);\x0a\x0a  if (!testRange) {\x0a    return false;\x0a  }\x0a\x0a  var side = isReverseDir ? \x27left\x27 : \x27right\x27;\x0a  var testRect = getRectangleFromRange(testRange);\x0a  return Math.round(testRect[side]) === Math.round(rangeRect[side]);\x0a}\x0a/**\x0a * Check whether the selection is horizontally at the edge of the container.\x0a *\x0a * @param {Element} container Focusable element.\x0a * @param {boolean} isReverse Set to true to check left, false for right.\x0a *\x0a * @return {boolean} True if at the horizontal edge, false if not.\x0a */\x0a\x0a\x0afunction isHorizontalEdge(container, isReverse) {\x0a  return isEdge(container, isReverse);\x0a}\x0a/**\x0a * Check whether the selection is vertically at the edge of the container.\x0a *\x0a * @param {Element} container Focusable element.\x0a * @param {boolean} isReverse Set to true to check top, false for bottom.\x0a *\x0a * @return {boolean} True if at the vertical edge, false if not.\x0a */\x0a\x0afunction isVerticalEdge(container, isReverse) {\x0a  return isEdge(container, isReverse, true);\x0a}\x0a/**\x0a * Get the rectangle of a given Range.\x0a *\x0a * @param {Range} range The range.\x0a *\x0a * @return {DOMRect} The rectangle.\x0a */\x0a\x0afunction getRectangleFromRange(range) {\x0a  // For uncollapsed ranges, get the rectangle that bounds the contents of the\x0a  // range; this a rectangle enclosing the union of the bounding rectangles\x0a  // for all the elements in the range.\x0a  if (!range.collapsed) {\x0a    return range.getBoundingClientRect();\x0a  }\x0a\x0a  var _range = range,\x0a      startContainer = _range.startContainer; // Correct invalid \x22BR\x22 ranges. The cannot contain any children.\x0a\x0a  if (startContainer.nodeName === \x27BR\x27) {\x0a    var parentNode = startContainer.parentNode;\x0a    var index = Array.from(parentNode.childNodes).indexOf(startContainer);\x0a    range = document.createRange();\x0a    range.setStart(parentNode, index);\x0a    range.setEnd(parentNode, index);\x0a  }\x0a\x0a  var rect = range.getClientRects()[0]; // If the collapsed range starts (and therefore ends) at an element node,\x0a  // `getClientRects` can be empty in some browsers. This can be resolved\x0a  // by adding a temporary text node with zero-width space to the range.\x0a  //\x0a  // See: https://stackoverflow.com/a/6847328/995445\x0a\x0a  if (!rect) {\x0a    var padNode = document.createTextNode(\x22\x5cu200B\x22); // Do not modify the live range.\x0a\x0a    range = range.cloneRange();\x0a    range.insertNode(padNode);\x0a    rect = range.getClientRects()[0];\x0a    padNode.parentNode.removeChild(padNode);\x0a  }\x0a\x0a  return rect;\x0a}\x0a/**\x0a * Get the rectangle for the selection in a container.\x0a *\x0a * @param {Element} container Editable container.\x0a *\x0a * @return {?DOMRect} The rectangle.\x0a */\x0a\x0afunction computeCaretRect(container) {\x0a  if (!container.isContentEditable) {\x0a    return;\x0a  }\x0a\x0a  var selection = window.getSelection();\x0a  var range = selection.rangeCount ? selection.getRangeAt(0) : null;\x0a\x0a  if (!range) {\x0a    return;\x0a  }\x0a\x0a  return getRectangleFromRange(range);\x0a}\x0a/**\x0a * Places the caret at start or end of a given element.\x0a *\x0a * @param {Element} container Focusable element.\x0a * @param {boolean} isReverse True for end, false for start.\x0a */\x0a\x0afunction placeCaretAtHorizontalEdge(container, isReverse) {\x0a  if (!container) {\x0a    return;\x0a  }\x0a\x0a  if (Object(external_lodash_[\x22includes\x22])([\x27INPUT\x27, \x27TEXTAREA\x27], container.tagName)) {\x0a    container.focus();\x0a\x0a    if (isReverse) {\x0a      container.selectionStart = container.value.length;\x0a      container.selectionEnd = container.value.length;\x0a    } else {\x0a      container.selectionStart = 0;\x0a      container.selectionEnd = 0;\x0a    }\x0a\x0a    return;\x0a  }\x0a\x0a  container.focus();\x0a\x0a  if (!container.isContentEditable) {\x0a    return;\x0a  } // Select on extent child of the container, not the container itself. This\x0a  // avoids the selection always being `endOffset` of 1 when placed at end,\x0a  // where `startContainer`, `endContainer` would always be container itself.\x0a\x0a\x0a  var rangeTarget = container[isReverse ? \x27lastChild\x27 : \x27firstChild\x27]; // If no range target, it implies that the container is empty. Focusing is\x0a  // sufficient for caret to be placed correctly.\x0a\x0a  if (!rangeTarget) {\x0a    return;\x0a  }\x0a\x0a  var selection = window.getSelection();\x0a  var range = document.createRange();\x0a  range.selectNodeContents(rangeTarget);\x0a  range.collapse(!isReverse);\x0a  selection.removeAllRanges();\x0a  selection.addRange(range);\x0a}\x0a/**\x0a * Polyfill.\x0a * Get a collapsed range for a given point.\x0a *\x0a * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\x0a *\x0a * @param {Document} doc The document of the range.\x0a * @param {number}    x   Horizontal position within the current viewport.\x0a * @param {number}    y   Vertical position within the current viewport.\x0a *\x0a * @return {?Range} The best range for the given point.\x0a */\x0a\x0afunction caretRangeFromPoint(doc, x, y) {\x0a  if (doc.caretRangeFromPoint) {\x0a    return doc.caretRangeFromPoint(x, y);\x0a  }\x0a\x0a  if (!doc.caretPositionFromPoint) {\x0a    return null;\x0a  }\x0a\x0a  var point = doc.caretPositionFromPoint(x, y); // If x or y are negative, outside viewport, or there is no text entry node.\x0a  // https://developer.mozilla.org/en-US/docs/Web/API/Document/caretRangeFromPoint\x0a\x0a  if (!point) {\x0a    return null;\x0a  }\x0a\x0a  var range = doc.createRange();\x0a  range.setStart(point.offsetNode, point.offset);\x0a  range.collapse(true);\x0a  return range;\x0a}\x0a/**\x0a * Get a collapsed range for a given point.\x0a * Gives the container a temporary high z-index (above any UI).\x0a * This is preferred over getting the UI nodes and set styles there.\x0a *\x0a * @param {Document} doc       The document of the range.\x0a * @param {number}    x         Horizontal position within the current viewport.\x0a * @param {number}    y         Vertical position within the current viewport.\x0a * @param {Element}  container Container in which the range is expected to be found.\x0a *\x0a * @return {?Range} The best range for the given point.\x0a */\x0a\x0a\x0afunction hiddenCaretRangeFromPoint(doc, x, y, container) {\x0a  container.style.zIndex = \x2710000\x27;\x0a  var range = caretRangeFromPoint(doc, x, y);\x0a  container.style.zIndex = null;\x0a  return range;\x0a}\x0a/**\x0a * Places the caret at the top or bottom of a given element.\x0a *\x0a * @param {Element} container           Focusable element.\x0a * @param {boolean} isReverse           True for bottom, false for top.\x0a * @param {DOMRect} [rect]              The rectangle to position the caret with.\x0a * @param {boolean} [mayUseScroll=true] True to allow scrolling, false to disallow.\x0a */\x0a\x0a\x0afunction placeCaretAtVerticalEdge(container, isReverse, rect) {\x0a  var mayUseScroll = arguments.length \x3e 3 && arguments[3] !== undefined ? arguments[3] : true;\x0a\x0a  if (!container) {\x0a    return;\x0a  }\x0a\x0a  if (!rect || !container.isContentEditable) {\x0a    placeCaretAtHorizontalEdge(container, isReverse);\x0a    return;\x0a  } // Offset by a buffer half the height of the caret rect. This is needed\x0a  // because caretRangeFromPoint may default to the end of the selection if\x0a  // offset is too close to the edge. It\x27s unclear how to precisely calculate\x0a  // this threshold; it may be the padded area of some combination of line\x0a  // height, caret height, and font size. The buffer offset is effectively\x0a  // equivalent to a point at half the height of a line of text.\x0a\x0a\x0a  var buffer = rect.height / 2;\x0a  var editableRect = container.getBoundingClientRect();\x0a  var x = rect.left;\x0a  var y = isReverse ? editableRect.bottom - buffer : editableRect.top + buffer;\x0a  var range = hiddenCaretRangeFromPoint(document, x, y, container);\x0a\x0a  if (!range || !container.contains(range.startContainer)) {\x0a    if (mayUseScroll && (!range || !range.startContainer || !range.startContainer.contains(container))) {\x0a      // Might be out of view.\x0a      // Easier than attempting to calculate manually.\x0a      container.scrollIntoView(isReverse);\x0a      placeCaretAtVerticalEdge(container, isReverse, rect, false);\x0a      return;\x0a    }\x0a\x0a    placeCaretAtHorizontalEdge(container, isReverse);\x0a    return;\x0a  } // Check if the closest text node is actually further away.\x0a  // If so, attempt to get the range again with the y position adjusted to get the right offset.\x0a\x0a\x0a  if (range.startContainer.nodeType === TEXT_NODE) {\x0a    var parentNode = range.startContainer.parentNode;\x0a    var parentRect = parentNode.getBoundingClientRect();\x0a    var side = isReverse ? \x27bottom\x27 : \x27top\x27;\x0a    var padding = parseInt(getComputedStyle(parentNode).getPropertyValue(\x22padding-\x22.concat(side)), 10) || 0;\x0a    var actualY = isReverse ? parentRect.bottom - padding - buffer : parentRect.top + padding + buffer;\x0a\x0a    if (y !== actualY) {\x0a      range = hiddenCaretRangeFromPoint(document, x, actualY, container);\x0a    }\x0a  }\x0a\x0a  var selection = window.getSelection();\x0a  selection.removeAllRanges();\x0a  selection.addRange(range);\x0a  container.focus(); // Editable was already focussed, it goes back to old range...\x0a  // This fixes it.\x0a\x0a  selection.removeAllRanges();\x0a  selection.addRange(range);\x0a}\x0a/**\x0a * Check whether the given element is a text field, where text field is defined\x0a * by the ability to select within the input, or that it is contenteditable.\x0a *\x0a * See: https://html.spec.whatwg.org/#textFieldSelection\x0a *\x0a * @param {HTMLElement} element The HTML element.\x0a *\x0a * @return {boolean} True if the element is an text field, false if not.\x0a */\x0a\x0afunction isTextField(element) {\x0a  try {\x0a    var nodeName = element.nodeName,\x0a        selectionStart = element.selectionStart,\x0a        contentEditable = element.contentEditable;\x0a    return nodeName === \x27INPUT\x27 && selectionStart !== null || nodeName === \x27TEXTAREA\x27 || contentEditable === \x27true\x27;\x0a  } catch (error) {\x0a    // Safari throws an exception when trying to get `selectionStart`\x0a    // on non-text \x3cinput\x3e elements (which, understandably, don\x27t\x0a    // have the text selection API). We catch this via a try/catch\x0a    // block, as opposed to a more explicit check of the element\x27s\x0a    // input types, because of Safari\x27s non-standard behavior. This\x0a    // also means we don\x27t have to worry about the list of input\x0a    // types that support `selectionStart` changing as the HTML spec\x0a    // evolves over time.\x0a    return false;\x0a  }\x0a}\x0a/**\x0a * Check wether the current document has a selection.\x0a * This checks both for focus in an input field and general text selection.\x0a *\x0a * @return {boolean} True if there is selection, false if not.\x0a */\x0a\x0afunction documentHasSelection() {\x0a  if (isTextField(document.activeElement)) {\x0a    return true;\x0a  }\x0a\x0a  var selection = window.getSelection();\x0a  var range = selection.rangeCount ? selection.getRangeAt(0) : null;\x0a  return range && !range.collapsed;\x0a}\x0a/**\x0a * Check whether the contents of the element have been entirely selected.\x0a * Returns true if there is no possibility of selection.\x0a *\x0a * @param {Element} element The element to check.\x0a *\x0a * @return {boolean} True if entirely selected, false if not.\x0a */\x0a\x0afunction isEntirelySelected(element) {\x0a  if (Object(external_lodash_[\x22includes\x22])([\x27INPUT\x27, \x27TEXTAREA\x27], element.nodeName)) {\x0a    return element.selectionStart === 0 && element.value.length === element.selectionEnd;\x0a  }\x0a\x0a  if (!element.isContentEditable) {\x0a    return true;\x0a  }\x0a\x0a  var selection = window.getSelection();\x0a  var range = selection.rangeCount ? selection.getRangeAt(0) : null;\x0a\x0a  if (!range) {\x0a    return true;\x0a  }\x0a\x0a  var startContainer = range.startContainer,\x0a      endContainer = range.endContainer,\x0a      startOffset = range.startOffset,\x0a      endOffset = range.endOffset;\x0a\x0a  if (startContainer === element && endContainer === element && startOffset === 0 && endOffset === element.childNodes.length) {\x0a    return true;\x0a  }\x0a\x0a  var lastChild = element.lastChild;\x0a  var lastChildContentLength = lastChild.nodeType === TEXT_NODE ? lastChild.data.length : lastChild.childNodes.length;\x0a  return startContainer === element.firstChild && endContainer === element.lastChild && startOffset === 0 && endOffset === lastChildContentLength;\x0a}\x0a/**\x0a * Given a DOM node, finds the closest scrollable container node.\x0a *\x0a * @param {Element} node Node from which to start.\x0a *\x0a * @return {?Element} Scrollable container node, if found.\x0a */\x0a\x0afunction getScrollContainer(node) {\x0a  if (!node) {\x0a    return;\x0a  } // Scrollable if scrollable height exceeds displayed...\x0a\x0a\x0a  if (node.scrollHeight \x3e node.clientHeight) {\x0a    // ...except when overflow is defined to be hidden or visible\x0a    var _window$getComputedSt = window.getComputedStyle(node),\x0a        overflowY = _window$getComputedSt.overflowY;\x0a\x0a    if (/(auto|scroll)/.test(overflowY)) {\x0a      return node;\x0a    }\x0a  } // Continue traversing\x0a\x0a\x0a  return getScrollContainer(node.parentNode);\x0a}\x0a/**\x0a * Returns the closest positioned element, or null under any of the conditions\x0a * of the offsetParent specification. Unlike offsetParent, this function is not\x0a * limited to HTMLElement and accepts any Node (e.g. Node.TEXT_NODE).\x0a *\x0a * @see https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetparent\x0a *\x0a * @param {Node} node Node from which to find offset parent.\x0a *\x0a * @return {?Node} Offset parent.\x0a */\x0a\x0afunction getOffsetParent(node) {\x0a  // Cannot retrieve computed style or offset parent only anything other than\x0a  // an element node, so find the closest element node.\x0a  var closestElement;\x0a\x0a  while (closestElement = node.parentNode) {\x0a    if (closestElement.nodeType === ELEMENT_NODE) {\x0a      break;\x0a    }\x0a  }\x0a\x0a  if (!closestElement) {\x0a    return null;\x0a  } // If the closest element is already positioned, return it, as offsetParent\x0a  // does not otherwise consider the node itself.\x0a\x0a\x0a  if (getComputedStyle(closestElement).position !== \x27static\x27) {\x0a    return closestElement;\x0a  }\x0a\x0a  return closestElement.offsetParent;\x0a}\x0a/**\x0a * Given two DOM nodes, replaces the former with the latter in the DOM.\x0a *\x0a * @param {Element} processedNode Node to be removed.\x0a * @param {Element} newNode       Node to be inserted in its place.\x0a * @return {void}\x0a */\x0a\x0afunction replace(processedNode, newNode) {\x0a  insertAfter(newNode, processedNode.parentNode);\x0a  remove(processedNode);\x0a}\x0a/**\x0a * Given a DOM node, removes it from the DOM.\x0a *\x0a * @param {Element} node Node to be removed.\x0a * @return {void}\x0a */\x0a\x0afunction remove(node) {\x0a  node.parentNode.removeChild(node);\x0a}\x0a/**\x0a * Given two DOM nodes, inserts the former in the DOM as the next sibling of\x0a * the latter.\x0a *\x0a * @param {Element} newNode       Node to be inserted.\x0a * @param {Element} referenceNode Node after which to perform the insertion.\x0a * @return {void}\x0a */\x0a\x0afunction insertAfter(newNode, referenceNode) {\x0a  referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\x0a}\x0a/**\x0a * Unwrap the given node. This means any child nodes are moved to the parent.\x0a *\x0a * @param {Node} node The node to unwrap.\x0a *\x0a * @return {void}\x0a */\x0a\x0afunction unwrap(node) {\x0a  var parent = node.parentNode;\x0a\x0a  while (node.firstChild) {\x0a    parent.insertBefore(node.firstChild, node);\x0a  }\x0a\x0a  parent.removeChild(node);\x0a}\x0a/**\x0a * Replaces the given node with a new node with the given tag name.\x0a *\x0a * @param {Element}  node    The node to replace\x0a * @param {string}   tagName The new tag name.\x0a *\x0a * @return {Element} The new node.\x0a */\x0a\x0afunction replaceTag(node, tagName) {\x0a  var newNode = node.ownerDocument.createElement(tagName);\x0a\x0a  while (node.firstChild) {\x0a    newNode.appendChild(node.firstChild);\x0a  }\x0a\x0a  node.parentNode.replaceChild(newNode, node);\x0a  return newNode;\x0a}\x0a/**\x0a * Wraps the given node with a new node with the given tag name.\x0a *\x0a * @param {Element} newNode       The node to insert.\x0a * @param {Element} referenceNode The node to wrap.\x0a */\x0a\x0afunction wrap(newNode, referenceNode) {\x0a  referenceNode.parentNode.insertBefore(newNode, referenceNode);\x0a  newNode.appendChild(referenceNode);\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/dom/build-module/index.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22focus\x22, function() { return build_module_focus; });\x0a/* concated harmony reexport isHorizontalEdge */__webpack_require__.d(__webpack_exports__, \x22isHorizontalEdge\x22, function() { return isHorizontalEdge; });\x0a/* concated harmony reexport isVerticalEdge */__webpack_require__.d(__webpack_exports__, \x22isVerticalEdge\x22, function() { return isVerticalEdge; });\x0a/* concated harmony reexport getRectangleFromRange */__webpack_require__.d(__webpack_exports__, \x22getRectangleFromRange\x22, function() { return getRectangleFromRange; });\x0a/* concated harmony reexport computeCaretRect */__webpack_require__.d(__webpack_exports__, \x22computeCaretRect\x22, function() { return computeCaretRect; });\x0a/* concated harmony reexport placeCaretAtHorizontalEdge */__webpack_require__.d(__webpack_exports__, \x22placeCaretAtHorizontalEdge\x22, function() { return placeCaretAtHorizontalEdge; });\x0a/* concated harmony reexport placeCaretAtVerticalEdge */__webpack_require__.d(__webpack_exports__, \x22placeCaretAtVerticalEdge\x22, function() { return placeCaretAtVerticalEdge; });\x0a/* concated harmony reexport isTextField */__webpack_require__.d(__webpack_exports__, \x22isTextField\x22, function() { return isTextField; });\x0a/* concated harmony reexport documentHasSelection */__webpack_require__.d(__webpack_exports__, \x22documentHasSelection\x22, function() { return documentHasSelection; });\x0a/* concated harmony reexport isEntirelySelected */__webpack_require__.d(__webpack_exports__, \x22isEntirelySelected\x22, function() { return isEntirelySelected; });\x0a/* concated harmony reexport getScrollContainer */__webpack_require__.d(__webpack_exports__, \x22getScrollContainer\x22, function() { return getScrollContainer; });\x0a/* concated harmony reexport getOffsetParent */__webpack_require__.d(__webpack_exports__, \x22getOffsetParent\x22, function() { return getOffsetParent; });\x0a/* concated harmony reexport replace */__webpack_require__.d(__webpack_exports__, \x22replace\x22, function() { return replace; });\x0a/* concated harmony reexport remove */__webpack_require__.d(__webpack_exports__, \x22remove\x22, function() { return remove; });\x0a/* concated harmony reexport insertAfter */__webpack_require__.d(__webpack_exports__, \x22insertAfter\x22, function() { return insertAfter; });\x0a/* concated harmony reexport unwrap */__webpack_require__.d(__webpack_exports__, \x22unwrap\x22, function() { return unwrap; });\x0a/* concated harmony reexport replaceTag */__webpack_require__.d(__webpack_exports__, \x22replaceTag\x22, function() { return replaceTag; });\x0a/* concated harmony reexport wrap */__webpack_require__.d(__webpack_exports__, \x22wrap\x22, function() { return wrap; });\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a/**\x0a * Object grouping `focusable` and `tabbable` utils\x0a * under the keys with the same name.\x0a */\x0a\x0avar build_module_focus = {\x0a  focusable: focusable_namespaceObject,\x0a  tabbable: tabbable_namespaceObject\x0a};\x0a\x0a\x0a\x0a/***/ })\x0a\x0a/******/ });'}