var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:11:19 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Mon, 22 Apr 2019 12:40:04 GMT\x0aETag: \x22a554-5871dc47ed100-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-10714/10715\x0aContent-Length: 10715\x0aConnection: close\x0aContent-Type: application/javascript\x0a\x0athis[\x22wp\x22] = this[\x22wp\x22] || {}; this[\x22wp\x22][\x22annotations\x22] =\x0a/******/ (function(modules) { // webpackBootstrap\x0a/******/ \x09// The module cache\x0a/******/ \x09var installedModules = {};\x0a/******/\x0a/******/ \x09// The require function\x0a/******/ \x09function __webpack_require__(moduleId) {\x0a/******/\x0a/******/ \x09\x09// Check if module is in cache\x0a/******/ \x09\x09if(installedModules[moduleId]) {\x0a/******/ \x09\x09\x09return installedModules[moduleId].exports;\x0a/******/ \x09\x09}\x0a/******/ \x09\x09// Create a new module (and put it into the cache)\x0a/******/ \x09\x09var module = installedModules[moduleId] = {\x0a/******/ \x09\x09\x09i: moduleId,\x0a/******/ \x09\x09\x09l: false,\x0a/******/ \x09\x09\x09exports: {}\x0a/******/ \x09\x09};\x0a/******/\x0a/******/ \x09\x09// Execute the module function\x0a/******/ \x09\x09modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\x0a/******/\x0a/******/ \x09\x09// Flag the module as loaded\x0a/******/ \x09\x09module.l = true;\x0a/******/\x0a/******/ \x09\x09// Return the exports of the module\x0a/******/ \x09\x09return module.exports;\x0a/******/ \x09}\x0a/******/\x0a/******/\x0a/******/ \x09// expose the modules object (__webpack_modules__)\x0a/******/ \x09__webpack_require__.m = modules;\x0a/******/\x0a/******/ \x09// expose the module cache\x0a/******/ \x09__webpack_require__.c = installedModules;\x0a/******/\x0a/******/ \x09// define getter function for harmony exports\x0a/******/ \x09__webpack_require__.d = function(exports, name, getter) {\x0a/******/ \x09\x09if(!__webpack_require__.o(exports, name)) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, name, { enumerable: true, get: getter });\x0a/******/ \x09\x09}\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// define __esModule on exports\x0a/******/ \x09__webpack_require__.r = function(exports) {\x0a/******/ \x09\x09if(typeof Symbol !== \x27undefined\x27 && Symbol.toStringTag) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, Symbol.toStringTag, { value: \x27Module\x27 });\x0a/******/ \x09\x09}\x0a/******/ \x09\x09Object.defineProperty(exports, \x27__esModule\x27, { value: true });\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// create a fake namespace object\x0a/******/ \x09// mode & 1: value is a module id, require it\x0a/******/ \x09// mode & 2: merge all properties of value into the ns\x0a/******/ \x09// mode & 4: return value when already ns object\x0a/******/ \x09// mode & 8|1: behave like require\x0a/******/ \x09__webpack_require__.t = function(value, mode) {\x0a/******/ \x09\x09if(mode & 1) value = __webpack_require__(value);\x0a/******/ \x09\x09if(mode & 8) return value;\x0a/******/ \x09\x09if((mode & 4) && typeof value === \x27object\x27 && value && value.__esModule) return value;\x0a/******/ \x09\x09var ns = Object.create(null);\x0a/******/ \x09\x09__webpack_require__.r(ns);\x0a/******/ \x09\x09Object.defineProperty(ns, \x27default\x27, { enumerable: true, value: value });\x0a/******/ \x09\x09if(mode & 2 && typeof value != \x27string\x27) for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\x0a/******/ \x09\x09return ns;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// getDefaultExport function for compatibility with non-harmony modules\x0a/******/ \x09__webpack_require__.n = function(module) {\x0a/******/ \x09\x09var getter = module && module.__esModule ?\x0a/******/ \x09\x09\x09function getDefault() { return module[\x27default\x27]; } :\x0a/******/ \x09\x09\x09function getModuleExports() { return module; };\x0a/******/ \x09\x09__webpack_require__.d(getter, \x27a\x27, getter);\x0a/******/ \x09\x09return getter;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// Object.prototype.hasOwnProperty.call\x0a/******/ \x09__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\x0a/******/\x0a/******/ \x09// __webpack_public_path__\x0a/******/ \x09__webpack_require__.p = \x22\x22;\x0a/******/\x0a/******/\x0a/******/ \x09// Load entry module and return exports\x0a/******/ \x09return __webpack_require__(__webpack_require__.s = 370);\x0a/******/ })\x0a/************************************************************************/\x0a/******/ ({\x0a\x0a/***/ 1:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22i18n\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 15:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _defineProperty; });\x0afunction _defineProperty(obj, key, value) {\x0a  if (key in obj) {\x0a    Object.defineProperty(obj, key, {\x0a      value: value,\x0a      enumerable: true,\x0a      configurable: true,\x0a      writable: true\x0a    });\x0a  } else {\x0a    obj[key] = value;\x0a  }\x0a\x0a  return obj;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 17:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\x0afunction _arrayWithoutHoles(arr) {\x0a  if (Array.isArray(arr)) {\x0a    for (var i = 0, arr2 = new Array(arr.length); i \x3c arr.length; i++) {\x0a      arr2[i] = arr[i];\x0a    }\x0a\x0a    return arr2;\x0a  }\x0a}\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js\x0avar iterableToArray = __webpack_require__(34);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\x0afunction _nonIterableSpread() {\x0a  throw new TypeError(\x22Invalid attempt to spread non-iterable instance\x22);\x0a}\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _toConsumableArray; });\x0a\x0a\x0a\x0afunction _toConsumableArray(arr) {\x0a  return _arrayWithoutHoles(arr) || Object(iterableToArray[\x22a\x22 /* default */])(arr) || _nonIterableSpread();\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 2:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22lodash\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 20:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22richText\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 21:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\x0afunction _objectWithoutPropertiesLoose(source, excluded) {\x0a  if (source == null) return {};\x0a  var target = {};\x0a  var sourceKeys = Object.keys(source);\x0a  var key, i;\x0a\x0a  for (i = 0; i \x3c sourceKeys.length; i++) {\x0a    key = sourceKeys[i];\x0a    if (excluded.indexOf(key) \x3e= 0) continue;\x0a    target[key] = source[key];\x0a  }\x0a\x0a  return target;\x0a}\x0a// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _objectWithoutProperties; });\x0a\x0afunction _objectWithoutProperties(source, excluded) {\x0a  if (source == null) return {};\x0a  var target = _objectWithoutPropertiesLoose(source, excluded);\x0a  var key, i;\x0a\x0a  if (Object.getOwnPropertySymbols) {\x0a    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\x0a\x0a    for (i = 0; i \x3c sourceSymbolKeys.length; i++) {\x0a      key = sourceSymbolKeys[i];\x0a      if (excluded.indexOf(key) \x3e= 0) continue;\x0a      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\x0a      target[key] = source[key];\x0a    }\x0a  }\x0a\x0a  return target;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 26:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22hooks\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 30:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a\x0a\x0avar LEAF_KEY, hasWeakMap;\x0a\x0a/**\x0a * Arbitrary value used as key for referencing cache object in WeakMap tree.\x0a *\x0a * @type {Object}\x0a */\x0aLEAF_KEY = {};\x0a\x0a/**\x0a * Whether environment supports WeakMap.\x0a *\x0a * @type {boolean}\x0a */\x0ahasWeakMap = typeof WeakMap !== \x27undefined\x27;\x0a\x0a/**\x0a * Returns the first argument as the sole entry in an array.\x0a *\x0a * @param {*} value Value to return.\x0a *\x0a * @return {Array} Value returned as entry in array.\x0a */\x0afunction arrayOf( value ) {\x0a\x09return [ value ];\x0a}\x0a\x0a/**\x0a * Returns true if the value passed is object-like, or false otherwise. A value\x0a * is object-like if it can support property assignment, e.g. object or array.\x0a *\x0a * @param {*} value Value to test.\x0a *\x0a * @return {boolean} Whether value is object-like.\x0a */\x0afunction isObjectLike( value ) {\x0a\x09return !! value && \x27object\x27 === typeof value;\x0a}\x0a\x0a/**\x0a * Creates and returns a new cache object.\x0a *\x0a * @return {Object} Cache object.\x0a */\x0afunction createCache() {\x0a\x09var cache = {\x0a\x09\x09clear: function() {\x0a\x09\x09\x09cache.head = null;\x0a\x09\x09},\x0a\x09};\x0a\x0a\x09return cache;\x0a}\x0a\x0a/**\x0a * Returns true if entries within the two arrays are strictly equal by\x0a * reference from a starting index.\x0a *\x0a * @param {Array}  a         First array.\x0a * @param {Array}  b         Second array.\x0a * @param {number} fromIndex Index from which to start comparison.\x0a *\x0a * @return {boolean} Whether arrays are shallowly equal.\x0a */\x0afunction isShallowEqual( a, b, fromIndex ) {\x0a\x09var i;\x0a\x0a\x09if ( a.length !== b.length ) {\x0a\x09\x09return false;\x0a\x09}\x0a\x0a\x09for ( i = fromIndex; i \x3c a.length; i++ ) {\x0a\x09\x09if ( a[ i ] !== b[ i ] ) {\x0a\x09\x09\x09return false;\x0a\x09\x09}\x0a\x09}\x0a\x0a\x09return true;\x0a}\x0a\x0a/**\x0a * Returns a memoized selector function. The getDependants function argument is\x0a * called before the memoized selector and is expected to return an immutable\x0a * reference or array of references on which the selector depends for computing\x0a * its own return value. The memoize cache is preserved only as long as those\x0a * dependant references remain the same. If getDependants returns a different\x0a * reference(s), the cache is cleared and the selector value regenerated.\x0a *\x0a * @param {Function} selector      Selector function.\x0a * @param {Function} getDependants Dependant getter returning an immutable\x0a *                                 reference or array of reference used in\x0a *                                 cache bust consideration.\x0a *\x0a * @return {Function} Memoized selector.\x0a */\x0a/* harmony default export */ __webpack_exports__[\x22a\x22] = (function( selector, getDependants ) {\x0a\x09var rootCache, getCache;\x0a\x0a\x09// Use object source as dependant if getter not provided\x0a\x09if ( ! getDependants ) {\x0a\x09\x09getDependants = arrayOf;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Returns the root cache. If WeakMap is supported, this is assigned to the\x0a\x09 * root WeakMap cache set, otherwise it is a shared instance of the default\x0a\x09 * cache object.\x0a\x09 *\x0a\x09 * @return {(WeakMap|Object)} Root cache object.\x0a\x09 */\x0a\x09function getRootCache() {\x0a\x09\x09return rootCache;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * Returns the cache for a given dependants array. When possible, a WeakMap\x0a\x09 * will be used to create a unique cache for each set of dependants. This\x0a\x09 * is feasible due to the nature of WeakMap in allowing garbage collection\x0a\x09 * to occur on entries where the key object is no longer referenced. Since\x0a\x09 * WeakMap requires the key to be an object, this is only possible when the\x0a\x09 * dependant is object-like. The root cache is created as a hierarchy where\x0a\x09 * each top-level key is the first entry in a dependants set, the value a\x0a\x09 * WeakMap where each key is the next dependant, and so on. This continues\x0a\x09 * so long as the dependants are object-like. If no dependants are object-\x0a\x09 * like, then the cache is shared across all invocations.\x0a\x09 *\x0a\x09 * @see isObjectLike\x0a\x09 *\x0a\x09 * @param {Array} dependants Selector dependants.\x0a\x09 *\x0a\x09 * @return {Object} Cache object.\x0a\x09 */\x0a\x09function getWeakMapCache( dependants ) {\x0a\x09\x09var caches = rootCache,\x0a\x09\x09\x09isUniqueByDependants = true,\x0a\x09\x09\x09i, dependant, map, cache;\x0a\x0a\x09\x09for ( i = 0; i \x3c dependants.length; i++ ) {\x0a\x09\x09\x09dependant = dependants[ i ];\x0a\x0a\x09\x09\x09// Can only compose WeakMap from object-like key.\x0a\x09\x09\x09if ( ! isObjectLike( dependant ) ) {\x0a\x09\x09\x09\x09isUniqueByDependants = false;\x0a\x09\x09\x09\x09break;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Does current segment of cache already have a WeakMap?\x0a\x09\x09\x09if ( caches.has( dependant ) ) {\x0a\x09\x09\x09\x09// Traverse into nested WeakMap.\x0a\x09\x09\x09\x09caches = caches.get( dependant );\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09// Create, set, and traverse into a new one.\x0a\x09\x09\x09\x09map = new WeakMap();\x0a\x09\x09\x09\x09caches.set( dependant, map );\x0a\x09\x09\x09\x09caches = map;\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09// We use an arbitrary (but consistent) object as key for the last item\x0a\x09\x09// in the WeakMap to serve as our running cache.\x0a\x09\x09if ( ! caches.has( LEAF_KEY ) ) {\x0a\x09\x09\x09cache = createCache();\x0a\x09\x09\x09cache.isUniqueByDependants = isUniqueByDependants;\x0a\x09\x09\x09caches.set( LEAF_KEY, cache );\x0a\x09\x09}\x0a\x0a\x09\x09return caches.get( LEAF_KEY );\x0a\x09}\x0a\x0a\x09// Assign cache handler by availability of WeakMap\x0a\x09getCache = hasWeakMap ? getWeakMapCache : getRootCache;\x0a\x0a\x09/**\x0a\x09 * Resets root memoization cache.\x0a\x09 */\x0a\x09function clear() {\x0a\x09\x09rootCache = hasWeakMap ? new WeakMap() : createCache();\x0a\x09}\x0a\x0a\x09// eslint-disable-next-line jsdoc/check-param-names\x0a\x09/**\x0a\x09 * The augmented selector call, considering first whether dependants have\x0a\x09 * changed before passing it to underlying memoize function.\x0a\x09 *\x0a\x09 * @param {Object} source    Source object for derivation.\x0a\x09 * @param {...*}   extraArgs Additional arguments to pass to selector.\x0a\x09 *\x0a\x09 * @return {*} Selector result.\x0a\x09 */\x0a\x09function callSelector( /* source, ...extraArgs */ ) {\x0a\x09\x09var len = arguments.length,\x0a\x09\x09\x09cache, node, i, args, dependants;\x0a\x0a\x09\x09// Create copy of arguments (avoid leaking deoptimization).\x0a\x09\x09args = new Array( len );\x0a\x09\x09for ( i = 0; i \x3c len; i++ ) {\x0a\x09\x09\x09args[ i ] = arguments[ i ];\x0a\x09\x09}\x0a\x0a\x09\x09dependants = getDependants.apply( null, args );\x0a\x09\x09cache = getCache( dependants );\x0a\x0a\x09\x09// If not guaranteed uniqueness by dependants (primitive type or lack\x0a\x09\x09// of WeakMap support), shallow compare against last dependants and, if\x0a\x09\x09// references have changed, destroy cache to recalculate result.\x0a\x09\x09if ( ! cache.isUniqueByDependants ) {\x0a\x09\x09\x09if ( cache.lastDependants && ! isShallowEqual( dependants, cache.lastDependants, 0 ) ) {\x0a\x09\x09\x09\x09cache.clear();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09cache.lastDependants = dependants;\x0a\x09\x09}\x0a\x0a\x09\x09node = cache.head;\x0a\x09\x09while ( node ) {\x0a\x09\x09\x09// Check whether node arguments match arguments\x0a\x09\x09\x09if ( ! isShallowEqual( node.args, args, 1 ) ) {\x0a\x09\x09\x09\x09node = node.next;\x0a\x09\x09\x09\x09continue;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// At this point we can assume we\x27ve found a match\x0a\x0a\x09\x09\x09// Surface matched node to head if not already\x0a\x09\x09\x09if ( node !== cache.head ) {\x0a\x09\x09\x09\x09// Adjust siblings to point to each other.\x0a\x09\x09\x09\x09node.prev.next = node.next;\x0a\x09\x09\x09\x09if ( node.next ) {\x0a\x09\x09\x09\x09\x09node.next.prev = node.prev;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09node.next = cache.head;\x0a\x09\x09\x09\x09node.prev = null;\x0a\x09\x09\x09\x09cache.head.prev = node;\x0a\x09\x09\x09\x09cache.head = node;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Return immediately\x0a\x09\x09\x09return node.val;\x0a\x09\x09}\x0a\x0a\x09\x09// No cached value found. Continue to insertion phase:\x0a\x0a\x09\x09node = {\x0a\x09\x09\x09// Generate the result from original function\x0a\x09\x09\x09val: selector.apply( null, args ),\x0a\x09\x09};\x0a\x0a\x09\x09// Avoid including the source object in the cache.\x0a\x09\x09args[ 0 ] = null;\x0a\x09\x09node.args = args;\x0a\x0a\x09\x09// Don\x27t need to check whether node is already head, since it would\x0a\x09\x09// have been returned above already if it was\x0a\x0a\x09\x09// Shift existing head down list\x0a\x09\x09if ( cache.head ) {\x0a\x09\x09\x09cache.head.prev = node;\x0a\x09\x09\x09node.next = cache.head;\x0a\x09\x09}\x0a\x0a\x09\x09cache.head = node;\x0a\x0a\x09\x09return node.val;\x0a\x09}\x0a\x0a\x09callSelector.getDependants = getDependants;\x0a\x09callSelector.clear = clear;\x0a\x09clear();\x0a\x0a\x09return callSelector;\x0a});\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 34:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _iterableToArray; });\x0afunction _iterableToArray(iter) {\x0a  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \x22[object Arguments]\x22) return Array.from(iter);\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 370:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0avar selectors_namespaceObject = {};\x0a__webpack_require__.r(selectors_namespaceObject);\x0a__webpack_require__.d(selectors_namespaceObject, \x22__experimentalGetAnnotationsForBlock\x22, function() { return __experimentalGetAnnotationsForBlock; });\x0a__webpack_require__.d(selectors_namespaceObject, \x22__experimentalGetAllAnnotationsForBlock\x22, function() { return selectors_experimentalGetAllAnnotationsForBlock; });\x0a__webpack_require__.d(selectors_namespaceObject, \x22__experimentalGetAnnotationsForRichText\x22, function() { return __experimentalGetAnnotationsForRichText; });\x0a__webpack_require__.d(selectors_namespaceObject, \x22__experimentalGetAnnotations\x22, function() { return __experimentalGetAnnotations; });\x0avar actions_namespaceObject = {};\x0a__webpack_require__.r(actions_namespaceObject);\x0a__webpack_require__.d(actions_namespaceObject, \x22__experimentalAddAnnotation\x22, function() { return __experimentalAddAnnotation; });\x0a__webpack_require__.d(actions_namespaceObject, \x22__experimentalRemoveAnnotation\x22, function() { return __experimentalRemoveAnnotation; });\x0a__webpack_require__.d(actions_namespaceObject, \x22__experimentalUpdateAnnotationRange\x22, function() { return __experimentalUpdateAnnotationRange; });\x0a__webpack_require__.d(actions_namespaceObject, \x22__experimentalRemoveAnnotationsBySource\x22, function() { return __experimentalRemoveAnnotationsBySource; });\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22data\x22]}\x0avar external_this_wp_data_ = __webpack_require__(5);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\x0avar defineProperty = __webpack_require__(15);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 2 modules\x0avar toConsumableArray = __webpack_require__(17);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread.js\x0avar objectSpread = __webpack_require__(7);\x0a\x0a// EXTERNAL MODULE: external \x22lodash\x22\x0avar external_lodash_ = __webpack_require__(2);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/annotations/build-module/store/reducer.js\x0a\x0a\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Filters an array based on the predicate, but keeps the reference the same if\x0a * the array hasn\x27t changed.\x0a *\x0a * @param {Array}    collection The collection to filter.\x0a * @param {Function} predicate  Function that determines if the item should stay\x0a *                              in the array.\x0a * @return {Array} Filtered array.\x0a */\x0a\x0afunction filterWithReference(collection, predicate) {\x0a  var filteredCollection = collection.filter(predicate);\x0a  return collection.length === filteredCollection.length ? collection : filteredCollection;\x0a}\x0a/**\x0a * Verifies whether the given annotations is a valid annotation.\x0a *\x0a * @param {Object} annotation The annotation to verify.\x0a * @return {boolean} Whether the given annotation is valid.\x0a */\x0a\x0a\x0afunction isValidAnnotationRange(annotation) {\x0a  return Object(external_lodash_[\x22isNumber\x22])(annotation.start) && Object(external_lodash_[\x22isNumber\x22])(annotation.end) && annotation.start \x3c= annotation.end;\x0a}\x0a/**\x0a * Reducer managing annotations.\x0a *\x0a * @param {Array} state The annotations currently shown in the editor.\x0a * @param {Object} action Dispatched action.\x0a *\x0a * @return {Array} Updated state.\x0a */\x0a\x0a\x0afunction reducer_annotations() {\x0a  var state = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : {};\x0a  var action = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a\x0a  switch (action.type) {\x0a    case \x27ANNOTATION_ADD\x27:\x0a      var blockClientId = action.blockClientId;\x0a      var newAnnotation = {\x0a        id: action.id,\x0a        blockClientId: blockClientId,\x0a        richTextIdentifier: action.richTextIdentifier,\x0a        source: action.source,\x0a        selector: action.selector,\x0a        range: action.range\x0a      };\x0a\x0a      if (newAnnotation.selector === \x27range\x27 && !isValidAnnotationRange(newAnnotation.range)) {\x0a        return state;\x0a      }\x0a\x0a      var previousAnnotationsForBlock = Object(external_lodash_[\x22get\x22])(state, blockClientId, []);\x0a      return Object(objectSpread[\x22a\x22 /* default */])({}, state, Object(defineProperty[\x22a\x22 /* default */])({}, blockClientId, [].concat(Object(toConsumableArray[\x22a\x22 /* default */])(previousAnnotationsForBlock), [newAnnotation])));\x0a\x0a    case \x27ANNOTATION_REMOVE\x27:\x0a      return Object(external_lodash_[\x22mapValues\x22])(state, function (annotationsForBlock) {\x0a        return filterWithReference(annotationsForBlock, function (annotation) {\x0a          return annotation.id !== action.annotationId;\x0a        });\x0a      });\x0a\x0a    case \x27ANNOTATION_UPDATE_RANGE\x27:\x0a      return Object(external_lodash_[\x22mapValues\x22])(state, function (annotationsForBlock) {\x0a        var hasChangedRange = false;\x0a        var newAnnotations = annotationsForBlock.map(function (annotation) {\x0a          if (annotation.id === action.annotationId) {\x0a            hasChangedRange = true;\x0a            return Object(objectSpread[\x22a\x22 /* default */])({}, annotation, {\x0a              range: {\x0a                start: action.start,\x0a                end: action.end\x0a              }\x0a            });\x0a          }\x0a\x0a          return annotation;\x0a        });\x0a        return hasChangedRange ? newAnnotations : annotationsForBlock;\x0a      });\x0a\x0a    case \x27ANNOTATION_REMOVE_SOURCE\x27:\x0a      return Object(external_lodash_[\x22mapValues\x22])(state, function (annotationsForBlock) {\x0a        return filterWithReference(annotationsForBlock, function (annotation) {\x0a          return annotation.source !== action.source;\x0a        });\x0a      });\x0a  }\x0a\x0a  return state;\x0a}\x0a/* harmony default export */ var reducer = (reducer_annotations);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js + 1 modules\x0avar objectWithoutProperties = __webpack_require__(21);\x0a\x0a// EXTERNAL MODULE: ./node_modules/rememo/es/rememo.js\x0avar rememo = __webpack_require__(30);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/annotations/build-module/store/selectors.js\x0a\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a\x0a/**\x0a * Shared reference to an empty array for cases where it is important to avoid\x0a * returning a new array reference on every invocation, as in a connected or\x0a * other pure component which performs `shouldComponentUpdate` check on props.\x0a * This should be used as a last resort, since the normalized data should be\x0a * maintained by the reducer result in state.\x0a *\x0a * @type {Array}\x0a */\x0a\x0avar EMPTY_ARRAY = [];\x0a/**\x0a * Returns the annotations for a specific client ID.\x0a *\x0a * @param {Object} state Editor state.\x0a * @param {string} clientId The ID of the block to get the annotations for.\x0a *\x0a * @return {Array} The annotations applicable to this block.\x0a */\x0a\x0avar __experimentalGetAnnotationsForBlock = Object(rememo[\x22a\x22 /* default */])(function (state, blockClientId) {\x0a  return Object(external_lodash_[\x22get\x22])(state, blockClientId, []).filter(function (annotation) {\x0a    return annotation.selector === \x27block\x27;\x0a  });\x0a}, function (state, blockClientId) {\x0a  return [Object(external_lodash_[\x22get\x22])(state, blockClientId, EMPTY_ARRAY)];\x0a});\x0avar selectors_experimentalGetAllAnnotationsForBlock = function __experimentalGetAllAnnotationsForBlock(state, blockClientId) {\x0a  return Object(external_lodash_[\x22get\x22])(state, blockClientId, EMPTY_ARRAY);\x0a};\x0a/**\x0a * Returns the annotations that apply to the given RichText instance.\x0a *\x0a * Both a blockClientId and a richTextIdentifier are required. This is because\x0a * a block might have multiple `RichText` components. This does mean that every\x0a * block needs to implement annotations itself.\x0a *\x0a * @param {Object} state              Editor state.\x0a * @param {string} blockClientId      The client ID for the block.\x0a * @param {string} richTextIdentifier Unique identifier that identifies the given RichText.\x0a * @return {Array} All the annotations relevant for the `RichText`.\x0a */\x0a\x0avar __experimentalGetAnnotationsForRichText = Object(rememo[\x22a\x22 /* default */])(function (state, blockClientId, richTextIdentifier) {\x0a  return Object(external_lodash_[\x22get\x22])(state, blockClientId, []).filter(function (annotation) {\x0a    return annotation.selector === \x27range\x27 && richTextIdentifier === annotation.richTextIdentifier;\x0a  }).map(function (annotation) {\x0a    var range = annotation.range,\x0a        other = Object(objectWithoutProperties[\x22a\x22 /* default */])(annotation, [\x22range\x22]);\x0a\x0a    return Object(objectSpread[\x22a\x22 /* default */])({}, range, other);\x0a  });\x0a}, function (state, blockClientId) {\x0a  return [Object(external_lodash_[\x22get\x22])(state, blockClientId, EMPTY_ARRAY)];\x0a});\x0a/**\x0a * Returns all annotations in the editor state.\x0a *\x0a * @param {Object} state Editor state.\x0a * @return {Array} All annotations currently applied.\x0a */\x0a\x0afunction __experimentalGetAnnotations(state) {\x0a  return Object(external_lodash_[\x22flatMap\x22])(state, function (annotations) {\x0a    return annotations;\x0a  });\x0a}\x0a\x0a// EXTERNAL MODULE: ./node_modules/uuid/v4.js\x0avar v4 = __webpack_require__(65);\x0avar v4_default = /*#__PURE__*/__webpack_require__.n(v4);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/annotations/build-module/store/actions.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * Adds an annotation to a block.\x0a *\x0a * The `block` attribute refers to a block ID that needs to be annotated.\x0a * `isBlockAnnotation` controls whether or not the annotation is a block\x0a * annotation. The `source` is the source of the annotation, this will be used\x0a * to identity groups of annotations.\x0a *\x0a * The `range` property is only relevant if the selector is \x27range\x27.\x0a *\x0a * @param {Object} annotation         The annotation to add.\x0a * @param {string} blockClientId      The blockClientId to add the annotation to.\x0a * @param {string} richTextIdentifier Identifier for the RichText instance the annotation applies to.\x0a * @param {Object} range              The range at which to apply this annotation.\x0a * @param {number} range.start        The offset where the annotation should start.\x0a * @param {number} range.end          The offset where the annotation should end.\x0a * @param {string} [selector=\x22range\x22] The way to apply this annotation.\x0a * @param {string} [source=\x22default\x22] The source that added the annotation.\x0a * @param {string} [id=uuid()]        The ID the annotation should have.\x0a *                                    Generates a UUID by default.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction __experimentalAddAnnotation(_ref) {\x0a  var blockClientId = _ref.blockClientId,\x0a      _ref$richTextIdentifi = _ref.richTextIdentifier,\x0a      richTextIdentifier = _ref$richTextIdentifi === void 0 ? null : _ref$richTextIdentifi,\x0a      _ref$range = _ref.range,\x0a      range = _ref$range === void 0 ? null : _ref$range,\x0a      _ref$selector = _ref.selector,\x0a      selector = _ref$selector === void 0 ? \x27range\x27 : _ref$selector,\x0a      _ref$source = _ref.source,\x0a      source = _ref$source === void 0 ? \x27default\x27 : _ref$source,\x0a      _ref$id = _ref.id,\x0a      id = _ref$id === void 0 ? v4_default()() : _ref$id;\x0a  var action = {\x0a    type: \x27ANNOTATION_ADD\x27,\x0a    id: id,\x0a    blockClientId: blockClientId,\x0a    richTextIdentifier: richTextIdentifier,\x0a    source: source,\x0a    selector: selector\x0a  };\x0a\x0a  if (selector === \x27range\x27) {\x0a    action.range = range;\x0a  }\x0a\x0a  return action;\x0a}\x0a/**\x0a * Removes an annotation with a specific ID.\x0a *\x0a * @param {string} annotationId The annotation to remove.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction __experimentalRemoveAnnotation(annotationId) {\x0a  return {\x0a    type: \x27ANNOTATION_REMOVE\x27,\x0a    annotationId: annotationId\x0a  };\x0a}\x0a/**\x0a * Updates the range of an annotation.\x0a *\x0a * @param {string} annotationId ID of the annotation to update.\x0a * @param {number} start The start of the new range.\x0a * @param {number} end The end of the new range.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction __experimentalUpdateAnnotationRange(annotationId, start, end) {\x0a  return {\x0a    type: \x27ANNOTATION_UPDATE_RANGE\x27,\x0a    annotationId: annotationId,\x0a    start: start,\x0a    end: end\x0a  };\x0a}\x0a/**\x0a * Removes all annotations of a specific source.\x0a *\x0a * @param {string} source The source to remove.\x0a *\x0a * @return {Object} Action object.\x0a */\x0a\x0afunction __experimentalRemoveAnnotationsBySource(source) {\x0a  return {\x0a    type: \x27ANNOTATION_REMOVE_SOURCE\x27,\x0a    source: source\x0a  };\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/annotations/build-module/store/index.js\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0a/**\x0a * Module Constants\x0a */\x0a\x0avar MODULE_KEY = \x27core/annotations\x27;\x0avar store = Object(external_this_wp_data_[\x22registerStore\x22])(MODULE_KEY, {\x0a  reducer: reducer,\x0a  selectors: selectors_namespaceObject,\x0a  actions: actions_namespaceObject\x0a});\x0a/* harmony default export */ var build_module_store = (store);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22richText\x22]}\x0avar external_this_wp_richText_ = __webpack_require__(20);\x0a\x0a// EXTERNAL MODULE: ./node_modules/memize/index.js\x0avar memize = __webpack_require__(41);\x0avar memize_default = /*#__PURE__*/__webpack_require__.n(memize);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22i18n\x22]}\x0avar external_this_wp_i18n_ = __webpack_require__(1);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/annotations/build-module/format/annotation.js\x0a/**\x0a * External dependencies\x0a */\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a\x0avar FORMAT_NAME = \x27core/annotation\x27;\x0avar ANNOTATION_ATTRIBUTE_PREFIX = \x27annotation-text-\x27;\x0avar STORE_KEY = \x27core/annotations\x27;\x0a/**\x0a * Applies given annotations to the given record.\x0a *\x0a * @param {Object} record The record to apply annotations to.\x0a * @param {Array} annotations The annotation to apply.\x0a * @return {Object} A record with the annotations applied.\x0a */\x0a\x0afunction applyAnnotations(record) {\x0a  var annotations = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : [];\x0a  annotations.forEach(function (annotation) {\x0a    var start = annotation.start,\x0a        end = annotation.end;\x0a\x0a    if (start \x3e record.text.length) {\x0a      start = record.text.length;\x0a    }\x0a\x0a    if (end \x3e record.text.length) {\x0a      end = record.text.length;\x0a    }\x0a\x0a    var className = ANNOTATION_ATTRIBUTE_PREFIX + annotation.source;\x0a    var id = ANNOTATION_ATTRIBUTE_PREFIX + annotation.id;\x0a    record = Object(external_this_wp_richText_[\x22applyFormat\x22])(record, {\x0a      type: FORMAT_NAME,\x0a      attributes: {\x0a        className: className,\x0a        id: id\x0a      }\x0a    }, start, end);\x0a  });\x0a  return record;\x0a}\x0a/**\x0a * Removes annotations from the given record.\x0a *\x0a * @param {Object} record Record to remove annotations from.\x0a * @return {Object} The cleaned record.\x0a */\x0a\x0afunction removeAnnotations(record) {\x0a  return Object(external_this_wp_richText_[\x22removeFormat\x22])(record, \x27core/annotation\x27, 0, record.text.length);\x0a}\x0a/**\x0a * Retrieves the positions of annotations inside an array of formats.\x0a *\x0a * @param {Array} formats Formats with annotations in there.\x0a * @return {Object} ID keyed positions of annotations.\x0a */\x0a\x0afunction retrieveAnnotationPositions(formats) {\x0a  var positions = {};\x0a  formats.forEach(function (characterFormats, i) {\x0a    characterFormats = characterFormats || [];\x0a    characterFormats = characterFormats.filter(function (format) {\x0a      return format.type === FORMAT_NAME;\x0a    });\x0a    characterFormats.forEach(function (format) {\x0a      var id = format.attributes.id;\x0a      id = id.replace(ANNOTATION_ATTRIBUTE_PREFIX, \x27\x27);\x0a\x0a      if (!positions.hasOwnProperty(id)) {\x0a        positions[id] = {\x0a          start: i\x0a        };\x0a      } // Annotations refer to positions between characters.\x0a      // Formats refer to the character themselves.\x0a      // So we need to adjust for that here.\x0a\x0a\x0a      positions[id].end = i + 1;\x0a    });\x0a  });\x0a  return positions;\x0a}\x0a/**\x0a * Updates annotations in the state based on positions retrieved from RichText.\x0a *\x0a * @param {Array}    annotations           The annotations that are currently applied.\x0a * @param {Array}    positions             The current positions of the given annotations.\x0a * @param {Function} removeAnnotation      Function to remove an annotation from the state.\x0a * @param {Function} updateAnnotationRange Function to update an annotation range in the state.\x0a */\x0a\x0a\x0afunction updateAnnotationsWithPositions(annotations, positions, _ref) {\x0a  var removeAnnotation = _ref.removeAnnotation,\x0a      updateAnnotationRange = _ref.updateAnnotationRange;\x0a  annotations.forEach(function (currentAnnotation) {\x0a    var position = positions[currentAnnotation.id]; // If we cannot find an annotation, delete it.\x0a\x0a    if (!position) {\x0a      // Apparently the annotation has been removed, so remove it from the state:\x0a      // Remove...\x0a      removeAnnotation(currentAnnotation.id);\x0a      return;\x0a    }\x0a\x0a    var start = currentAnnotation.start,\x0a        end = currentAnnotation.end;\x0a\x0a    if (start !== position.start || end !== position.end) {\x0a      updateAnnotationRange(currentAnnotation.id, position.start, position.end);\x0a    }\x0a  });\x0a}\x0a/**\x0a * Create prepareEditableTree memoized based on the annotation props.\x0a *\x0a * @param {Object} The props with annotations in them.\x0a *\x0a * @return {Function} The prepareEditableTree.\x0a */\x0a\x0a\x0avar createPrepareEditableTree = memize_default()(function (props) {\x0a  var annotations = props.annotations;\x0a  return function (formats, text) {\x0a    if (annotations.length === 0) {\x0a      return formats;\x0a    }\x0a\x0a    var record = {\x0a      formats: formats,\x0a      text: text\x0a    };\x0a    record = applyAnnotations(record, annotations);\x0a    return record.formats;\x0a  };\x0a});\x0a/**\x0a * Returns the annotations as a props object. Memoized to prevent re-renders.\x0a *\x0a * @param {Array} The annotations to put in the object.\x0a *\x0a * @return {Object} The annotations props object.\x0a */\x0a\x0avar getAnnotationObject = memize_default()(function (annotations) {\x0a  return {\x0a    annotations: annotations\x0a  };\x0a});\x0avar annotation_annotation = {\x0a  name: FORMAT_NAME,\x0a  title: Object(external_this_wp_i18n_[\x22__\x22])(\x27Annotation\x27),\x0a  tagName: \x27mark\x27,\x0a  className: \x27annotation-text\x27,\x0a  attributes: {\x0a    className: \x27class\x27,\x0a    id: \x27id\x27\x0a  },\x0a  edit: function edit() {\x0a    return null;\x0a  },\x0a  __experimentalGetPropsForEditableTreePreparation: function __experimentalGetPropsForEditableTreePreparation(select, _ref2) {\x0a    var richTextIdentifier = _ref2.richTextIdentifier,\x0a        blockClientId = _ref2.blockClientId;\x0a    return getAnnotationObject(select(STORE_KEY).__experimentalGetAnnotationsForRichText(blockClientId, richTextIdentifier));\x0a  },\x0a  __experimentalCreatePrepareEditableTree: createPrepareEditableTree,\x0a  __experimentalGetPropsForEditableTreeChangeHandler: function __experimentalGetPropsForEditableTreeChangeHandler(dispatch) {\x0a    return {\x0a      removeAnnotation: dispatch(STORE_KEY).__experimentalRemoveAnnotation,\x0a      updateAnnotationRange: dispatch(STORE_KEY).__experimentalUpdateAnnotationRange\x0a    };\x0a  },\x0a  __experimentalCreateOnChangeEditableValue: function __experimentalCreateOnChangeEditableValue(props) {\x0a    return function (formats) {\x0a      var positions = retrieveAnnotationPositions(formats);\x0a      var removeAnnotation = props.removeAnnotation,\x0a          updateAnnotationRange = props.updateAnnotationRange,\x0a          annotations = props.annotations;\x0a      updateAnnotationsWithPositions(annotations, positions, {\x0a        removeAnnotation: removeAnnotation,\x0a        updateAnnotationRange: updateAnnotationRange\x0a      });\x0a    };\x0a  }\x0a};\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/annotations/build-module/format/index.js\x0a\x0a\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0avar format_name = annotation_annotation.name,\x0a    settings = Object(objectWithoutProperties[\x22a\x22 /* default */])(annotation_annotation, [\x22name\x22]);\x0a\x0aObject(external_this_wp_richText_[\x22registerFormatType\x22])(format_name, settings);\x0a\x0a// EXTERNAL MODULE: external {\x22this\x22:[\x22wp\x22,\x22hooks\x22]}\x0avar external_this_wp_hooks_ = __webpack_require__(26);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/annotations/build-module/block/index.js\x0a/**\x0a * WordPress dependencies\x0a */\x0a\x0a\x0a/**\x0a * Adds annotation className to the block-list-block component.\x0a *\x0a * @param {Object} OriginalComponent The original BlockListBlock component.\x0a * @return {Object} The enhanced component.\x0a */\x0a\x0avar block_addAnnotationClassName = function addAnnotationClassName(OriginalComponent) {\x0a  return Object(external_this_wp_data_[\x22withSelect\x22])(function (select, _ref) {\x0a    var clientId = _ref.clientId;\x0a\x0a    var annotations = select(\x27core/annotations\x27).__experimentalGetAnnotationsForBlock(clientId);\x0a\x0a    return {\x0a      className: annotations.map(function (annotation) {\x0a        return \x27is-annotated-by-\x27 + annotation.source;\x0a      }).join(\x27 \x27)\x0a    };\x0a  })(OriginalComponent);\x0a};\x0a\x0aObject(external_this_wp_hooks_[\x22addFilter\x22])(\x27editor.BlockListBlock\x27, \x27core/annotations\x27, block_addAnnotationClassName);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/annotations/build-module/index.js\x0a/**\x0a * Internal dependencies\x0a */\x0a\x0a\x0a\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 41:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0amodule.exports = function memize( fn, options ) {\x0a\x09var size = 0,\x0a\x09\x09maxSize, head, tail;\x0a\x0a\x09if ( options && options.maxSize ) {\x0a\x09\x09maxSize = options.maxSize;\x0a\x09}\x0a\x0a\x09function memoized( /* ...args */ ) {\x0a\x09\x09var node = head,\x0a\x09\x09\x09len = arguments.length,\x0a\x09\x09\x09args, i;\x0a\x0a\x09\x09searchCache: while ( node ) {\x0a\x09\x09\x09// Perform a shallow equality test to confirm that whether the node\x0a\x09\x09\x09// under test is a candidate for the arguments passed. Two arrays\x0a\x09\x09\x09// are shallowly equal if their length matches and each entry is\x0a\x09\x09\x09// strictly equal between the two sets. Avoid abstracting to a\x0a\x09\x09\x09// function which could incur an arguments leaking deoptimization.\x0a\x0a\x09\x09\x09// Check whether node arguments match arguments length\x0a\x09\x09\x09if ( node.args.length !== arguments.length ) {\x0a\x09\x09\x09\x09node = node.next;\x0a\x09\x09\x09\x09continue;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Check whether node arguments match arguments values\x0a\x09\x09\x09for ( i = 0; i \x3c len; i++ ) {\x0a\x09\x09\x09\x09if ( node.args[ i ] !== arguments[ i ] ) {\x0a\x09\x09\x09\x09\x09node = node.next;\x0a\x09\x09\x09\x09\x09continue searchCache;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// At this point we can assume we\x27ve found a match\x0a\x0a\x09\x09\x09// Surface matched node to head if not already\x0a\x09\x09\x09if ( node !== head ) {\x0a\x09\x09\x09\x09// As tail, shift to previous. Must only shift if not also\x0a\x09\x09\x09\x09// head, since if both head and tail, there is no previous.\x0a\x09\x09\x09\x09if ( node === tail ) {\x0a\x09\x09\x09\x09\x09tail = node.prev;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Adjust siblings to point to each other. If node was tail,\x0a\x09\x09\x09\x09// this also handles new tail\x27s empty `next` assignment.\x0a\x09\x09\x09\x09node.prev.next = node.next;\x0a\x09\x09\x09\x09if ( node.next ) {\x0a\x09\x09\x09\x09\x09node.next.prev = node.prev;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09node.next = head;\x0a\x09\x09\x09\x09node.prev = null;\x0a\x09\x09\x09\x09head.prev = node;\x0a\x09\x09\x09\x09head = node;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Return immediately\x0a\x09\x09\x09return node.val;\x0a\x09\x09}\x0a\x0a\x09\x09// No cached value found. Continue to insertion phase:\x0a\x0a\x09\x09// Create a copy of arguments (avoid leaking deoptimization)\x0a\x09\x09args = new Array( len );\x0a\x09\x09for ( i = 0; i \x3c len; i++ ) {\x0a\x09\x09\x09args[ i ] = arguments[ i ];\x0a\x09\x09}\x0a\x0a\x09\x09node = {\x0a\x09\x09\x09args: args,\x0a\x0a\x09\x09\x09// Generate the result from original function\x0a\x09\x09\x09val: fn.apply( null, args )\x0a\x09\x09};\x0a\x0a\x09\x09// Don\x27t need to check whether node is already head, since it would\x0a\x09\x09// have been returned above already if it was\x0a\x0a\x09\x09// Shift existing head down list\x0a\x09\x09if ( head ) {\x0a\x09\x09\x09head.prev = node;\x0a\x09\x09\x09node.next = head;\x0a\x09\x09} else {\x0a\x09\x09\x09// If no head, follows that there\x27s no tail (at initial or reset)\x0a\x09\x09\x09tail = node;\x0a\x09\x09}\x0a\x0a\x09\x09// Trim tail if we\x27re reached max size and are pending cache insertion\x0a\x09\x09if ( size === maxSize ) {\x0a\x09\x09\x09tail = tail.prev;\x0a\x09\x09\x09tail.next = null;\x0a\x09\x09} else {\x0a\x09\x09\x09size++;\x0a\x09\x09}\x0a\x0a\x09\x09head = node;\x0a\x0a\x09\x09return node.val;\x0a\x09}\x0a\x0a\x09memoized.clear = function() {\x0a\x09\x09head = null;\x0a\x09\x09tail = null;\x0a\x09\x09size = 0;\x0a\x09};\x0a\x0a\x09if ( false ) {}\x0a\x0a\x09return memoized;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 5:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22wp\x22][\x22data\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 65:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar rng = __webpack_require__(87);\x0avar bytesToUuid = __webpack_require__(88);\x0a\x0afunction v4(options, buf, offset) {\x0a  var i = buf && offset || 0;\x0a\x0a  if (typeof(options) == \x27string\x27) {\x0a    buf = options === \x27binary\x27 ? new Array(16) : null;\x0a    options = null;\x0a  }\x0a  options = options || {};\x0a\x0a  var rnds = options.random || (options.rng || rng)();\x0a\x0a  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\x0a  rnds[6] = (rnds[6] & 0x0f) | 0x40;\x0a  rnds[8] = (rnds[8] & 0x3f) | 0x80;\x0a\x0a  // Copy bytes to buffer, if provided\x0a  if (buf) {\x0a    for (var ii = 0; ii \x3c 16; ++ii) {\x0a      buf[i + ii] = rnds[ii];\x0a    }\x0a  }\x0a\x0a  return buf || bytesToUuid(rnds);\x0a}\x0a\x0amodule.exports = v4;\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 7:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _objectSpread; });\x0a/* harmony import */ var _defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);\x0a\x0afunction _objectSpread(target) {\x0a  for (var i = 1; i \x3c arguments.length; i++) {\x0a    var source = arguments[i] != null ? arguments[i] : {};\x0a    var ownKeys = Object.keys(source);\x0a\x0a    if (typeof Object.getOwnPropertySymbols === \x27function\x27) {\x0a      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\x0a        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\x0a      }));\x0a    }\x0a\x0a    ownKeys.forEach(function (key) {\x0a      Object(_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22])(target, key, source[key]);\x0a    });\x0a  }\x0a\x0a  return target;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 87:\x0a/***/ (function(module, exports) {\x0a\x0a// Unique ID creation requires a high quality random # generator.  In the\x0a// browser this is a little complicated due to unknown quality of Math.random()\x0a// and inconsistent support for the `crypto` API.  We do the best we can via\x0a// feature-detection\x0a\x0a// getRandomValues needs to be invoked in a context where \x22this\x22 is a Crypto\x0a// implementation. Also, find the complete implementation of crypto on IE11.\x0avar getRandomValues = (typeof(crypto) != \x27undefined\x27 && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||\x0a                      (typeof(msCrypto) != \x27undefined\x27 && typeof window.msCrypto.getRandomValues == \x27function\x27 && msCrypto.getRandomValues.bind(msCrypto));\x0a\x0aif (getRandomValues) {\x0a  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\x0a  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\x0a\x0a  module.exports = function whatwgRNG() {\x0a    getRandomValues(rnds8);\x0a    return rnds8;\x0a  };\x0a} else {\x0a  // Math.random()-based (RNG)\x0a  //\x0a  // If all else fails, use Math.random().  It\x27s fast, but is of unspecified\x0a  // quality.\x0a  var rnds = new Array(16);\x0a\x0a  module.exports = function mathRNG() {\x0a    for (var i = 0, r; i \x3c 16; i++) {\x0a      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\x0a      rnds[i] = r \x3e\x3e\x3e ((i & 0x03) \x3c\x3c 3) & 0xff;\x0a    }\x0a\x0a    return rnds;\x0a  };\x0a}\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 88:\x0a/***/ (function(module, exports) {\x0a\x0a/**\x0a * Convert array of 16 byte values to UUID string format of the form:\x0a * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\x0a */\x0avar byteToHex = [];\x0afor (var i = 0; i \x3c 256; ++i) {\x0a  byteToHex[i] = (i + 0x100).toString(16).substr(1);\x0a}\x0a\x0afunction bytesToUuid(buf, offset) {\x0a  var i = offset || 0;\x0a  var bth = byteToHex;\x0a  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\x0a  return ([bth[buf[i++]], bth[buf[i++]], \x0a\x09bth[buf[i++]], bth[buf[i++]], \x27-\x27,\x0a\x09bth[buf[i++]], bth[buf[i++]], \x27-\x27,\x0a\x09bth[buf[i++]], bth[buf[i++]], \x27-\x27,\x0a\x09bth[buf[i++]], bth[buf[i++]], \x27-\x27,\x0a\x09bth[buf[i++]], bth[buf[i++]],\x0a\x09bth[buf[i++]], bth[buf[i++]],\x0a\x09bth[buf[i++]], bth[buf[i++]]]).join(\x27\x27);\x0a}\x0a\x0amodule.exports = bytesToUuid;\x0a\x0a\x0a/***/ })\x0a\x0a/******/ });'}