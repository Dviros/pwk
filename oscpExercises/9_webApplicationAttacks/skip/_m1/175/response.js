var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:11:59 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 28 Jun 2018 02:30:15 GMT\x0aETag: \x225a6d-56faa82e93bc0-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-5859/5860\x0aContent-Length: 5860\x0aKeep-Alive: timeout=5, max=70\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/**\x0a * @output wp-includes/js/customize-preview-widgets.js\x0a */\x0a\x0a/* global _wpWidgetCustomizerPreviewSettings */\x0a\x0a/**\x0a * Handles the initialization, refreshing and rendering of widget partials and sidebar widgets.\x0a *\x0a * @since 4.5.0\x0a *\x0a * @namespace wp.customize.widgetsPreview\x0a *\x0a * @param {jQuery} $   The jQuery object.\x0a * @param {Object} _   The utilities library.\x0a * @param {Object} wp  Current WordPress environment instance.\x0a * @param {Object} api Information from the API.\x0a *\x0a * @returns {Object} Widget-related variables.\x0a */\x0awp.customize.widgetsPreview = wp.customize.WidgetCustomizerPreview = (function( $, _, wp, api ) {\x0a\x0a\x09var self;\x0a\x0a\x09self = {\x0a\x09\x09renderedSidebars: {},\x0a\x09\x09renderedWidgets: {},\x0a\x09\x09registeredSidebars: [],\x0a\x09\x09registeredWidgets: {},\x0a\x09\x09widgetSelectors: [],\x0a\x09\x09preview: null,\x0a\x09\x09l10n: {\x0a\x09\x09\x09widgetTooltip: \x27\x27\x0a\x09\x09},\x0a\x09\x09selectiveRefreshableWidgets: {}\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Initializes the widgets preview.\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 *\x0a\x09 * @memberOf wp.customize.widgetsPreview\x0a\x09 *\x0a\x09 * @returns {void}\x0a\x09 */\x0a\x09self.init = function() {\x0a\x09\x09var self = this;\x0a\x0a\x09\x09self.preview = api.preview;\x0a\x09\x09if ( ! _.isEmpty( self.selectiveRefreshableWidgets ) ) {\x0a\x09\x09\x09self.addPartials();\x0a\x09\x09}\x0a\x0a\x09\x09self.buildWidgetSelectors();\x0a\x09\x09self.highlightControls();\x0a\x0a\x09\x09self.preview.bind( \x27highlight-widget\x27, self.highlightWidget );\x0a\x0a\x09\x09api.preview.bind( \x27active\x27, function() {\x0a\x09\x09\x09self.highlightControls();\x0a\x09\x09} );\x0a\x0a\x09\x09/*\x0a\x09\x09 * Refresh a partial when the controls pane requests it. This is used currently just by the\x0a\x09\x09 * Gallery widget so that when an attachment\x27s caption is updated in the media modal,\x0a\x09\x09 * the widget in the preview will then be refreshed to show the change. Normally doing this\x0a\x09\x09 * would not be necessary because all of the state should be contained inside the changeset,\x0a\x09\x09 * as everything done in the Customizer should not make a change to the site unless the\x0a\x09\x09 * changeset itself is published. Attachments are a current exception to this rule.\x0a\x09\x09 * For a proposal to include attachments in the customized state, see #37887.\x0a\x09\x09 */\x0a\x09\x09api.preview.bind( \x27refresh-widget-partial\x27, function( widgetId ) {\x0a\x09\x09\x09var partialId = \x27widget[\x27 + widgetId + \x27]\x27;\x0a\x09\x09\x09if ( api.selectiveRefresh.partial.has( partialId ) ) {\x0a\x09\x09\x09\x09api.selectiveRefresh.partial( partialId ).refresh();\x0a\x09\x09\x09} else if ( self.renderedWidgets[ widgetId ] ) {\x0a\x09\x09\x09\x09api.preview.send( \x27refresh\x27 ); // Fallback in case theme does not support \x27customize-selective-refresh-widgets\x27.\x0a\x09\x09\x09}\x0a\x09\x09} );\x0a\x09};\x0a\x0a\x09self.WidgetPartial = api.selectiveRefresh.Partial.extend(/** @lends wp.customize.widgetsPreview.WidgetPartial.prototype */{\x0a\x0a\x09\x09/**\x0a\x09\x09 * Represents a partial widget instance.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @constructs\x0a\x09\x09 * @augments wp.customize.selectiveRefresh.Partial\x0a\x09\x09 *\x0a\x09\x09 * @alias wp.customize.widgetsPreview.WidgetPartial\x0a\x09\x09 * @memberOf wp.customize.widgetsPreview\x0a\x09\x09 *\x0a\x09\x09 * @param {string} id             The partial\x27s ID.\x0a\x09\x09 * @param {Object} options        Options used to initialize the partial\x27s\x0a\x09\x09 *                                instance.\x0a\x09\x09 * @param {Object} options.params The options parameters.\x0a\x09\x09 */\x0a\x09\x09initialize: function( id, options ) {\x0a\x09\x09\x09var partial = this, matches;\x0a\x09\x09\x09matches = id.match( /^widget\x5c[(.+)]$/ );\x0a\x09\x09\x09if ( ! matches ) {\x0a\x09\x09\x09\x09throw new Error( \x27Illegal id for widget partial.\x27 );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09partial.widgetId = matches[1];\x0a\x09\x09\x09partial.widgetIdParts = self.parseWidgetId( partial.widgetId );\x0a\x09\x09\x09options = options || {};\x0a\x09\x09\x09options.params = _.extend(\x0a\x09\x09\x09\x09{\x0a\x09\x09\x09\x09\x09settings: [ self.getWidgetSettingId( partial.widgetId ) ],\x0a\x09\x09\x09\x09\x09containerInclusive: true\x0a\x09\x09\x09\x09},\x0a\x09\x09\x09\x09options.params || {}\x0a\x09\x09\x09);\x0a\x0a\x09\x09\x09api.selectiveRefresh.Partial.prototype.initialize.call( partial, id, options );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Refreshes the widget partial.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @returns {Promise|void} Either a promise postponing the refresh, or void.\x0a\x09\x09 */\x0a\x09\x09refresh: function() {\x0a\x09\x09\x09var partial = this, refreshDeferred;\x0a\x09\x09\x09if ( ! self.selectiveRefreshableWidgets[ partial.widgetIdParts.idBase ] ) {\x0a\x09\x09\x09\x09refreshDeferred = $.Deferred();\x0a\x09\x09\x09\x09refreshDeferred.reject();\x0a\x09\x09\x09\x09partial.fallback();\x0a\x09\x09\x09\x09return refreshDeferred.promise();\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09return api.selectiveRefresh.Partial.prototype.refresh.call( partial );\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Sends the widget-updated message to the parent so the spinner will get\x0a\x09\x09 * removed from the widget control.\x0a\x09\x09 *\x0a\x09\x09 * @inheritDoc\x0a\x09\x09 * @param {wp.customize.selectiveRefresh.Placement} placement The placement\x0a\x09\x09 *                                                            function.\x0a\x09\x09 *\x0a\x09\x09 * @returns {void}\x0a\x09\x09 */\x0a\x09\x09renderContent: function( placement ) {\x0a\x09\x09\x09var partial = this;\x0a\x09\x09\x09if ( api.selectiveRefresh.Partial.prototype.renderContent.call( partial, placement ) ) {\x0a\x09\x09\x09\x09api.preview.send( \x27widget-updated\x27, partial.widgetId );\x0a\x09\x09\x09\x09api.selectiveRefresh.trigger( \x27widget-updated\x27, partial );\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x09});\x0a\x0a\x09self.SidebarPartial = api.selectiveRefresh.Partial.extend(/** @lends wp.customize.widgetsPreview.SidebarPartial.prototype */{\x0a\x0a\x09\x09/**\x0a\x09\x09 * Represents a partial widget area.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @class\x0a\x09\x09 * @augments wp.customize.selectiveRefresh.Partial\x0a\x09\x09 *\x0a\x09\x09 * @memberOf wp.customize.widgetsPreview\x0a\x09\x09 * @alias wp.customize.widgetsPreview.SidebarPartial\x0a\x09\x09 *\x0a\x09\x09 * @param {string} id             The partial\x27s ID.\x0a\x09\x09 * @param {Object} options        Options used to initialize the partial\x27s instance.\x0a\x09\x09 * @param {Object} options.params The options parameters.\x0a\x09\x09 */\x0a\x09\x09initialize: function( id, options ) {\x0a\x09\x09\x09var partial = this, matches;\x0a\x09\x09\x09matches = id.match( /^sidebar\x5c[(.+)]$/ );\x0a\x09\x09\x09if ( ! matches ) {\x0a\x09\x09\x09\x09throw new Error( \x27Illegal id for sidebar partial.\x27 );\x0a\x09\x09\x09}\x0a\x09\x09\x09partial.sidebarId = matches[1];\x0a\x0a\x09\x09\x09options = options || {};\x0a\x09\x09\x09options.params = _.extend(\x0a\x09\x09\x09\x09{\x0a\x09\x09\x09\x09\x09settings: [ \x27sidebars_widgets[\x27 + partial.sidebarId + \x27]\x27 ]\x0a\x09\x09\x09\x09},\x0a\x09\x09\x09\x09options.params || {}\x0a\x09\x09\x09);\x0a\x0a\x09\x09\x09api.selectiveRefresh.Partial.prototype.initialize.call( partial, id, options );\x0a\x0a\x09\x09\x09if ( ! partial.params.sidebarArgs ) {\x0a\x09\x09\x09\x09throw new Error( \x27The sidebarArgs param was not provided.\x27 );\x0a\x09\x09\x09}\x0a\x09\x09\x09if ( partial.params.settings.length \x3e 1 ) {\x0a\x09\x09\x09\x09throw new Error( \x27Expected SidebarPartial to only have one associated setting\x27 );\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Sets up the partial.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @returns {void}\x0a\x09\x09 */\x0a\x09\x09ready: function() {\x0a\x09\x09\x09var sidebarPartial = this;\x0a\x0a\x09\x09\x09// Watch for changes to the sidebar_widgets setting.\x0a\x09\x09\x09_.each( sidebarPartial.settings(), function( settingId ) {\x0a\x09\x09\x09\x09api( settingId ).bind( _.bind( sidebarPartial.handleSettingChange, sidebarPartial ) );\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09// Trigger an event for this sidebar being updated whenever a widget inside is rendered.\x0a\x09\x09\x09api.selectiveRefresh.bind( \x27partial-content-rendered\x27, function( placement ) {\x0a\x09\x09\x09\x09var isAssignedWidgetPartial = (\x0a\x09\x09\x09\x09\x09placement.partial.extended( self.WidgetPartial ) &&\x0a\x09\x09\x09\x09\x09( -1 !== _.indexOf( sidebarPartial.getWidgetIds(), placement.partial.widgetId ) )\x0a\x09\x09\x09\x09);\x0a\x09\x09\x09\x09if ( isAssignedWidgetPartial ) {\x0a\x09\x09\x09\x09\x09api.selectiveRefresh.trigger( \x27sidebar-updated\x27, sidebarPartial );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09// Make sure that a widget partial has a container in the DOM prior to a refresh.\x0a\x09\x09\x09api.bind( \x27change\x27, function( widgetSetting ) {\x0a\x09\x09\x09\x09var widgetId, parsedId;\x0a\x09\x09\x09\x09parsedId = self.parseWidgetSettingId( widgetSetting.id );\x0a\x09\x09\x09\x09if ( ! parsedId ) {\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09widgetId = parsedId.idBase;\x0a\x09\x09\x09\x09if ( parsedId.number ) {\x0a\x09\x09\x09\x09\x09widgetId += \x27-\x27 + String( parsedId.number );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09if ( -1 !== _.indexOf( sidebarPartial.getWidgetIds(), widgetId ) ) {\x0a\x09\x09\x09\x09\x09sidebarPartial.ensureWidgetPlacementContainers( widgetId );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09} );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Gets the before/after boundary nodes for all instances of this sidebar\x0a\x09\x09 * (usually one).\x0a\x09\x09 *\x0a\x09\x09 * Note that TreeWalker is not implemented in IE8.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @returns {Array.\x3c{before: Comment, after: Comment, instanceNumber: number}\x3e}\x0a\x09\x09 *          An array with an object for each sidebar instance, containing the\x0a\x09\x09 *          node before and after the sidebar instance and its instance number.\x0a\x09\x09 */\x0a\x09\x09findDynamicSidebarBoundaryNodes: function() {\x0a\x09\x09\x09var partial = this, regExp, boundaryNodes = {}, recursiveCommentTraversal;\x0a\x09\x09\x09regExp = /^(dynamic_sidebar_before|dynamic_sidebar_after):(.+):(\x5cd+)$/;\x0a\x09\x09\x09recursiveCommentTraversal = function( childNodes ) {\x0a\x09\x09\x09\x09_.each( childNodes, function( node ) {\x0a\x09\x09\x09\x09\x09var matches;\x0a\x09\x09\x09\x09\x09if ( 8 === node.nodeType ) {\x0a\x09\x09\x09\x09\x09\x09matches = node.nodeValue.match( regExp );\x0a\x09\x09\x09\x09\x09\x09if ( ! matches || matches[2] !== partial.sidebarId ) {\x0a\x09\x09\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09if ( _.isUndefined( boundaryNodes[ matches[3] ] ) ) {\x0a\x09\x09\x09\x09\x09\x09\x09boundaryNodes[ matches[3] ] = {\x0a\x09\x09\x09\x09\x09\x09\x09\x09before: null,\x0a\x09\x09\x09\x09\x09\x09\x09\x09after: null,\x0a\x09\x09\x09\x09\x09\x09\x09\x09instanceNumber: parseInt( matches[3], 10 )\x0a\x09\x09\x09\x09\x09\x09\x09};\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09if ( \x27dynamic_sidebar_before\x27 === matches[1] ) {\x0a\x09\x09\x09\x09\x09\x09\x09boundaryNodes[ matches[3] ].before = node;\x0a\x09\x09\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09\x09\x09boundaryNodes[ matches[3] ].after = node;\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09} else if ( 1 === node.nodeType ) {\x0a\x09\x09\x09\x09\x09\x09recursiveCommentTraversal( node.childNodes );\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09};\x0a\x0a\x09\x09\x09recursiveCommentTraversal( document.body.childNodes );\x0a\x09\x09\x09return _.values( boundaryNodes );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Gets the placements for this partial.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @returns {Array} An array containing placement objects for each of the\x0a\x09\x09 *                  dynamic sidebar boundary nodes.\x0a\x09\x09 */\x0a\x09\x09placements: function() {\x0a\x09\x09\x09var partial = this;\x0a\x09\x09\x09return _.map( partial.findDynamicSidebarBoundaryNodes(), function( boundaryNodes ) {\x0a\x09\x09\x09\x09return new api.selectiveRefresh.Placement( {\x0a\x09\x09\x09\x09\x09partial: partial,\x0a\x09\x09\x09\x09\x09container: null,\x0a\x09\x09\x09\x09\x09startNode: boundaryNodes.before,\x0a\x09\x09\x09\x09\x09endNode: boundaryNodes.after,\x0a\x09\x09\x09\x09\x09context: {\x0a\x09\x09\x09\x09\x09\x09instanceNumber: boundaryNodes.instanceNumber\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09} );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Get the list of widget IDs associated with this widget area.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @throws {Error} If there\x27s no settingId.\x0a\x09\x09 * @throws {Error} If the setting doesn\x27t exist in the API.\x0a\x09\x09 * @throws {Error} If the API doesn\x27t pass an array of widget ids.\x0a\x09\x09 *\x0a\x09\x09 * @returns {Array} A shallow copy of the array containing widget IDs.\x0a\x09\x09 */\x0a\x09\x09getWidgetIds: function() {\x0a\x09\x09\x09var sidebarPartial = this, settingId, widgetIds;\x0a\x09\x09\x09settingId = sidebarPartial.settings()[0];\x0a\x09\x09\x09if ( ! settingId ) {\x0a\x09\x09\x09\x09throw new Error( \x27Missing associated setting.\x27 );\x0a\x09\x09\x09}\x0a\x09\x09\x09if ( ! api.has( settingId ) ) {\x0a\x09\x09\x09\x09throw new Error( \x27Setting does not exist.\x27 );\x0a\x09\x09\x09}\x0a\x09\x09\x09widgetIds = api( settingId ).get();\x0a\x09\x09\x09if ( ! _.isArray( widgetIds ) ) {\x0a\x09\x09\x09\x09throw new Error( \x27Expected setting to be array of widget IDs\x27 );\x0a\x09\x09\x09}\x0a\x09\x09\x09return widgetIds.slice( 0 );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Reflows widgets in the sidebar, ensuring they have the proper position in the\x0a\x09\x09 * DOM.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @returns {Array.\x3cwp.customize.selectiveRefresh.Placement\x3e} List of placements\x0a\x09\x09 *                                                            that were reflowed.\x0a\x09\x09 */\x0a\x09\x09reflowWidgets: function() {\x0a\x09\x09\x09var sidebarPartial = this, sidebarPlacements, widgetIds, widgetPartials, sortedSidebarContainers = [];\x0a\x09\x09\x09widgetIds = sidebarPartial.getWidgetIds();\x0a\x09\x09\x09sidebarPlacements = sidebarPartial.placements();\x0a\x0a\x09\x09\x09widgetPartials = {};\x0a\x09\x09\x09_.each( widgetIds, function( widgetId ) {\x0a\x09\x09\x09\x09var widgetPartial = api.selectiveRefresh.partial( \x27widget[\x27 + widgetId + \x27]\x27 );\x0a\x09\x09\x09\x09if ( widgetPartial ) {\x0a\x09\x09\x09\x09\x09widgetPartials[ widgetId ] = widgetPartial;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09_.each( sidebarPlacements, function( sidebarPlacement ) {\x0a\x09\x09\x09\x09var sidebarWidgets = [], needsSort = false, thisPosition, lastPosition = -1;\x0a\x0a\x09\x09\x09\x09// Gather list of widget partial containers in this sidebar, and determine if a sort is needed.\x0a\x09\x09\x09\x09_.each( widgetPartials, function( widgetPartial ) {\x0a\x09\x09\x09\x09\x09_.each( widgetPartial.placements(), function( widgetPlacement ) {\x0a\x0a\x09\x09\x09\x09\x09\x09if ( sidebarPlacement.context.instanceNumber === widgetPlacement.context.sidebar_instance_number ) {\x0a\x09\x09\x09\x09\x09\x09\x09thisPosition = widgetPlacement.container.index();\x0a\x09\x09\x09\x09\x09\x09\x09sidebarWidgets.push( {\x0a\x09\x09\x09\x09\x09\x09\x09\x09partial: widgetPartial,\x0a\x09\x09\x09\x09\x09\x09\x09\x09placement: widgetPlacement,\x0a\x09\x09\x09\x09\x09\x09\x09\x09position: thisPosition\x0a\x09\x09\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09\x09\x09\x09if ( thisPosition \x3c lastPosition ) {\x0a\x09\x09\x09\x09\x09\x09\x09\x09needsSort = true;\x0a\x09\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09\x09\x09lastPosition = thisPosition;\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09if ( needsSort ) {\x0a\x09\x09\x09\x09\x09_.each( sidebarWidgets, function( sidebarWidget ) {\x0a\x09\x09\x09\x09\x09\x09sidebarPlacement.endNode.parentNode.insertBefore(\x0a\x09\x09\x09\x09\x09\x09\x09sidebarWidget.placement.container[0],\x0a\x09\x09\x09\x09\x09\x09\x09sidebarPlacement.endNode\x0a\x09\x09\x09\x09\x09\x09);\x0a\x0a\x09\x09\x09\x09\x09\x09// @todo Rename partial-placement-moved?\x0a\x09\x09\x09\x09\x09\x09api.selectiveRefresh.trigger( \x27partial-content-moved\x27, sidebarWidget.placement );\x0a\x09\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09\x09sortedSidebarContainers.push( sidebarPlacement );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09if ( sortedSidebarContainers.length \x3e 0 ) {\x0a\x09\x09\x09\x09api.selectiveRefresh.trigger( \x27sidebar-updated\x27, sidebarPartial );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09return sortedSidebarContainers;\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Makes sure there is a widget instance container in this sidebar for the given\x0a\x09\x09 * widget ID.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @param {string} widgetId The widget ID.\x0a\x09\x09 *\x0a\x09\x09 * @returns {wp.customize.selectiveRefresh.Partial} The widget instance partial.\x0a\x09\x09 */\x0a\x09\x09ensureWidgetPlacementContainers: function( widgetId ) {\x0a\x09\x09\x09var sidebarPartial = this, widgetPartial, wasInserted = false, partialId = \x27widget[\x27 + widgetId + \x27]\x27;\x0a\x09\x09\x09widgetPartial = api.selectiveRefresh.partial( partialId );\x0a\x09\x09\x09if ( ! widgetPartial ) {\x0a\x09\x09\x09\x09widgetPartial = new self.WidgetPartial( partialId, {\x0a\x09\x09\x09\x09\x09params: {}\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Make sure that there is a container element for the widget in the sidebar, if at least a placeholder.\x0a\x09\x09\x09_.each( sidebarPartial.placements(), function( sidebarPlacement ) {\x0a\x09\x09\x09\x09var foundWidgetPlacement, widgetContainerElement;\x0a\x0a\x09\x09\x09\x09foundWidgetPlacement = _.find( widgetPartial.placements(), function( widgetPlacement ) {\x0a\x09\x09\x09\x09\x09return ( widgetPlacement.context.sidebar_instance_number === sidebarPlacement.context.instanceNumber );\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09if ( foundWidgetPlacement ) {\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09widgetContainerElement = $(\x0a\x09\x09\x09\x09\x09sidebarPartial.params.sidebarArgs.before_widget.replace( /%1\x5c$s/g, widgetId ).replace( /%2\x5c$s/g, \x27widget\x27 ) +\x0a\x09\x09\x09\x09\x09sidebarPartial.params.sidebarArgs.after_widget\x0a\x09\x09\x09\x09);\x0a\x0a\x09\x09\x09\x09// Handle rare case where before_widget and after_widget are empty.\x0a\x09\x09\x09\x09if ( ! widgetContainerElement[0] ) {\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09widgetContainerElement.attr( \x27data-customize-partial-id\x27, widgetPartial.id );\x0a\x09\x09\x09\x09widgetContainerElement.attr( \x27data-customize-partial-type\x27, \x27widget\x27 );\x0a\x09\x09\x09\x09widgetContainerElement.attr( \x27data-customize-widget-id\x27, widgetId );\x0a\x0a\x09\x09\x09\x09/*\x0a\x09\x09\x09\x09 * Make sure the widget container element has the customize-container context data.\x0a\x09\x09\x09\x09 * The sidebar_instance_number is used to disambiguate multiple instances of the\x0a\x09\x09\x09\x09 * same sidebar are rendered onto the template, and so the same widget is embedded\x0a\x09\x09\x09\x09 * multiple times.\x0a\x09\x09\x09\x09 */\x0a\x09\x09\x09\x09widgetContainerElement.data( \x27customize-partial-placement-context\x27, {\x0a\x09\x09\x09\x09\x09\x27sidebar_id\x27: sidebarPartial.sidebarId,\x0a\x09\x09\x09\x09\x09\x27sidebar_instance_number\x27: sidebarPlacement.context.instanceNumber\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09sidebarPlacement.endNode.parentNode.insertBefore( widgetContainerElement[0], sidebarPlacement.endNode );\x0a\x09\x09\x09\x09wasInserted = true;\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09api.selectiveRefresh.partial.add( widgetPartial );\x0a\x0a\x09\x09\x09if ( wasInserted ) {\x0a\x09\x09\x09\x09sidebarPartial.reflowWidgets();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09return widgetPartial;\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Handles changes to the sidebars_widgets[] setting.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @param {Array} newWidgetIds New widget IDs.\x0a\x09\x09 * @param {Array} oldWidgetIds Old widget IDs.\x0a\x09\x09 *\x0a\x09\x09 * @returns {void}\x0a\x09\x09 */\x0a\x09\x09handleSettingChange: function( newWidgetIds, oldWidgetIds ) {\x0a\x09\x09\x09var sidebarPartial = this, needsRefresh, widgetsRemoved, widgetsAdded, addedWidgetPartials = [];\x0a\x0a\x09\x09\x09needsRefresh = (\x0a\x09\x09\x09\x09( oldWidgetIds.length \x3e 0 && 0 === newWidgetIds.length ) ||\x0a\x09\x09\x09\x09( newWidgetIds.length \x3e 0 && 0 === oldWidgetIds.length )\x0a\x09\x09\x09);\x0a\x09\x09\x09if ( needsRefresh ) {\x0a\x09\x09\x09\x09sidebarPartial.fallback();\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Handle removal of widgets.\x0a\x09\x09\x09widgetsRemoved = _.difference( oldWidgetIds, newWidgetIds );\x0a\x09\x09\x09_.each( widgetsRemoved, function( removedWidgetId ) {\x0a\x09\x09\x09\x09var widgetPartial = api.selectiveRefresh.partial( \x27widget[\x27 + removedWidgetId + \x27]\x27 );\x0a\x09\x09\x09\x09if ( widgetPartial ) {\x0a\x09\x09\x09\x09\x09_.each( widgetPartial.placements(), function( placement ) {\x0a\x09\x09\x09\x09\x09\x09var isRemoved = (\x0a\x09\x09\x09\x09\x09\x09\x09placement.context.sidebar_id === sidebarPartial.sidebarId ||\x0a\x09\x09\x09\x09\x09\x09\x09( placement.context.sidebar_args && placement.context.sidebar_args.id === sidebarPartial.sidebarId )\x0a\x09\x09\x09\x09\x09\x09);\x0a\x09\x09\x09\x09\x09\x09if ( isRemoved ) {\x0a\x09\x09\x09\x09\x09\x09\x09placement.container.remove();\x0a\x09\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09delete self.renderedWidgets[ removedWidgetId ];\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09// Handle insertion of widgets.\x0a\x09\x09\x09widgetsAdded = _.difference( newWidgetIds, oldWidgetIds );\x0a\x09\x09\x09_.each( widgetsAdded, function( addedWidgetId ) {\x0a\x09\x09\x09\x09var widgetPartial = sidebarPartial.ensureWidgetPlacementContainers( addedWidgetId );\x0a\x09\x09\x09\x09addedWidgetPartials.push( widgetPartial );\x0a\x09\x09\x09\x09self.renderedWidgets[ addedWidgetId ] = true;\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09_.each( addedWidgetPartials, function( widgetPartial ) {\x0a\x09\x09\x09\x09widgetPartial.refresh();\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09api.selectiveRefresh.trigger( \x27sidebar-updated\x27, sidebarPartial );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Refreshes the sidebar partial.\x0a\x09\x09 *\x0a\x09\x09 * Note that the meat is handled in handleSettingChange because it has the\x0a\x09\x09 * context of which widgets were removed.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 *\x0a\x09\x09 * @returns {Promise} A promise postponing the refresh.\x0a\x09\x09 */\x0a\x09\x09refresh: function() {\x0a\x09\x09\x09var partial = this, deferred = $.Deferred();\x0a\x0a\x09\x09\x09deferred.fail( function() {\x0a\x09\x09\x09\x09partial.fallback();\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09if ( 0 === partial.placements().length ) {\x0a\x09\x09\x09\x09deferred.reject();\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09_.each( partial.reflowWidgets(), function( sidebarPlacement ) {\x0a\x09\x09\x09\x09\x09api.selectiveRefresh.trigger( \x27partial-content-rendered\x27, sidebarPlacement );\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09deferred.resolve();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09return deferred.promise();\x0a\x09\x09}\x0a\x09});\x0a\x0a\x09api.selectiveRefresh.partialConstructor.sidebar = self.SidebarPartial;\x0a\x09api.selectiveRefresh.partialConstructor.widget = self.WidgetPartial;\x0a\x0a\x09/**\x0a\x09 * Adds partials for the registered widget areas (sidebars).\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 *\x0a\x09 * @returns {void}\x0a\x09 */\x0a\x09self.addPartials = function() {\x0a\x09\x09_.each( self.registeredSidebars, function( registeredSidebar ) {\x0a\x09\x09\x09var partial, partialId = \x27sidebar[\x27 + registeredSidebar.id + \x27]\x27;\x0a\x09\x09\x09partial = api.selectiveRefresh.partial( partialId );\x0a\x09\x09\x09if ( ! partial ) {\x0a\x09\x09\x09\x09partial = new self.SidebarPartial( partialId, {\x0a\x09\x09\x09\x09\x09params: {\x0a\x09\x09\x09\x09\x09\x09sidebarArgs: registeredSidebar\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09api.selectiveRefresh.partial.add( partial );\x0a\x09\x09\x09}\x0a\x09\x09} );\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Calculates the selector for the sidebar\x27s widgets based on the registered\x0a\x09 * sidebar\x27s info.\x0a\x09 *\x0a\x09 * @memberOf wp.customize.widgetsPreview\x0a\x09 *\x0a\x09 * @since 3.9.0\x0a\x09 *\x0a\x09 * @returns {void}\x0a\x09 */\x0a\x09self.buildWidgetSelectors = function() {\x0a\x09\x09var self = this;\x0a\x0a\x09\x09$.each( self.registeredSidebars, function( i, sidebar ) {\x0a\x09\x09\x09var widgetTpl = [\x0a\x09\x09\x09\x09\x09sidebar.before_widget,\x0a\x09\x09\x09\x09\x09sidebar.before_title,\x0a\x09\x09\x09\x09\x09sidebar.after_title,\x0a\x09\x09\x09\x09\x09sidebar.after_widget\x0a\x09\x09\x09\x09].join( \x27\x27 ),\x0a\x09\x09\x09\x09emptyWidget,\x0a\x09\x09\x09\x09widgetSelector,\x0a\x09\x09\x09\x09widgetClasses;\x0a\x0a\x09\x09\x09emptyWidget = $( widgetTpl );\x0a\x09\x09\x09widgetSelector = emptyWidget.prop( \x27tagName\x27 ) || \x27\x27;\x0a\x09\x09\x09widgetClasses = emptyWidget.prop( \x27className\x27 ) || \x27\x27;\x0a\x0a\x09\x09\x09// Prevent a rare case when before_widget, before_title, after_title and after_widget is empty.\x0a\x09\x09\x09if ( ! widgetClasses ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Remove class names that incorporate the string formatting placeholders %1$s and %2$s.\x0a\x09\x09\x09widgetClasses = widgetClasses.replace( /\x5cS*%[12]\x5c$s\x5cS*/g, \x27\x27 );\x0a\x09\x09\x09widgetClasses = widgetClasses.replace( /^\x5cs+|\x5cs+$/g, \x27\x27 );\x0a\x09\x09\x09if ( widgetClasses ) {\x0a\x09\x09\x09\x09widgetSelector += \x27.\x27 + widgetClasses.split( /\x5cs+/ ).join( \x27.\x27 );\x0a\x09\x09\x09}\x0a\x09\x09\x09self.widgetSelectors.push( widgetSelector );\x0a\x09\x09});\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Highlights the widget on widget updates or widget control mouse overs.\x0a\x09 *\x0a\x09 * @memberOf wp.customize.widgetsPreview\x0a\x09 *\x0a\x09 * @since 3.9.0\x0a\x09 * @param  {string} widgetId ID of the widget.\x0a\x09 *\x0a\x09 * @returns {void}\x0a\x09 */\x0a\x09self.highlightWidget = function( widgetId ) {\x0a\x09\x09var $body = $( document.body ),\x0a\x09\x09\x09$widget = $( \x27#\x27 + widgetId );\x0a\x0a\x09\x09$body.find( \x27.widget-customizer-highlighted-widget\x27 ).removeClass( \x27widget-customizer-highlighted-widget\x27 );\x0a\x0a\x09\x09$widget.addClass( \x27widget-customizer-highlighted-widget\x27 );\x0a\x09\x09setTimeout( function() {\x0a\x09\x09\x09$widget.removeClass( \x27widget-customizer-highlighted-widget\x27 );\x0a\x09\x09}, 500 );\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Shows a title and highlights widgets on hover. On shift+clicking focuses the\x0a\x09 * widget control.\x0a\x09 *\x0a\x09 * @memberOf wp.customize.widgetsPreview\x0a\x09 *\x0a\x09 * @since 3.9.0\x0a\x09 *\x0a\x09 * @returns {void}\x0a\x09 */\x0a\x09self.highlightControls = function() {\x0a\x09\x09var self = this,\x0a\x09\x09\x09selector = this.widgetSelectors.join( \x27,\x27 );\x0a\x0a\x09\x09// Skip adding highlights if not in the customizer preview iframe.\x0a\x09\x09if ( ! api.settings.channel ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09$( selector ).attr( \x27title\x27, this.l10n.widgetTooltip );\x0a\x09\x09// Highlights widget when entering the widget editor.\x0a\x09\x09$( document ).on( \x27mouseenter\x27, selector, function() {\x0a\x09\x09\x09self.preview.send( \x27highlight-widget-control\x27, $( this ).prop( \x27id\x27 ) );\x0a\x09\x09});\x0a\x0a\x09\x09// Open expand the widget control when shift+clicking the widget element\x0a\x09\x09$( document ).on( \x27click\x27, selector, function( e ) {\x0a\x09\x09\x09if ( ! e.shiftKey ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x09\x09\x09e.preventDefault();\x0a\x0a\x09\x09\x09self.preview.send( \x27focus-widget-control\x27, $( this ).prop( \x27id\x27 ) );\x0a\x09\x09});\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Parses a widget ID.\x0a\x09 *\x0a\x09 * @memberOf wp.customize.widgetsPreview\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 *\x0a\x09 * @param {string} widgetId The widget ID.\x0a\x09 *\x0a\x09 * @returns {{idBase: string, number: number|null}} An object containing the\x0a\x09 *          idBase and number of the parsed widget ID.\x0a\x09 */\x0a\x09self.parseWidgetId = function( widgetId ) {\x0a\x09\x09var matches, parsed = {\x0a\x09\x09\x09idBase: \x27\x27,\x0a\x09\x09\x09number: null\x0a\x09\x09};\x0a\x0a\x09\x09matches = widgetId.match( /^(.+)-(\x5cd+)$/ );\x0a\x09\x09if ( matches ) {\x0a\x09\x09\x09parsed.idBase = matches[1];\x0a\x09\x09\x09parsed.number = parseInt( matches[2], 10 );\x0a\x09\x09} else {\x0a\x09\x09\x09parsed.idBase = widgetId; // Likely an old single widget.\x0a\x09\x09}\x0a\x0a\x09\x09return parsed;\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Parses a widget setting ID.\x0a\x09 *\x0a\x09 * @memberOf wp.customize.widgetsPreview\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 *\x0a\x09 * @param {string} settingId Widget setting ID.\x0a\x09 *\x0a\x09 * @returns {{idBase: string, number: number|null}|null} Either an object\x0a\x09 *          containing the idBase and number of the parsed widget setting ID, or\x0a\x09 *          null.\x0a\x09 */\x0a\x09self.parseWidgetSettingId = function( settingId ) {\x0a\x09\x09var matches, parsed = {\x0a\x09\x09\x09idBase: \x27\x27,\x0a\x09\x09\x09number: null\x0a\x09\x09};\x0a\x0a\x09\x09matches = settingId.match( /^widget_([^\x5c[]+?)(?:\x5c[(\x5cd+)])?$/ );\x0a\x09\x09if ( ! matches ) {\x0a\x09\x09\x09return null;\x0a\x09\x09}\x0a\x09\x09parsed.idBase = matches[1];\x0a\x09\x09if ( matches[2] ) {\x0a\x09\x09\x09parsed.number = parseInt( matches[2], 10 );\x0a\x09\x09}\x0a\x09\x09return parsed;\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Converts a widget ID into a Customizer setting ID.\x0a\x09 *\x0a\x09 * @memberOf wp.customize.widgetsPreview\x0a\x09 *\x0a\x09 * @since 4.5.0\x0a\x09 *\x0a\x09 * @param {string} widgetId The widget ID.\x0a\x09 *\x0a\x09 * @returns {string} The setting ID.\x0a\x09 */\x0a\x09self.getWidgetSettingId = function( widgetId ) {\x0a\x09\x09var parsed = this.parseWidgetId( widgetId ), settingId;\x0a\x0a\x09\x09settingId = \x27widget_\x27 + parsed.idBase;\x0a\x09\x09if ( parsed.number ) {\x0a\x09\x09\x09settingId += \x27[\x27 + String( parsed.number ) + \x27]\x27;\x0a\x09\x09}\x0a\x0a\x09\x09return settingId;\x0a\x09};\x0a\x0a\x09api.bind( \x27preview-ready\x27, function() {\x0a\x09\x09$.extend( self, _wpWidgetCustomizerPreviewSettings );\x0a\x09\x09self.init();\x0a\x09});\x0a\x0a\x09return self;\x0a})( jQuery, _, wp, wp.customize );\x0a'}