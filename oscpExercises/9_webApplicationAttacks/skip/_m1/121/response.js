var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:00:03 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Fri, 15 Dec 2017 13:42:46 GMT\x0aETag: \x223206-560612cf68180-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-4286/4287\x0aContent-Length: 4287\x0aKeep-Alive: timeout=5, max=96\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/* global pluploadL10n, plupload, _wpPluploadSettings */\x0a\x0a/**\x0a * @namespace wp\x0a */\x0awindow.wp = window.wp || {};\x0a\x0a( function( exports, $ ) {\x0a\x09var Uploader;\x0a\x0a\x09if ( typeof _wpPluploadSettings === \x27undefined\x27 ) {\x0a\x09\x09return;\x0a\x09}\x0a\x0a\x09/**\x0a\x09 * A WordPress uploader.\x0a\x09 *\x0a\x09 * The Plupload library provides cross-browser uploader UI integration.\x0a\x09 * This object bridges the Plupload API to integrate uploads into the\x0a\x09 * WordPress back end and the WordPress media experience.\x0a\x09 *\x0a\x09 * @class\x0a\x09 * @memberOf wp\x0a\x09 * @alias wp.Uploader\x0a\x09 *\x0a\x09 * @param {object} options           The options passed to the new plupload instance.\x0a\x09 * @param {object} options.container The id of uploader container.\x0a\x09 * @param {object} options.browser   The id of button to trigger the file select.\x0a\x09 * @param {object} options.dropzone  The id of file drop target.\x0a\x09 * @param {object} options.plupload  An object of parameters to pass to the plupload instance.\x0a\x09 * @param {object} options.params    An object of parameters to pass to $_POST when uploading the file.\x0a\x09 *                                   Extends this.plupload.multipart_params under the hood.\x0a\x09 */\x0a\x09Uploader = function( options ) {\x0a\x09\x09var self = this,\x0a\x09\x09\x09isIE = navigator.userAgent.indexOf(\x27Trident/\x27) != -1 || navigator.userAgent.indexOf(\x27MSIE \x27) != -1,\x0a\x09\x09\x09elements = {\x0a\x09\x09\x09\x09container: \x27container\x27,\x0a\x09\x09\x09\x09browser:   \x27browse_button\x27,\x0a\x09\x09\x09\x09dropzone:  \x27drop_element\x27\x0a\x09\x09\x09},\x0a\x09\x09\x09key, error;\x0a\x0a\x09\x09this.supports = {\x0a\x09\x09\x09upload: Uploader.browser.supported\x0a\x09\x09};\x0a\x0a\x09\x09this.supported = this.supports.upload;\x0a\x0a\x09\x09if ( ! this.supported ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09// Arguments to send to pluplad.Uploader().\x0a\x09\x09// Use deep extend to ensure that multipart_params and other objects are cloned.\x0a\x09\x09this.plupload = $.extend( true, { multipart_params: {} }, Uploader.defaults );\x0a\x09\x09this.container = document.body; // Set default container.\x0a\x0a\x09\x09// Extend the instance with options.\x0a\x09\x09//\x0a\x09\x09// Use deep extend to allow options.plupload to override individual\x0a\x09\x09// default plupload keys.\x0a\x09\x09$.extend( true, this, options );\x0a\x0a\x09\x09// Proxy all methods so this always refers to the current instance.\x0a\x09\x09for ( key in this ) {\x0a\x09\x09\x09if ( $.isFunction( this[ key ] ) ) {\x0a\x09\x09\x09\x09this[ key ] = $.proxy( this[ key ], this );\x0a\x09\x09\x09}\x0a\x09\x09}\x0a\x0a\x09\x09// Ensure all elements are jQuery elements and have id attributes,\x0a\x09\x09// then set the proper plupload arguments to the ids.\x0a\x09\x09for ( key in elements ) {\x0a\x09\x09\x09if ( ! this[ key ] ) {\x0a\x09\x09\x09\x09continue;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09this[ key ] = $( this[ key ] ).first();\x0a\x0a\x09\x09\x09if ( ! this[ key ].length ) {\x0a\x09\x09\x09\x09delete this[ key ];\x0a\x09\x09\x09\x09continue;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if ( ! this[ key ].prop(\x27id\x27) ) {\x0a\x09\x09\x09\x09this[ key ].prop( \x27id\x27, \x27__wp-uploader-id-\x27 + Uploader.uuid++ );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09this.plupload[ elements[ key ] ] = this[ key ].prop(\x27id\x27);\x0a\x09\x09}\x0a\x0a\x09\x09// If the uploader has neither a browse button nor a dropzone, bail.\x0a\x09\x09if ( ! ( this.browser && this.browser.length ) && ! ( this.dropzone && this.dropzone.length ) ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09// Make sure flash sends cookies (seems in IE it does without switching to urlstream mode)\x0a\x09\x09if ( ! isIE && \x27flash\x27 === plupload.predictRuntime( this.plupload ) &&\x0a\x09\x09\x09( ! this.plupload.required_features || ! this.plupload.required_features.hasOwnProperty( \x27send_binary_string\x27 ) ) ) {\x0a\x0a\x09\x09\x09this.plupload.required_features = this.plupload.required_features || {};\x0a\x09\x09\x09this.plupload.required_features.send_binary_string = true;\x0a\x09\x09}\x0a\x0a\x09\x09// Initialize the plupload instance.\x0a\x09\x09this.uploader = new plupload.Uploader( this.plupload );\x0a\x09\x09delete this.plupload;\x0a\x0a\x09\x09// Set default params and remove this.params alias.\x0a\x09\x09this.param( this.params || {} );\x0a\x09\x09delete this.params;\x0a\x0a\x09\x09/**\x0a\x09\x09 * Custom error callback.\x0a\x09\x09 *\x0a\x09\x09 * Add a new error to the errors collection, so other modules can track\x0a\x09\x09 * and display errors. @see wp.Uploader.errors.\x0a\x09\x09 *\x0a\x09\x09 * @param  {string}        message\x0a\x09\x09 * @param  {object}        data\x0a\x09\x09 * @param  {plupload.File} file     File that was uploaded.\x0a\x09\x09 */\x0a\x09\x09error = function( message, data, file ) {\x0a\x09\x09\x09if ( file.attachment ) {\x0a\x09\x09\x09\x09file.attachment.destroy();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09Uploader.errors.unshift({\x0a\x09\x09\x09\x09message: message || pluploadL10n.default_error,\x0a\x09\x09\x09\x09data:    data,\x0a\x09\x09\x09\x09file:    file\x0a\x09\x09\x09});\x0a\x0a\x09\x09\x09self.error( message, data, file );\x0a\x09\x09};\x0a\x0a\x09\x09/**\x0a\x09\x09 * After the Uploader has been initialized, initialize some behaviors for the dropzone.\x0a\x09\x09 *\x0a\x09\x09 * @param {plupload.Uploader} uploader Uploader instance.\x0a\x09\x09 */\x0a\x09\x09this.uploader.bind( \x27init\x27, function( uploader ) {\x0a\x09\x09\x09var timer, active, dragdrop,\x0a\x09\x09\x09\x09dropzone = self.dropzone;\x0a\x0a\x09\x09\x09dragdrop = self.supports.dragdrop = uploader.features.dragdrop && ! Uploader.browser.mobile;\x0a\x0a\x09\x09\x09// Generate drag/drop helper classes.\x0a\x09\x09\x09if ( ! dropzone ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09dropzone.toggleClass( \x27supports-drag-drop\x27, !! dragdrop );\x0a\x0a\x09\x09\x09if ( ! dragdrop ) {\x0a\x09\x09\x09\x09return dropzone.unbind(\x27.wp-uploader\x27);\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// \x27dragenter\x27 doesn\x27t fire correctly, simulate it with a limited \x27dragover\x27.\x0a\x09\x09\x09dropzone.bind( \x27dragover.wp-uploader\x27, function() {\x0a\x09\x09\x09\x09if ( timer ) {\x0a\x09\x09\x09\x09\x09clearTimeout( timer );\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09if ( active ) {\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09dropzone.trigger(\x27dropzone:enter\x27).addClass(\x27drag-over\x27);\x0a\x09\x09\x09\x09active = true;\x0a\x09\x09\x09});\x0a\x0a\x09\x09\x09dropzone.bind(\x27dragleave.wp-uploader, drop.wp-uploader\x27, function() {\x0a\x09\x09\x09\x09// Using an instant timer prevents the drag-over class from\x0a\x09\x09\x09\x09// being quickly removed and re-added when elements inside the\x0a\x09\x09\x09\x09// dropzone are repositioned.\x0a\x09\x09\x09\x09//\x0a\x09\x09\x09\x09// @see https://core.trac.wordpress.org/ticket/21705\x0a\x09\x09\x09\x09timer = setTimeout( function() {\x0a\x09\x09\x09\x09\x09active = false;\x0a\x09\x09\x09\x09\x09dropzone.trigger(\x27dropzone:leave\x27).removeClass(\x27drag-over\x27);\x0a\x09\x09\x09\x09}, 0 );\x0a\x09\x09\x09});\x0a\x0a\x09\x09\x09self.ready = true;\x0a\x09\x09\x09$(self).trigger( \x27uploader:ready\x27 );\x0a\x09\x09});\x0a\x0a\x09\x09this.uploader.bind( \x27postinit\x27, function( up ) {\x0a\x09\x09\x09up.refresh();\x0a\x09\x09\x09self.init();\x0a\x09\x09});\x0a\x0a\x09\x09this.uploader.init();\x0a\x0a\x09\x09if ( this.browser ) {\x0a\x09\x09\x09this.browser.on( \x27mouseenter\x27, this.refresh );\x0a\x09\x09} else {\x0a\x09\x09\x09this.uploader.disableBrowse( true );\x0a\x09\x09\x09// If HTML5 mode, hide the auto-created file container.\x0a\x09\x09\x09$(\x27#\x27 + this.uploader.id + \x27_html5_container\x27).hide();\x0a\x09\x09}\x0a\x0a\x09\x09/**\x0a\x09\x09 * After files were filtered and added to the queue, create a model for each.\x0a\x09\x09 *\x0a\x09\x09 * @param {plupload.Uploader} uploader Uploader instance.\x0a\x09\x09 * @param {Array}             files    Array of file objects that were added to queue by the user.\x0a\x09\x09 */\x0a\x09\x09this.uploader.bind( \x27FilesAdded\x27, function( up, files ) {\x0a\x09\x09\x09_.each( files, function( file ) {\x0a\x09\x09\x09\x09var attributes, image;\x0a\x0a\x09\x09\x09\x09// Ignore failed uploads.\x0a\x09\x09\x09\x09if ( plupload.FAILED === file.status ) {\x0a\x09\x09\x09\x09\x09return;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Generate attributes for a new `Attachment` model.\x0a\x09\x09\x09\x09attributes = _.extend({\x0a\x09\x09\x09\x09\x09file:      file,\x0a\x09\x09\x09\x09\x09uploading: true,\x0a\x09\x09\x09\x09\x09date:      new Date(),\x0a\x09\x09\x09\x09\x09filename:  file.name,\x0a\x09\x09\x09\x09\x09menuOrder: 0,\x0a\x09\x09\x09\x09\x09uploadedTo: wp.media.model.settings.post.id\x0a\x09\x09\x09\x09}, _.pick( file, \x27loaded\x27, \x27size\x27, \x27percent\x27 ) );\x0a\x0a\x09\x09\x09\x09// Handle early mime type scanning for images.\x0a\x09\x09\x09\x09image = /(?:jpe?g|png|gif)$/i.exec( file.name );\x0a\x0a\x09\x09\x09\x09// For images set the model\x27s type and subtype attributes.\x0a\x09\x09\x09\x09if ( image ) {\x0a\x09\x09\x09\x09\x09attributes.type = \x27image\x27;\x0a\x0a\x09\x09\x09\x09\x09// `jpeg`, `png` and `gif` are valid subtypes.\x0a\x09\x09\x09\x09\x09// `jpg` is not, so map it to `jpeg`.\x0a\x09\x09\x09\x09\x09attributes.subtype = ( \x27jpg\x27 === image[0] ) ? \x27jpeg\x27 : image[0];\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Create a model for the attachment, and add it to the Upload queue collection\x0a\x09\x09\x09\x09// so listeners to the upload queue can track and display upload progress.\x0a\x09\x09\x09\x09file.attachment = wp.media.model.Attachment.create( attributes );\x0a\x09\x09\x09\x09Uploader.queue.add( file.attachment );\x0a\x0a\x09\x09\x09\x09self.added( file.attachment );\x0a\x09\x09\x09});\x0a\x0a\x09\x09\x09up.refresh();\x0a\x09\x09\x09up.start();\x0a\x09\x09});\x0a\x0a\x09\x09this.uploader.bind( \x27UploadProgress\x27, function( up, file ) {\x0a\x09\x09\x09file.attachment.set( _.pick( file, \x27loaded\x27, \x27percent\x27 ) );\x0a\x09\x09\x09self.progress( file.attachment );\x0a\x09\x09});\x0a\x0a\x09\x09/**\x0a\x09\x09 * After a file is successfully uploaded, update its model.\x0a\x09\x09 *\x0a\x09\x09 * @param {plupload.Uploader} uploader Uploader instance.\x0a\x09\x09 * @param {plupload.File}     file     File that was uploaded.\x0a\x09\x09 * @param {Object}            response Object with response properties.\x0a\x09\x09 * @return {mixed}\x0a\x09\x09 */\x0a\x09\x09this.uploader.bind( \x27FileUploaded\x27, function( up, file, response ) {\x0a\x09\x09\x09var complete;\x0a\x0a\x09\x09\x09try {\x0a\x09\x09\x09\x09response = JSON.parse( response.response );\x0a\x09\x09\x09} catch ( e ) {\x0a\x09\x09\x09\x09return error( pluploadL10n.default_error, e, file );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if ( ! _.isObject( response ) || _.isUndefined( response.success ) )\x0a\x09\x09\x09\x09return error( pluploadL10n.default_error, null, file );\x0a\x09\x09\x09else if ( ! response.success )\x0a\x09\x09\x09\x09return error( response.data && response.data.message, response.data, file );\x0a\x0a\x09\x09\x09_.each([\x27file\x27,\x27loaded\x27,\x27size\x27,\x27percent\x27], function( key ) {\x0a\x09\x09\x09\x09file.attachment.unset( key );\x0a\x09\x09\x09});\x0a\x0a\x09\x09\x09file.attachment.set( _.extend( response.data, { uploading: false }) );\x0a\x09\x09\x09wp.media.model.Attachment.get( response.data.id, file.attachment );\x0a\x0a\x09\x09\x09complete = Uploader.queue.all( function( attachment ) {\x0a\x09\x09\x09\x09return ! attachment.get(\x27uploading\x27);\x0a\x09\x09\x09});\x0a\x0a\x09\x09\x09if ( complete )\x0a\x09\x09\x09\x09Uploader.queue.reset();\x0a\x0a\x09\x09\x09self.success( file.attachment );\x0a\x09\x09});\x0a\x0a\x09\x09/**\x0a\x09\x09 * When plupload surfaces an error, send it to the error handler.\x0a\x09\x09 *\x0a\x09\x09 * @param {plupload.Uploader} uploader Uploader instance.\x0a\x09\x09 * @param {Object}            error    Contains code, message and sometimes file and other details.\x0a\x09\x09 */\x0a\x09\x09this.uploader.bind( \x27Error\x27, function( up, pluploadError ) {\x0a\x09\x09\x09var message = pluploadL10n.default_error,\x0a\x09\x09\x09\x09key;\x0a\x0a\x09\x09\x09// Check for plupload errors.\x0a\x09\x09\x09for ( key in Uploader.errorMap ) {\x0a\x09\x09\x09\x09if ( pluploadError.code === plupload[ key ] ) {\x0a\x09\x09\x09\x09\x09message = Uploader.errorMap[ key ];\x0a\x0a\x09\x09\x09\x09\x09if ( _.isFunction( message ) ) {\x0a\x09\x09\x09\x09\x09\x09message = message( pluploadError.file, pluploadError );\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09break;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09error( message, pluploadError, pluploadError.file );\x0a\x09\x09\x09up.refresh();\x0a\x09\x09});\x0a\x0a\x09};\x0a\x0a\x09// Adds the \x27defaults\x27 and \x27browser\x27 properties.\x0a\x09$.extend( Uploader, _wpPluploadSettings );\x0a\x0a\x09Uploader.uuid = 0;\x0a\x0a\x09// Map Plupload error codes to user friendly error messages.\x0a\x09Uploader.errorMap = {\x0a\x09\x09\x27FAILED\x27:                 pluploadL10n.upload_failed,\x0a\x09\x09\x27FILE_EXTENSION_ERROR\x27:   pluploadL10n.invalid_filetype,\x0a\x09\x09\x27IMAGE_FORMAT_ERROR\x27:     pluploadL10n.not_an_image,\x0a\x09\x09\x27IMAGE_MEMORY_ERROR\x27:     pluploadL10n.image_memory_exceeded,\x0a\x09\x09\x27IMAGE_DIMENSIONS_ERROR\x27: pluploadL10n.image_dimensions_exceeded,\x0a\x09\x09\x27GENERIC_ERROR\x27:          pluploadL10n.upload_failed,\x0a\x09\x09\x27IO_ERROR\x27:               pluploadL10n.io_error,\x0a\x09\x09\x27HTTP_ERROR\x27:             pluploadL10n.http_error,\x0a\x09\x09\x27SECURITY_ERROR\x27:         pluploadL10n.security_error,\x0a\x0a\x09\x09\x27FILE_SIZE_ERROR\x27: function( file ) {\x0a\x09\x09\x09return pluploadL10n.file_exceeds_size_limit.replace(\x27%s\x27, file.name);\x0a\x09\x09}\x0a\x09};\x0a\x0a\x09$.extend( Uploader.prototype, /** @lends wp.Uploader.prototype */{\x0a\x09\x09/**\x0a\x09\x09 * Acts as a shortcut to extending the uploader\x27s multipart_params object.\x0a\x09\x09 *\x0a\x09\x09 * param( key )\x0a\x09\x09 *    Returns the value of the key.\x0a\x09\x09 *\x0a\x09\x09 * param( key, value )\x0a\x09\x09 *    Sets the value of a key.\x0a\x09\x09 *\x0a\x09\x09 * param( map )\x0a\x09\x09 *    Sets values for a map of data.\x0a\x09\x09 */\x0a\x09\x09param: function( key, value ) {\x0a\x09\x09\x09if ( arguments.length === 1 && typeof key === \x27string\x27 ) {\x0a\x09\x09\x09\x09return this.uploader.settings.multipart_params[ key ];\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if ( arguments.length \x3e 1 ) {\x0a\x09\x09\x09\x09this.uploader.settings.multipart_params[ key ] = value;\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09$.extend( this.uploader.settings.multipart_params, key );\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Make a few internal event callbacks available on the wp.Uploader object\x0a\x09\x09 * to change the Uploader internals if absolutely necessary.\x0a\x09\x09 */\x0a\x09\x09init:     function() {},\x0a\x09\x09error:    function() {},\x0a\x09\x09success:  function() {},\x0a\x09\x09added:    function() {},\x0a\x09\x09progress: function() {},\x0a\x09\x09complete: function() {},\x0a\x09\x09refresh:  function() {\x0a\x09\x09\x09var node, attached, container, id;\x0a\x0a\x09\x09\x09if ( this.browser ) {\x0a\x09\x09\x09\x09node = this.browser[0];\x0a\x0a\x09\x09\x09\x09// Check if the browser node is in the DOM.\x0a\x09\x09\x09\x09while ( node ) {\x0a\x09\x09\x09\x09\x09if ( node === document.body ) {\x0a\x09\x09\x09\x09\x09\x09attached = true;\x0a\x09\x09\x09\x09\x09\x09break;\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09\x09node = node.parentNode;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// If the browser node is not attached to the DOM, use a\x0a\x09\x09\x09\x09// temporary container to house it, as the browser button\x0a\x09\x09\x09\x09// shims require the button to exist in the DOM at all times.\x0a\x09\x09\x09\x09if ( ! attached ) {\x0a\x09\x09\x09\x09\x09id = \x27wp-uploader-browser-\x27 + this.uploader.id;\x0a\x0a\x09\x09\x09\x09\x09container = $( \x27#\x27 + id );\x0a\x09\x09\x09\x09\x09if ( ! container.length ) {\x0a\x09\x09\x09\x09\x09\x09container = $(\x27\x3cdiv class=\x22wp-uploader-browser\x22 /\x3e\x27).css({\x0a\x09\x09\x09\x09\x09\x09\x09position: \x27fixed\x27,\x0a\x09\x09\x09\x09\x09\x09\x09top: \x27-1000px\x27,\x0a\x09\x09\x09\x09\x09\x09\x09left: \x27-1000px\x27,\x0a\x09\x09\x09\x09\x09\x09\x09height: 0,\x0a\x09\x09\x09\x09\x09\x09\x09width: 0\x0a\x09\x09\x09\x09\x09\x09}).attr( \x27id\x27, \x27wp-uploader-browser-\x27 + this.uploader.id ).appendTo(\x27body\x27);\x0a\x09\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09\x09container.append( this.browser );\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09this.uploader.refresh();\x0a\x09\x09}\x0a\x09});\x0a\x0a\x09// Create a collection of attachments in the upload queue,\x0a\x09// so that other modules can track and display upload progress.\x0a\x09Uploader.queue = new wp.media.model.Attachments( [], { query: false });\x0a\x0a\x09// Create a collection to collect errors incurred while attempting upload.\x0a\x09Uploader.errors = new Backbone.Collection();\x0a\x0a\x09exports.Uploader = Uploader;\x0a})( wp, jQuery );\x0a'}