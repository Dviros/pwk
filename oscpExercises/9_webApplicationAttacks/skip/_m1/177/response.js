var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:11:59 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Mon, 21 Jan 2019 23:03:50 GMT\x0aETag: \x226d41-57fffdfb32180-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-7423/7424\x0aContent-Length: 7424\x0aKeep-Alive: timeout=5, max=90\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/*\x0a * Script run inside a Customizer preview frame.\x0a *\x0a * @output wp-includes/js/customize-preview.js\x0a */\x0a(function( exports, $ ){\x0a\x09var api = wp.customize,\x0a\x09\x09debounce,\x0a\x09\x09currentHistoryState = {};\x0a\x0a\x09/*\x0a\x09 * Capture the state that is passed into history.replaceState() and history.pushState()\x0a\x09 * and also which is returned in the popstate event so that when the changeset_uuid\x0a\x09 * gets updated when transitioning to a new changeset there the current state will\x0a\x09 * be supplied in the call to history.replaceState().\x0a\x09 */\x0a\x09( function( history ) {\x0a\x09\x09var injectUrlWithState;\x0a\x0a\x09\x09if ( ! history.replaceState ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09/**\x0a\x09\x09 * Amend the supplied URL with the customized state.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.7.0\x0a\x09\x09 * @access private\x0a\x09\x09 *\x0a\x09\x09 * @param {string} url URL.\x0a\x09\x09 * @returns {string} URL with customized state.\x0a\x09\x09 */\x0a\x09\x09injectUrlWithState = function( url ) {\x0a\x09\x09\x09var urlParser, oldQueryParams, newQueryParams;\x0a\x09\x09\x09urlParser = document.createElement( \x27a\x27 );\x0a\x09\x09\x09urlParser.href = url;\x0a\x09\x09\x09oldQueryParams = api.utils.parseQueryString( location.search.substr( 1 ) );\x0a\x09\x09\x09newQueryParams = api.utils.parseQueryString( urlParser.search.substr( 1 ) );\x0a\x0a\x09\x09\x09newQueryParams.customize_changeset_uuid = oldQueryParams.customize_changeset_uuid;\x0a\x09\x09\x09if ( oldQueryParams.customize_autosaved ) {\x0a\x09\x09\x09\x09newQueryParams.customize_autosaved = \x27on\x27;\x0a\x09\x09\x09}\x0a\x09\x09\x09if ( oldQueryParams.customize_theme ) {\x0a\x09\x09\x09\x09newQueryParams.customize_theme = oldQueryParams.customize_theme;\x0a\x09\x09\x09}\x0a\x09\x09\x09if ( oldQueryParams.customize_messenger_channel ) {\x0a\x09\x09\x09\x09newQueryParams.customize_messenger_channel = oldQueryParams.customize_messenger_channel;\x0a\x09\x09\x09}\x0a\x09\x09\x09urlParser.search = $.param( newQueryParams );\x0a\x09\x09\x09return urlParser.href;\x0a\x09\x09};\x0a\x0a\x09\x09history.replaceState = ( function( nativeReplaceState ) {\x0a\x09\x09\x09return function historyReplaceState( data, title, url ) {\x0a\x09\x09\x09\x09currentHistoryState = data;\x0a\x09\x09\x09\x09return nativeReplaceState.call( history, data, title, \x27string\x27 === typeof url && url.length \x3e 0 ? injectUrlWithState( url ) : url );\x0a\x09\x09\x09};\x0a\x09\x09} )( history.replaceState );\x0a\x0a\x09\x09history.pushState = ( function( nativePushState ) {\x0a\x09\x09\x09return function historyPushState( data, title, url ) {\x0a\x09\x09\x09\x09currentHistoryState = data;\x0a\x09\x09\x09\x09return nativePushState.call( history, data, title, \x27string\x27 === typeof url && url.length \x3e 0 ? injectUrlWithState( url ) : url );\x0a\x09\x09\x09};\x0a\x09\x09} )( history.pushState );\x0a\x0a\x09\x09window.addEventListener( \x27popstate\x27, function( event ) {\x0a\x09\x09\x09currentHistoryState = event.state;\x0a\x09\x09} );\x0a\x0a\x09}( history ) );\x0a\x0a\x09/**\x0a\x09 * Returns a debounced version of the function.\x0a\x09 *\x0a\x09 * @todo Require Underscore.js for this file and retire this.\x0a\x09 */\x0a\x09debounce = function( fn, delay, context ) {\x0a\x09\x09var timeout;\x0a\x09\x09return function() {\x0a\x09\x09\x09var args = arguments;\x0a\x0a\x09\x09\x09context = context || this;\x0a\x0a\x09\x09\x09clearTimeout( timeout );\x0a\x09\x09\x09timeout = setTimeout( function() {\x0a\x09\x09\x09\x09timeout = null;\x0a\x09\x09\x09\x09fn.apply( context, args );\x0a\x09\x09\x09}, delay );\x0a\x09\x09};\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * @memberOf wp.customize\x0a\x09 * @alias wp.customize.Preview\x0a\x09 *\x0a\x09 * @constructor\x0a\x09 * @augments wp.customize.Messenger\x0a\x09 * @augments wp.customize.Class\x0a\x09 * @mixes wp.customize.Events\x0a\x09 */\x0a\x09api.Preview = api.Messenger.extend(/** @lends wp.customize.Preview.prototype */{\x0a\x09\x09/**\x0a\x09\x09 * @param {object} params  - Parameters to configure the messenger.\x0a\x09\x09 * @param {object} options - Extend any instance parameter or method with this object.\x0a\x09\x09 */\x0a\x09\x09initialize: function( params, options ) {\x0a\x09\x09\x09var preview = this, urlParser = document.createElement( \x27a\x27 );\x0a\x0a\x09\x09\x09api.Messenger.prototype.initialize.call( preview, params, options );\x0a\x0a\x09\x09\x09urlParser.href = preview.origin();\x0a\x09\x09\x09preview.add( \x27scheme\x27, urlParser.protocol.replace( /:$/, \x27\x27 ) );\x0a\x0a\x09\x09\x09preview.body = $( document.body );\x0a\x09\x09\x09preview.window = $( window );\x0a\x0a\x09\x09\x09if ( api.settings.channel ) {\x0a\x0a\x09\x09\x09\x09// If in an iframe, then intercept the link clicks and form submissions.\x0a\x09\x09\x09\x09preview.body.on( \x27click.preview\x27, \x27a\x27, function( event ) {\x0a\x09\x09\x09\x09\x09preview.handleLinkClick( event );\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09preview.body.on( \x27submit.preview\x27, \x27form\x27, function( event ) {\x0a\x09\x09\x09\x09\x09preview.handleFormSubmit( event );\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09preview.window.on( \x27scroll.preview\x27, debounce( function() {\x0a\x09\x09\x09\x09\x09preview.send( \x27scroll\x27, preview.window.scrollTop() );\x0a\x09\x09\x09\x09}, 200 ) );\x0a\x0a\x09\x09\x09\x09preview.bind( \x27scroll\x27, function( distance ) {\x0a\x09\x09\x09\x09\x09preview.window.scrollTop( distance );\x0a\x09\x09\x09\x09});\x0a\x09\x09\x09}\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Handle link clicks in preview.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.7.0\x0a\x09\x09 * @access public\x0a\x09\x09 *\x0a\x09\x09 * @param {jQuery.Event} event Event.\x0a\x09\x09 */\x0a\x09\x09handleLinkClick: function( event ) {\x0a\x09\x09\x09var preview = this, link, isInternalJumpLink;\x0a\x09\x09\x09link = $( event.target ).closest( \x27a\x27 );\x0a\x0a\x09\x09\x09// No-op if the anchor is not a link.\x0a\x09\x09\x09if ( _.isUndefined( link.attr( \x27href\x27 ) ) ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Allow internal jump links and JS links to behave normally without preventing default.\x0a\x09\x09\x09isInternalJumpLink = ( \x27#\x27 === link.attr( \x27href\x27 ).substr( 0, 1 ) );\x0a\x09\x09\x09if ( isInternalJumpLink || ! /^https?:$/.test( link.prop( \x27protocol\x27 ) ) ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// If the link is not previewable, prevent the browser from navigating to it.\x0a\x09\x09\x09if ( ! api.isLinkPreviewable( link[0] ) ) {\x0a\x09\x09\x09\x09wp.a11y.speak( api.settings.l10n.linkUnpreviewable );\x0a\x09\x09\x09\x09event.preventDefault();\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Prevent initiating navigating from click and instead rely on sending url message to pane.\x0a\x09\x09\x09event.preventDefault();\x0a\x0a\x09\x09\x09/*\x0a\x09\x09\x09 * Note the shift key is checked so shift+click on widgets or\x0a\x09\x09\x09 * nav menu items can just result on focusing on the corresponding\x0a\x09\x09\x09 * control instead of also navigating to the URL linked to.\x0a\x09\x09\x09 */\x0a\x09\x09\x09if ( event.shiftKey ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Note: It\x27s not relevant to send scroll because sending url message will have the same effect.\x0a\x09\x09\x09preview.send( \x27url\x27, link.prop( \x27href\x27 ) );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Handle form submit.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.7.0\x0a\x09\x09 * @access public\x0a\x09\x09 *\x0a\x09\x09 * @param {jQuery.Event} event Event.\x0a\x09\x09 */\x0a\x09\x09handleFormSubmit: function( event ) {\x0a\x09\x09\x09var preview = this, urlParser, form;\x0a\x09\x09\x09urlParser = document.createElement( \x27a\x27 );\x0a\x09\x09\x09form = $( event.target );\x0a\x09\x09\x09urlParser.href = form.prop( \x27action\x27 );\x0a\x0a\x09\x09\x09// If the link is not previewable, prevent the browser from navigating to it.\x0a\x09\x09\x09if ( \x27GET\x27 !== form.prop( \x27method\x27 ).toUpperCase() || ! api.isLinkPreviewable( urlParser ) ) {\x0a\x09\x09\x09\x09wp.a11y.speak( api.settings.l10n.formUnpreviewable );\x0a\x09\x09\x09\x09event.preventDefault();\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09/*\x0a\x09\x09\x09 * If the default wasn\x27t prevented already (in which case the form\x0a\x09\x09\x09 * submission is already being handled by JS), and if it has a GET\x0a\x09\x09\x09 * request method, then take the serialized form data and add it as\x0a\x09\x09\x09 * a query string to the action URL and send this in a url message\x0a\x09\x09\x09 * to the customizer pane so that it will be loaded. If the form\x27s\x0a\x09\x09\x09 * action points to a non-previewable URL, the customizer pane\x27s\x0a\x09\x09\x09 * previewUrl setter will reject it so that the form submission is\x0a\x09\x09\x09 * a no-op, which is the same behavior as when clicking a link to an\x0a\x09\x09\x09 * external site in the preview.\x0a\x09\x09\x09 */\x0a\x09\x09\x09if ( ! event.isDefaultPrevented() ) {\x0a\x09\x09\x09\x09if ( urlParser.search.length \x3e 1 ) {\x0a\x09\x09\x09\x09\x09urlParser.search += \x27&\x27;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09urlParser.search += form.serialize();\x0a\x09\x09\x09\x09preview.send( \x27url\x27, urlParser.href );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Prevent default since navigation should be done via sending url message or via JS submit handler.\x0a\x09\x09\x09event.preventDefault();\x0a\x09\x09}\x0a\x09});\x0a\x0a\x09/**\x0a\x09 * Inject the changeset UUID into links in the document.\x0a\x09 *\x0a\x09 * @since 4.7.0\x0a\x09 * @access protected\x0a\x09 *\x0a\x09 * @access private\x0a\x09 * @returns {void}\x0a\x09 */\x0a\x09api.addLinkPreviewing = function addLinkPreviewing() {\x0a\x09\x09var linkSelectors = \x27a[href], area[href]\x27;\x0a\x0a\x09\x09// Inject links into initial document.\x0a\x09\x09$( document.body ).find( linkSelectors ).each( function() {\x0a\x09\x09\x09api.prepareLinkPreview( this );\x0a\x09\x09} );\x0a\x0a\x09\x09// Inject links for new elements added to the page.\x0a\x09\x09if ( \x27undefined\x27 !== typeof MutationObserver ) {\x0a\x09\x09\x09api.mutationObserver = new MutationObserver( function( mutations ) {\x0a\x09\x09\x09\x09_.each( mutations, function( mutation ) {\x0a\x09\x09\x09\x09\x09$( mutation.target ).find( linkSelectors ).each( function() {\x0a\x09\x09\x09\x09\x09\x09api.prepareLinkPreview( this );\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09} );\x0a\x09\x09\x09api.mutationObserver.observe( document.documentElement, {\x0a\x09\x09\x09\x09childList: true,\x0a\x09\x09\x09\x09subtree: true\x0a\x09\x09\x09} );\x0a\x09\x09} else {\x0a\x0a\x09\x09\x09// If mutation observers aren\x27t available, fallback to just-in-time injection.\x0a\x09\x09\x09$( document.documentElement ).on( \x27click focus mouseover\x27, linkSelectors, function() {\x0a\x09\x09\x09\x09api.prepareLinkPreview( this );\x0a\x09\x09\x09} );\x0a\x09\x09}\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Should the supplied link is previewable.\x0a\x09 *\x0a\x09 * @since 4.7.0\x0a\x09 * @access public\x0a\x09 *\x0a\x09 * @param {HTMLAnchorElement|HTMLAreaElement} element Link element.\x0a\x09 * @param {string} element.search Query string.\x0a\x09 * @param {string} element.pathname Path.\x0a\x09 * @param {string} element.host Host.\x0a\x09 * @param {object} [options]\x0a\x09 * @param {object} [options.allowAdminAjax=false] Allow admin-ajax.php requests.\x0a\x09 * @returns {boolean} Is appropriate for changeset link.\x0a\x09 */\x0a\x09api.isLinkPreviewable = function isLinkPreviewable( element, options ) {\x0a\x09\x09var matchesAllowedUrl, parsedAllowedUrl, args, elementHost;\x0a\x0a\x09\x09args = _.extend( {}, { allowAdminAjax: false }, options || {} );\x0a\x0a\x09\x09if ( \x27javascript:\x27 === element.protocol ) { // jshint ignore:line\x0a\x09\x09\x09return true;\x0a\x09\x09}\x0a\x0a\x09\x09// Only web URLs can be previewed.\x0a\x09\x09if ( \x27https:\x27 !== element.protocol && \x27http:\x27 !== element.protocol ) {\x0a\x09\x09\x09return false;\x0a\x09\x09}\x0a\x0a\x09\x09elementHost = element.host.replace( /:(80|443)$/, \x27\x27 );\x0a\x09\x09parsedAllowedUrl = document.createElement( \x27a\x27 );\x0a\x09\x09matchesAllowedUrl = ! _.isUndefined( _.find( api.settings.url.allowed, function( allowedUrl ) {\x0a\x09\x09\x09parsedAllowedUrl.href = allowedUrl;\x0a\x09\x09\x09return parsedAllowedUrl.protocol === element.protocol && parsedAllowedUrl.host.replace( /:(80|443)$/, \x27\x27 ) === elementHost && 0 === element.pathname.indexOf( parsedAllowedUrl.pathname.replace( /\x5c/$/, \x27\x27 ) );\x0a\x09\x09} ) );\x0a\x09\x09if ( ! matchesAllowedUrl ) {\x0a\x09\x09\x09return false;\x0a\x09\x09}\x0a\x0a\x09\x09// Skip wp login and signup pages.\x0a\x09\x09if ( /\x5c/wp-(login|signup)\x5c.php$/.test( element.pathname ) ) {\x0a\x09\x09\x09return false;\x0a\x09\x09}\x0a\x0a\x09\x09// Allow links to admin ajax as faux frontend URLs.\x0a\x09\x09if ( /\x5c/wp-admin\x5c/admin-ajax\x5c.php$/.test( element.pathname ) ) {\x0a\x09\x09\x09return args.allowAdminAjax;\x0a\x09\x09}\x0a\x0a\x09\x09// Disallow links to admin, includes, and content.\x0a\x09\x09if ( /\x5c/wp-(admin|includes|content)(\x5c/|$)/.test( element.pathname ) ) {\x0a\x09\x09\x09return false;\x0a\x09\x09}\x0a\x0a\x09\x09return true;\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Inject the customize_changeset_uuid query param into links on the frontend.\x0a\x09 *\x0a\x09 * @since 4.7.0\x0a\x09 * @access protected\x0a\x09 *\x0a\x09 * @param {HTMLAnchorElement|HTMLAreaElement} element Link element.\x0a\x09 * @param {string} element.search Query string.\x0a\x09 * @param {string} element.host Host.\x0a\x09 * @param {string} element.protocol Protocol.\x0a\x09 * @returns {void}\x0a\x09 */\x0a\x09api.prepareLinkPreview = function prepareLinkPreview( element ) {\x0a\x09\x09var queryParams, $element = $( element );\x0a\x0a        // Skip elements with no href attribute. Check first to avoid more expensive checks down the road\x0a        if ( ! element.hasAttribute( \x27href\x27 ) ) {\x0a            return;\x0a        }\x0a\x0a\x09\x09// Skip links in admin bar.\x0a\x09\x09if ( $element.closest( \x27#wpadminbar\x27 ).length ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09// Ignore links with href=\x22#\x22, href=\x22#id\x22, or non-HTTP protocols (e.g. javascript: and mailto:).\x0a\x09\x09if ( \x27#\x27 === $element.attr( \x27href\x27 ).substr( 0, 1 ) || ! /^https?:$/.test( element.protocol ) ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09// Make sure links in preview use HTTPS if parent frame uses HTTPS.\x0a\x09\x09if ( api.settings.channel && \x27https\x27 === api.preview.scheme.get() && \x27http:\x27 === element.protocol && -1 !== api.settings.url.allowedHosts.indexOf( element.host ) ) {\x0a\x09\x09\x09element.protocol = \x27https:\x27;\x0a\x09\x09}\x0a\x0a\x09\x09// Ignore links with class wp-playlist-caption\x0a\x09\x09if ( $element.hasClass( \x27wp-playlist-caption\x27 ) ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09if ( ! api.isLinkPreviewable( element ) ) {\x0a\x0a\x09\x09\x09// Style link as unpreviewable only if previewing in iframe; if previewing on frontend, links will be allowed to work normally.\x0a\x09\x09\x09if ( api.settings.channel ) {\x0a\x09\x09\x09\x09$element.addClass( \x27customize-unpreviewable\x27 );\x0a\x09\x09\x09}\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x09\x09$element.removeClass( \x27customize-unpreviewable\x27 );\x0a\x0a\x09\x09queryParams = api.utils.parseQueryString( element.search.substring( 1 ) );\x0a\x09\x09queryParams.customize_changeset_uuid = api.settings.changeset.uuid;\x0a\x09\x09if ( api.settings.changeset.autosaved ) {\x0a\x09\x09\x09queryParams.customize_autosaved = \x27on\x27;\x0a\x09\x09}\x0a\x09\x09if ( ! api.settings.theme.active ) {\x0a\x09\x09\x09queryParams.customize_theme = api.settings.theme.stylesheet;\x0a\x09\x09}\x0a\x09\x09if ( api.settings.channel ) {\x0a\x09\x09\x09queryParams.customize_messenger_channel = api.settings.channel;\x0a\x09\x09}\x0a\x09\x09element.search = $.param( queryParams );\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Inject the changeset UUID into Ajax requests.\x0a\x09 *\x0a\x09 * @since 4.7.0\x0a\x09 * @access protected\x0a\x09 *\x0a\x09 * @return {void}\x0a\x09 */\x0a\x09api.addRequestPreviewing = function addRequestPreviewing() {\x0a\x0a\x09\x09/**\x0a\x09\x09 * Rewrite Ajax requests to inject customizer state.\x0a\x09\x09 *\x0a\x09\x09 * @param {object} options Options.\x0a\x09\x09 * @param {string} options.type Type.\x0a\x09\x09 * @param {string} options.url URL.\x0a\x09\x09 * @param {object} originalOptions Original options.\x0a\x09\x09 * @param {XMLHttpRequest} xhr XHR.\x0a\x09\x09 * @returns {void}\x0a\x09\x09 */\x0a\x09\x09var prefilterAjax = function( options, originalOptions, xhr ) {\x0a\x09\x09\x09var urlParser, queryParams, requestMethod, dirtyValues = {};\x0a\x09\x09\x09urlParser = document.createElement( \x27a\x27 );\x0a\x09\x09\x09urlParser.href = options.url;\x0a\x0a\x09\x09\x09// Abort if the request is not for this site.\x0a\x09\x09\x09if ( ! api.isLinkPreviewable( urlParser, { allowAdminAjax: true } ) ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x09\x09\x09queryParams = api.utils.parseQueryString( urlParser.search.substring( 1 ) );\x0a\x0a\x09\x09\x09// Note that _dirty flag will be cleared with changeset updates.\x0a\x09\x09\x09api.each( function( setting ) {\x0a\x09\x09\x09\x09if ( setting._dirty ) {\x0a\x09\x09\x09\x09\x09dirtyValues[ setting.id ] = setting.get();\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09if ( ! _.isEmpty( dirtyValues ) ) {\x0a\x09\x09\x09\x09requestMethod = options.type.toUpperCase();\x0a\x0a\x09\x09\x09\x09// Override underlying request method to ensure unsaved changes to changeset can be included (force Backbone.emulateHTTP).\x0a\x09\x09\x09\x09if ( \x27POST\x27 !== requestMethod ) {\x0a\x09\x09\x09\x09\x09xhr.setRequestHeader( \x27X-HTTP-Method-Override\x27, requestMethod );\x0a\x09\x09\x09\x09\x09queryParams._method = requestMethod;\x0a\x09\x09\x09\x09\x09options.type = \x27POST\x27;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Amend the post data with the customized values.\x0a\x09\x09\x09\x09if ( options.data ) {\x0a\x09\x09\x09\x09\x09options.data += \x27&\x27;\x0a\x09\x09\x09\x09} else {\x0a\x09\x09\x09\x09\x09options.data = \x27\x27;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09\x09options.data += $.param( {\x0a\x09\x09\x09\x09\x09customized: JSON.stringify( dirtyValues )\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Include customized state query params in URL.\x0a\x09\x09\x09queryParams.customize_changeset_uuid = api.settings.changeset.uuid;\x0a\x09\x09\x09if ( api.settings.changeset.autosaved ) {\x0a\x09\x09\x09\x09queryParams.customize_autosaved = \x27on\x27;\x0a\x09\x09\x09}\x0a\x09\x09\x09if ( ! api.settings.theme.active ) {\x0a\x09\x09\x09\x09queryParams.customize_theme = api.settings.theme.stylesheet;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Ensure preview nonce is included with every customized request, to allow post data to be read.\x0a\x09\x09\x09queryParams.customize_preview_nonce = api.settings.nonce.preview;\x0a\x0a\x09\x09\x09urlParser.search = $.param( queryParams );\x0a\x09\x09\x09options.url = urlParser.href;\x0a\x09\x09};\x0a\x0a\x09\x09$.ajaxPrefilter( prefilterAjax );\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Inject changeset UUID into forms, allowing preview to persist through submissions.\x0a\x09 *\x0a\x09 * @since 4.7.0\x0a\x09 * @access protected\x0a\x09 *\x0a\x09 * @returns {void}\x0a\x09 */\x0a\x09api.addFormPreviewing = function addFormPreviewing() {\x0a\x0a\x09\x09// Inject inputs for forms in initial document.\x0a\x09\x09$( document.body ).find( \x27form\x27 ).each( function() {\x0a\x09\x09\x09api.prepareFormPreview( this );\x0a\x09\x09} );\x0a\x0a\x09\x09// Inject inputs for new forms added to the page.\x0a\x09\x09if ( \x27undefined\x27 !== typeof MutationObserver ) {\x0a\x09\x09\x09api.mutationObserver = new MutationObserver( function( mutations ) {\x0a\x09\x09\x09\x09_.each( mutations, function( mutation ) {\x0a\x09\x09\x09\x09\x09$( mutation.target ).find( \x27form\x27 ).each( function() {\x0a\x09\x09\x09\x09\x09\x09api.prepareFormPreview( this );\x0a\x09\x09\x09\x09\x09} );\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09} );\x0a\x09\x09\x09api.mutationObserver.observe( document.documentElement, {\x0a\x09\x09\x09\x09childList: true,\x0a\x09\x09\x09\x09subtree: true\x0a\x09\x09\x09} );\x0a\x09\x09}\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Inject changeset into form inputs.\x0a\x09 *\x0a\x09 * @since 4.7.0\x0a\x09 * @access protected\x0a\x09 *\x0a\x09 * @param {HTMLFormElement} form Form.\x0a\x09 * @returns {void}\x0a\x09 */\x0a\x09api.prepareFormPreview = function prepareFormPreview( form ) {\x0a\x09\x09var urlParser, stateParams = {};\x0a\x0a\x09\x09if ( ! form.action ) {\x0a\x09\x09\x09form.action = location.href;\x0a\x09\x09}\x0a\x0a\x09\x09urlParser = document.createElement( \x27a\x27 );\x0a\x09\x09urlParser.href = form.action;\x0a\x0a\x09\x09// Make sure forms in preview use HTTPS if parent frame uses HTTPS.\x0a\x09\x09if ( api.settings.channel && \x27https\x27 === api.preview.scheme.get() && \x27http:\x27 === urlParser.protocol && -1 !== api.settings.url.allowedHosts.indexOf( urlParser.host ) ) {\x0a\x09\x09\x09urlParser.protocol = \x27https:\x27;\x0a\x09\x09\x09form.action = urlParser.href;\x0a\x09\x09}\x0a\x0a\x09\x09if ( \x27GET\x27 !== form.method.toUpperCase() || ! api.isLinkPreviewable( urlParser ) ) {\x0a\x0a\x09\x09\x09// Style form as unpreviewable only if previewing in iframe; if previewing on frontend, all forms will be allowed to work normally.\x0a\x09\x09\x09if ( api.settings.channel ) {\x0a\x09\x09\x09\x09$( form ).addClass( \x27customize-unpreviewable\x27 );\x0a\x09\x09\x09}\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x09\x09$( form ).removeClass( \x27customize-unpreviewable\x27 );\x0a\x0a\x09\x09stateParams.customize_changeset_uuid = api.settings.changeset.uuid;\x0a\x09\x09if ( api.settings.changeset.autosaved ) {\x0a\x09\x09\x09stateParams.customize_autosaved = \x27on\x27;\x0a\x09\x09}\x0a\x09\x09if ( ! api.settings.theme.active ) {\x0a\x09\x09\x09stateParams.customize_theme = api.settings.theme.stylesheet;\x0a\x09\x09}\x0a\x09\x09if ( api.settings.channel ) {\x0a\x09\x09\x09stateParams.customize_messenger_channel = api.settings.channel;\x0a\x09\x09}\x0a\x0a\x09\x09_.each( stateParams, function( value, name ) {\x0a\x09\x09\x09var input = $( form ).find( \x27input[name=\x22\x27 + name + \x27\x22]\x27 );\x0a\x09\x09\x09if ( input.length ) {\x0a\x09\x09\x09\x09input.val( value );\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09$( form ).prepend( $( \x27\x3cinput\x3e\x27, {\x0a\x09\x09\x09\x09\x09type: \x27hidden\x27,\x0a\x09\x09\x09\x09\x09name: name,\x0a\x09\x09\x09\x09\x09value: value\x0a\x09\x09\x09\x09} ) );\x0a\x09\x09\x09}\x0a\x09\x09} );\x0a\x0a\x09\x09// Prevent links from breaking out of preview iframe.\x0a\x09\x09if ( api.settings.channel ) {\x0a\x09\x09\x09form.target = \x27_self\x27;\x0a\x09\x09}\x0a\x09};\x0a\x0a\x09/**\x0a\x09 * Watch current URL and send keep-alive (heartbeat) messages to the parent.\x0a\x09 *\x0a\x09 * Keep the customizer pane notified that the preview is still alive\x0a\x09 * and that the user hasn\x27t navigated to a non-customized URL.\x0a\x09 *\x0a\x09 * @since 4.7.0\x0a\x09 * @access protected\x0a\x09 */\x0a\x09api.keepAliveCurrentUrl = ( function() {\x0a\x09\x09var previousPathName = location.pathname,\x0a\x09\x09\x09previousQueryString = location.search.substr( 1 ),\x0a\x09\x09\x09previousQueryParams = null,\x0a\x09\x09\x09stateQueryParams = [ \x27customize_theme\x27, \x27customize_changeset_uuid\x27, \x27customize_messenger_channel\x27, \x27customize_autosaved\x27 ];\x0a\x0a\x09\x09return function keepAliveCurrentUrl() {\x0a\x09\x09\x09var urlParser, currentQueryParams;\x0a\x0a\x09\x09\x09// Short-circuit with keep-alive if previous URL is identical (as is normal case).\x0a\x09\x09\x09if ( previousQueryString === location.search.substr( 1 ) && previousPathName === location.pathname ) {\x0a\x09\x09\x09\x09api.preview.send( \x27keep-alive\x27 );\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09urlParser = document.createElement( \x27a\x27 );\x0a\x09\x09\x09if ( null === previousQueryParams ) {\x0a\x09\x09\x09\x09urlParser.search = previousQueryString;\x0a\x09\x09\x09\x09previousQueryParams = api.utils.parseQueryString( previousQueryString );\x0a\x09\x09\x09\x09_.each( stateQueryParams, function( name ) {\x0a\x09\x09\x09\x09\x09delete previousQueryParams[ name ];\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Determine if current URL minus customized state params and URL hash.\x0a\x09\x09\x09urlParser.href = location.href;\x0a\x09\x09\x09currentQueryParams = api.utils.parseQueryString( urlParser.search.substr( 1 ) );\x0a\x09\x09\x09_.each( stateQueryParams, function( name ) {\x0a\x09\x09\x09\x09delete currentQueryParams[ name ];\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09if ( previousPathName !== location.pathname || ! _.isEqual( previousQueryParams, currentQueryParams ) ) {\x0a\x09\x09\x09\x09urlParser.search = $.param( currentQueryParams );\x0a\x09\x09\x09\x09urlParser.hash = \x27\x27;\x0a\x09\x09\x09\x09api.settings.url.self = urlParser.href;\x0a\x09\x09\x09\x09api.preview.send( \x27ready\x27, {\x0a\x09\x09\x09\x09\x09currentUrl: api.settings.url.self,\x0a\x09\x09\x09\x09\x09activePanels: api.settings.activePanels,\x0a\x09\x09\x09\x09\x09activeSections: api.settings.activeSections,\x0a\x09\x09\x09\x09\x09activeControls: api.settings.activeControls,\x0a\x09\x09\x09\x09\x09settingValidities: api.settings.settingValidities\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09api.preview.send( \x27keep-alive\x27 );\x0a\x09\x09\x09}\x0a\x09\x09\x09previousQueryParams = currentQueryParams;\x0a\x09\x09\x09previousQueryString = location.search.substr( 1 );\x0a\x09\x09\x09previousPathName = location.pathname;\x0a\x09\x09};\x0a\x09} )();\x0a\x0a\x09api.settingPreviewHandlers = {\x0a\x0a\x09\x09/**\x0a\x09\x09 * Preview changes to custom logo.\x0a\x09\x09 *\x0a\x09\x09 * @param {number} attachmentId Attachment ID for custom logo.\x0a\x09\x09 * @returns {void}\x0a\x09\x09 */\x0a\x09\x09custom_logo: function( attachmentId ) {\x0a\x09\x09\x09$( \x27body\x27 ).toggleClass( \x27wp-custom-logo\x27, !! attachmentId );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Preview changes to custom css.\x0a\x09\x09 *\x0a\x09\x09 * @param {string} value Custom CSS..\x0a\x09\x09 * @returns {void}\x0a\x09\x09 */\x0a\x09\x09custom_css: function( value ) {\x0a\x09\x09\x09$( \x27#wp-custom-css\x27 ).text( value );\x0a\x09\x09},\x0a\x0a\x09\x09/**\x0a\x09\x09 * Preview changes to any of the background settings.\x0a\x09\x09 *\x0a\x09\x09 * @returns {void}\x0a\x09\x09 */\x0a\x09\x09background: function() {\x0a\x09\x09\x09var css = \x27\x27, settings = {};\x0a\x0a\x09\x09\x09_.each( [\x27color\x27, \x27image\x27, \x27preset\x27, \x27position_x\x27, \x27position_y\x27, \x27size\x27, \x27repeat\x27, \x27attachment\x27], function( prop ) {\x0a\x09\x09\x09\x09settings[ prop ] = api( \x27background_\x27 + prop );\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09/*\x0a\x09\x09\x09 * The body will support custom backgrounds if either the color or image are set.\x0a\x09\x09\x09 *\x0a\x09\x09\x09 * See get_body_class() in /wp-includes/post-template.php\x0a\x09\x09\x09 */\x0a\x09\x09\x09$( document.body ).toggleClass( \x27custom-background\x27, !! ( settings.color() || settings.image() ) );\x0a\x0a\x09\x09\x09if ( settings.color() ) {\x0a\x09\x09\x09\x09css += \x27background-color: \x27 + settings.color() + \x27;\x27;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09if ( settings.image() ) {\x0a\x09\x09\x09\x09css += \x27background-image: url(\x22\x27 + settings.image() + \x27\x22);\x27;\x0a\x09\x09\x09\x09css += \x27background-size: \x27 + settings.size() + \x27;\x27;\x0a\x09\x09\x09\x09css += \x27background-position: \x27 + settings.position_x() + \x27 \x27 + settings.position_y() + \x27;\x27;\x0a\x09\x09\x09\x09css += \x27background-repeat: \x27 + settings.repeat() + \x27;\x27;\x0a\x09\x09\x09\x09css += \x27background-attachment: \x27 + settings.attachment() + \x27;\x27;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09$( \x27#custom-background-css\x27 ).text( \x27body.custom-background { \x27 + css + \x27 }\x27 );\x0a\x09\x09}\x0a\x09};\x0a\x0a\x09$( function() {\x0a\x09\x09var bg, setValue, handleUpdatedChangesetUuid;\x0a\x0a\x09\x09api.settings = window._wpCustomizeSettings;\x0a\x09\x09if ( ! api.settings ) {\x0a\x09\x09\x09return;\x0a\x09\x09}\x0a\x0a\x09\x09api.preview = new api.Preview({\x0a\x09\x09\x09url: window.location.href,\x0a\x09\x09\x09channel: api.settings.channel\x0a\x09\x09});\x0a\x0a\x09\x09api.addLinkPreviewing();\x0a\x09\x09api.addRequestPreviewing();\x0a\x09\x09api.addFormPreviewing();\x0a\x0a\x09\x09/**\x0a\x09\x09 * Create/update a setting value.\x0a\x09\x09 *\x0a\x09\x09 * @param {string}  id            - Setting ID.\x0a\x09\x09 * @param {*}       value         - Setting value.\x0a\x09\x09 * @param {boolean} [createDirty] - Whether to create a setting as dirty. Defaults to false.\x0a\x09\x09 */\x0a\x09\x09setValue = function( id, value, createDirty ) {\x0a\x09\x09\x09var setting = api( id );\x0a\x09\x09\x09if ( setting ) {\x0a\x09\x09\x09\x09setting.set( value );\x0a\x09\x09\x09} else {\x0a\x09\x09\x09\x09createDirty = createDirty || false;\x0a\x09\x09\x09\x09setting = api.create( id, value, {\x0a\x09\x09\x09\x09\x09id: id\x0a\x09\x09\x09\x09} );\x0a\x0a\x09\x09\x09\x09// Mark dynamically-created settings as dirty so they will get posted.\x0a\x09\x09\x09\x09if ( createDirty ) {\x0a\x09\x09\x09\x09\x09setting._dirty = true;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x09\x09};\x0a\x0a\x09\x09api.preview.bind( \x27settings\x27, function( values ) {\x0a\x09\x09\x09$.each( values, setValue );\x0a\x09\x09});\x0a\x0a\x09\x09api.preview.trigger( \x27settings\x27, api.settings.values );\x0a\x0a\x09\x09$.each( api.settings._dirty, function( i, id ) {\x0a\x09\x09\x09var setting = api( id );\x0a\x09\x09\x09if ( setting ) {\x0a\x09\x09\x09\x09setting._dirty = true;\x0a\x09\x09\x09}\x0a\x09\x09} );\x0a\x0a\x09\x09api.preview.bind( \x27setting\x27, function( args ) {\x0a\x09\x09\x09var createDirty = true;\x0a\x09\x09\x09setValue.apply( null, args.concat( createDirty ) );\x0a\x09\x09});\x0a\x0a\x09\x09api.preview.bind( \x27sync\x27, function( events ) {\x0a\x0a\x09\x09\x09/*\x0a\x09\x09\x09 * Delete any settings that already exist locally which haven\x27t been\x0a\x09\x09\x09 * modified in the controls while the preview was loading. This prevents\x0a\x09\x09\x09 * situations where the JS value being synced from the pane may differ\x0a\x09\x09\x09 * from the PHP-sanitized JS value in the preview which causes the\x0a\x09\x09\x09 * non-sanitized JS value to clobber the PHP-sanitized value. This\x0a\x09\x09\x09 * is particularly important for selective refresh partials that\x0a\x09\x09\x09 * have a fallback refresh behavior since infinite refreshing would\x0a\x09\x09\x09 * result.\x0a\x09\x09\x09 */\x0a\x09\x09\x09if ( events.settings && events[\x27settings-modified-while-loading\x27] ) {\x0a\x09\x09\x09\x09_.each( _.keys( events.settings ), function( syncedSettingId ) {\x0a\x09\x09\x09\x09\x09if ( api.has( syncedSettingId ) && ! events[\x27settings-modified-while-loading\x27][ syncedSettingId ] ) {\x0a\x09\x09\x09\x09\x09\x09delete events.settings[ syncedSettingId ];\x0a\x09\x09\x09\x09\x09}\x0a\x09\x09\x09\x09} );\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09$.each( events, function( event, args ) {\x0a\x09\x09\x09\x09api.preview.trigger( event, args );\x0a\x09\x09\x09});\x0a\x09\x09\x09api.preview.send( \x27synced\x27 );\x0a\x09\x09});\x0a\x0a\x09\x09api.preview.bind( \x27active\x27, function() {\x0a\x09\x09\x09api.preview.send( \x27nonce\x27, api.settings.nonce );\x0a\x0a\x09\x09\x09api.preview.send( \x27documentTitle\x27, document.title );\x0a\x0a\x09\x09\x09// Send scroll in case of loading via non-refresh.\x0a\x09\x09\x09api.preview.send( \x27scroll\x27, $( window ).scrollTop() );\x0a\x09\x09});\x0a\x0a\x09\x09/**\x0a\x09\x09 * Handle update to changeset UUID.\x0a\x09\x09 *\x0a\x09\x09 * @param {string} uuid - UUID.\x0a\x09\x09 * @returns {void}\x0a\x09\x09 */\x0a\x09\x09handleUpdatedChangesetUuid = function( uuid ) {\x0a\x09\x09\x09api.settings.changeset.uuid = uuid;\x0a\x0a\x09\x09\x09// Update UUIDs in links and forms.\x0a\x09\x09\x09$( document.body ).find( \x27a[href], area[href]\x27 ).each( function() {\x0a\x09\x09\x09\x09api.prepareLinkPreview( this );\x0a\x09\x09\x09} );\x0a\x09\x09\x09$( document.body ).find( \x27form\x27 ).each( function() {\x0a\x09\x09\x09\x09api.prepareFormPreview( this );\x0a\x09\x09\x09} );\x0a\x0a\x09\x09\x09/*\x0a\x09\x09\x09 * Replace the UUID in the URL. Note that the wrapped history.replaceState()\x0a\x09\x09\x09 * will handle injecting the current api.settings.changeset.uuid into the URL,\x0a\x09\x09\x09 * so this is merely to trigger that logic.\x0a\x09\x09\x09 */\x0a\x09\x09\x09if ( history.replaceState ) {\x0a\x09\x09\x09\x09history.replaceState( currentHistoryState, \x27\x27, location.href );\x0a\x09\x09\x09}\x0a\x09\x09};\x0a\x0a\x09\x09api.preview.bind( \x27changeset-uuid\x27, handleUpdatedChangesetUuid );\x0a\x0a\x09\x09api.preview.bind( \x27saved\x27, function( response ) {\x0a\x09\x09\x09if ( response.next_changeset_uuid ) {\x0a\x09\x09\x09\x09handleUpdatedChangesetUuid( response.next_changeset_uuid );\x0a\x09\x09\x09}\x0a\x09\x09\x09api.trigger( \x27saved\x27, response );\x0a\x09\x09} );\x0a\x0a\x09\x09// Update the URLs to reflect the fact we\x27ve started autosaving.\x0a\x09\x09api.preview.bind( \x27autosaving\x27, function() {\x0a\x09\x09\x09if ( api.settings.changeset.autosaved ) {\x0a\x09\x09\x09\x09return;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09api.settings.changeset.autosaved = true; // Start deferring to any autosave once changeset is updated.\x0a\x0a\x09\x09\x09$( document.body ).find( \x27a[href], area[href]\x27 ).each( function() {\x0a\x09\x09\x09\x09api.prepareLinkPreview( this );\x0a\x09\x09\x09} );\x0a\x09\x09\x09$( document.body ).find( \x27form\x27 ).each( function() {\x0a\x09\x09\x09\x09api.prepareFormPreview( this );\x0a\x09\x09\x09} );\x0a\x09\x09\x09if ( history.replaceState ) {\x0a\x09\x09\x09\x09history.replaceState( currentHistoryState, \x27\x27, location.href );\x0a\x09\x09\x09}\x0a\x09\x09} );\x0a\x0a\x09\x09/*\x0a\x09\x09 * Clear dirty flag for settings when saved to changeset so that they\x0a\x09\x09 * won\x27t be needlessly included in selective refresh or ajax requests.\x0a\x09\x09 */\x0a\x09\x09api.preview.bind( \x27changeset-saved\x27, function( data ) {\x0a\x09\x09\x09_.each( data.saved_changeset_values, function( value, settingId ) {\x0a\x09\x09\x09\x09var setting = api( settingId );\x0a\x09\x09\x09\x09if ( setting && _.isEqual( setting.get(), value ) ) {\x0a\x09\x09\x09\x09\x09setting._dirty = false;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09} );\x0a\x09\x09} );\x0a\x0a\x09\x09api.preview.bind( \x27nonce-refresh\x27, function( nonce ) {\x0a\x09\x09\x09$.extend( api.settings.nonce, nonce );\x0a\x09\x09} );\x0a\x0a\x09\x09/*\x0a\x09\x09 * Send a message to the parent customize frame with a list of which\x0a\x09\x09 * containers and controls are active.\x0a\x09\x09 */\x0a\x09\x09api.preview.send( \x27ready\x27, {\x0a\x09\x09\x09currentUrl: api.settings.url.self,\x0a\x09\x09\x09activePanels: api.settings.activePanels,\x0a\x09\x09\x09activeSections: api.settings.activeSections,\x0a\x09\x09\x09activeControls: api.settings.activeControls,\x0a\x09\x09\x09settingValidities: api.settings.settingValidities\x0a\x09\x09} );\x0a\x0a\x09\x09// Send ready when URL changes via JS.\x0a\x09\x09setInterval( api.keepAliveCurrentUrl, api.settings.timeouts.keepAliveSend );\x0a\x0a\x09\x09// Display a loading indicator when preview is reloading, and remove on failure.\x0a\x09\x09api.preview.bind( \x27loading-initiated\x27, function () {\x0a\x09\x09\x09$( \x27body\x27 ).addClass( \x27wp-customizer-unloading\x27 );\x0a\x09\x09});\x0a\x09\x09api.preview.bind( \x27loading-failed\x27, function () {\x0a\x09\x09\x09$( \x27body\x27 ).removeClass( \x27wp-customizer-unloading\x27 );\x0a\x09\x09});\x0a\x0a\x09\x09/* Custom Backgrounds */\x0a\x09\x09bg = $.map( [\x27color\x27, \x27image\x27, \x27preset\x27, \x27position_x\x27, \x27position_y\x27, \x27size\x27, \x27repeat\x27, \x27attachment\x27], function( prop ) {\x0a\x09\x09\x09return \x27background_\x27 + prop;\x0a\x09\x09} );\x0a\x0a\x09\x09api.when.apply( api, bg ).done( function() {\x0a\x09\x09\x09$.each( arguments, function() {\x0a\x09\x09\x09\x09this.bind( api.settingPreviewHandlers.background );\x0a\x09\x09\x09});\x0a\x09\x09});\x0a\x0a\x09\x09/**\x0a\x09\x09 * Custom Logo\x0a\x09\x09 *\x0a\x09\x09 * Toggle the wp-custom-logo body class when a logo is added or removed.\x0a\x09\x09 *\x0a\x09\x09 * @since 4.5.0\x0a\x09\x09 */\x0a\x09\x09api( \x27custom_logo\x27, function ( setting ) {\x0a\x09\x09\x09api.settingPreviewHandlers.custom_logo.call( setting, setting.get() );\x0a\x09\x09\x09setting.bind( api.settingPreviewHandlers.custom_logo );\x0a\x09\x09} );\x0a\x0a\x09\x09api( \x27custom_css[\x27 + api.settings.theme.stylesheet + \x27]\x27, function( setting ) {\x0a\x09\x09\x09setting.bind( api.settingPreviewHandlers.custom_css );\x0a\x09\x09} );\x0a\x0a\x09\x09api.trigger( \x27preview-ready\x27 );\x0a\x09});\x0a\x0a})( wp, jQuery );\x0a'}