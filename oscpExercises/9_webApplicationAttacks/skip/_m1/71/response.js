var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:05:57 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 21 Mar 2019 12:48:00 GMT\x0aETag: \x228485-5849a25f20000-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-9121/9122\x0aContent-Length: 9122\x0aKeep-Alive: timeout=5, max=76\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0athis[\x22wp\x22] = this[\x22wp\x22] || {}; this[\x22wp\x22][\x22i18n\x22] =\x0a/******/ (function(modules) { // webpackBootstrap\x0a/******/ \x09// The module cache\x0a/******/ \x09var installedModules = {};\x0a/******/\x0a/******/ \x09// The require function\x0a/******/ \x09function __webpack_require__(moduleId) {\x0a/******/\x0a/******/ \x09\x09// Check if module is in cache\x0a/******/ \x09\x09if(installedModules[moduleId]) {\x0a/******/ \x09\x09\x09return installedModules[moduleId].exports;\x0a/******/ \x09\x09}\x0a/******/ \x09\x09// Create a new module (and put it into the cache)\x0a/******/ \x09\x09var module = installedModules[moduleId] = {\x0a/******/ \x09\x09\x09i: moduleId,\x0a/******/ \x09\x09\x09l: false,\x0a/******/ \x09\x09\x09exports: {}\x0a/******/ \x09\x09};\x0a/******/\x0a/******/ \x09\x09// Execute the module function\x0a/******/ \x09\x09modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\x0a/******/\x0a/******/ \x09\x09// Flag the module as loaded\x0a/******/ \x09\x09module.l = true;\x0a/******/\x0a/******/ \x09\x09// Return the exports of the module\x0a/******/ \x09\x09return module.exports;\x0a/******/ \x09}\x0a/******/\x0a/******/\x0a/******/ \x09// expose the modules object (__webpack_modules__)\x0a/******/ \x09__webpack_require__.m = modules;\x0a/******/\x0a/******/ \x09// expose the module cache\x0a/******/ \x09__webpack_require__.c = installedModules;\x0a/******/\x0a/******/ \x09// define getter function for harmony exports\x0a/******/ \x09__webpack_require__.d = function(exports, name, getter) {\x0a/******/ \x09\x09if(!__webpack_require__.o(exports, name)) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, name, { enumerable: true, get: getter });\x0a/******/ \x09\x09}\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// define __esModule on exports\x0a/******/ \x09__webpack_require__.r = function(exports) {\x0a/******/ \x09\x09if(typeof Symbol !== \x27undefined\x27 && Symbol.toStringTag) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, Symbol.toStringTag, { value: \x27Module\x27 });\x0a/******/ \x09\x09}\x0a/******/ \x09\x09Object.defineProperty(exports, \x27__esModule\x27, { value: true });\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// create a fake namespace object\x0a/******/ \x09// mode & 1: value is a module id, require it\x0a/******/ \x09// mode & 2: merge all properties of value into the ns\x0a/******/ \x09// mode & 4: return value when already ns object\x0a/******/ \x09// mode & 8|1: behave like require\x0a/******/ \x09__webpack_require__.t = function(value, mode) {\x0a/******/ \x09\x09if(mode & 1) value = __webpack_require__(value);\x0a/******/ \x09\x09if(mode & 8) return value;\x0a/******/ \x09\x09if((mode & 4) && typeof value === \x27object\x27 && value && value.__esModule) return value;\x0a/******/ \x09\x09var ns = Object.create(null);\x0a/******/ \x09\x09__webpack_require__.r(ns);\x0a/******/ \x09\x09Object.defineProperty(ns, \x27default\x27, { enumerable: true, value: value });\x0a/******/ \x09\x09if(mode & 2 && typeof value != \x27string\x27) for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\x0a/******/ \x09\x09return ns;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// getDefaultExport function for compatibility with non-harmony modules\x0a/******/ \x09__webpack_require__.n = function(module) {\x0a/******/ \x09\x09var getter = module && module.__esModule ?\x0a/******/ \x09\x09\x09function getDefault() { return module[\x27default\x27]; } :\x0a/******/ \x09\x09\x09function getModuleExports() { return module; };\x0a/******/ \x09\x09__webpack_require__.d(getter, \x27a\x27, getter);\x0a/******/ \x09\x09return getter;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// Object.prototype.hasOwnProperty.call\x0a/******/ \x09__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\x0a/******/\x0a/******/ \x09// __webpack_public_path__\x0a/******/ \x09__webpack_require__.p = \x22\x22;\x0a/******/\x0a/******/\x0a/******/ \x09// Load entry module and return exports\x0a/******/ \x09return __webpack_require__(__webpack_require__.s = 376);\x0a/******/ })\x0a/************************************************************************/\x0a/******/ ({\x0a\x0a/***/ 137:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0avar __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */\x0a\x0a!function() {\x0a    \x27use strict\x27\x0a\x0a    var re = {\x0a        not_string: /[^s]/,\x0a        not_bool: /[^t]/,\x0a        not_type: /[^T]/,\x0a        not_primitive: /[^v]/,\x0a        number: /[diefg]/,\x0a        numeric_arg: /[bcdiefguxX]/,\x0a        json: /[j]/,\x0a        not_json: /[^j]/,\x0a        text: /^[^\x5cx25]+/,\x0a        modulo: /^\x5cx25{2}/,\x0a        placeholder: /^\x5cx25(?:([1-9]\x5cd*)\x5c$|\x5c(([^)]+)\x5c))?(\x5c+)?(0|\x27[^$])?(-)?(\x5cd+)?(?:\x5c.(\x5cd+))?([b-gijostTuvxX])/,\x0a        key: /^([a-z_][a-z_\x5cd]*)/i,\x0a        key_access: /^\x5c.([a-z_][a-z_\x5cd]*)/i,\x0a        index_access: /^\x5c[(\x5cd+)\x5c]/,\x0a        sign: /^[+-]/\x0a    }\x0a\x0a    function sprintf(key) {\x0a        // `arguments` is not an array, but should be fine for this call\x0a        return sprintf_format(sprintf_parse(key), arguments)\x0a    }\x0a\x0a    function vsprintf(fmt, argv) {\x0a        return sprintf.apply(null, [fmt].concat(argv || []))\x0a    }\x0a\x0a    function sprintf_format(parse_tree, argv) {\x0a        var cursor = 1, tree_length = parse_tree.length, arg, output = \x27\x27, i, k, ph, pad, pad_character, pad_length, is_positive, sign\x0a        for (i = 0; i \x3c tree_length; i++) {\x0a            if (typeof parse_tree[i] === \x27string\x27) {\x0a                output += parse_tree[i]\x0a            }\x0a            else if (typeof parse_tree[i] === \x27object\x27) {\x0a                ph = parse_tree[i] // convenience purposes only\x0a                if (ph.keys) { // keyword argument\x0a                    arg = argv[cursor]\x0a                    for (k = 0; k \x3c ph.keys.length; k++) {\x0a                        if (arg == undefined) {\x0a                            throw new Error(sprintf(\x27[sprintf] Cannot access property \x22%s\x22 of undefined value \x22%s\x22\x27, ph.keys[k], ph.keys[k-1]))\x0a                        }\x0a                        arg = arg[ph.keys[k]]\x0a                    }\x0a                }\x0a                else if (ph.param_no) { // positional argument (explicit)\x0a                    arg = argv[ph.param_no]\x0a                }\x0a                else { // positional argument (implicit)\x0a                    arg = argv[cursor++]\x0a                }\x0a\x0a                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\x0a                    arg = arg()\x0a                }\x0a\x0a                if (re.numeric_arg.test(ph.type) && (typeof arg !== \x27number\x27 && isNaN(arg))) {\x0a                    throw new TypeError(sprintf(\x27[sprintf] expecting number but found %T\x27, arg))\x0a                }\x0a\x0a                if (re.number.test(ph.type)) {\x0a                    is_positive = arg \x3e= 0\x0a                }\x0a\x0a                switch (ph.type) {\x0a                    case \x27b\x27:\x0a                        arg = parseInt(arg, 10).toString(2)\x0a                        break\x0a                    case \x27c\x27:\x0a                        arg = String.fromCharCode(parseInt(arg, 10))\x0a                        break\x0a                    case \x27d\x27:\x0a                    case \x27i\x27:\x0a                        arg = parseInt(arg, 10)\x0a                        break\x0a                    case \x27j\x27:\x0a                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)\x0a                        break\x0a                    case \x27e\x27:\x0a                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()\x0a                        break\x0a                    case \x27f\x27:\x0a                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)\x0a                        break\x0a                    case \x27g\x27:\x0a                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)\x0a                        break\x0a                    case \x27o\x27:\x0a                        arg = (parseInt(arg, 10) \x3e\x3e\x3e 0).toString(8)\x0a                        break\x0a                    case \x27s\x27:\x0a                        arg = String(arg)\x0a                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\x0a                        break\x0a                    case \x27t\x27:\x0a                        arg = String(!!arg)\x0a                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\x0a                        break\x0a                    case \x27T\x27:\x0a                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\x0a                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\x0a                        break\x0a                    case \x27u\x27:\x0a                        arg = parseInt(arg, 10) \x3e\x3e\x3e 0\x0a                        break\x0a                    case \x27v\x27:\x0a                        arg = arg.valueOf()\x0a                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\x0a                        break\x0a                    case \x27x\x27:\x0a                        arg = (parseInt(arg, 10) \x3e\x3e\x3e 0).toString(16)\x0a                        break\x0a                    case \x27X\x27:\x0a                        arg = (parseInt(arg, 10) \x3e\x3e\x3e 0).toString(16).toUpperCase()\x0a                        break\x0a                }\x0a                if (re.json.test(ph.type)) {\x0a                    output += arg\x0a                }\x0a                else {\x0a                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\x0a                        sign = is_positive ? \x27+\x27 : \x27-\x27\x0a                        arg = arg.toString().replace(re.sign, \x27\x27)\x0a                    }\x0a                    else {\x0a                        sign = \x27\x27\x0a                    }\x0a                    pad_character = ph.pad_char ? ph.pad_char === \x270\x27 ? \x270\x27 : ph.pad_char.charAt(1) : \x27 \x27\x0a                    pad_length = ph.width - (sign + arg).length\x0a                    pad = ph.width ? (pad_length \x3e 0 ? pad_character.repeat(pad_length) : \x27\x27) : \x27\x27\x0a                    output += ph.align ? sign + arg + pad : (pad_character === \x270\x27 ? sign + pad + arg : pad + sign + arg)\x0a                }\x0a            }\x0a        }\x0a        return output\x0a    }\x0a\x0a    var sprintf_cache = Object.create(null)\x0a\x0a    function sprintf_parse(fmt) {\x0a        if (sprintf_cache[fmt]) {\x0a            return sprintf_cache[fmt]\x0a        }\x0a\x0a        var _fmt = fmt, match, parse_tree = [], arg_names = 0\x0a        while (_fmt) {\x0a            if ((match = re.text.exec(_fmt)) !== null) {\x0a                parse_tree.push(match[0])\x0a            }\x0a            else if ((match = re.modulo.exec(_fmt)) !== null) {\x0a                parse_tree.push(\x27%\x27)\x0a            }\x0a            else if ((match = re.placeholder.exec(_fmt)) !== null) {\x0a                if (match[2]) {\x0a                    arg_names |= 1\x0a                    var field_list = [], replacement_field = match[2], field_match = []\x0a                    if ((field_match = re.key.exec(replacement_field)) !== null) {\x0a                        field_list.push(field_match[1])\x0a                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== \x27\x27) {\x0a                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\x0a                                field_list.push(field_match[1])\x0a                            }\x0a                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\x0a                                field_list.push(field_match[1])\x0a                            }\x0a                            else {\x0a                                throw new SyntaxError(\x27[sprintf] failed to parse named argument key\x27)\x0a                            }\x0a                        }\x0a                    }\x0a                    else {\x0a                        throw new SyntaxError(\x27[sprintf] failed to parse named argument key\x27)\x0a                    }\x0a                    match[2] = field_list\x0a                }\x0a                else {\x0a                    arg_names |= 2\x0a                }\x0a                if (arg_names === 3) {\x0a                    throw new Error(\x27[sprintf] mixing positional and named placeholders is not (yet) supported\x27)\x0a                }\x0a\x0a                parse_tree.push(\x0a                    {\x0a                        placeholder: match[0],\x0a                        param_no:    match[1],\x0a                        keys:        match[2],\x0a                        sign:        match[3],\x0a                        pad_char:    match[4],\x0a                        align:       match[5],\x0a                        width:       match[6],\x0a                        precision:   match[7],\x0a                        type:        match[8]\x0a                    }\x0a                )\x0a            }\x0a            else {\x0a                throw new SyntaxError(\x27[sprintf] unexpected placeholder\x27)\x0a            }\x0a            _fmt = _fmt.substring(match[0].length)\x0a        }\x0a        return sprintf_cache[fmt] = parse_tree\x0a    }\x0a\x0a    /**\x0a     * export to either browser or node.js\x0a     */\x0a    /* eslint-disable quote-props */\x0a    if (true) {\x0a        exports[\x27sprintf\x27] = sprintf\x0a        exports[\x27vsprintf\x27] = vsprintf\x0a    }\x0a    if (typeof window !== \x27undefined\x27) {\x0a        window[\x27sprintf\x27] = sprintf\x0a        window[\x27vsprintf\x27] = vsprintf\x0a\x0a        if (true) {\x0a            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\x0a                return {\x0a                    \x27sprintf\x27: sprintf,\x0a                    \x27vsprintf\x27: vsprintf\x0a                }\x0a            }).call(exports, __webpack_require__, exports, module),\x0a\x09\x09\x09\x09__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\x0a        }\x0a    }\x0a    /* eslint-enable quote-props */\x0a}(); // eslint-disable-line\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 15:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _defineProperty; });\x0afunction _defineProperty(obj, key, value) {\x0a  if (key in obj) {\x0a    Object.defineProperty(obj, key, {\x0a      value: value,\x0a      enumerable: true,\x0a      configurable: true,\x0a      writable: true\x0a    });\x0a  } else {\x0a    obj[key] = value;\x0a  }\x0a\x0a  return obj;\x0a}\x0a\x0a/***/ }),\x0a\x0a/***/ 376:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread.js\x0avar objectSpread = __webpack_require__(7);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@tannin/postfix/index.js\x0avar PRECEDENCE, OPENERS, TERMINATORS, PATTERN;\x0a\x0a/**\x0a * Operator precedence mapping.\x0a *\x0a * @type {Object}\x0a */\x0aPRECEDENCE = {\x0a\x09\x27(\x27: 9,\x0a\x09\x27!\x27: 8,\x0a\x09\x27*\x27: 7,\x0a\x09\x27/\x27: 7,\x0a\x09\x27%\x27: 7,\x0a\x09\x27+\x27: 6,\x0a\x09\x27-\x27: 6,\x0a\x09\x27\x3c\x27: 5,\x0a\x09\x27\x3c=\x27: 5,\x0a\x09\x27\x3e\x27: 5,\x0a\x09\x27\x3e=\x27: 5,\x0a\x09\x27==\x27: 4,\x0a\x09\x27!=\x27: 4,\x0a\x09\x27&&\x27: 3,\x0a\x09\x27||\x27: 2,\x0a\x09\x27?\x27: 1,\x0a\x09\x27?:\x27: 1,\x0a};\x0a\x0a/**\x0a * Characters which signal pair opening, to be terminated by terminators.\x0a *\x0a * @type {string[]}\x0a */\x0aOPENERS = [ \x27(\x27, \x27?\x27 ];\x0a\x0a/**\x0a * Characters which signal pair termination, the value an array with the\x0a * opener as its first member. The second member is an optional operator\x0a * replacement to push to the stack.\x0a *\x0a * @type {string[]}\x0a */\x0aTERMINATORS = {\x0a\x09\x27)\x27: [ \x27(\x27 ],\x0a\x09\x27:\x27: [ \x27?\x27, \x27?:\x27 ],\x0a};\x0a\x0a/**\x0a * Pattern matching operators and openers.\x0a *\x0a * @type {RegExp}\x0a */\x0aPATTERN = /\x3c=|\x3e=|==|!=|&&|\x5c|\x5c||\x5c?:|\x5c(|!|\x5c*|\x5c/|%|\x5c+|-|\x3c|\x3e|\x5c?|\x5c)|:/;\x0a\x0a/**\x0a * Given a C expression, returns the equivalent postfix (Reverse Polish)\x0a * notation terms as an array.\x0a *\x0a * If a postfix string is desired, simply `.join( \x27 \x27 )` the result.\x0a *\x0a * @example\x0a *\x0a * ```js\x0a * import postfix from \x27@tannin/postfix\x27;\x0a *\x0a * postfix( \x27n \x3e 1\x27 );\x0a * // \xe2\x87\x92 [ \x27n\x27, \x271\x27, \x27\x3e\x27 ]\x0a * ```\x0a *\x0a * @param {string} expression C expression.\x0a *\x0a * @return {string[]} Postfix terms.\x0a */\x0afunction postfix( expression ) {\x0a\x09var terms = [],\x0a\x09\x09stack = [],\x0a\x09\x09match, operator, term, element;\x0a\x0a\x09while ( ( match = expression.match( PATTERN ) ) ) {\x0a\x09\x09operator = match[ 0 ];\x0a\x0a\x09\x09// Term is the string preceding the operator match. It may contain\x0a\x09\x09// whitespace, and may be empty (if operator is at beginning).\x0a\x09\x09term = expression.substr( 0, match.index ).trim();\x0a\x09\x09if ( term ) {\x0a\x09\x09\x09terms.push( term );\x0a\x09\x09}\x0a\x0a\x09\x09while ( ( element = stack.pop() ) ) {\x0a\x09\x09\x09if ( TERMINATORS[ operator ] ) {\x0a\x09\x09\x09\x09if ( TERMINATORS[ operator ][ 0 ] === element ) {\x0a\x09\x09\x09\x09\x09// Substitution works here under assumption that because\x0a\x09\x09\x09\x09\x09// the assigned operator will no longer be a terminator, it\x0a\x09\x09\x09\x09\x09// will be pushed to the stack during the condition below.\x0a\x09\x09\x09\x09\x09operator = TERMINATORS[ operator ][ 1 ] || operator;\x0a\x09\x09\x09\x09\x09break;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09} else if ( OPENERS.indexOf( element ) \x3e= 0 || PRECEDENCE[ element ] \x3c PRECEDENCE[ operator ] ) {\x0a\x09\x09\x09\x09// Push to stack if either an opener or when pop reveals an\x0a\x09\x09\x09\x09// element of lower precedence.\x0a\x09\x09\x09\x09stack.push( element );\x0a\x09\x09\x09\x09break;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// For each popped from stack, push to terms.\x0a\x09\x09\x09terms.push( element );\x0a\x09\x09}\x0a\x0a\x09\x09if ( ! TERMINATORS[ operator ] ) {\x0a\x09\x09\x09stack.push( operator );\x0a\x09\x09}\x0a\x0a\x09\x09// Slice matched fragment from expression to continue match.\x0a\x09\x09expression = expression.substr( match.index + operator.length );\x0a\x09}\x0a\x0a\x09// Push remainder of operand, if exists, to terms.\x0a\x09expression = expression.trim();\x0a\x09if ( expression ) {\x0a\x09\x09terms.push( expression );\x0a\x09}\x0a\x0a\x09// Pop remaining items from stack into terms.\x0a\x09return terms.concat( stack.reverse() );\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@tannin/evaluate/index.js\x0a/**\x0a * Operator callback functions.\x0a *\x0a * @type {Object}\x0a */\x0avar OPERATORS = {\x0a\x09\x27!\x27: function( a ) {\x0a\x09\x09return ! a;\x0a\x09},\x0a\x09\x27*\x27: function( a, b ) {\x0a\x09\x09return a * b;\x0a\x09},\x0a\x09\x27/\x27: function( a, b ) {\x0a\x09\x09return a / b;\x0a\x09},\x0a\x09\x27%\x27: function( a, b ) {\x0a\x09\x09return a % b;\x0a\x09},\x0a\x09\x27+\x27: function( a, b ) {\x0a\x09\x09return a + b;\x0a\x09},\x0a\x09\x27-\x27: function( a, b ) {\x0a\x09\x09return a - b;\x0a\x09},\x0a\x09\x27\x3c\x27: function( a, b ) {\x0a\x09\x09return a \x3c b;\x0a\x09},\x0a\x09\x27\x3c=\x27: function( a, b ) {\x0a\x09\x09return a \x3c= b;\x0a\x09},\x0a\x09\x27\x3e\x27: function( a, b ) {\x0a\x09\x09return a \x3e b;\x0a\x09},\x0a\x09\x27\x3e=\x27: function( a, b ) {\x0a\x09\x09return a \x3e= b;\x0a\x09},\x0a\x09\x27==\x27: function( a, b ) {\x0a\x09\x09return a === b;\x0a\x09},\x0a\x09\x27!=\x27: function( a, b ) {\x0a\x09\x09return a !== b;\x0a\x09},\x0a\x09\x27&&\x27: function( a, b ) {\x0a\x09\x09return a && b;\x0a\x09},\x0a\x09\x27||\x27: function( a, b ) {\x0a\x09\x09return a || b;\x0a\x09},\x0a\x09\x27?:\x27: function( a, b, c ) {\x0a\x09\x09if ( a ) {\x0a\x09\x09\x09throw b;\x0a\x09\x09}\x0a\x0a\x09\x09return c;\x0a\x09},\x0a};\x0a\x0a/**\x0a * Given an array of postfix terms and operand variables, returns the result of\x0a * the postfix evaluation.\x0a *\x0a * @example\x0a *\x0a * ```js\x0a * import evaluate from \x27@tannin/evaluate\x27;\x0a *\x0a * // 3 + 4 * 5 / 6 \xe2\x87\x92 \x273 4 5 * 6 / +\x27\x0a * const terms = [ \x273\x27, \x274\x27, \x275\x27, \x27*\x27, \x276\x27, \x27/\x27, \x27+\x27 ];\x0a *\x0a * evaluate( terms, {} );\x0a * // \xe2\x87\x92 6.333333333333334\x0a * ```\x0a *\x0a * @param {string[]} postfix   Postfix terms.\x0a * @param {Object}   variables Operand variables.\x0a *\x0a * @return {*} Result of evaluation.\x0a */\x0afunction evaluate_evaluate( postfix, variables ) {\x0a\x09var stack = [],\x0a\x09\x09i, j, args, getOperatorResult, term, value;\x0a\x0a\x09for ( i = 0; i \x3c postfix.length; i++ ) {\x0a\x09\x09term = postfix[ i ];\x0a\x0a\x09\x09getOperatorResult = OPERATORS[ term ];\x0a\x09\x09if ( getOperatorResult ) {\x0a\x09\x09\x09// Pop from stack by number of function arguments.\x0a\x09\x09\x09j = getOperatorResult.length;\x0a\x09\x09\x09args = Array( j );\x0a\x09\x09\x09while ( j-- ) {\x0a\x09\x09\x09\x09args[ j ] = stack.pop();\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09try {\x0a\x09\x09\x09\x09value = getOperatorResult.apply( null, args );\x0a\x09\x09\x09} catch ( earlyReturn ) {\x0a\x09\x09\x09\x09return earlyReturn;\x0a\x09\x09\x09}\x0a\x09\x09} else if ( variables.hasOwnProperty( term ) ) {\x0a\x09\x09\x09value = variables[ term ];\x0a\x09\x09} else {\x0a\x09\x09\x09value = +term;\x0a\x09\x09}\x0a\x0a\x09\x09stack.push( value );\x0a\x09}\x0a\x0a\x09return stack[ 0 ];\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@tannin/compile/index.js\x0a\x0a\x0a\x0a/**\x0a * Given a C expression, returns a function which can be called to evaluate its\x0a * result.\x0a *\x0a * @example\x0a *\x0a * ```js\x0a * import compile from \x27@tannin/compile\x27;\x0a *\x0a * const evaluate = compile( \x27n \x3e 1\x27 );\x0a *\x0a * evaluate( { n: 2 } );\x0a * // \xe2\x87\x92 true\x0a * ```\x0a *\x0a * @param {string} expression C expression.\x0a *\x0a * @return {Function} Compiled evaluator.\x0a */\x0afunction compile( expression ) {\x0a\x09var terms = postfix( expression );\x0a\x0a\x09return function( variables ) {\x0a\x09\x09return evaluate_evaluate( terms, variables );\x0a\x09};\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/@tannin/plural-forms/index.js\x0a\x0a\x0a/**\x0a * Given a C expression, returns a function which, when called with a value,\x0a * evaluates the result with the value assumed to be the \x22n\x22 variable of the\x0a * expression. The result will be coerced to its numeric equivalent.\x0a *\x0a * @param {string} expression C expression.\x0a *\x0a * @return {Function} Evaluator function.\x0a */\x0afunction pluralForms( expression ) {\x0a\x09var evaluate = compile( expression );\x0a\x0a\x09return function( n ) {\x0a\x09\x09return +evaluate( { n: n } );\x0a\x09};\x0a}\x0a\x0a// CONCATENATED MODULE: ./node_modules/tannin/index.js\x0a\x0a\x0a/**\x0a * Tannin constructor options.\x0a *\x0a * @property {?string}   contextDelimiter Joiner in string lookup with context.\x0a * @property {?Function} onMissingKey     Callback to invoke when key missing.\x0a *\x0a * @type {Object}\x0a *\x0a * @typedef {TanninOptions}\x0a */\x0a\x0a/**\x0a * Default Tannin constructor options.\x0a *\x0a * @type {TanninOptions}\x0a */\x0avar DEFAULT_OPTIONS = {\x0a\x09contextDelimiter: \x27\x5cu0004\x27,\x0a\x09onMissingKey: null,\x0a};\x0a\x0a/**\x0a * Given a specific locale data\x27s config `plural_forms` value, returns the\x0a * expression.\x0a *\x0a * @example\x0a *\x0a * ```\x0a * getPluralExpression( \x27nplurals=2; plural=(n != 1);\x27 ) === \x27(n != 1)\x27\x0a * ```\x0a *\x0a * @param {string} pf Locale data plural forms.\x0a *\x0a * @return {string} Plural forms expression.\x0a */\x0afunction getPluralExpression( pf ) {\x0a\x09var parts, i, part;\x0a\x0a\x09parts = pf.split( \x27;\x27 );\x0a\x0a\x09for ( i = 0; i \x3c parts.length; i++ ) {\x0a\x09\x09part = parts[ i ].trim();\x0a\x09\x09if ( part.indexOf( \x27plural=\x27 ) === 0 ) {\x0a\x09\x09\x09return part.substr( 7 );\x0a\x09\x09}\x0a\x09}\x0a}\x0a\x0a/**\x0a * Tannin constructor.\x0a *\x0a * @param {Object}        data    Jed-formatted locale data.\x0a * @param {TanninOptions} options Tannin options.\x0a */\x0afunction Tannin( data, options ) {\x0a\x09var key;\x0a\x0a\x09this.data = data;\x0a\x09this.pluralForms = {};\x0a\x0a\x09options = options || {};\x0a\x09this.options = {};\x0a\x09for ( key in DEFAULT_OPTIONS ) {\x0a\x09\x09this.options[ key ] = options[ key ] || DEFAULT_OPTIONS[ key ];\x0a\x09}\x0a}\x0a\x0a/**\x0a * Returns the plural form index for the given domain and value.\x0a *\x0a * @param {string} domain Domain on which to calculate plural form.\x0a * @param {number} n      Value for which plural form is to be calculated.\x0a *\x0a * @return {number} Plural form index.\x0a */\x0aTannin.prototype.getPluralForm = function( domain, n ) {\x0a\x09var getPluralForm = this.pluralForms[ domain ],\x0a\x09\x09config, plural, pf;\x0a\x0a\x09if ( ! getPluralForm ) {\x0a\x09\x09config = this.data[ domain ][ \x27\x27 ];\x0a\x0a\x09\x09pf = (\x0a\x09\x09\x09config[ \x27Plural-Forms\x27 ] ||\x0a\x09\x09\x09config[ \x27plural-forms\x27 ] ||\x0a\x09\x09\x09config.plural_forms\x0a\x09\x09);\x0a\x0a\x09\x09if ( typeof pf !== \x27function\x27 ) {\x0a\x09\x09\x09plural = getPluralExpression(\x0a\x09\x09\x09\x09config[ \x27Plural-Forms\x27 ] ||\x0a\x09\x09\x09\x09config[ \x27plural-forms\x27 ] ||\x0a\x09\x09\x09\x09config.plural_forms\x0a\x09\x09\x09);\x0a\x0a\x09\x09\x09pf = pluralForms( plural );\x0a\x09\x09}\x0a\x0a\x09\x09getPluralForm = this.pluralForms[ domain ] = pf;\x0a\x09}\x0a\x0a\x09return getPluralForm( n );\x0a};\x0a\x0a/**\x0a * Translate a string.\x0a *\x0a * @param {string} domain   Translation domain.\x0a * @param {string} context  Context distinguishing terms of the same name.\x0a * @param {string} singular Primary key for translation lookup.\x0a * @param {string} plural   Fallback value used for non-zero plural form index.\x0a * @param {number} n        Value to use in calculating plural form.\x0a *\x0a * @return {string} Translated string.\x0a */\x0aTannin.prototype.dcnpgettext = function( domain, context, singular, plural, n ) {\x0a\x09var index, key, entry;\x0a\x0a\x09if ( n === undefined ) {\x0a\x09\x09// Default to singular.\x0a\x09\x09index = 0;\x0a\x09} else {\x0a\x09\x09// Find index by evaluating plural form for value.\x0a\x09\x09index = this.getPluralForm( domain, n );\x0a\x09}\x0a\x0a\x09key = singular;\x0a\x0a\x09// If provided, context is prepended to key with delimiter.\x0a\x09if ( context ) {\x0a\x09\x09key = context + this.options.contextDelimiter + singular;\x0a\x09}\x0a\x0a\x09entry = this.data[ domain ][ key ];\x0a\x0a\x09// Verify not only that entry exists, but that the intended index is within\x0a\x09// range and non-empty.\x0a\x09if ( entry && entry[ index ] ) {\x0a\x09\x09return entry[ index ];\x0a\x09}\x0a\x0a\x09if ( this.options.onMissingKey ) {\x0a\x09\x09this.options.onMissingKey( singular, domain );\x0a\x09}\x0a\x0a\x09// If entry not found, fall back to singular vs. plural with zero index\x0a\x09// representing the singular value.\x0a\x09return index === 0 ? singular : plural;\x0a};\x0a\x0a// EXTERNAL MODULE: ./node_modules/memize/index.js\x0avar memize = __webpack_require__(41);\x0avar memize_default = /*#__PURE__*/__webpack_require__.n(memize);\x0a\x0a// EXTERNAL MODULE: ./node_modules/@wordpress/i18n/node_modules/sprintf-js/src/sprintf.js\x0avar sprintf = __webpack_require__(137);\x0avar sprintf_default = /*#__PURE__*/__webpack_require__.n(sprintf);\x0a\x0a// CONCATENATED MODULE: ./node_modules/@wordpress/i18n/build-module/index.js\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22setLocaleData\x22, function() { return setLocaleData; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22__\x22, function() { return __; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22_x\x22, function() { return _x; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22_n\x22, function() { return _n; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22_nx\x22, function() { return _nx; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22sprintf\x22, function() { return build_module_sprintf; });\x0a\x0a\x0a/**\x0a * External dependencies\x0a */\x0a\x0a\x0a\x0a/**\x0a * Default locale data to use for Tannin domain when not otherwise provided.\x0a * Assumes an English plural forms expression.\x0a *\x0a * @type {Object}\x0a */\x0a\x0avar DEFAULT_LOCALE_DATA = {\x0a  \x27\x27: {\x0a    plural_forms: \x27plural=(n!=1)\x27\x0a  }\x0a};\x0a/**\x0a * Log to console, once per message; or more precisely, per referentially equal\x0a * argument set. Because Jed throws errors, we log these to the console instead\x0a * to avoid crashing the application.\x0a *\x0a * @param {...*} args Arguments to pass to `console.error`\x0a */\x0a\x0avar logErrorOnce = memize_default()(console.error); // eslint-disable-line no-console\x0a\x0a/**\x0a * The underlying instance of Tannin to which exported functions interface.\x0a *\x0a * @type {Tannin}\x0a */\x0a\x0avar i18n = new Tannin({});\x0a/**\x0a * Merges locale data into the Tannin instance by domain. Accepts data in a\x0a * Jed-formatted JSON object shape.\x0a *\x0a * @see http://messageformat.github.io/Jed/\x0a *\x0a * @param {?Object} data   Locale data configuration.\x0a * @param {?string} domain Domain for which configuration applies.\x0a */\x0a\x0afunction setLocaleData(data) {\x0a  var domain = arguments.length \x3e 1 && arguments[1] !== undefined ? arguments[1] : \x27default\x27;\x0a  i18n.data[domain] = Object(objectSpread[\x22a\x22 /* default */])({}, DEFAULT_LOCALE_DATA, i18n.data[domain], data); // Populate default domain configuration (supported locale date which omits\x0a  // a plural forms expression).\x0a\x0a  i18n.data[domain][\x27\x27] = Object(objectSpread[\x22a\x22 /* default */])({}, DEFAULT_LOCALE_DATA[\x27\x27], i18n.data[domain][\x27\x27]);\x0a}\x0a/**\x0a * Wrapper for Tannin\x27s `dcnpgettext`. Populates default locale data if not\x0a * otherwise previously assigned.\x0a *\x0a * @param {?string} domain  Domain to retrieve the translated text.\x0a * @param {?string} context Context information for the translators.\x0a * @param {string}  single  Text to translate if non-plural. Used as fallback\x0a *                          return value on a caught error.\x0a * @param {?string} plural  The text to be used if the number is plural.\x0a * @param {?number} number  The number to compare against to use either the\x0a *                          singular or plural form.\x0a *\x0a * @return {string} The translated string.\x0a */\x0a\x0afunction dcnpgettext() {\x0a  var domain = arguments.length \x3e 0 && arguments[0] !== undefined ? arguments[0] : \x27default\x27;\x0a  var context = arguments.length \x3e 1 ? arguments[1] : undefined;\x0a  var single = arguments.length \x3e 2 ? arguments[2] : undefined;\x0a  var plural = arguments.length \x3e 3 ? arguments[3] : undefined;\x0a  var number = arguments.length \x3e 4 ? arguments[4] : undefined;\x0a\x0a  if (!i18n.data[domain]) {\x0a    setLocaleData(undefined, domain);\x0a  }\x0a\x0a  return i18n.dcnpgettext(domain, context, single, plural, number);\x0a}\x0a/**\x0a * Retrieve the translation of text.\x0a *\x0a * @see https://developer.wordpress.org/reference/functions/__/\x0a *\x0a * @param {string}  text   Text to translate.\x0a * @param {?string} domain Domain to retrieve the translated text.\x0a *\x0a * @return {string} Translated text.\x0a */\x0a\x0a\x0afunction __(text, domain) {\x0a  return dcnpgettext(domain, undefined, text);\x0a}\x0a/**\x0a * Retrieve translated string with gettext context.\x0a *\x0a * @see https://developer.wordpress.org/reference/functions/_x/\x0a *\x0a * @param {string}  text    Text to translate.\x0a * @param {string}  context Context information for the translators.\x0a * @param {?string} domain  Domain to retrieve the translated text.\x0a *\x0a * @return {string} Translated context string without pipe.\x0a */\x0a\x0afunction _x(text, context, domain) {\x0a  return dcnpgettext(domain, context, text);\x0a}\x0a/**\x0a * Translates and retrieves the singular or plural form based on the supplied\x0a * number.\x0a *\x0a * @see https://developer.wordpress.org/reference/functions/_n/\x0a *\x0a * @param {string}  single The text to be used if the number is singular.\x0a * @param {string}  plural The text to be used if the number is plural.\x0a * @param {number}  number The number to compare against to use either the\x0a *                         singular or plural form.\x0a * @param {?string} domain Domain to retrieve the translated text.\x0a *\x0a * @return {string} The translated singular or plural form.\x0a */\x0a\x0afunction _n(single, plural, number, domain) {\x0a  return dcnpgettext(domain, undefined, single, plural, number);\x0a}\x0a/**\x0a * Translates and retrieves the singular or plural form based on the supplied\x0a * number, with gettext context.\x0a *\x0a * @see https://developer.wordpress.org/reference/functions/_nx/\x0a *\x0a * @param {string}  single  The text to be used if the number is singular.\x0a * @param {string}  plural  The text to be used if the number is plural.\x0a * @param {number}  number  The number to compare against to use either the\x0a *                          singular or plural form.\x0a * @param {string}  context Context information for the translators.\x0a * @param {?string} domain  Domain to retrieve the translated text.\x0a *\x0a * @return {string} The translated singular or plural form.\x0a */\x0a\x0afunction _nx(single, plural, number, context, domain) {\x0a  return dcnpgettext(domain, context, single, plural, number);\x0a}\x0a/**\x0a * Returns a formatted string. If an error occurs in applying the format, the\x0a * original format string is returned.\x0a *\x0a * @param {string}   format  The format of the string to generate.\x0a * @param {...string} args Arguments to apply to the format.\x0a *\x0a * @see http://www.diveintojavascript.com/projects/javascript-sprintf\x0a *\x0a * @return {string} The formatted string.\x0a */\x0a\x0afunction build_module_sprintf(format) {\x0a  try {\x0a    for (var _len = arguments.length, args = new Array(_len \x3e 1 ? _len - 1 : 0), _key = 1; _key \x3c _len; _key++) {\x0a      args[_key - 1] = arguments[_key];\x0a    }\x0a\x0a    return sprintf_default.a.sprintf.apply(sprintf_default.a, [format].concat(args));\x0a  } catch (error) {\x0a    logErrorOnce(\x27sprintf error: \x5cn\x5cn\x27 + error.toString());\x0a    return format;\x0a  }\x0a}\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 41:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0amodule.exports = function memize( fn, options ) {\x0a\x09var size = 0,\x0a\x09\x09maxSize, head, tail;\x0a\x0a\x09if ( options && options.maxSize ) {\x0a\x09\x09maxSize = options.maxSize;\x0a\x09}\x0a\x0a\x09function memoized( /* ...args */ ) {\x0a\x09\x09var node = head,\x0a\x09\x09\x09len = arguments.length,\x0a\x09\x09\x09args, i;\x0a\x0a\x09\x09searchCache: while ( node ) {\x0a\x09\x09\x09// Perform a shallow equality test to confirm that whether the node\x0a\x09\x09\x09// under test is a candidate for the arguments passed. Two arrays\x0a\x09\x09\x09// are shallowly equal if their length matches and each entry is\x0a\x09\x09\x09// strictly equal between the two sets. Avoid abstracting to a\x0a\x09\x09\x09// function which could incur an arguments leaking deoptimization.\x0a\x0a\x09\x09\x09// Check whether node arguments match arguments length\x0a\x09\x09\x09if ( node.args.length !== arguments.length ) {\x0a\x09\x09\x09\x09node = node.next;\x0a\x09\x09\x09\x09continue;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Check whether node arguments match arguments values\x0a\x09\x09\x09for ( i = 0; i \x3c len; i++ ) {\x0a\x09\x09\x09\x09if ( node.args[ i ] !== arguments[ i ] ) {\x0a\x09\x09\x09\x09\x09node = node.next;\x0a\x09\x09\x09\x09\x09continue searchCache;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// At this point we can assume we\x27ve found a match\x0a\x0a\x09\x09\x09// Surface matched node to head if not already\x0a\x09\x09\x09if ( node !== head ) {\x0a\x09\x09\x09\x09// As tail, shift to previous. Must only shift if not also\x0a\x09\x09\x09\x09// head, since if both head and tail, there is no previous.\x0a\x09\x09\x09\x09if ( node === tail ) {\x0a\x09\x09\x09\x09\x09tail = node.prev;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Adjust siblings to point to each other. If node was tail,\x0a\x09\x09\x09\x09// this also handles new tail\x27s empty `next` assignment.\x0a\x09\x09\x09\x09node.prev.next = node.next;\x0a\x09\x09\x09\x09if ( node.next ) {\x0a\x09\x09\x09\x09\x09node.next.prev = node.prev;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09node.next = head;\x0a\x09\x09\x09\x09node.prev = null;\x0a\x09\x09\x09\x09head.prev = node;\x0a\x09\x09\x09\x09head = node;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Return immediately\x0a\x09\x09\x09return node.val;\x0a\x09\x09}\x0a\x0a\x09\x09// No cached value found. Continue to insertion phase:\x0a\x0a\x09\x09// Create a copy of arguments (avoid leaking deoptimization)\x0a\x09\x09args = new Array( len );\x0a\x09\x09for ( i = 0; i \x3c len; i++ ) {\x0a\x09\x09\x09args[ i ] = arguments[ i ];\x0a\x09\x09}\x0a\x0a\x09\x09node = {\x0a\x09\x09\x09args: args,\x0a\x0a\x09\x09\x09// Generate the result from original function\x0a\x09\x09\x09val: fn.apply( null, args )\x0a\x09\x09};\x0a\x0a\x09\x09// Don\x27t need to check whether node is already head, since it would\x0a\x09\x09// have been returned above already if it was\x0a\x0a\x09\x09// Shift existing head down list\x0a\x09\x09if ( head ) {\x0a\x09\x09\x09head.prev = node;\x0a\x09\x09\x09node.next = head;\x0a\x09\x09} else {\x0a\x09\x09\x09// If no head, follows that there\x27s no tail (at initial or reset)\x0a\x09\x09\x09tail = node;\x0a\x09\x09}\x0a\x0a\x09\x09// Trim tail if we\x27re reached max size and are pending cache insertion\x0a\x09\x09if ( size === maxSize ) {\x0a\x09\x09\x09tail = tail.prev;\x0a\x09\x09\x09tail.next = null;\x0a\x09\x09} else {\x0a\x09\x09\x09size++;\x0a\x09\x09}\x0a\x0a\x09\x09head = node;\x0a\x0a\x09\x09return node.val;\x0a\x09}\x0a\x0a\x09memoized.clear = function() {\x0a\x09\x09head = null;\x0a\x09\x09tail = null;\x0a\x09\x09size = 0;\x0a\x09};\x0a\x0a\x09if ( false ) {}\x0a\x0a\x09return memoized;\x0a};\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 7:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22a\x22, function() { return _objectSpread; });\x0a/* harmony import */ var _defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);\x0a\x0afunction _objectSpread(target) {\x0a  for (var i = 1; i \x3c arguments.length; i++) {\x0a    var source = arguments[i] != null ? arguments[i] : {};\x0a    var ownKeys = Object.keys(source);\x0a\x0a    if (typeof Object.getOwnPropertySymbols === \x27function\x27) {\x0a      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\x0a        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\x0a      }));\x0a    }\x0a\x0a    ownKeys.forEach(function (key) {\x0a      Object(_defineProperty__WEBPACK_IMPORTED_MODULE_0__[/* default */ \x22a\x22])(target, key, source[key]);\x0a    });\x0a  }\x0a\x0a  return target;\x0a}\x0a\x0a/***/ })\x0a\x0a/******/ });'}