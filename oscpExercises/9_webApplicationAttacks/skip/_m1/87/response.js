var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 15:05:35 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Thu, 21 Mar 2019 12:48:00 GMT\x0aETag: \x2246b2-5849a25f20000-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-5364/5365\x0aContent-Length: 5365\x0aKeep-Alive: timeout=5, max=65\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0athis[\x22wp\x22] = this[\x22wp\x22] || {}; this[\x22wp\x22][\x22shortcode\x22] =\x0a/******/ (function(modules) { // webpackBootstrap\x0a/******/ \x09// The module cache\x0a/******/ \x09var installedModules = {};\x0a/******/\x0a/******/ \x09// The require function\x0a/******/ \x09function __webpack_require__(moduleId) {\x0a/******/\x0a/******/ \x09\x09// Check if module is in cache\x0a/******/ \x09\x09if(installedModules[moduleId]) {\x0a/******/ \x09\x09\x09return installedModules[moduleId].exports;\x0a/******/ \x09\x09}\x0a/******/ \x09\x09// Create a new module (and put it into the cache)\x0a/******/ \x09\x09var module = installedModules[moduleId] = {\x0a/******/ \x09\x09\x09i: moduleId,\x0a/******/ \x09\x09\x09l: false,\x0a/******/ \x09\x09\x09exports: {}\x0a/******/ \x09\x09};\x0a/******/\x0a/******/ \x09\x09// Execute the module function\x0a/******/ \x09\x09modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\x0a/******/\x0a/******/ \x09\x09// Flag the module as loaded\x0a/******/ \x09\x09module.l = true;\x0a/******/\x0a/******/ \x09\x09// Return the exports of the module\x0a/******/ \x09\x09return module.exports;\x0a/******/ \x09}\x0a/******/\x0a/******/\x0a/******/ \x09// expose the modules object (__webpack_modules__)\x0a/******/ \x09__webpack_require__.m = modules;\x0a/******/\x0a/******/ \x09// expose the module cache\x0a/******/ \x09__webpack_require__.c = installedModules;\x0a/******/\x0a/******/ \x09// define getter function for harmony exports\x0a/******/ \x09__webpack_require__.d = function(exports, name, getter) {\x0a/******/ \x09\x09if(!__webpack_require__.o(exports, name)) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, name, { enumerable: true, get: getter });\x0a/******/ \x09\x09}\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// define __esModule on exports\x0a/******/ \x09__webpack_require__.r = function(exports) {\x0a/******/ \x09\x09if(typeof Symbol !== \x27undefined\x27 && Symbol.toStringTag) {\x0a/******/ \x09\x09\x09Object.defineProperty(exports, Symbol.toStringTag, { value: \x27Module\x27 });\x0a/******/ \x09\x09}\x0a/******/ \x09\x09Object.defineProperty(exports, \x27__esModule\x27, { value: true });\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// create a fake namespace object\x0a/******/ \x09// mode & 1: value is a module id, require it\x0a/******/ \x09// mode & 2: merge all properties of value into the ns\x0a/******/ \x09// mode & 4: return value when already ns object\x0a/******/ \x09// mode & 8|1: behave like require\x0a/******/ \x09__webpack_require__.t = function(value, mode) {\x0a/******/ \x09\x09if(mode & 1) value = __webpack_require__(value);\x0a/******/ \x09\x09if(mode & 8) return value;\x0a/******/ \x09\x09if((mode & 4) && typeof value === \x27object\x27 && value && value.__esModule) return value;\x0a/******/ \x09\x09var ns = Object.create(null);\x0a/******/ \x09\x09__webpack_require__.r(ns);\x0a/******/ \x09\x09Object.defineProperty(ns, \x27default\x27, { enumerable: true, value: value });\x0a/******/ \x09\x09if(mode & 2 && typeof value != \x27string\x27) for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\x0a/******/ \x09\x09return ns;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// getDefaultExport function for compatibility with non-harmony modules\x0a/******/ \x09__webpack_require__.n = function(module) {\x0a/******/ \x09\x09var getter = module && module.__esModule ?\x0a/******/ \x09\x09\x09function getDefault() { return module[\x27default\x27]; } :\x0a/******/ \x09\x09\x09function getModuleExports() { return module; };\x0a/******/ \x09\x09__webpack_require__.d(getter, \x27a\x27, getter);\x0a/******/ \x09\x09return getter;\x0a/******/ \x09};\x0a/******/\x0a/******/ \x09// Object.prototype.hasOwnProperty.call\x0a/******/ \x09__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\x0a/******/\x0a/******/ \x09// __webpack_public_path__\x0a/******/ \x09__webpack_require__.p = \x22\x22;\x0a/******/\x0a/******/\x0a/******/ \x09// Load entry module and return exports\x0a/******/ \x09return __webpack_require__(__webpack_require__.s = 352);\x0a/******/ })\x0a/************************************************************************/\x0a/******/ ({\x0a\x0a/***/ 2:\x0a/***/ (function(module, exports) {\x0a\x0a(function() { module.exports = this[\x22lodash\x22]; }());\x0a\x0a/***/ }),\x0a\x0a/***/ 352:\x0a/***/ (function(module, __webpack_exports__, __webpack_require__) {\x0a\x0a\x22use strict\x22;\x0a__webpack_require__.r(__webpack_exports__);\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22next\x22, function() { return next; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22replace\x22, function() { return replace; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22string\x22, function() { return string; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22regexp\x22, function() { return regexp; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22attrs\x22, function() { return attrs; });\x0a/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \x22fromMatch\x22, function() { return fromMatch; });\x0a/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\x0a/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\x0a/* harmony import */ var memize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);\x0a/* harmony import */ var memize__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(memize__WEBPACK_IMPORTED_MODULE_1__);\x0a/**\x0a * External dependencies\x0a */\x0a\x0a\x0a/**\x0a * Shortcode attributes object.\x0a *\x0a * @typedef {Object} WPShortcodeAttrs\x0a *\x0a * @property {Object} named   Object with named attributes.\x0a * @property {Array}  numeric Array with numeric attributes.\x0a */\x0a\x0a/**\x0a * Shortcode object.\x0a *\x0a * @typedef {Object} WPShortcode\x0a *\x0a * @property {string}           tag     Shortcode tag.\x0a * @property {WPShortcodeAttrs} attrs   Shortcode attributes.\x0a * @property {string}           content Shortcode content.\x0a * @property {string}           type    Shortcode type: `self-closing`,\x0a *                                      `closed`, or `single`.\x0a */\x0a\x0a/**\x0a * @typedef {Object} WPShortcodeMatch\x0a *\x0a * @property {number}      index     Index the shortcode is found at.\x0a * @property {string}      content   Matched content.\x0a * @property {WPShortcode} shortcode Shortcode instance of the match.\x0a */\x0a\x0a/**\x0a * Find the next matching shortcode.\x0a *\x0a * @param {string} tag   Shortcode tag.\x0a * @param {string} text  Text to search.\x0a * @param {number} index Index to start search from.\x0a *\x0a * @return {?WPShortcodeMatch} Matched information.\x0a */\x0a\x0afunction next(tag, text) {\x0a  var index = arguments.length \x3e 2 && arguments[2] !== undefined ? arguments[2] : 0;\x0a  var re = regexp(tag);\x0a  re.lastIndex = index;\x0a  var match = re.exec(text);\x0a\x0a  if (!match) {\x0a    return;\x0a  } // If we matched an escaped shortcode, try again.\x0a\x0a\x0a  if (\x27[\x27 === match[1] && \x27]\x27 === match[7]) {\x0a    return next(tag, text, re.lastIndex);\x0a  }\x0a\x0a  var result = {\x0a    index: match.index,\x0a    content: match[0],\x0a    shortcode: fromMatch(match)\x0a  }; // If we matched a leading `[`, strip it from the match and increment the\x0a  // index accordingly.\x0a\x0a  if (match[1]) {\x0a    result.content = result.content.slice(1);\x0a    result.index++;\x0a  } // If we matched a trailing `]`, strip it from the match.\x0a\x0a\x0a  if (match[7]) {\x0a    result.content = result.content.slice(0, -1);\x0a  }\x0a\x0a  return result;\x0a}\x0a/**\x0a * Replace matching shortcodes in a block of text.\x0a *\x0a * @param {string}   tag      Shortcode tag.\x0a * @param {string}   text     Text to search.\x0a * @param {Function} callback Function to process the match and return\x0a *                            replacement string.\x0a *\x0a * @return {string} Text with shortcodes replaced.\x0a */\x0a\x0afunction replace(tag, text, callback) {\x0a  var _arguments = arguments;\x0a  return text.replace(regexp(tag), function (match, left, $3, attrs, slash, content, closing, right) {\x0a    // If both extra brackets exist, the shortcode has been properly\x0a    // escaped.\x0a    if (left === \x27[\x27 && right === \x27]\x27) {\x0a      return match;\x0a    } // Create the match object and pass it through the callback.\x0a\x0a\x0a    var result = callback(fromMatch(_arguments)); // Make sure to return any of the extra brackets if they weren\x27t used to\x0a    // escape the shortcode.\x0a\x0a    return result ? left + result + right : match;\x0a  });\x0a}\x0a/**\x0a * Generate a string from shortcode parameters.\x0a *\x0a * Creates a shortcode instance and returns a string.\x0a *\x0a * Accepts the same `options` as the `shortcode()` constructor, containing a\x0a * `tag` string, a string or object of `attrs`, a boolean indicating whether to\x0a * format the shortcode using a `single` tag, and a `content` string.\x0a *\x0a * @param {Object} options\x0a *\x0a * @return {string} String representation of the shortcode.\x0a */\x0a\x0afunction string(options) {\x0a  return new shortcode(options).string();\x0a}\x0a/**\x0a * Generate a RegExp to identify a shortcode.\x0a *\x0a * The base regex is functionally equivalent to the one found in\x0a * `get_shortcode_regex()` in `wp-includes/shortcodes.php`.\x0a *\x0a * Capture groups:\x0a *\x0a * 1. An extra `[` to allow for escaping shortcodes with double `[[]]`\x0a * 2. The shortcode name\x0a * 3. The shortcode argument list\x0a * 4. The self closing `/`\x0a * 5. The content of a shortcode when it wraps some content.\x0a * 6. The closing tag.\x0a * 7. An extra `]` to allow for escaping shortcodes with double `[[]]`\x0a *\x0a * @param {string} tag Shortcode tag.\x0a *\x0a * @return {RegExp} Shortcode RegExp.\x0a */\x0a\x0afunction regexp(tag) {\x0a  return new RegExp(\x27\x5c\x5c[(\x5c\x5c[?)(\x27 + tag + \x27)(?![\x5c\x5cw-])([^\x5c\x5c]\x5c\x5c/]*(?:\x5c\x5c/(?!\x5c\x5c])[^\x5c\x5c]\x5c\x5c/]*)*?)(?:(\x5c\x5c/)\x5c\x5c]|\x5c\x5c](?:([^\x5c\x5c[]*(?:\x5c\x5c[(?!\x5c\x5c/\x5c\x5c2\x5c\x5c])[^\x5c\x5c[]*)*)(\x5c\x5c[\x5c\x5c/\x5c\x5c2\x5c\x5c]))?)(\x5c\x5c]?)\x27, \x27g\x27);\x0a}\x0a/**\x0a * Parse shortcode attributes.\x0a *\x0a * Shortcodes accept many types of attributes. These can chiefly be divided into\x0a * named and numeric attributes:\x0a *\x0a * Named attributes are assigned on a key/value basis, while numeric attributes\x0a * are treated as an array.\x0a *\x0a * Named attributes can be formatted as either `name=\x22value\x22`, `name=\x27value\x27`,\x0a * or `name=value`. Numeric attributes can be formatted as `\x22value\x22` or just\x0a * `value`.\x0a *\x0a * @param {string} text Serialised shortcode attributes.\x0a *\x0a * @return {WPShortcodeAttrs} Parsed shortcode attributes.\x0a */\x0a\x0avar attrs = memize__WEBPACK_IMPORTED_MODULE_1___default()(function (text) {\x0a  var named = {};\x0a  var numeric = []; // This regular expression is reused from `shortcode_parse_atts()` in\x0a  // `wp-includes/shortcodes.php`.\x0a  //\x0a  // Capture groups:\x0a  //\x0a  // 1. An attribute name, that corresponds to...\x0a  // 2. a value in double quotes.\x0a  // 3. An attribute name, that corresponds to...\x0a  // 4. a value in single quotes.\x0a  // 5. An attribute name, that corresponds to...\x0a  // 6. an unquoted value.\x0a  // 7. A numeric attribute in double quotes.\x0a  // 8. A numeric attribute in single quotes.\x0a  // 9. An unquoted numeric attribute.\x0a\x0a  var pattern = /([\x5cw-]+)\x5cs*=\x5cs*\x22([^\x22]*)\x22(?:\x5cs|$)|([\x5cw-]+)\x5cs*=\x5cs*\x27([^\x27]*)\x27(?:\x5cs|$)|([\x5cw-]+)\x5cs*=\x5cs*([^\x5cs\x27\x22]+)(?:\x5cs|$)|\x22([^\x22]*)\x22(?:\x5cs|$)|\x27([^\x27]*)\x27(?:\x5cs|$)|(\x5cS+)(?:\x5cs|$)/g; // Map zero-width spaces to actual spaces.\x0a\x0a  text = text.replace(/[\x5cu00a0\x5cu200b]/g, \x27 \x27);\x0a  var match; // Match and normalize attributes.\x0a\x0a  while (match = pattern.exec(text)) {\x0a    if (match[1]) {\x0a      named[match[1].toLowerCase()] = match[2];\x0a    } else if (match[3]) {\x0a      named[match[3].toLowerCase()] = match[4];\x0a    } else if (match[5]) {\x0a      named[match[5].toLowerCase()] = match[6];\x0a    } else if (match[7]) {\x0a      numeric.push(match[7]);\x0a    } else if (match[8]) {\x0a      numeric.push(match[8]);\x0a    } else if (match[9]) {\x0a      numeric.push(match[9]);\x0a    }\x0a  }\x0a\x0a  return {\x0a    named: named,\x0a    numeric: numeric\x0a  };\x0a});\x0a/**\x0a * Generate a Shortcode Object from a RegExp match.\x0a *\x0a * Accepts a `match` object from calling `regexp.exec()` on a `RegExp` generated\x0a * by `regexp()`. `match` can also be set to the `arguments` from a callback\x0a * passed to `regexp.replace()`.\x0a *\x0a * @param {Array} match Match array.\x0a *\x0a * @return {WPShortcode} Shortcode instance.\x0a */\x0a\x0afunction fromMatch(match) {\x0a  var type;\x0a\x0a  if (match[4]) {\x0a    type = \x27self-closing\x27;\x0a  } else if (match[6]) {\x0a    type = \x27closed\x27;\x0a  } else {\x0a    type = \x27single\x27;\x0a  }\x0a\x0a  return new shortcode({\x0a    tag: match[2],\x0a    attrs: match[3],\x0a    type: type,\x0a    content: match[5]\x0a  });\x0a}\x0a/**\x0a * Creates a shortcode instance.\x0a *\x0a * To access a raw representation of a shortcode, pass an `options` object,\x0a * containing a `tag` string, a string or object of `attrs`, a string indicating\x0a * the `type` of the shortcode (\x27single\x27, \x27self-closing\x27, or \x27closed\x27), and a\x0a * `content` string.\x0a *\x0a * @param {Object} options Options as described.\x0a *\x0a * @return {WPShortcode} Shortcode instance.\x0a */\x0a\x0avar shortcode = Object(lodash__WEBPACK_IMPORTED_MODULE_0__[\x22extend\x22])(function (options) {\x0a  var _this = this;\x0a\x0a  Object(lodash__WEBPACK_IMPORTED_MODULE_0__[\x22extend\x22])(this, Object(lodash__WEBPACK_IMPORTED_MODULE_0__[\x22pick\x22])(options || {}, \x27tag\x27, \x27attrs\x27, \x27type\x27, \x27content\x27));\x0a  var attributes = this.attrs; // Ensure we have a correctly formatted `attrs` object.\x0a\x0a  this.attrs = {\x0a    named: {},\x0a    numeric: []\x0a  };\x0a\x0a  if (!attributes) {\x0a    return;\x0a  } // Parse a string of attributes.\x0a\x0a\x0a  if (Object(lodash__WEBPACK_IMPORTED_MODULE_0__[\x22isString\x22])(attributes)) {\x0a    this.attrs = attrs(attributes); // Identify a correctly formatted `attrs` object.\x0a  } else if (Object(lodash__WEBPACK_IMPORTED_MODULE_0__[\x22isEqual\x22])(Object.keys(attributes), [\x27named\x27, \x27numeric\x27])) {\x0a    this.attrs = attributes; // Handle a flat object of attributes.\x0a  } else {\x0a    Object(lodash__WEBPACK_IMPORTED_MODULE_0__[\x22forEach\x22])(attributes, function (value, key) {\x0a      _this.set(key, value);\x0a    });\x0a  }\x0a}, {\x0a  next: next,\x0a  replace: replace,\x0a  string: string,\x0a  regexp: regexp,\x0a  attrs: attrs,\x0a  fromMatch: fromMatch\x0a});\x0aObject(lodash__WEBPACK_IMPORTED_MODULE_0__[\x22extend\x22])(shortcode.prototype, {\x0a  /**\x0a   * Get a shortcode attribute.\x0a   *\x0a   * Automatically detects whether `attr` is named or numeric and routes it\x0a   * accordingly.\x0a   *\x0a   * @param {(number|string)} attr Attribute key.\x0a   *\x0a   * @return {string} Attribute value.\x0a   */\x0a  get: function get(attr) {\x0a    return this.attrs[Object(lodash__WEBPACK_IMPORTED_MODULE_0__[\x22isNumber\x22])(attr) ? \x27numeric\x27 : \x27named\x27][attr];\x0a  },\x0a\x0a  /**\x0a   * Set a shortcode attribute.\x0a   *\x0a   * Automatically detects whether `attr` is named or numeric and routes it\x0a   * accordingly.\x0a   *\x0a   * @param {(number|string)} attr  Attribute key.\x0a   * @param {string}          value Attribute value.\x0a   *\x0a   * @return {WPShortcode} Shortcode instance.\x0a   */\x0a  set: function set(attr, value) {\x0a    this.attrs[Object(lodash__WEBPACK_IMPORTED_MODULE_0__[\x22isNumber\x22])(attr) ? \x27numeric\x27 : \x27named\x27][attr] = value;\x0a    return this;\x0a  },\x0a\x0a  /**\x0a   * Transform the shortcode into a string.\x0a   *\x0a   * @return {string} String representation of the shortcode.\x0a   */\x0a  string: function string() {\x0a    var text = \x27[\x27 + this.tag;\x0a    Object(lodash__WEBPACK_IMPORTED_MODULE_0__[\x22forEach\x22])(this.attrs.numeric, function (value) {\x0a      if (/\x5cs/.test(value)) {\x0a        text += \x27 \x22\x27 + value + \x27\x22\x27;\x0a      } else {\x0a        text += \x27 \x27 + value;\x0a      }\x0a    });\x0a    Object(lodash__WEBPACK_IMPORTED_MODULE_0__[\x22forEach\x22])(this.attrs.named, function (value, name) {\x0a      text += \x27 \x27 + name + \x27=\x22\x27 + value + \x27\x22\x27;\x0a    }); // If the tag is marked as `single` or `self-closing`, close the tag and\x0a    // ignore any additional content.\x0a\x0a    if (\x27single\x27 === this.type) {\x0a      return text + \x27]\x27;\x0a    } else if (\x27self-closing\x27 === this.type) {\x0a      return text + \x27 /]\x27;\x0a    } // Complete the opening tag.\x0a\x0a\x0a    text += \x27]\x27;\x0a\x0a    if (this.content) {\x0a      text += this.content;\x0a    } // Add the closing tag.\x0a\x0a\x0a    return text + \x27[/\x27 + this.tag + \x27]\x27;\x0a  }\x0a});\x0a/* harmony default export */ __webpack_exports__[\x22default\x22] = (shortcode);\x0a\x0a\x0a/***/ }),\x0a\x0a/***/ 41:\x0a/***/ (function(module, exports, __webpack_require__) {\x0a\x0amodule.exports = function memize( fn, options ) {\x0a\x09var size = 0,\x0a\x09\x09maxSize, head, tail;\x0a\x0a\x09if ( options && options.maxSize ) {\x0a\x09\x09maxSize = options.maxSize;\x0a\x09}\x0a\x0a\x09function memoized( /* ...args */ ) {\x0a\x09\x09var node = head,\x0a\x09\x09\x09len = arguments.length,\x0a\x09\x09\x09args, i;\x0a\x0a\x09\x09searchCache: while ( node ) {\x0a\x09\x09\x09// Perform a shallow equality test to confirm that whether the node\x0a\x09\x09\x09// under test is a candidate for the arguments passed. Two arrays\x0a\x09\x09\x09// are shallowly equal if their length matches and each entry is\x0a\x09\x09\x09// strictly equal between the two sets. Avoid abstracting to a\x0a\x09\x09\x09// function which could incur an arguments leaking deoptimization.\x0a\x0a\x09\x09\x09// Check whether node arguments match arguments length\x0a\x09\x09\x09if ( node.args.length !== arguments.length ) {\x0a\x09\x09\x09\x09node = node.next;\x0a\x09\x09\x09\x09continue;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Check whether node arguments match arguments values\x0a\x09\x09\x09for ( i = 0; i \x3c len; i++ ) {\x0a\x09\x09\x09\x09if ( node.args[ i ] !== arguments[ i ] ) {\x0a\x09\x09\x09\x09\x09node = node.next;\x0a\x09\x09\x09\x09\x09continue searchCache;\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// At this point we can assume we\x27ve found a match\x0a\x0a\x09\x09\x09// Surface matched node to head if not already\x0a\x09\x09\x09if ( node !== head ) {\x0a\x09\x09\x09\x09// As tail, shift to previous. Must only shift if not also\x0a\x09\x09\x09\x09// head, since if both head and tail, there is no previous.\x0a\x09\x09\x09\x09if ( node === tail ) {\x0a\x09\x09\x09\x09\x09tail = node.prev;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09// Adjust siblings to point to each other. If node was tail,\x0a\x09\x09\x09\x09// this also handles new tail\x27s empty `next` assignment.\x0a\x09\x09\x09\x09node.prev.next = node.next;\x0a\x09\x09\x09\x09if ( node.next ) {\x0a\x09\x09\x09\x09\x09node.next.prev = node.prev;\x0a\x09\x09\x09\x09}\x0a\x0a\x09\x09\x09\x09node.next = head;\x0a\x09\x09\x09\x09node.prev = null;\x0a\x09\x09\x09\x09head.prev = node;\x0a\x09\x09\x09\x09head = node;\x0a\x09\x09\x09}\x0a\x0a\x09\x09\x09// Return immediately\x0a\x09\x09\x09return node.val;\x0a\x09\x09}\x0a\x0a\x09\x09// No cached value found. Continue to insertion phase:\x0a\x0a\x09\x09// Create a copy of arguments (avoid leaking deoptimization)\x0a\x09\x09args = new Array( len );\x0a\x09\x09for ( i = 0; i \x3c len; i++ ) {\x0a\x09\x09\x09args[ i ] = arguments[ i ];\x0a\x09\x09}\x0a\x0a\x09\x09node = {\x0a\x09\x09\x09args: args,\x0a\x0a\x09\x09\x09// Generate the result from original function\x0a\x09\x09\x09val: fn.apply( null, args )\x0a\x09\x09};\x0a\x0a\x09\x09// Don\x27t need to check whether node is already head, since it would\x0a\x09\x09// have been returned above already if it was\x0a\x0a\x09\x09// Shift existing head down list\x0a\x09\x09if ( head ) {\x0a\x09\x09\x09head.prev = node;\x0a\x09\x09\x09node.next = head;\x0a\x09\x09} else {\x0a\x09\x09\x09// If no head, follows that there\x27s no tail (at initial or reset)\x0a\x09\x09\x09tail = node;\x0a\x09\x09}\x0a\x0a\x09\x09// Trim tail if we\x27re reached max size and are pending cache insertion\x0a\x09\x09if ( size === maxSize ) {\x0a\x09\x09\x09tail = tail.prev;\x0a\x09\x09\x09tail.next = null;\x0a\x09\x09} else {\x0a\x09\x09\x09size++;\x0a\x09\x09}\x0a\x0a\x09\x09head = node;\x0a\x0a\x09\x09return node.val;\x0a\x09}\x0a\x0a\x09memoized.clear = function() {\x0a\x09\x09head = null;\x0a\x09\x09tail = null;\x0a\x09\x09size = 0;\x0a\x09};\x0a\x0a\x09if ( false ) {}\x0a\x0a\x09return memoized;\x0a};\x0a\x0a\x0a/***/ })\x0a\x0a/******/ })[\x22default\x22];'}