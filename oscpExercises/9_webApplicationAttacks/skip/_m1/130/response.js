var res = {'data':'HTTP/1.1 200 Partial Content\x0aDate: Sun, 20 Sep 2020 14:57:23 GMT\x0aServer: Apache/2.4.29 (Ubuntu)\x0aLast-Modified: Wed, 25 Apr 2018 22:35:21 GMT\x0aETag: \x2224ea-56ab3e2d73c40-gzip\x22\x0aAccept-Ranges: bytes\x0aVary: Accept-Encoding\x0aContent-Encoding: gzip\x0aContent-Range: bytes 0-2757/2758\x0aContent-Length: 2758\x0aKeep-Alive: timeout=5, max=35\x0aConnection: Keep-Alive\x0aContent-Type: application/javascript\x0a\x0a/**\x0a * plugin.js\x0a *\x0a * Released under LGPL License.\x0a * Copyright (c) 1999-2017 Ephox Corp. All rights reserved\x0a *\x0a * License: http://www.tinymce.com/license\x0a * Contributing: http://www.tinymce.com/contributing\x0a */\x0a\x0a/*global tinymce:true, console:true */\x0a/*eslint no-console:0, new-cap:0 */\x0a\x0a/**\x0a * This plugin adds missing events form the 4.x API back. Not every event is\x0a * properly supported but most things should work.\x0a *\x0a * Unsupported things:\x0a *  - No editor.onEvent\x0a *  - Can\x27t cancel execCommands with beforeExecCommand\x0a */\x0a(function (tinymce) {\x0a  var reported;\x0a\x0a  function noop() {\x0a  }\x0a\x0a  function log(apiCall) {\x0a    if (!reported && window && window.console) {\x0a      reported = true;\x0a      console.log(\x22Deprecated TinyMCE API call: \x22 + apiCall);\x0a    }\x0a  }\x0a\x0a  function Dispatcher(target, newEventName, argsMap, defaultScope) {\x0a    target = target || this;\x0a    var cbs = [];\x0a\x0a    if (!newEventName) {\x0a      this.add = this.addToTop = this.remove = this.dispatch = noop;\x0a      return;\x0a    }\x0a\x0a    this.add = function (callback, scope, prepend) {\x0a      log(\x27\x3ctarget\x3e.on\x27 + newEventName + \x22.add(..)\x22);\x0a\x0a      // Convert callback({arg1:x, arg2:x}) -\x3e callback(arg1, arg2)\x0a      function patchedEventCallback(e) {\x0a        var callbackArgs = [];\x0a\x0a        if (typeof argsMap == \x22string\x22) {\x0a          argsMap = argsMap.split(\x22 \x22);\x0a        }\x0a\x0a        if (argsMap && typeof argsMap !== \x22function\x22) {\x0a          for (var i = 0; i \x3c argsMap.length; i++) {\x0a            callbackArgs.push(e[argsMap[i]]);\x0a          }\x0a        }\x0a\x0a        if (typeof argsMap == \x22function\x22) {\x0a          callbackArgs = argsMap(newEventName, e, target);\x0a          if (!callbackArgs) {\x0a            return;\x0a          }\x0a        }\x0a\x0a        if (!argsMap) {\x0a          callbackArgs = [e];\x0a        }\x0a\x0a        callbackArgs.unshift(defaultScope || target);\x0a\x0a        if (callback.apply(scope || defaultScope || target, callbackArgs) === false) {\x0a          e.stopImmediatePropagation();\x0a        }\x0a      }\x0a\x0a      target.on(newEventName, patchedEventCallback, prepend);\x0a\x0a      var handlers = {\x0a        original: callback,\x0a        patched: patchedEventCallback\x0a      };\x0a\x0a      cbs.push(handlers);\x0a      return patchedEventCallback;\x0a    };\x0a\x0a    this.addToTop = function (callback, scope) {\x0a      this.add(callback, scope, true);\x0a    };\x0a\x0a    this.remove = function (callback) {\x0a      cbs.forEach(function (item, i) {\x0a        if (item.original === callback) {\x0a          cbs.splice(i, 1);\x0a          return target.off(newEventName, item.patched);\x0a        }\x0a      });\x0a\x0a      return target.off(newEventName, callback);\x0a    };\x0a\x0a    this.dispatch = function () {\x0a      target.fire(newEventName);\x0a      return true;\x0a    };\x0a  }\x0a\x0a  tinymce.util.Dispatcher = Dispatcher;\x0a  tinymce.onBeforeUnload = new Dispatcher(tinymce, \x22BeforeUnload\x22);\x0a  tinymce.onAddEditor = new Dispatcher(tinymce, \x22AddEditor\x22, \x22editor\x22);\x0a  tinymce.onRemoveEditor = new Dispatcher(tinymce, \x22RemoveEditor\x22, \x22editor\x22);\x0a\x0a  tinymce.util.Cookie = {\x0a    get: noop, getHash: noop, remove: noop, set: noop, setHash: noop\x0a  };\x0a\x0a  function patchEditor(editor) {\x0a\x0a    function translate(str) {\x0a      var prefix = editor.settings.language || \x22en\x22;\x0a      var prefixedStr = [prefix, str].join(\x27.\x27);\x0a      var translatedStr = tinymce.i18n.translate(prefixedStr);\x0a\x0a      return prefixedStr !== translatedStr ? translatedStr : tinymce.i18n.translate(str);\x0a    }\x0a\x0a    function patchEditorEvents(oldEventNames, argsMap) {\x0a      tinymce.each(oldEventNames.split(\x22 \x22), function (oldName) {\x0a        editor[\x22on\x22 + oldName] = new Dispatcher(editor, oldName, argsMap);\x0a      });\x0a    }\x0a\x0a    function convertUndoEventArgs(type, event, target) {\x0a      return [\x0a        event.level,\x0a        target\x0a      ];\x0a    }\x0a\x0a    function filterSelectionEvents(needsSelection) {\x0a      return function (type, e) {\x0a        if ((!e.selection && !needsSelection) || e.selection == needsSelection) {\x0a          return [e];\x0a        }\x0a      };\x0a    }\x0a\x0a    if (editor.controlManager) {\x0a      return;\x0a    }\x0a\x0a    function cmNoop() {\x0a      var obj = {}, methods = \x27add addMenu addSeparator collapse createMenu destroy displayColor expand focus \x27 +\x0a        \x27getLength hasMenus hideMenu isActive isCollapsed isDisabled isRendered isSelected mark \x27 +\x0a        \x27postRender remove removeAll renderHTML renderMenu renderNode renderTo select selectByIndex \x27 +\x0a        \x27setActive setAriaProperty setColor setDisabled setSelected setState showMenu update\x27;\x0a\x0a      log(\x27editor.controlManager.*\x27);\x0a\x0a      function _noop() {\x0a        return cmNoop();\x0a      }\x0a\x0a      tinymce.each(methods.split(\x27 \x27), function (method) {\x0a        obj[method] = _noop;\x0a      });\x0a\x0a      return obj;\x0a    }\x0a\x0a    editor.controlManager = {\x0a      buttons: {},\x0a\x0a      setDisabled: function (name, state) {\x0a        log(\x22controlManager.setDisabled(..)\x22);\x0a\x0a        if (this.buttons[name]) {\x0a          this.buttons[name].disabled(state);\x0a        }\x0a      },\x0a\x0a      setActive: function (name, state) {\x0a        log(\x22controlManager.setActive(..)\x22);\x0a\x0a        if (this.buttons[name]) {\x0a          this.buttons[name].active(state);\x0a        }\x0a      },\x0a\x0a      onAdd: new Dispatcher(),\x0a      onPostRender: new Dispatcher(),\x0a\x0a      add: function (obj) {\x0a        return obj;\x0a      },\x0a      createButton: cmNoop,\x0a      createColorSplitButton: cmNoop,\x0a      createControl: cmNoop,\x0a      createDropMenu: cmNoop,\x0a      createListBox: cmNoop,\x0a      createMenuButton: cmNoop,\x0a      createSeparator: cmNoop,\x0a      createSplitButton: cmNoop,\x0a      createToolbar: cmNoop,\x0a      createToolbarGroup: cmNoop,\x0a      destroy: noop,\x0a      get: noop,\x0a      setControlType: cmNoop\x0a    };\x0a\x0a    patchEditorEvents(\x22PreInit BeforeRenderUI PostRender Load Init Remove Activate Deactivate\x22, \x22editor\x22);\x0a    patchEditorEvents(\x22Click MouseUp MouseDown DblClick KeyDown KeyUp KeyPress ContextMenu Paste Submit Reset\x22);\x0a    patchEditorEvents(\x22BeforeExecCommand ExecCommand\x22, \x22command ui value args\x22); // args.terminate not supported\x0a    patchEditorEvents(\x22PreProcess PostProcess LoadContent SaveContent Change\x22);\x0a    patchEditorEvents(\x22BeforeSetContent BeforeGetContent SetContent GetContent\x22, filterSelectionEvents(false));\x0a    patchEditorEvents(\x22SetProgressState\x22, \x22state time\x22);\x0a    patchEditorEvents(\x22VisualAid\x22, \x22element hasVisual\x22);\x0a    patchEditorEvents(\x22Undo Redo\x22, convertUndoEventArgs);\x0a\x0a    patchEditorEvents(\x22NodeChange\x22, function (type, e) {\x0a      return [\x0a        editor.controlManager,\x0a        e.element,\x0a        editor.selection.isCollapsed(),\x0a        e\x0a      ];\x0a    });\x0a\x0a    var originalAddButton = editor.addButton;\x0a    editor.addButton = function (name, settings) {\x0a      var originalOnPostRender;\x0a\x0a      function patchedPostRender() {\x0a        editor.controlManager.buttons[name] = this;\x0a\x0a        if (originalOnPostRender) {\x0a          return originalOnPostRender.apply(this, arguments);\x0a        }\x0a      }\x0a\x0a      for (var key in settings) {\x0a        if (key.toLowerCase() === \x22onpostrender\x22) {\x0a          originalOnPostRender = settings[key];\x0a          settings.onPostRender = patchedPostRender;\x0a        }\x0a      }\x0a\x0a      if (!originalOnPostRender) {\x0a        settings.onPostRender = patchedPostRender;\x0a      }\x0a\x0a      if (settings.title) {\x0a        settings.title = translate(settings.title);\x0a      }\x0a\x0a      return originalAddButton.call(this, name, settings);\x0a    };\x0a\x0a    editor.on(\x27init\x27, function () {\x0a      var undoManager = editor.undoManager, selection = editor.selection;\x0a\x0a      undoManager.onUndo = new Dispatcher(editor, \x22Undo\x22, convertUndoEventArgs, null, undoManager);\x0a      undoManager.onRedo = new Dispatcher(editor, \x22Redo\x22, convertUndoEventArgs, null, undoManager);\x0a      undoManager.onBeforeAdd = new Dispatcher(editor, \x22BeforeAddUndo\x22, null, undoManager);\x0a      undoManager.onAdd = new Dispatcher(editor, \x22AddUndo\x22, null, undoManager);\x0a\x0a      selection.onBeforeGetContent = new Dispatcher(editor, \x22BeforeGetContent\x22, filterSelectionEvents(true), selection);\x0a      selection.onGetContent = new Dispatcher(editor, \x22GetContent\x22, filterSelectionEvents(true), selection);\x0a      selection.onBeforeSetContent = new Dispatcher(editor, \x22BeforeSetContent\x22, filterSelectionEvents(true), selection);\x0a      selection.onSetContent = new Dispatcher(editor, \x22SetContent\x22, filterSelectionEvents(true), selection);\x0a    });\x0a\x0a    editor.on(\x27BeforeRenderUI\x27, function () {\x0a      var windowManager = editor.windowManager;\x0a\x0a      windowManager.onOpen = new Dispatcher();\x0a      windowManager.onClose = new Dispatcher();\x0a      windowManager.createInstance = function (className, a, b, c, d, e) {\x0a        log(\x22windowManager.createInstance(..)\x22);\x0a\x0a        var constr = tinymce.resolve(className);\x0a        return new constr(a, b, c, d, e);\x0a      };\x0a    });\x0a  }\x0a\x0a  tinymce.on(\x27SetupEditor\x27, function (e) {\x0a    patchEditor(e.editor);\x0a  });\x0a\x0a  tinymce.PluginManager.add(\x22compat3x\x22, patchEditor);\x0a\x0a  tinymce.addI18n = function (prefix, o) {\x0a    var I18n = tinymce.util.I18n, each = tinymce.each;\x0a\x0a    if (typeof prefix == \x22string\x22 && prefix.indexOf(\x27.\x27) === -1) {\x0a      I18n.add(prefix, o);\x0a      return;\x0a    }\x0a\x0a    if (!tinymce.is(prefix, \x27string\x27)) {\x0a      each(prefix, function (o, lc) {\x0a        each(o, function (o, g) {\x0a          each(o, function (o, k) {\x0a            if (g === \x27common\x27) {\x0a              I18n.data[lc + \x27.\x27 + k] = o;\x0a            } else {\x0a              I18n.data[lc + \x27.\x27 + g + \x27.\x27 + k] = o;\x0a            }\x0a          });\x0a        });\x0a      });\x0a    } else {\x0a      each(o, function (o, k) {\x0a        I18n.data[prefix + \x27.\x27 + k] = o;\x0a      });\x0a    }\x0a  };\x0a})(tinymce);\x0a'}